
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（五）：工厂方法模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（五）：工厂方法模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-29</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81">2.2 抽象产品</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81">2.3 具体产品</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">2.4 抽象工厂</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82">2.5 具体工厂</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E9%9A%90%E8%97%8F">4 隐藏</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>尽管简单工厂模式实现了对象的创建和使用分离，但是仍然存在以下两个问题：</p>
<ul>
<li>工厂类过于庞大，包含了大量的判断代码，导致维护和测试难度增大</li>
<li>系统扩展不灵活，如果增加了新的产品类型，必须修改静态工厂方法的业务逻辑，违反了开闭原则</li>
<li>具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性</li>
</ul>
<p>一个更好的办法是使用工厂方法模式。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。</strong></p>
<p>工厂方法又简称工厂模式或虚拟构造器模式或多态工厂模式，让一个类的实例化延迟到其子类，是一种类创建型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200715162916816.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Product</code>（抽象产品）：定义产品的接口，是工厂方法模式所创建的超类型，也就是产品对象的公共父类</strong></li>
<li><strong><code>ConcreteProduct</code>（具体产品）：实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂与具体产品一一对应</strong></li>
<li><strong><code>Factory</code>（抽象工厂）：在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口</strong></li>
<li><strong><code>ConcreteFactory</code>（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象产品：定义为接口/抽象类，是所有具体产品的父类</li>
<li>定义具体产品：实现/继承抽象产品，一个类对应与一个具体产品</li>
<li>定义抽象工厂：定义为接口/抽象类，声明工厂方法，但不需要实现，在运行时确定具体工厂</li>
<li>定义具体工厂：实现/继承抽象工厂，实现其中的工厂方法</li>
</ul>
<h2 id="22-抽象产品">2.2 抽象产品</h2>
<p>这里定义为接口：</p>
<pre><code class="language-java">interface Product
{
    void method();
}
</code></pre>
<h2 id="23-具体产品">2.3 具体产品</h2>
<p>两个示例具体产品：</p>
<pre><code class="language-java">class ConcreteProductA implements Product
{
    public void method()
    {
        System.out.println(&quot;Concrete Product A&quot;);
    }
}

class ConcreteProductB implements Product
{
    public void method()
    {
        System.out.println(&quot;Concrete Product B&quot;);
    }
}
</code></pre>
<h2 id="24-抽象工厂">2.4 抽象工厂</h2>
<p>这里定义为接口：</p>
<pre><code class="language-java">interface Factory
{
    Product get();
}
</code></pre>
<p>抽象工厂中声明了工厂方法但没有实现，交由子类具体工厂负责。</p>
<h2 id="25-具体工厂">2.5 具体工厂</h2>
<pre><code class="language-java">class ConcreteFactoryA implements Factory
{
    public Product get()
    {
        return new ConcreteProductA();
    }
}

class ConcreteFactoryB implements Factory
{
    public Product get()
    {
        return new ConcreteProductB();
    }
}
</code></pre>
<p>一个具体产品对应一个具体工厂，每一个具体工厂返回不同的具体产品。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<p>客户端针对抽象产品以及抽象工厂进行编程，无需知道具体产品的类名，只需要知道具体产品对应的工厂，即可获取具体产品：</p>
<pre><code class="language-java">Factory factory = new ConcreteFactoryA();
Product product = factory.get();
product.method();
factory = new ConcreteFactoryB();
product = factory.get();
product.method();
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>日志记录器的设计：该记录器可以通过多种途径保存系统的运行日志，例如文件记录或者数据库记录，使用工厂方法模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象产品：<code>Logger</code></li>
<li>具体产品：<code>DatabaseLogger</code>+<code>FileLogger</code></li>
<li>抽象工厂：<code>LoggerFactory</code></li>
<li>具体工厂：<code>DatabaseLoggerFactory</code>+<code>FileLoggerFactory</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        LoggerFactory factory = new FileLoggerFactory();        
        Logger logger = factory.createLogger();
        logger.log();
    }
}

//抽象产品
interface Logger
{
    void log();
}

//具体产品:DatabaseLogger
class DatabaseLogger implements Logger
{
    public void log()
    {
        System.out.println(&quot;数据库日志记录&quot;);
    }
}

//具体产品:FileLogger
class FileLogger implements Logger
{
    public void log()
    {
        System.out.println(&quot;文件日志记录&quot;);
    }
}

//抽象工厂
interface LoggerFactory
{
    Logger createLogger();
}

//具体工厂:DatabaseLoggerFactory
class DatabaseLoggerFactory implements LoggerFactory
{
    public Logger createLogger()
    {
        return new DatabaseLogger();
    }
}

//具体工厂:FileLoggerFactory
class FileLoggerFactory implements LoggerFactory
{
    public Logger createLogger()
    {
        return new FileLogger();
    }
}
</code></pre>
<h1 id="4-隐藏">4 隐藏</h1>
<p>可以把抽象工厂设置为抽象类，工厂方法直接可以对客户端隐藏，也就是说可以直接通过抽象工厂调用具体产品类的业务方法，客户端无需创建具体产品，直接通过工厂类调用即可，代码修改如下（抽象产品以及具体产品类不用修改）：</p>
<pre><code class="language-java">//抽象工厂
abstract class LoggerFactory
{
    public void log()
    {
        this.createLogger().log();
    }
    public abstract Logger createLogger();
}

//具体工厂:DatabaseLoggerFactory
class DatabaseLoggerFactory extends LoggerFactory
{
    public Logger createLogger()
    {
        return new DatabaseLogger();
    }
}

//具体工厂:FileLoggerFactory
class FileLoggerFactory extends LoggerFactory
{
    public Logger createLogger()
    {
        return new FileLogger();
    }
}

public class Test
{
    public static void main(String[] args) {
        LoggerFactory factory = new FileLoggerFactory();
        factory.log();
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>封装细节：工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名</li>
<li>多态：工厂方法的多态性能够让工厂可以自主确定创建何种产品对象，而如何创建对象的细节则完全封装在具体工厂内部</li>
<li>扩展性好：加入新产品时无须修改抽象工厂，抽象产品的接口，也无须修改客户端与其他的具体产品和具体工厂，只需要增加一个具体工厂以及具体产品，系统扩展性很好，完全符合开闭原则</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>类数量多：在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度，有更多的类需要编译和运行，给系统带来额外开销</li>
<li>增加理解难度：基于系统的扩展性需要引入抽象层，在客户端中均使用了抽象层的定义，增加了系统的抽象性以及理解难度</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>客户端不知道其所需要的对象的类：在工厂方法模式中，客户端不需要知道具体的产品类名，只需要知道所对应的工厂即可</li>
<li>抽象工厂类通过子类来指定创建哪个对象：工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而有其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更加容易扩展</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200728202541743.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-40-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第40期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
