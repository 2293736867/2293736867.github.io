
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（二十一）：备忘录模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-er-shi-yi-bei-wang-lu-mo-shi.png')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（二十一）：备忘录模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-04</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E5%8E%9F%E5%8F%91%E5%99%A8">2.2 原发器</a></li>
<li><a href="#23-%E5%A4%87%E5%BF%98%E5%BD%95">2.3 备忘录</a></li>
<li><a href="#24-%E8%B4%9F%E8%B4%A3%E4%BA%BA">2.4 负责人</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%A4%87%E5%BF%98%E5%BD%95%E5%B0%81%E8%A3%85">4 备忘录封装</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在手机上玩象棋时，往往会提供一个悔棋的功能，实际上，悔棋就是恢复到某个历史状态，很多软件中称之为撤销，实现撤销时，需要先保存历史状态，这样撤销时，取出某个历史状态并覆盖当前状态。备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态恢复。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</strong></p>
<p>备忘录模式是一种对象行为型模式，别名为Token。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200803021243722.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Originator</code>（原发器）：一个普通类，可以创建一个备忘录，并存储当前内部状态，也可以使用备忘录恢复内部状态，一般为需要保存内部状态的类</strong></li>
<li><strong><code>Memento</code>（备忘录）：存储原发器内部状态，根据原发器决定保存哪些内部状态。除了原发器以及负责人以外，备忘录不能供其他对象直接使用</strong></li>
<li><strong><code>Caretaker</code>（负责人）：又叫管理者，负责保存备忘录，可以存储一个或多个备忘录，只负责保存备忘录对象，不能修改备忘录</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义原发器：原发器是需要保存内部状态的类，提供一个从当前状态创建备忘录的方法以及一个从备忘录中恢复内部状态的方法</li>
<li>定义备忘录：存储原发器内部状态，需要考虑封装性，不能被除原发器以及负责人以外的类访问，否则失去备忘录意义</li>
<li>定义负责人：保存备忘录对象，一般使用集合存储多个备忘录</li>
</ul>
<h2 id="22-原发器">2.2 原发器</h2>
<pre><code class="language-java">class Originator
{
    private String state;
    public String getState() 
    {
        return this.state;
    }
    public void setState(String state) 
    {
        this.state = state;
    }
    public Memento save()
    {
        return new Memento(state);
    }
    public void restore(Memento memento)
    {
        this.state = memento.getState();
    }
}
</code></pre>
<p>原发器中相应的字段表示内部状态，<code>save()</code>返回一个将内部状态封装为备忘录的对象，<code>restore()</code>获取备忘录中的内部状态并进行恢复。</p>
<h2 id="23-备忘录">2.3 备忘录</h2>
<pre><code class="language-java">class Memento
{
    private String state;

    public Memento(String state)
    {
        this.state = state;
    }

    public String getState() 
    {
        return this.state;
    }
}
</code></pre>
<p>简单的保存内部状态的类，需要保证封装性，不允许除原发器以及负责人外的类访问。</p>
<p>不同语言实现机制不同，比如C++中可以通过<code>friend</code>友元实现，Java中可通过将备忘录或者原发器防置同一个包或者将备忘录作为原发器的内部类实现。</p>
<h2 id="24-负责人">2.4 负责人</h2>
<pre><code class="language-java">class Caretaker
{
    private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
    public Memento get()
    {
        return mementos.remove(0);
    }
    public void add(Memento memento)
    {
        mementos.add(0,memento);
    }
}
</code></pre>
<p>负责人使用一个<code>LinkedList</code>保存多个备忘录，由于恢复操作是逐步进行的，也就是不能一次恢复到“撤销两次”的历史状态，只能恢复到“撤销一次”的历史状态，因此可以考虑栈来保存备忘录。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Originator originator = new Originator();
    Caretaker caretaker = new Caretaker();
    originator.setState(&quot;状态1&quot;);
    caretaker.add(originator.save());
    originator.setState(&quot;状态2&quot;);
    caretaker.add(originator.save());
    originator.setState(&quot;状态3&quot;);
    caretaker.add(originator.save());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
}
</code></pre>
<p>对于客户端，每修改一次原发器的状态就通过负责人保存一次生成的备忘录，需要时从负责人获取备忘录并恢复到相应的状态。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803023850584.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>象棋悔棋的实现，使用备忘录模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>原发器：<code>Chessman</code></li>
<li>备忘录：<code>Memento</code></li>
<li>负责人：<code>Caretaker</code></li>
</ul>
<p>原发器如下：</p>
<pre><code class="language-java">class Chessman
{
    private String label;
    private int x;
    private int y;
   
    public Chessman(int x,int y,String label)
    {
        this.x = x;
        this.y = y;
        this.label = label;
    }

    public Memento save()
    {
        return new Memento(x,y,label);
    }

    public void restore(Memento memento)
    {
        this.x = memento.getX();
        this.y = memento.getY();
        this.label = memento.getLabel();
    }
	
	//setter+getter...

    @Override
    public String toString()
    {
        return &quot;x:&quot;+x+&quot;\ty:&quot;+y+&quot;\tlabel:&quot;+label;
    }
}
</code></pre>
<p>原发器的两个核心方法就是<code>save()</code>与<code>restore</code>，<code>save()</code>将内部状态保存为备忘录，而<code>restore()</code>根据备忘录参数恢复到之前的内部状态。</p>
<p>备忘录如下：</p>
<pre><code class="language-java">class Memento
{
    private int x;
    private int y;
    private String label;

    public Memento(int x,int y,String label)
    {
        this.x = x;
        this.y = y;
        this.label = label;
    }
    //getter...
}
</code></pre>
<p>属性与原发器一致，最后是负责人：</p>
<pre><code class="language-java">class Caretaker
{
    private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
    public Memento get()
    {
        return mementos.remove(0);
    }
    public void add(Memento memento)
    {
        mementos.add(0,memento);
    }
}
</code></pre>
<p>使用<code>LinkedList</code>模拟栈的操作，<code>get</code>获取栈顶的状态。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Chessman chessman = new Chessman(1,2,&quot;车&quot;);
    Caretaker caretaker = new Caretaker();
    caretaker.add(chessman.save());
    chessman.setX(8);
    caretaker.add(chessman.save());
    chessman.setY(5);
    caretaker.add(chessman.save());

    chessman.restore(caretaker.get());
    System.out.println(chessman);
    chessman.restore(caretaker.get());
    System.out.println(chessman);
    chessman.restore(caretaker.get());
    System.out.println(chessman);
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803025132367.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-备忘录封装">4 备忘录封装</h1>
<p>备忘录是一个特殊的对象，只有原发器对它拥有控制权力，负责人只负责管理备忘录，其他类无法直接访问备忘录，因此需要对备忘录进行封装。在Java中可以使用内部类对备忘录进行封装，比如上面的例子可以封装内部类如下：</p>
<pre><code class="language-java">class Chessman
{
    //...
    public class Memento
    {
        private int x;
        private int y;
        private String label;
    
        public Memento(int x,int y,String label)
        {
            this.x = x;
            this.y = y;
            this.label = label;
        }
    
        public int getX() 
        {
            return this.x;
        }
    
        public int getY() 
        {
            return this.y;
        }
    
        public String getLabel() 
        {
            return this.label;
        }
    }
    //...
}
</code></pre>
<p>这样可以最大程度地限制外部类对于备忘录的访问，如果想进一步的完全限制，可以将备忘录设置为私有内部类，将负责人类也作为原发器的内部类，这样外部类就完全不能访问备忘录：</p>
<pre><code class="language-java">class Chessman
{
    //...
    private class Memento
    {
        //...
    }
    public class Caretaker
    {
        private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
        public Memento get()
        {
            return mementos.remove(0);
        }
        public void add(Memento memento)
        {
            mementos.add(0,memento);
        }
    }
    public Caretaker getCaretaker()
    {
        return new Caretaker();
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>状态恢复：备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史状态</li>
<li>多次撤销：备忘录实现了对信息的封装，保存了原发器的状态，配合列表，堆栈等集合可以实现多次撤销操作</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>资源消耗大：如果需要保存的原发器状态太多，将会占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时就能恢复到先前的状态，实现撤销操作</li>
<li>防止外界对象破坏一个对象历史状态的封装性，避免将历史状态的实现细节暴露给外部对象</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200803031745173.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-zhong-jie-zhe-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（二十）：中介者模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
