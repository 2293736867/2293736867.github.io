
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Spring 学习笔记（三）：Spring Bean | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/spring-xue-xi-bi-ji-san-spring-bean.jpg')">
            </div>
          
          <h2 class="post-title">Spring 学习笔记（三）：Spring Bean</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-09-09</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/jM1IwIS2X/">
                    Spring
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-bean%E9%85%8D%E7%BD%AE">1 <code>Bean</code>配置</a></li>
<li><a href="#2-bean%E5%AE%9E%E4%BE%8B%E5%8C%96">2 <code>Bean</code>实例化</a>
<ul>
<li><a href="#21-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96">2.1 构造方法实例化</a></li>
<li><a href="#22-%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%AE%9E%E4%BE%8B%E5%8C%96">2.2 静态工厂实例化</a></li>
<li><a href="#23-%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%AE%9E%E4%BE%8B%E5%8C%96">2.3 实例工厂实例化</a></li>
</ul>
</li>
<li><a href="#3-bean%E4%BD%9C%E7%94%A8%E5%9F%9F">3 <code>Bean</code>作用域</a>
<ul>
<li><a href="#31-%E5%88%86%E7%B1%BB">3.1 分类</a></li>
<li><a href="#32-singleton">3.2 <code>singleton</code></a></li>
<li><a href="#33-prototype">3.3 <code>prototype</code></a></li>
</ul>
</li>
<li><a href="#4-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4 <code>Bean</code>生命周期</a></li>
<li><a href="#5-bean%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F">5 <code>Bean</code>装配方式</a>
<ul>
<li><a href="#51-%E5%9F%BA%E4%BA%8Exml%E8%A3%85%E9%85%8D">5.1 基于<code>XML</code>装配</a></li>
<li><a href="#52-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D">5.2 基于注解装配</a></li>
<li><a href="#53-%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">5.3 注解使用示例</a>
<ul>
<li><a href="#531-bean">5.3.1 <code>@Bean</code></a></li>
<li><a href="#532-%E5%85%B6%E4%BB%96">5.3.2 其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="1-bean配置">1 <code>Bean</code>配置</h1>
<p><code>Spring</code>可以看做是一个管理<code>Bean</code>的工厂，开发者需要将<code>Bean</code>配置在<code>XML</code>或者<code>Properties</code>配置文件中。实际开发中常使用<code>XML</code>的格式，其中<code>&lt;bean&gt;</code>中的属性或子元素如下：</p>
<ul>
<li><code>id</code>：<code>Bean</code>在<code>BeanFactory</code>中的唯一标识，在代码中通过<code>BeanFactory</code>获取<code>Bean</code>的实例时候需要以此作为索引</li>
<li><code>class</code>：<code>Bean</code>的具体实体类，使用<code>包名+类名</code>的形式指定</li>
<li><code>scope</code>：指定<code>Bean</code>实例的作用域</li>
<li><code>&lt;constructor-arg&gt;</code>：使用构造方法注入，指定构造方法的参数，<code>index</code>表示序号，<code>ref</code>指定对<code>BeanFactory</code>中其他<code>Bean</code>的引用关系，<code>type</code>指定参数类型，<code>value</code>指定参数常量值</li>
<li><code>&lt;property&gt;</code>：用于设置一个属性，表示使用<code>setter</code>注入，<code>name</code>指定属性的名字，<code>value</code>指定要注入的值，<code>ref</code>指定注入的某个<code>Bean</code>的<code>id</code></li>
<li><code>&lt;list&gt;</code>：用于封装<code>List</code>或者数组类型的依赖注入</li>
<li><code>&lt;map&gt;</code>：封装<code>Map</code>类型的依赖注入</li>
<li><code>&lt;set&gt;</code>：封装<code>Set</code>类型的依赖注入</li>
<li><code>&lt;entry&gt;</code>：<code>&lt;map&gt;</code>的子元素，用于设置一个键值对</li>
</ul>
<h1 id="2-bean实例化">2 <code>Bean</code>实例化</h1>
<p><code>Spring</code>实例化<code>Bean</code>有三种方式：</p>
<ul>
<li>构造方法实例化</li>
<li>静态工厂实例化</li>
<li>实例工厂实例化</li>
</ul>
<p>下面进行简单的演示。</p>
<h2 id="21-构造方法实例化">2.1 构造方法实例化</h2>
<p><code>Spring</code>可以调用<code>Bean</code>对应的类的无参构造方法进行实例化，比如：</p>
<pre><code class="language-java">public class TestBean {
    public TestBean()
    {
        System.out.println(&quot;构造方法实例化&quot;);
    }
}
</code></pre>
<p>配置文件如下：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot;/&gt;
</code></pre>
<p>则会调用无参构造方法初始化。</p>
<p>其实就是只写一个<code>&lt;bean&gt;</code>就可以了，默认的话会调用无参构造方法初始化。</p>
<h2 id="22-静态工厂实例化">2.2 静态工厂实例化</h2>
<p>静态工厂实例化需要在工厂类中配置一个静态方法来创建<code>Bean</code>，并添加<code>factory-method</code>元素，首先创建工厂类：</p>
<pre><code class="language-java">public class TestBeanFactory {
    private static final TestBean testBean = new TestBean();
    public static TestBean getInstance()
    {
        return testBean;
    }
}
</code></pre>
<p>接着配置文件通过<code>class</code>指定该工厂类，通过<code>factory-method</code>指定获取实例的方法：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBeanFactory&quot; class=&quot;TestBeanFactory&quot; factory-method=&quot;getInstance&quot;/&gt;
</code></pre>
<p>这样就可以通过<code>id</code>获取了：</p>
<pre><code class="language-java">TestBean test = (TestBean) context.getBean(&quot;testBeanFactory&quot;);
</code></pre>
<h2 id="23-实例工厂实例化">2.3 实例工厂实例化</h2>
<p>实例工厂实例化与静态工厂实例化类似，不过是非静态方法，然后加上一个<code>factory-bean</code>元素，同样首先创建工厂类：</p>
<pre><code class="language-java">public class TestBeanFactory {
    public TestBean getInstance()
    {
        return new TestBean();
    }
}
</code></pre>
<p>在配置文件需要添加两个<code>Bean</code>，一个指定工厂类，一个指定使用哪一个工厂类以及使用工厂类的哪一个方法：</p>
<pre><code class="language-xml">&lt;bean id=&quot;factory&quot; class=&quot;TestBeanFactory&quot; /&gt; &lt;!--指定工厂类--&gt;
&lt;bean id=&quot;testBeanFactory&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot; /&gt; &lt;!--指定工厂Bean以及哪一个工厂方法--&gt;
</code></pre>
<p>获取：</p>
<pre><code class="language-java">TestBean test = (TestBean) context.getBean(&quot;testBeanFactory&quot;);
</code></pre>
<h1 id="3-bean作用域">3 <code>Bean</code>作用域</h1>
<h2 id="31-分类">3.1 分类</h2>
<p><code>&lt;bean&gt;</code>中的<code>scope</code>可以指定的作用域如下：</p>
<ul>
<li><code>singleton</code>：默认作用域，在<code>Spring</code>容器只有一个<code>Bean</code>实例</li>
<li><code>prototype</code>：每次获取<code>Bean</code>都会返回一个新的实例</li>
<li><code>request</code>：在一次<code>HTTP</code>请求中只返回一个<code>Bean</code>实例，不同<code>HTTP</code>请求返回不同的<code>Bean</code>实例，仅在<code>Spring Web</code>应用程序上下文使用</li>
<li><code>session</code>：在一个<code>HTTP Session</code>中，容器将返回同一个<code>Bean</code>实例，仅在<code>Spring Web</code>应用程序上下文中使用</li>
<li><code>application</code>：为每个<code>ServletContext</code>对象创建一个实例，即同一个应用共享一个<code>Bean</code>实例，仅在<code>Spring Web</code>应用程序上下文使用</li>
<li><code>websocket</code>：为每个<code>WebSocket</code>对象创建一个<code>Bean</code>实例，仅在<code>Spring Web</code>应用程序上下文使用</li>
</ul>
<p>下面具体说一下最常用的两个：<code>singleton</code>和<code>prototype</code>。</p>
<h2 id="32-singleton">3.2 <code>singleton</code></h2>
<p><code>scope</code>设置为<code>singleton</code>时，<code>Spring IoC</code>仅生成和管理一个<code>Bean</code>实例，使用<code>id</code>/<code>name</code>获取<code>Bean</code>实例时，<code>IoC</code>容器返回共享的<code>Bean</code>实例。设置方式如下：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot;/&gt;
&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<p>因为这是默认的作用域，设置的话<code>IDE</code>也智能提示是多余的：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200909075954376.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>所以通过不需要加上<code>scope</code>，测试例子：</p>
<pre><code class="language-java">TestBean test1 = (TestBean) context.getBean(&quot;testBean&quot;);
TestBean test2 = (TestBean) context.getBean(&quot;testBean&quot;);
System.out.println(test1 == test2);
</code></pre>
<p>输入的结果为<code>True</code>。</p>
<h2 id="33-prototype">3.3 <code>prototype</code></h2>
<p>每次获取<code>Bean</code>时都会创建一个新的实例，例子如下：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<pre><code class="language-java">TestBean test1 = (TestBean) context.getBean(&quot;testBean&quot;);
TestBean test2 = (TestBean) context.getBean(&quot;testBean&quot;);
System.out.println(test1 == test2);
</code></pre>
<p>测试结果为<code>False</code>。</p>
<h1 id="4-bean生命周期">4 <code>Bean</code>生命周期</h1>
<p><code>Spring</code>可以管理作用域为<code>singleton</code>的生命周期，在此作用域下<code>Spring</code>能精确知道<code>Bean</code>何时被创建，何时初始化完成以及何时被摧毁。<code>Bean</code>的整个生命周期如下：</p>
<ul>
<li>实例化<code>Bean</code></li>
<li>进行依赖注入</li>
<li>如果<code>Bean</code>实现了<code>BeanNameAware</code>，调用<code>setBeanName</code></li>
<li>如果<code>Bean</code>实现了<code>BeanFactoryAware</code>，调用<code>setBeanFactory</code></li>
<li>如果<code>Bean</code>实现了<code>ApplicationContextAware</code>，调用<code>setApplicationContext</code></li>
<li>如果<code>Bean</code>实现了<code>BeanPostProcessor</code>，调用<code>postProcessBeforeInitialization</code></li>
<li>如果<code>Bean</code>实现了<code>InitializingBean</code>，调用<code>afterPropertiesSet</code></li>
<li>如果配置文件配置了<code>init-method</code>属性，调用该方法</li>
<li>如果实现了<code>BeanPostProcessor</code>，调用<code>postProcessAfterInitialization</code>，注意接口与上面的相同但是方法不一样</li>
<li>不需要时进入销毁阶段</li>
<li>如果<code>Bean</code>实现了<code>DisposableBean</code>，调用<code>destroy</code></li>
<li>如果配置文件配置了<code>destroy-method</code>，调用该方法</li>
</ul>
<p>下面用代码进行演示：</p>
<pre><code class="language-java">public class TestBean implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, BeanPostProcessor, InitializingBean, DisposableBean {
    public TestBean()
    {
        System.out.println(&quot;调用构造方法&quot;);
    }

    @Override
    public void setBeanName(String s) {
        System.out.println(&quot;调用BeanNameAware的setBeanName&quot;);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;调用BeanFactoryAware的setBeanFactory&quot;);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println(&quot;调用ApplicationContextAware的setApplicationContext&quot;);
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用BeanPostProcessor的postProcessBeforeInitialization&quot;);
        return null;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;调用InitializingBean的afterPropertiesSet&quot;);
    }

    public void initMethod()
    {
        System.out.println(&quot;调用XML配置的init-method&quot;);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;调用BeanPostProcessor的postProcessAfterInitialization&quot;);
        return null;
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;调用DisposableBean的destroy&quot;);
    }

    public void destroyMethod()
    {
        System.out.println(&quot;调用XML配置的destroy-method&quot;);
    }
}
</code></pre>
<p>配置文件如下，指定了<code>init-method</code>以及<code>destroy-method</code>：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;/&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) {
    ConfigurableApplicationContext context = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    TestBean test = (TestBean) context.getBean(&quot;testBean&quot;);
    ((BeanDefinitionRegistry) context.getBeanFactory()).removeBeanDefinition(&quot;testBean&quot;);
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200909125748530.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如果没有最后一行的手动删除<code>Bean</code>定义是不会看见最后两行的输出的，另外，这里没有调用<code>BeanPostProcessor</code>接口的两个方法，如果把<code>scope</code>改为<code>prototype</code>，输出如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020090912593951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到首先对<code>Bean</code>进行一次初始化，并且再次生成一个新的实例，而且调用了<code>BeanPostProcessor</code>的两个方法。但是需要注意<code>Spring</code>不会管理<code>scope</code>为<code>prototype</code>的销毁，所以图中没有看到调用销毁的方法。</p>
<h1 id="5-bean装配方式">5 <code>Bean</code>装配方式</h1>
<p><code>Spring</code>支持以下两种装配方式：</p>
<ul>
<li>基于<code>XML</code>装配</li>
<li>基于注解装配</li>
<li>显式<code>Bean</code>装配</li>
</ul>
<p><code>Bean</code>的装配方式也就是<code>Bean</code>的依赖注入方式，下面分别进行阐述。</p>
<h2 id="51-基于xml装配">5.1 基于<code>XML</code>装配</h2>
<p>基于<code>XML</code>装配也就是在<code>XML</code>文件中指定使用构造方法注入或者<code>setter</code>注入，比如：</p>
<pre><code class="language-java">public class TestBean {
    private final List&lt;String&gt; stringList;
    private String s;

    public TestBean(List&lt;String&gt; stringList) {
        this.stringList = stringList;
    }

    public void setS(String s)
    {
        this.s = s;
    }

    @Override
    public String toString() {
        return stringList.toString() + &quot;\n&quot; + s + &quot;\n&quot;;
    }
}
</code></pre>
<p>该<code>Bean</code>有一个带参数的构造方法以及一个<code>setter</code>，接着在<code>XML</code>中指定相应的值即可：</p>
<pre><code class="language-xml">&lt;bean id=&quot;testBean&quot; class=&quot;TestBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;2&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    &lt;property name=&quot;s&quot; value=&quot;444&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
System.out.println(context.getBean(&quot;testBean&quot;));
</code></pre>
<h2 id="52-基于注解装配">5.2 基于注解装配</h2>
<p>尽管<code>XML</code>方式可以简单地装配<code>Bean</code>，但是一旦<code>Bean</code>过多就会造成<code>XML</code>文件过于庞大，不方便以后的升级和维护，因此推荐使用基于注解的装配方式，先来看一下常用的注解：</p>
<ul>
<li><code>@Autowired</code>：自动装配，默认按照<code>Bean</code>的类型进行装配，这是<code>Spring</code>的注解</li>
<li><code>@Resource</code>：与<code>@Autowired</code>类似，但是是按名称进行装配，当找不到与名称匹配的<code>Bean</code>时才按照类型进行装配，这是<code>JDK</code>的注解</li>
<li><code>@Qualifier</code>：与<code>@Autowired</code>配合使用，因为<code>@Autowired</code>默认按<code>Bean</code>类型进行装配，使用<code>@Qualifier</code>可以按名称进行装配</li>
<li><code>@Bean</code>：方法上的注解，用于产生一个<code>Bean</code>，然后交由<code>Spring</code>管理</li>
<li><code>@Component</code>：表示一个组件对象，加上了该注解就能实现自动装配，默认的<code>Bean</code>的<code>id</code>为使用小驼峰命名法的类</li>
<li><code>@Repository</code>/<code>@Service</code>/<code>@Controller</code>：实际上是<code>@Component</code>的别名，只不过是专门用于持久层/业务层/控制层的，从源码可以看出三个注解的定义除了名字不一样其他都一致，并且都是<code>@Component</code>的别名：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200908201601356.PNG" alt="在这里插入图片描述" loading="lazy"></figure>
<p>官方文档也提到相比起使用<code>@Component</code>，使用<code>@Repository</code>/<code>@Service</code>/<code>@Controller</code>在持久层/业务层/控制层更加合适，而不是统一使用<code>@Component</code>：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200908201800199.PNG" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="53-注解使用示例">5.3 注解使用示例</h2>
<h3 id="531-bean">5.3.1 <code>@Bean</code></h3>
<p><code>@Bean</code>示例如下：</p>
<pre><code class="language-java">public class TestBean implements BeanNameAware{
    @Override
    public void setBeanName(String s) {
        System.out.println(&quot;setBeanName&quot;);
    }
}

@Configuration
public class Config {
    @Bean
    public TestBean getBean()
    {
        return new TestBean();
    }
}

public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        context.getBean(&quot;getBean&quot;);
    }
}
</code></pre>
<p>注意通过<code>@Bean</code>自动产生的<code>Bean</code>的<code>id</code>为方法名，而不是<code>Bean</code>的类名的小驼峰形式。</p>
<h3 id="532-其他">5.3.2 其他</h3>
<p><code>@Autowired</code>/<code>@Resource</code>/<code>@Qualifier</code>/<code>@Repository</code>/<code>@Service</code>/<code>@Controller</code>综合示例，首先创建如下包以及文件：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200909155801661.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-java">@Controller
public class TestController {
    @Resource
    private TestService service;

    public void save()
    {
        System.out.println(&quot;controller save&quot;);
        service.save();
    }
}
</code></pre>
<pre><code class="language-java">@Service
public class TestService {
    @Autowired
    @Qualifier(&quot;testRepository1&quot;)
    private TestInterface repository1;

    @Autowired
    @Qualifier(&quot;testRepository2&quot;)
    private TestInterface repository2;
    public void save()
    {
        System.out.println(&quot;service save&quot;);
        repository1.save();
        repository2.save();
    }
}
</code></pre>
<pre><code class="language-java">@Repository
public class TestRepository1 implements TestInterface{
    @Override
    public void save() {
        System.out.println(&quot;repository1 save&quot;);
    }
}
</code></pre>
<pre><code class="language-java">@Repository
public class TestRepository2 implements TestInterface{
    @Override
    public void save() {
        System.out.println(&quot;repository2 save&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public interface TestInterface {
    void save();
}
</code></pre>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        ((TestController)context.getBean(&quot;testController&quot;)).save();
    }
}
</code></pre>
<p>配置文件：</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;bean&quot; /&gt;
</code></pre>
<p>在<code>TestService</code>中，使用了<code>@Qualifier</code>：</p>
<pre><code class="language-java">@Autowired
@Qualifier(&quot;testRepository1&quot;)
private TestInterface repository1;

@Autowired
@Qualifier(&quot;testRepository2&quot;)
private TestInterface repository2;
</code></pre>
<p>因为<code>TestInterface</code>有两个实现类，<code>@Autowired</code>不知道是选择<code>TestRepository1</code>还是<code>TestRepository2</code>，因此需要加上<code>@Qualifier</code>，指定需要注入的<code>Bean</code>的<code>id</code>，或者使用<code>@Resouce</code>：</p>
<pre><code class="language-java">@Resource
private TestInterface testRepository1;

@Resource
private TestInterface testRepository2;
</code></pre>
<p>但是要注意这样默认了成员的名字就是<code>Bean</code>的<code>id</code>，可以看到这里的名字是<code>testRepository1</code>与<code>testRepository2</code>而不是<code>repository1</code>和<code>repository2</code>。</p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/spring-xue-xi-bi-ji-er-springioc/">
              <h3 class="post-title">
                下一篇：Spring 学习笔记（二）：SpringIoC
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
