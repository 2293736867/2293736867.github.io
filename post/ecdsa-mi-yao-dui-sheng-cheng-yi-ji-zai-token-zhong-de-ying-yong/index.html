
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>ECDSA密钥对生成以及在Token中的应用 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/ecdsa-mi-yao-dui-sheng-cheng-yi-ji-zai-token-zhong-de-ying-yong.jpeg')">
            </div>
          
          <h2 class="post-title">ECDSA密钥对生成以及在Token中的应用</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-12-31</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/TFZz0NHYM/">
                    Token
                    
                      ，
                    
                  </a>
                
                  <a href="https://2293736867.github.io/tag/v6JZElgCrM/">
                    ECC
                    
                      ，
                    
                  </a>
                
                  <a href="https://2293736867.github.io/tag/sYkFqGm0dQ/">
                    ECDSA
                    
                      ，
                    
                  </a>
                
                  <a href="https://2293736867.github.io/tag/8dOYqqfXPD/">
                    Auth0
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h1 id="1-概述">1 概述</h1>
<p>本文主要讲述了如何利用<code>Openssl</code>生成<code>ECDSA</code>密钥对，并利用<code>Auth0</code>库进行<code>Token</code>生成及验证的过程。</p>
<h1 id="2-ecdsa">2 <code>ECDSA</code></h1>
<h2 id="21-简介">2.1 简介</h2>
<p><code>ECC</code>（<code>Elliptic Curve Cryptography</code>，椭圆曲线加密）是一种基于椭圆曲线数学的公钥加密算法，而<code>ECDSA</code>是使用<code>ECC</code>对数字签名算法（<code>DSA</code>）的模拟，总的来说<code>ECC</code>相比起常见的<code>RSA</code>更加安全并且生成密钥对的过程会更快。本文不会涉及过多原理性的东西，只是作简单的介绍，想要详情了解这些算法的可以<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">戳这里</a>。</p>
<h2 id="22-密钥对生成">2.2 密钥对生成</h2>
<p>在<code>Openssl</code>中生成<code>ECDSA</code>密钥对的流程如下：</p>
<pre><code class="language-bash">openssl ecparam -genkey -name secp521r1 -out private.pem #生成私钥
openssl ec -in private.pem -pubout -out public.pem #生成公钥
</code></pre>
<p>参数说明如下：</p>
<ul>
<li><code>ecparam</code>：<code>EC</code>参数设置以及生成命令</li>
<li><code>-genkey</code>：使用特定参数生成<code>EC</code>私钥</li>
<li><code>-name</code>：<code>ec</code>参数，可以使用<code>openssl ecparam -list_curves</code>查看，这里用的是<code>secp521r1</code></li>
<li><code>-out</code>：输出文件名</li>
<li><code>ec</code>：<code>EC</code>密钥处理命令</li>
<li><code>-in</code>：输入文件</li>
<li><code>-pubout</code>：默认情况下会输出私钥，加上该选项会变成输出公钥（如果输入是公钥的情况下该参数会自动设置）</li>
</ul>
<p>执行完命令后就成功生成密钥对了，可以查看一下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201231184510714.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>密钥对生成之后就可以准备一下生成<code>Token</code>了。</p>
<h1 id="3-auth0中的token应用">3 <code>Auth0</code>中的<code>Token</code>应用</h1>
<h2 id="31-auth0">3.1 <code>Auth0</code></h2>
<p><code>Auth0</code>提供了验证以及授权服务，这里利用官方提供的<code>Java</code>实现去生成<code>Token</code>（这里插一句题外话，<code>Java</code>常用的<code>Token</code>实现还有一个叫<code>JJWT</code>的库），首先引入包：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.auth0&lt;/groupId&gt;
    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
    &lt;version&gt;3.12.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>：</p>
<pre><code class="language-bash">compile group: 'com.auth0', name: 'java-jwt', version: '3.12.0'
</code></pre>
<p>引入后来看一下支持的加密算法，如下图：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201231184815559.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最简单的使用<code>HMAC</code>算法生成的<code>Token</code>如下：</p>
<pre><code class="language-java">System.out.println(JWT.create().withIssuer(&quot;issuer&quot;).withAudience(&quot;content&quot;).sign(Algorithm.HMAC512(&quot;password&quot;)));
</code></pre>
<p>当然这不是本文的重点，本文的重点是介绍如何利用<code>ECDSA</code>去生成<code>Token</code>。</p>
<p>首先<code>Auth0</code>提供的签名<code>api</code>如下：</p>
<pre><code class="language-java">JWT.create().sign(Algorithm)
</code></pre>
<p>其中<code>Algorithm</code>可以取值如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201231185509373.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201231185539866.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>想要使用<code>ECDSA</code>算法需要提供一个<code>ECDSAKeyProvider</code>或一个<code>ECPublicKey</code>和一个<code>ECPrivateKey</code>，这里选择后一种方式实现。</p>
<h2 id="32-密钥对处理">3.2 密钥对处理</h2>
<p>官方并没有提供如何生成<code>ECPublicKey</code>/<code>ECPrivateKey</code>的方法，甚至连从文件读取密钥对的方法都没有提供，笔者从官方提供的<a href="https://github.com/auth0/java-jwt/blob/6b802545d97d40208ea0c3945f5300da904fcf45/lib/src/test/java/com/auth0/jwt/algorithms/ECDSAAlgorithmTest.java">测试代码</a>中发现了如下方法：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201231190113708.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其中核心就是读取密钥对的两个方法：</p>
<ul>
<li><code>readPublicKeyFromFile</code></li>
<li><code>readPrivateKeyFromFile</code></li>
</ul>
<p>从<code>import</code>结果可以看到这是一个工具类：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20201231190230365.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>但问题是官方该工具类是测试使用的，换句话说不对外暴露的，在<code>IDEA</code>中直接引入会报错：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201231190332726.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>因此直接找到该工具类的源码（链接可以<a href="https://github.com/auth0/java-jwt/blob/6b802545d97d40208ea0c3945f5300da904fcf45/lib/src/test/java/com/auth0/jwt/PemUtils.java">戳这里</a>，需要引入<code>bouncycastle</code>包，<code>Maven</code>仓库链接可以<a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on">戳这里</a>）</p>
<pre><code class="language-java">package com.auth0.jwt;

import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class PemUtils {

    private static byte[] parsePEMFile(File pemFile) throws IOException {
        if (!pemFile.isFile() || !pemFile.exists()) {
            throw new FileNotFoundException(String.format(&quot;The file '%s' doesn't exist.&quot;, pemFile.getAbsolutePath()));
        }
        PemReader reader = new PemReader(new FileReader(pemFile));
        PemObject pemObject = reader.readPemObject();
        byte[] content = pemObject.getContent();
        reader.close();
        return content;
    }

    private static PublicKey getPublicKey(byte[] keyBytes, String algorithm) {
        PublicKey publicKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
            publicKey = kf.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException e) {
            System.out.println(&quot;Could not reconstruct the public key, the given algorithm could not be found.&quot;);
        } catch (InvalidKeySpecException e) {
            System.out.println(&quot;Could not reconstruct the public key&quot;);
        }

        return publicKey;
    }
    
    private static PrivateKey getPrivateKey(byte[] keyBytes, String algorithm) {
        PrivateKey privateKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
            privateKey = kf.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException e) {
            System.out.println(&quot;Could not reconstruct the private key, the given algorithm could not be found.&quot;);
        } catch (InvalidKeySpecException e) {
            System.out.println(&quot;Could not reconstruct the private key&quot;);
        }

        return privateKey;
    }

    public static PublicKey readPublicKeyFromFile(String filepath, String algorithm) throws IOException {
        byte[] bytes = PemUtils.parsePEMFile(new File(filepath));
        return PemUtils.getPublicKey(bytes, algorithm);
    }

    public static PrivateKey readPrivateKeyFromFile(String filepath, String algorithm) throws IOException {
        byte[] bytes = PemUtils.parsePEMFile(new File(filepath));
        return PemUtils.getPrivateKey(bytes, algorithm);
    }
}
</code></pre>
<p>直接复制该工具类后，将前一步生成的<code>private.pem</code>以及<code>public.pem</code>放置合适位置，通过工具类读取并生成<code>Token</code>：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        try {
            ECPublicKey publicKey = (ECPublicKey) PemUtils.readPublicKeyFromFile(&quot;src/main/resources/public.pem&quot;,&quot;EC&quot;);
            ECPrivateKey privateKey = (ECPrivateKey) PemUtils.readPrivateKeyFromFile(&quot;src/main/resources/private.pem&quot;,&quot;EC&quot;);
            Algorithm algorithm = Algorithm.ECDSA512(publicKey,privateKey);
            String token = JWT.create()
                    .withIssuer(&quot;issuer&quot;)
                    .sign(algorithm);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(JWT.decode(token));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>但是会报错说私钥是<code>null</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20201231191117155.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>从官方<code>issue</code>中查到了类似的<a href="https://github.com/auth0/java-jwt/issues/270">问题</a>：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20201231191417875.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>回答说是密钥格式的问题，其中提到的<code>pkcs8</code>是<a href="https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html">私钥格式转换命令</a>：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20201231191634348.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>将私钥的格式进行转换：</p>
<pre><code class="language-bash">openssl pkcs8 -topk8 -inform pem -in private.pem -outform pem -nocrypt -out newprivate.pem
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>pkcs8</code>：私钥格式转换命令</li>
<li><code>-topk8</code>：读取私钥并转换为<code>PKCS#8</code>格式</li>
<li><code>-inform</code>：指定输入格式，默认<code>pem</code>，使用该参数并配合<code>-topk8</code>后会生成加密后的<code>PKCS#8</code>格式的私钥</li>
<li><code>-in</code>：输入文件</li>
<li><code>-outform</code>：与<code>-inform</code>类似</li>
<li><code>-nocrypt</code>：在这里主要配合<code>-inform</code>+<code>-topk8</code>使用，生成不加密的<code>PrivateKeyInfo</code>而不是加密的<code>PKCS#8 EncryptedPrivateKeyInfo</code>，因为一些软件（比如某些版本的<code>Java</code>代码）使用的是不加密格式的私钥</li>
<li><code>-out</code>：输出文件</li>
</ul>
<p>转换后就可以生成<code>Token</code>了。</p>
<h2 id="33-生成token">3.3 生成<code>Token</code></h2>
<p>最后<code>readPrivateKeyFromFile</code>中的参数修改为新的私钥即可：</p>
<pre><code class="language-bash">ECPrivateKey privateKey = (ECPrivateKey) PemUtils.readPrivateKeyFromFile(&quot;src/main/resources/newprivate.pem&quot;,&quot;EC&quot;);
</code></pre>
<h1 id="4-参考源码">4 参考源码</h1>
<p>包含了示例密钥对以及如何使用（<code>Gradle</code>版的）：</p>
<ul>
<li><a href="https://github.com/2293736867/ECDSA-Auth0-Token-Demo">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/ECDSA-Auth0-Token-Demo">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/ECDSA-Auth0-Token-Demo">CODE.CHINA</a></li>
</ul>
<h1 id="5-参考网站">5 参考网站</h1>
<p>1、<a href="https://zhuanlan.zhihu.com/p/36326221">知乎-ECC椭圆曲线加密算法：介绍</a></p>
<p>2、<a href="https://www.chainnode.com/tutorial/140">什么是椭圆曲线数字签名算法（ECDSA）？</a></p>
<p>3、<a href="https://andrea.corbellini.name/2015/06/08/elliptic-curve-cryptography-breaking-security-and-a-comparison-with-rsa/">Elliptic Curve Cryptography: breaking security and a comparison with RSA</a></p>
<p>4、<a href="https://www.openssl.org/docs/manmaster/man1/">OpenSSL doc</a></p>
<p>5、<a href="https://superuser.com/questions/1103401/generate-an-ecdsa-key-and-csr-with-openssl">StackExange-https://superuser.com/questions/1103401/generate-an-ecdsa-key-and-csr-with-openssl</a></p>
<p>6、<a href="https://github.com/auth0/java-jwt/issues/270">auth0/java-jwt Issue - ECDSA key version mismatch from openssl pem files #270</a></p>
<p>7、<a href="https://github.com/auth0/java-jwt">auth0/java-jwt Github</a></p>
<p>8、<a href="https://www.codota.com/code/java/methods/com.auth0.jwt.algorithms.Algorithm/ECDSA512">codota-How to useECDSA512methodincom.auth0.jwt.algorithms.Algorithm</a></p>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200806194605566.gif" alt="" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-199-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第199期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
