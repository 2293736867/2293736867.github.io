
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十三）：外观模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-san-wai-guan-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十三）：外观模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-27</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E5%A4%96%E8%A7%82%E8%A7%92%E8%89%B2">2.2 外观角色</a></li>
<li><a href="#23-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.3 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB">4 引入抽象外观类</a>
<ul>
<li><a href="#41-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB">4.1 为什么需要引入抽象外观类？</a></li>
<li><a href="#42-%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5">4.2 如何引入？</a></li>
</ul>
</li>
<li><a href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5 注意事项</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>根据单一权责原则，软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，使客户类与子系统之间的通信和相互依赖关系达到最小，方法之一就是引入一个外观角色，为子系统的访问提供一个简单而单一的入口。外观模式通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p>
<p>（这里的子系统是广义的概念，可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统）</p>
<p>如果没有外观角色，每个客户端可能需要和多个子系统之间进行复杂的交互，系统的耦合度很大，简化示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200726194628891.png" alt="" loading="lazy"></figure>
<p>而引入外观角色后，客户端只需直接与外观角色交互，客户端与子系统之间的原有复杂度由外观角色实现，从而降低系统耦合度，简化示意图如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200726195100190.png" alt="" loading="lazy"></figure>
<p><strong>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观角色进行，外观角色将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</strong></p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>外观模式：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口。</strong></p>
<p>外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>外观模式又叫门面模式，是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200726195644651.png" alt="" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong>Facade（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的一个或多个子系统的功能和责任，正常情况下将来自客户端的请求委派到对应的子系统中去，传递给相应的子系统对象处理</strong></li>
<li><strong>SubSystem（子系统角色）：每一个子系统是一个单独的类，也可以是一个类的集合，实现子系统的功能。每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求，子系统并不知道外观类的存在，对于子系统而已，外观角色仅仅是另一个客户端</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义子系统：首先定义子系统，实现一个单一的功能，处理由客户端传来的请求</li>
<li>定义外观角色：外观角色可以知道一个或多个子系统的功能和责任，将来自客户端的请求委派到对应的子系统去，外观角色对于子系统而言是另一个客户端</li>
</ul>
<h2 id="22-外观角色">2.2 外观角色</h2>
<p>通常实现如下：</p>
<pre><code class="language-java">class Facade
{
    private SubSystemA subSystemA = new SubSystemA();
    private SubSystemB subSystemB = new SubSystemB();
    private SubSystemC subSystemC = new SubSystemC();

    public void method()
    {
        subSystemA.method();
        subSystemB.method();
        subSystemC.method();
    }
}

class SubSystemA
{
    public void method()
    {
        System.out.println(&quot;子系统A&quot;);
    }
}

class SubSystemB
{
    public void method()
    {
        System.out.println(&quot;子系统B&quot;);
    }
}

class SubSystemC
{
    public void method()
    {
        System.out.println(&quot;子系统C&quot;);
    }
}
</code></pre>
<h2 id="23-客户端">2.3 客户端</h2>
<p>使用外观模式的原因就是简化客户端的调用，在这里只需定义外观对象并调用业务方法即可：</p>
<pre><code class="language-java">Facade facade = new Facade();
facade.method();
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个文件加密系统，加密流程包括三部分：读取文件，加密文件，保存文件。这三个操作相对独立，并且封装在三个不同的类中，使用外观模式设计该系统。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>子系统类：<code>FileReader</code>+<code>Encrypt</code>+<code>FileWriter</code></li>
<li>外观角色类：<code>Facade</code></li>
<li><code>FileReader</code>：文件读取类</li>
<li><code>Encrypt</code>：文件加密类</li>
<li><code>FileWriter</code>：文件保存类</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.fileEncrypt(&quot;111&quot;);
    }
}

class FileReader
{
    public void read(String name)
    {
        System.out.println(&quot;读取文件&quot;+name);
    }
}

class Encrypt
{
    public void encrypt(String name)
    {
        System.out.println(&quot;加密文件&quot;+name);
    }
}

class FileWriter
{
    public void write(String name)
    {
        System.out.println(&quot;保存文件&quot;+name);
    }
}

class Facade
{
    private FileReader reader = new FileReader();
    private Encrypt encrypt = new Encrypt();
    private FileWriter writer = new FileWriter();

    public void fileEncrypt(String name)
    {
        reader.read(name);
        encrypt.encrypt(name);
        writer.write(name);
    }
}
</code></pre>
<p>这里的例子比较简单，其实就是将读取，加密以及保存操作用外观角色包装起来，方便客户端调用。</p>
<h1 id="4-引入抽象外观类">4 引入抽象外观类</h1>
<h2 id="41-为什么需要引入抽象外观类">4.1 为什么需要引入抽象外观类？</h2>
<p>在标准的外观模式结构中，如果需要增加，删除或修改外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，比如上面的例子中需要更换一种加密方法，也就是换一个加密类，这样需要直接修改外观类。</p>
<p>可以通过引入抽象外观类来解决该问题，引入后，客户端可以针对抽象外观类进行编程，对于新的业务需求不需要修改原有的外<br>
观类，只需要新增一个对应的具体外观类即可。</p>
<h2 id="42-如何引入">4.2 如何引入？</h2>
<p>首先定义抽象外观类，接着具体外观类继承或者实线抽象外观类即可。客户端针对抽象外观类进行编程，在运行时再确定具体的外观类，比如在上面例子的基础上修改加密方法，首先定义抽象外观类（这里是接口，只有一个加密方法）：</p>
<pre><code class="language-java">interface AbstractFacade
{
    void encrypt(String name);
}
</code></pre>
<p>接着定义具体外观类：</p>
<pre><code class="language-java">class Facade1 implements AbstractFacade
{
    private FileReader reader = new FileReader();
    private Encrypt1 encrypt1 = new Encrypt1();
    private FileWriter writer = new FileWriter();

    @Override
    public void encrypt(String name)
    {
        reader.read(name);
        encrypt1.encrypt(name);
        writer.write(name);
    }
}

class Facade2 implements AbstractFacade
{
    private FileReader reader = new FileReader();
    private Encrypt2 encrypt2 = new Encrypt2();
    private FileWriter writer = new FileWriter();

    @Override
    public void encrypt(String name)
    {
        reader.read(name);
        encrypt2.encrypt(name);
        writer.write(name);
    }
}
</code></pre>
<p>这两个类除了加密方法不一样其他都一样，测试：</p>
<pre><code class="language-java">AbstractFacade facade = new Facade1();
facade.encrypt(&quot;111&quot;);
facade = new Facade2();
facade.encrypt(&quot;222&quot;);
</code></pre>
<p>引入抽象外观类后，客户端针对抽象外观类进行编程，运行时确定具体外观类，输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200726230649714.png" alt="" loading="lazy"></p>
<h1 id="5-注意事项">5 注意事项</h1>
<ul>
<li><strong>外观单例</strong>：很多情况下为了节约系统资源，系统只需要一个外观类的实例，也就是外观类可以是一个单例类，这样可以降低系统资源的消耗</li>
<li><strong>多个外观类</strong>：在一个系统中可以设计多个外观类，每个外观类负责和一些特定子对象交互，向客户端提供相应业务功能</li>
<li><strong>不要通过外观类增加新行为</strong>：外观模式的意图是为子系统提供一个集中简化的沟通渠道，而不是向子系统中增加新行为，新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现而不是通过外观类实现</li>
</ul>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>简化处理：对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易，引入外观模式后客户端代码将简化</li>
<li>松耦合：实现了子系统于客户端之间松耦合关系，使得子系统的变化不会影响到客户端，只需修改外观类</li>
<li>子系统修改灵活：一个子系统的修改对其他子系统没有影响，而且子系统内部变化也不会影响外观对象</li>
<li>唯一入口：只提供了一个访问子系统的唯一入口，但不会影响客户端直接使用子系统类</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>不能限制客户端使用子系统：外观模式不能很好地限制客户端直接使用子系统，如果客户端对访问子系统做太多的限制就会减少可变性与灵活性</li>
<li>可能需要修改外观类：如果设计不当，增加新的子系统可能需要外观类，违背OCP</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>当要为访问一系列复杂的子系统提供一个简单的入口时</li>
<li>客户端与多个子系统存在很大依赖性</li>
<li>层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200726233051374.png" alt="" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（十二）：装饰模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
