
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（二十三） 状态模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-er-shi-san-zhuang-tai-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（二十三） 状态模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-07</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.2 环境类</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E7%8A%B6%E6%80%81%E7%B1%BB">2.3 抽象状态类</a></li>
<li><a href="#24-%E5%85%B7%E4%BD%93%E7%8A%B6%E6%80%81%E7%B1%BB">2.4 具体状态类</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81">4 共享状态</a></li>
<li><a href="#5-%E7%8E%AF%E5%A2%83%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2">5 环境类实现状态切换</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。</p>
<p>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何处状态对象，客户端都可以一致性地处理。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类。</strong></p>
<p>状态模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804023536851.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Context</code>（环境类）：环境类角色又称上下文类，是拥有多种状态的对象，环境类的状态存在多样性且在不同状态下对象的行为有所不同。在环境类中维护一个抽象状态类<code>State</code>的实例，定义当前状态，实现时将具体状态类注入其中</strong></li>
<li><strong><code>State</code>（抽象状态类）：声明各种不同状态对应的方法，封装具体状态类的共同方法</strong></li>
<li><strong><code>ConcreteState</code>（具体状态类）：抽象状态类的子类，实现其中的具体状态行为方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义环境类：环境类包含一个抽象状态成员，可以通过构造方法或者setter注入具体状态，同时包含业务方法，该业务方法会调用抽象状态类的处理状态方法</li>
<li>定义抽象状态类：声明状态处理方法，使用环境类作为参数</li>
<li>定义具体状态类：实现/继承抽象状态类，按实际需要实现其中的状态处理方法</li>
</ul>
<h2 id="22-环境类">2.2 环境类</h2>
<pre><code class="language-java">class Context
{
    private State state = new ConcreteState1();

    public void setState(State state)
    {
        this.state = state;
    }

    public void request()
    {
        state.handle(this);
    }
}
</code></pre>
<p>具有默认初始化状态，可以通过setter修改状态，<code>request</code>为环境类业务方法，其中调用了抽象状态类的状态处理方法。</p>
<h2 id="23-抽象状态类">2.3 抽象状态类</h2>
<pre><code class="language-java">interface State
{
    void handle(Context context);
}
</code></pre>
<p>这里设计为接口，使用环境类作为参数。</p>
<h2 id="24-具体状态类">2.4 具体状态类</h2>
<pre><code class="language-java">class ConcreteState1 implements State
{
    @Override
    public void handle(Context context)
    {
        System.out.println(&quot;具体状态1方法&quot;);
        context.setState(new ConcreteState2());
    }
}

class ConcreteState2 implements State
{
    @Override
    public void handle(Context context)
    {
        System.out.println(&quot;具体状态2方法&quot;);
        context.setState(new ConcreteState1());
    }
}
</code></pre>
<p>两个具体状态类，执行完具体状态类里面的代码后，通过环境类参数将环境类切换到另一个状态。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Context context = new Context();
    context.request();
    context.request();
}
</code></pre>
<p>客户端直接调用环境类业务方法，输出如下：<br>
<img src="https://img-blog.csdnimg.cn/2020080410270591.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个银行账户，账户允许不同的状态，余额大于0处于正常状态，余额大于-2000小于0处于透支状态，余额小于等于-2000处理受限状态。根据余额不同状态可发生转换，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Account</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>NormalState</code>+<code>OverdraftState</code>+<code>RestrictedState</code></li>
</ul>
<p>首先是环境类：</p>
<pre><code class="language-java">class Account
{
    private State state = new NormalState(this);
    private double balance = 0.0;

    public void setState(State state)
    {
        this.state = state;
    }

    public void deposit(double amount)
    {
        balance += amount;
        state.check();
    }

    public void withdraw(double amount)
    {
        balance -= amount;
        state.check();
    }

    public double getBalance()
    {
        return balance;
    }

    @Override
    public String toString()
    {
        return &quot;当前状态:&quot;+state;
    }

}
</code></pre>
<p>初始化为正常状态，余额为0，在存款/取款中调用抽象状态类的状态检查方法，也就是状态转换交由状态类处理。</p>
<p>接着是抽象状态类：</p>
<pre><code class="language-java">abstract class State
{
    protected Account account;
    public abstract void check();
}
</code></pre>
<p>拥有一个环境类的引用，以便使用环境类的<code>setState</code>改变状态方法。</p>
<p>最后是具体状态类：</p>
<pre><code class="language-java">class NormalState extends State
{
    public NormalState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
        else if(account.getBalance() &lt; -2000)
            account.setState(new RestrictedState(account));
    }

    @Override
    public String toString()
    {
        return &quot;正常状态&quot;;
    }
}

class OverdraftState extends State
{
    public OverdraftState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &lt; -2000)
            account.setState(new RestrictedState(account));
    }

    @Override
    public String toString()
    {
        return &quot;透支状态&quot;;
    }
}

class RestrictedState extends State
{
    public RestrictedState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
    }

    @Override
    public String toString()
    {
        return &quot;受限状态&quot;;
    }
}
</code></pre>
<p>三个具体状态类分别表示三种不同状态，在其中的<code>check</code>方法中进行状态检查以及切换状态。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Account account = new Account();
    account.deposit(1000);
    System.out.println(account);        
    account.withdraw(2000);
    System.out.println(account);
    account.withdraw(2000);
    System.out.println(account);
    account.deposit(10000);
    System.out.println(account);
}
</code></pre>
<p>客户端不需要理会具体状态，按正常流程操作即可，下面是输出：<br>
<img src="https://img-blog.csdnimg.cn/20200804104938384.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-共享状态">4 共享状态</h1>
<p>有时候多个环境对象可能需要共享同一个状态，这时需要将状态对象定义为环境类的静态成员，例子如下：</p>
<blockquote>
<p>某个系统要求两个开关对象必须处于一样的状态，要么同时关，要么同时开，开关可以自由切换状态，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Switch</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>OffState</code>+<code>OnState</code></li>
</ul>
<p>环境类：</p>
<pre><code class="language-java">class Switch
{
    private State state;
    private static final State onState;
    private static final State offState;

    private String name;

    static
    {
        onState = new OnState();
        offState = new OffState();
    }

    public Switch(String name)
    {
        this.name = name;
        this.state = offState;
    }

    public String getName()
    {
        return name;
    }

    public void setState(State state)
    {
        this.state = state;
    }

    public static State getOnState()
    {
        return onState;
    }

    public static State getOffState()
    {
        return offState;
    }

    public void on()
    {
        state.on(this);
    }

    public void off()
    {
        state.off(this);
    }
}
</code></pre>
<p>环境类初始化两个静态的开与关状态，在<code>on</code>以及<code>off</code>中调用状态方法。</p>
<p>抽象状态：</p>
<pre><code class="language-java">interface State
{
    void on(Switch s);
    void off(Switch s);
}
</code></pre>
<p>具体状态：</p>
<pre><code class="language-java">class OnState implements State
{
    @Override
    public void on(Switch s)
    {
        System.out.println(&quot;开关&quot;+s.getName()+&quot;已经打开&quot;);
    }

    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;);
        s.setState(Switch.getOffState());
    }
}

class OffState implements State
{
    @Override
    public void on(Switch s)
    {
        System.out.println(&quot;开关&quot;+s.getName()+&quot;开启&quot;);
        s.setState(Switch.getOnState());
    }

    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;已经关闭&quot;);
    }
}
</code></pre>
<p>实现抽象状态的开关方法，处于关状态时调用<code>on</code>会切换到开状态，调用<code>off</code>则不处理，处于开状态同理。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Switch a = new Switch(&quot;A&quot;);
    Switch b = new Switch(&quot;B&quot;);
    a.on();
    b.on();
    a.off();
    b.off();
    a.on();
    b.on();
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/2020080411150944.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-环境类实现状态切换">5 环境类实现状态切换</h1>
<p>在上面的例子中，都是通过具体状态类进行状态切换，比如：</p>
<pre><code class="language-java">class RestrictedState extends State
{
    //...
    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
    }
}
</code></pre>
<pre><code class="language-java">class OnState implements State
{
	//...   
    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;);
        s.setState(Switch.getOffState());
    }
}
</code></pre>
<p>状态切换也可以由环境类进行统一处理，但是如果增加新的状态类可能需要修改环境类代码。例子如下：</p>
<blockquote>
<p>设计一个放大镜工具，单击一次放大一倍，单击两次再放大一杯，第三次就恢复默认大小，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Screen</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>NormalState</code>+<code>LargerState</code>+<code>LargestState</code></li>
</ul>
<p>环境类：</p>
<pre><code class="language-java">class Screen
{
    private State state;
    private static final State normalState;
    private static final State largerState;
    private static final State largestState;

    static
    {
        normalState = new NormalState();
        largerState = new LargerState();
        largestState = new LargestState();
    }

    public Screen()
    {
        this.state = normalState;
    }

    public void onClick()
    {
        if(state == normalState)
            state = largerState;
        else if(state == largerState)
            state = largestState;
        else
            state = normalState;
        state.display();
    }
}
</code></pre>
<p>首先初始化各个状态，然后在<code>onClick()</code>中由环境类控制状态切换。</p>
<p>状态类：</p>
<pre><code class="language-java">interface State
{
    void display();
}

class NormalState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;正常大小&quot;);
    }
}

class LargerState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;两倍大小&quot;);
    }
}

class LargestState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;四倍大小&quot;);
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Screen screen = new Screen();
    screen.onClick();
    screen.onClick();
    screen.onClick();
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200804112804218.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>封装转换规则：状态模式中可以将状态的转换代码封装在环境类或具体状态类中，可以将状态转换代码进行集中管理，而不是分散在一个个业务方法中</li>
<li>通过注入状态修改行为：将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境拥有不同的行为</li>
<li>状态转换逻辑与状态对象一体化：允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>增大运行开销：使用状态模式会增加系统中类和对象的个数</li>
<li>实现复杂：状态模式的程序结构实现复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计难度</li>
<li>对OCP支持不好：增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态，而且修改某个状态类的行为也需要修改对应的源代码</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>对象的行为依赖于它的状态，状态的改变会导致行为的变化</li>
<li>在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合度增强</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200804113352370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-51-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第51期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
