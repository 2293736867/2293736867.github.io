
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Java性能优化的十条小技巧 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/java-xing-neng-you-hua-de-shi-tiao-xiao-ji-qiao.jpeg')">
            </div>
          
          <h2 class="post-title">Java性能优化的十条小技巧</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-03-07</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/-AktfIpz8/">
                    Java
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h1 id="1-systemnanotime">1 <code>System.nanoTime</code></h1>
<p>测试性能时，<code>System.nanoTime</code>比<code>System.currentTimeMills</code>更精确，前者使用纳秒计时，且对系统影响更小。</p>
<p>具体来说：</p>
<ul>
<li><code>System.currentTimeMills</code>返回自<code>1970年1月1日</code>以来经过的毫秒数，返回的精度与操作系统有关</li>
<li><code>System.nanoTime</code>：不是现实时间，是虚拟机提供的计时时间，精确到纳秒</li>
</ul>
<h1 id="2-threadlocalrandom">2 <code>ThreadLocalRandom</code></h1>
<p>通常生成随机数会使用<code>Random</code>类，<code>Random</code>是线程安全的，<code>Random</code>实例里面有一个原子性的种子变量来记录当前种子的值，当要生成新的随机数时，会根据当前种子计算新的种子并更新回原子变量。多线程下计算新种子，会竞争同一个原子变量的更新操作，会造成大量线程进行自旋测试，降低并发性能。</p>
<p>而<code>ThreadLocalRandom</code>在当前线程维护了一个种子，适合在多线程场景下提供高性能的伪随机数生成，使用如下：</p>
<pre><code class="language-java">ThreadLocalRandom random = ThreadLocalRandom.current();
random.nextInt(range);
</code></pre>
<h1 id="3-使用局部变量">3 使用局部变量</h1>
<p>理论上说，访问局部变量会快于类变量，因为局部变量保存在方法栈中，而类变量保存在堆中。如果在某个类方法中需要多次访问类变量，建议先创建一个局部变量并使其具有与类变量相同的值。</p>
<h1 id="4-关于正则表达式替换">4 关于正则表达式替换</h1>
<p>由于正则表达式替换时每次都需要编译正则表达式到一个中间结构，因此比常规的直接替换要慢，如果是固定的正则表达式替换，可以采用预编译的思想：</p>
<pre><code class="language-java">Pattern pattern = Pattern.compile(&quot;origin str&quot;);
public String replace(String str){
	return pattern.matcher(str).replaceAll(&quot;target str&quot;);
}
</code></pre>
<p>而不是采用：</p>
<pre><code class="language-java">public String replace(String str){
	return str.replace(&quot;origin str&quot;,&quot;target str&quot;);
}
</code></pre>
<h1 id="5-关于字符串拼接">5 关于字符串拼接</h1>
<p>尽可能使用如下形式：</p>
<pre><code class="language-java">String a = &quot;xxx&quot;;
String b = &quot;xxx&quot;;
String c = new StringBuilder().append(a).append(b).toString();
</code></pre>
<p>性能相对不好的是如下情形（得益于<code>JVM</code>默认开启字符串拼接优化）：</p>
<pre><code class="language-java">String c = a+b;
</code></pre>
<p>性能最差的是：</p>
<pre><code class="language-java">StringBuilder c = new StringBuilder();
c.append(a);
c.append(b);
String result = c.toString();
</code></pre>
<p>因为这样<code>JIT</code>不会优化。</p>
<p>另外，在无关线程安全的情况下，尽可能使用<code>StringBuilder</code>而不是<code>StringBuffer</code>。</p>
<h1 id="6-关于数字转字符串">6 关于数字转字符串</h1>
<p><code>int</code>转<code>String</code>是一个较为耗时的操作，尽量避免不必要的转化，如果确实需要，可以预先将一批<code>int</code>转为<code>String</code>，需要的时候直接取出：</p>
<pre><code class="language-java">public static class CommonUtil{
	static int cacheSize = 1024;
	static String [] caches = new String[cacheSize];
	static{
		for(int i=0;i&lt;cacheSize;++i){
			caches[i] = String.valueOf(i);
		}
	}
	public static String int2String(int data){
		if(data &lt; cacheSize){
			return caches[size];
		}else{
			return String.valueOf(data);
		}
	}
}
</code></pre>
<p>这样相比起直接使用</p>
<pre><code class="language-java">Stirng.valueOf(data)
</code></pre>
<p>性能会高一点。</p>
<h1 id="7-switchif">7 <code>switch</code>/<code>if</code></h1>
<p>少分支的情况下，建议使用<code>if</code>，多分支建议使用<code>switch</code>，常用的“少分支”标准是<code>2-5个</code>。</p>
<h1 id="8-采用返回码而不是抛异常">8 采用返回码而不是抛异常</h1>
<p>除非必要使用异常，应该避免把正常的返回错误结果使用异常来代替。抛异常会导致性能是因为构造异常对象时需要一个填写异常栈的过程，就是<code>Throwable</code>中的<code>fillInStackTrace</code>，这是一个<code>Native</code>方法，会填写异常栈，造成较为严重的耗时。</p>
<p>一种优化方法是，自定义异常，重写<code>fillInStackTrace()</code>：</p>
<pre><code class="language-java">public class MyException extends RuntimeException{
	...
	public synchronized Throwable fillInStackTrace(){
		this.setStackTrace(new StackTraceElement[0]);
		return this;
	}
}
</code></pre>
<p>另外，<code>JVM</code>会对频繁抛出的异常做<code>Fast Throw</code>优化，如果检测到代码中某一位置连续多次抛出同一类型的异常，则采用<code>Fast Throw</code>方式，异常栈信息不会被填写，这种异常抛出速度很快，因为不需要在堆里分配内存，也不需要构造完整的异常栈信息，默认对如下异常采用<code>Fast Throw</code>优化：</p>
<ul>
<li><code>NullPointerException</code></li>
<li><code>ArithmeticException</code></li>
<li><code>ArrayIndexOutOfBoundsExpcetion</code></li>
<li><code>ArrayStoreException</code></li>
<li><code>ClassCastException</code></li>
</ul>
<p>需要注意的是，<code>Fast Throw</code>虽然提高了性能，但是会导致异常栈消息，从而无法快速定位到错误代码，如果需要避免异常栈优化，可以使用参数：</p>
<pre><code class="language-java">-XX:-OmitStackTraceInFastThrow
</code></pre>
<h1 id="9-位运算">9 位运算</h1>
<p>可以通过位运算代替部分算术运算以提高性能，比如：</p>
<ul>
<li>判断奇数：<code>(a &amp; 1) == 1</code></li>
<li>判断偶数：<code>(a &amp; 1) == 0</code></li>
<li>除2：<code>a&gt;&gt;1</code></li>
<li>乘2：<code>a&lt;&lt;1</code></li>
</ul>
<h1 id="10-其他技巧">10 其他技巧</h1>
<ul>
<li>字符串搜索等需要搜索单个字符时，使用<code>String.indexOf(char)</code>而不是<code>String.indexOf(String)</code></li>
<li>对于判断一些特殊的<code>ID</code>，比如长度<code>9位</code>且以<code>11</code>开头，可以直接使用常数判断：<code>id&gt;=110_000_000 &amp;&amp; id&lt;=120_000_000</code>，而不需要通过<code>String.valueOf</code>转为字符串再通过<code>String.length</code>+<code>String.startWith</code>判断</li>
<li>在<code>switch</code>中，可以使用<code>int</code>去代替<code>String</code></li>
<li>日志输出可以直接使用字符串拼接而不是<code>模板+{}</code>，因为会有一个占位符<code>{}</code>替换成目标变量的耗时过程，被频繁调用的话建议直接字符串拼接</li>
<li>传输的实体类尽量避免使用<code>String</code>，因为其中涉及序列化、反序列化、字符串构造，而对于<code>byte[]</code>构造<code>String</code>的方法，内部会调用<code>StringCoding.decode</code>，相比起通过<code>char[]</code>/<code>Stirng</code>构造会造成更大的耗时</li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-265-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第265期
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
