
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（九）：适配器模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-jiu-gua-pei-qi-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（九）：适配器模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-24</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E5%88%86%E7%B1%BB">1.3 分类</a>
<ul>
<li><a href="#131-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1.3.1 对象适配器模式</a></li>
<li><a href="#132-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1.3.2 类适配器模式</a></li>
</ul>
</li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%9B%AE%E6%A0%87%E6%8A%BD%E8%B1%A1%E7%B1%BB">2.2 目标抽象类</a></li>
<li><a href="#23-%E9%80%82%E9%85%8D%E8%80%85%E7%B1%BB">2.3 适配者类</a></li>
<li><a href="#24-%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB">2.4 适配器类</a>
<ul>
<li><a href="#241-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8">2.4.1 对象适配器</a></li>
<li><a href="#242-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8">2.4.2 类适配器</a></li>
</ul>
</li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8">4 双向适配器</a></li>
<li><a href="#5-%E7%BC%BA%E7%9C%81%E9%80%82%E9%85%8D%E5%99%A8">5 缺省适配器</a>
<ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89">5.1 定义</a></li>
<li><a href="#52-%E7%BB%93%E6%9E%84%E5%9B%BE">5.2 结构图</a></li>
<li><a href="#53-%E8%A7%92%E8%89%B2">5.3 角色</a></li>
<li><a href="#54-%E5%AE%9E%E4%BE%8B">5.4 实例</a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>有的笔记本电脑工作电压为20V，而我国家庭用电为220V，如何让20V的笔记本在220V的电压下工作？答案就是引入一个电源适配器，有了这个电源适配器笔记本就能在220V的电压下工作。</p>
<p>在软件开发中，有时也会存在这类不兼容的状况，需要引入一个像电源适配器这样的称之为适配器的角色来协调这些不兼容的结构，这种设计方案就是适配器模式。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>将一个接口转换为客户希望的另一个接口，使接口不兼容的那些类可以一起工作，别名为包装器。</strong></p>
<p>适配器中的接口是广义的接口，可以表示一个方法或者方法的集合。</p>
<p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<h2 id="13-分类">1.3 分类</h2>
<p>根据适配器与适配者类的关系不同，可以分为对象适配器模式以及类适配器模式。</p>
<h3 id="131-对象适配器模式">1.3.1 对象适配器模式</h3>
<p><strong>对象适配器模式就是适配器与适配者之间是关联关系</strong>。</p>
<p>结构图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200724211913928.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="132-类适配器模式">1.3.2 类适配器模式</h3>
<p><strong>类适配器模式就是适配器与适配者之间是继承或实现关系。</strong></p>
<p>结构图如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200724212614271.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>由于语言特性的限制，比如Java，C#不支持多重继承，类适配器模式受到很多限制，例如Target如果不是接口而是一个类，就无法使用类适配器模式。此外如果适配者为<code>final</code>类也无法使用适配器模式，在Java等语言中大部分情况下使用对象适配器模式。</p>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong>Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是一个具体类</strong></li>
<li><strong>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器类是适配器模式的核心，在对象适配器模式中，它通过继承Target并关联一个Adaptee对象使两者产生联系，在类适配器模式，通过继承Adaptee并实现Target使两者产生联系</strong></li>
<li><strong>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义目标抽象类：接口/抽象类/具体类，客户端需要的接口，比如上面电源的例子，目标类就是给笔记本充电</li>
<li>（可选）定义适配者类：定义适配者类，但是一般来说适配者已经存在，比如上面电源的例子，适配者类就是220V的电压，而且对于某些库来说可能没有适配者的源码</li>
<li>定义适配器类：继承/实现目标抽象类，并通过转发请求到适配者来完成操作</li>
</ul>
<h2 id="22-目标抽象类">2.2 目标抽象类</h2>
<p>这里实现为具体类：</p>
<pre><code class="language-java">class Target
{
    public void request()
    {
        System.out.println(&quot;Target方法&quot;);
    }
}
</code></pre>
<h2 id="23-适配者类">2.3 适配者类</h2>
<p>适配者一般为具体类，但是很多情况下已经存在并且没有源码实现：</p>
<pre><code class="language-java">class Adaptee
{
    public void specificRequest()
    {
        System.out.println(&quot;Adaptee方法&quot;);
    }
}
</code></pre>
<h2 id="24-适配器类">2.4 适配器类</h2>
<h3 id="241-对象适配器">2.4.1 对象适配器</h3>
<p>对象适配器种适配器与适配者是关联关系，适配器中包含一个适配者成员，代码如下：</p>
<pre><code class="language-java">class Adapter extends Target
{
    private Adaptee adaptee = new Adaptee();
    @Override
    public void request()
    {
        adaptee.specificRequest();
    }
}
</code></pre>
<p>适配器覆盖目标抽象类的<code>request</code>，并将请求转发，交由适配者完成。</p>
<h3 id="242-类适配器">2.4.2 类适配器</h3>
<p>类适配器中适配器与适配者是继承关系，其中适配者为父类，适配器为子类。但是在Java中由于不支持多重继承，因此想要在Java中实现类适配器模式，并且如果适配者是具体类的话，那么必须将目标抽象类指定为接口：</p>
<pre><code class="language-java">interface Target
{
    void request();
}

class Adaptee
{
    public void specificRequest()
    {
        System.out.println(&quot;Adaptee方法&quot;);
    }
}

class Adapter extends Adaptee implements Target
{
    @Override
    public void request()
    {
        super.specificRequest();
    }
}
</code></pre>
<p>在上述对象适配器的基础上，将目标抽象类修改为接口，同时适配器继承了适配者并实现了Target，并取消了适配者作为成员变量，在方法内直接调用<code>super.xxx</code>，也就是适配者的方法。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<p>客户端的代码很简单，针对目标抽象类进行编程：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Target adapter = new Adapter();
    adapter.request();
}
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>假设目前只有一条Micro USB线以及一台只有Type-C接口的手机，需要对其进行充电，这时候就需要一个转接头把Micro USB转为Type-C接口，才能给手机充电，使用适配器模式对其进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>目标抽象类：<code>TypeC</code></li>
<li>适配者类：<code>MicroUSB</code></li>
<li>适配器：<code>MicroUSBToTypeC</code></li>
</ul>
<p>简化实现代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        TypeC typeC = new MicroUSBToTypeC();
        typeC.chargeWithTypeC();
    }
}

//Target:给TypeC接口的手机充电
interface TypeC
{
    void chargeWithTypeC();
}

//Adaptee:适配者,MicroUSB线
class MicroUSB
{
    public void chargeWithMicroUSB()
    {
        System.out.println(&quot;MicroUSB充电&quot;);
    }
}

//Adapter:适配器,MicroUSB到TypeC的转接头
class MicroUSBToTypeC implements TypeC
{
    private MicroUSB microUSB = new MicroUSB();
    @Override
    public void chargeWithTypeC()
    {
        microUSB.chargeWithMicroUSB();
    }
}
</code></pre>
<h1 id="4-双向适配器">4 双向适配器</h1>
<p>在对象适配器的使用过程中，如果在适配器中同时包含对Target类和Adaptee类的引用，Adaptee类可以通过适配器调用Target类中的方法，Target类也可以通过适配器调用Adaptee类的方法，那么该适配器就是一个双向适配器。例子如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Adapter adapter = new Adapter();
        adapter.request();
        adapter.specificRequest();
    }
}

//适配者
interface Adaptee
{
    void specificRequest();
}

//Target类
interface Target
{
    void request();
}

//Target实现
class TargetImpl implements Target
{
    @Override
    public void request()
    {
        System.out.println(&quot;Target方法&quot;);
    }
}

//适配者实现
class AdapteeImpl implements Adaptee
{
    @Override
    public void specificRequest()
    {
        System.out.println(&quot;Adaptee方法&quot;);
    }
}

//适配器
class Adapter implements Adaptee,Target
{
    private Target target = new TargetImpl();
    private Adaptee adaptee = new AdapteeImpl();
    @Override
    public void request()
    {
    	//Target的方法调用适配者方法
        adaptee.specificRequest();
    }

    @Override
    public void specificRequest()
    {
    	//适配者方法调用Target的方法
        target.request();        
    }
}
</code></pre>
<h1 id="5-缺省适配器">5 缺省适配器</h1>
<h2 id="51-定义">5.1 定义</h2>
<p><strong>缺省适配器：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法都提供一个默认实现（空实现），那么该抽象类子类可以选择性覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中所有方法的情况，又叫单接口适配器模式。</strong></p>
<h2 id="52-结构图">5.2 结构图</h2>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200724220658161.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="53-角色">5.3 角色</h2>
<ul>
<li><strong><code>ServiceInterface</code>（适配者接口）：通常是一个声明了大量方法的接口</strong></li>
<li><strong><code>AbstractServiceClass</code>（缺省适配器类）：缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法，通常定义为抽象类</strong></li>
<li><strong><code>ConcreteServiceClass</code>（具体业务类）：是缺省适配器类的子类，只需要有选择性地覆盖适配器者中定义的方法，其他的方法在缺省适配器类中提供了空实现</strong></li>
</ul>
<h2 id="54-实例">5.4 实例</h2>
<p>Java AWT中一般可以通过两种方式来处理窗口事件：</p>
<ul>
<li>实现<code>WindowListener</code></li>
<li>继承<code>WindowAdapter</code></li>
</ul>
<p>其中<code>WindowAdapter</code>实现了<code>WindowListener</code>接口，但是都是提供了空实现，也就是说实现<code>WindowsListener</code>的话需要实现里面所有的方法，而继承<code>WindowAdapter</code>只需要选择性地覆盖方法即可，结构图：<br>
<img src="https://img-blog.csdnimg.cn/20200724222411465.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-主要优点">6 主要优点</h1>
<p>类适配器以及对象适配器的共同优点如下：</p>
<ul>
<li>解耦：将Target与Adaptee解耦，引入适配器来重用现有的适配者类，无须修改原有结构</li>
<li>提高复用性：将具体的业务实现过程封装在适配者类中，对于客户端而言是透明的，而且提高了适配者类的复用性，同一个适配者类可以在多个不同的系统复用</li>
<li>扩展性好：可以很方便地更换适配器，也可以在不修改代码的基础上增加了新的适配器类，完全符合开闭原则，扩展灵活</li>
</ul>
<p>类适配器的独有优点如下：</p>
<ul>
<li>由于适配器类是适配者的子类，因此在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li>
</ul>
<p>对象适配器的独有优点如下：</p>
<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个Target</li>
<li>可以适配一个适配者的子类，由于适配器与适配者之间是关联关系，根据LSP（里氏代换原则），适配者的子类也可以通过该适配器进行适配</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<p>类适配器缺点：</p>
<ul>
<li>对于Java，C#等不支持多重继承的语言，一次最多只能适配一个适配者类</li>
<li>适配者不能是“不能继承的类”，比如Java的<code>final</code>类，C#的<code>sealed</code>类</li>
<li>在Java，C#等Target只能是接口不能是类</li>
</ul>
<p>对象适配器缺点：</p>
<ul>
<li>置换麻烦：相比起类适配器，在适配器中置换适配者的某些方法比较麻烦，需要先创建一个适配者类的子类，在子类将适配者类的方法置换掉，再把适配者的子类作为真正的适配者类进行适配，实现较为复杂</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需求，甚至没有这些类的源代码</li>
<li>想创建一个可以重复使用的类，用于与彼此之间没有太大关联的类，包括可能在将来引进的类一起工作</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200729075145937.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/vue-xue-xi-bi-ji-si/">
              <h3 class="post-title">
                下一篇：Vue学习笔记（四）
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
