
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（六）：抽象工厂模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-liu-chou-xiang-gong-han-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（六）：抽象工厂模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-29</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a>
<ul>
<li><a href="#111-%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E7%BB%93%E6%9E%84">1.1.1 产品等级结构</a></li>
<li><a href="#112-%E4%BA%A7%E5%93%81%E6%97%8F">1.1.2 产品族</a></li>
</ul>
</li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81">2.2 抽象产品</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81">2.3 具体产品</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">2.4 抽象工厂</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82">2.5 具体工厂</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%9C%89%E5%85%B3ocp">4 有关OCP</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在了解抽象工厂模式之前，首先来了解一下两个术语：</p>
<ul>
<li>产品等级结构</li>
<li>产品族</li>
</ul>
<h3 id="111-产品等级结构">1.1.1 产品等级结构</h3>
<p>产品等级结构也就是产品的继承结构，例如一个抽象类是电视机，子类有不同品牌的电视机，比如海尔电视机，海信电视机，TCL电视机，而抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是子类。</p>
<h3 id="112-产品族">1.1.2 产品族</h3>
<p>产品族是指由一个同一个工厂产生的位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机，海尔电冰箱。海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机与海尔电冰箱共同构成了一个产品族。</p>
<p>两者示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200716202932265.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式是针对一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。</p>
<p>每一个具体工厂可以生产属于一个产品族的所有产品，所生产的产品又位于不同的产品等级结构中，在上图的例子中，如果使用工厂方法模式需要12个具体工厂类，而使用抽象工厂模式只需要4个工厂类，大大减少了系统中类的个数。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</strong></p>
<p>抽象工厂模式又叫Kit模式，是一种对象创建型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200716202048426.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>AbstractFactory</code>（抽象工厂）：声明了一组用于创建一族产品的方法，每一个方法对应一种产品</strong></li>
<li><strong><code>ConcreteFactory</code>（具体工厂）：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品的等级结构中</strong></li>
<li><strong><code>AbstractProduct</code>（抽象产品）：为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</strong></li>
<li><strong><code>ConcreteProduct</code>（具体产品）：定义具体工厂生产的具体对象，实现在抽象层产品接口中声明的业务方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>确定产品等级结构：也就是定义抽象产品，抽象产品的数量就是产品等级结构的数量，为抽象产品声明产品所具有的业务方法</li>
<li>确定产品族：也就是定义具体产品，对于每个抽象产品，有多少个子类就有多少个产品族，具体产品类实现或继承抽象产品，实现其中的业务方法</li>
<li>定义抽象工厂：定义为接口/抽象类，声明创建一族产品的方法，根据产品等级结构数量确定方法数量</li>
<li>定义具体工厂：实现/继承抽象工厂，实现其中的业务方法</li>
</ul>
<h2 id="22-抽象产品">2.2 抽象产品</h2>
<p>这里简单定义两个抽象产品接口，也就是假设有两个产品等级结构（A与B）：</p>
<pre><code class="language-java">interface ProductA
{
    void methodA();
}

interface ProductB
{
    void methodB();
}
</code></pre>
<h2 id="23-具体产品">2.3 具体产品</h2>
<p>声明四个具体产品，假设每种产品由分别两个工厂生产，也就是假设有两个产品族：</p>
<pre><code class="language-java">class ProductA1 implements ProductA
{
    public void methodA()
    {
        System.out.println(&quot;Product A1&quot;);
    }
}

class ProductA2 implements ProductA
{
    public void methodA()
    {
        System.out.println(&quot;Product A2&quot;);
    }
}

class ProductB1 implements ProductB
{
    public void methodB()
    {
        System.out.println(&quot;Product B1&quot;);
    }
}

class ProductB2 implements ProductB
{
    public void methodB()
    {
        System.out.println(&quot;Product B2&quot;);
    }
}
</code></pre>
<h2 id="24-抽象工厂">2.4 抽象工厂</h2>
<p>由于只有两个产品等级结构（A与B），这里的抽象工厂只需要两个方法，分别表示生产这两种产品：</p>
<pre><code class="language-java">interface Factory
{
    ProductA getProductA();
    ProductB getProductB();
}
</code></pre>
<h2 id="25-具体工厂">2.5 具体工厂</h2>
<p>由于上面已经假设为两个产品族，因此这里需要两个具体工厂：</p>
<pre><code class="language-java">//产品族Factory1
class Factory1 implements Factory
{
    public ProductA getProductA()
    {
        return new ProductA1();
    }

    public ProductB getProductB()
    {
        return new ProductB1();
    }
}

//产品族Factory2
class Factory2 implements Factory
{
    public ProductA getProductA()
    {
        return new ProductA2();
    }

    public ProductB getProductB()
    {
        return new ProductB2();
    }
}
</code></pre>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) {
    Factory factory = new Factory1();
    ProductA productA = factory.getProductA();
    ProductB productB = factory.getProductB();
    productA.methodA();
    productB.methodB();

    factory = new Factory2();
    productA = factory.getProductA();
    productB = factory.getProductB();
    productA.methodA();
    productB.methodB();
}
</code></pre>
<p>客户端针对抽象工厂以及抽象产品编程，只需要知道工厂类名即可获取同一工厂（同一产品族）不同产品等级结构的产品。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>界面皮肤库设计：开发一套皮肤库，用户可以通过菜单选择皮肤，不同的皮肤提供视觉不同的按钮，文本框等UI元素，使用抽象工厂模式进行设计。</p>
</blockquote>
<p>这里简单起见假设开发两套皮肤：</p>
<ul>
<li>春季皮肤（SpringSkin）</li>
<li>夏季皮肤（SummerSkin）</li>
</ul>
<p>每套皮肤具有以下UI元素：</p>
<ul>
<li>按钮（Button）</li>
<li>文本框（TextField）</li>
<li>组合框（ComboBox）</li>
</ul>
<p>具体设计如下：</p>
<ul>
<li>抽象产品：<code>Button</code>+<code>TextField</code>+<code>ComboBox</code></li>
<li>具体产品：<code>SpringButton</code>+<code>SummerButton</code>+<code>SpringTextField</code>+<code>SummerTextField</code>+<code>SpringComboBox</code>+<code>SummerComboBox</code></li>
<li>抽象工厂：<code>SkinFactory</code></li>
<li>具体工厂：<code>SpringSkinFactory</code>+<code>SummerSkinFactory</code></li>
</ul>
<p>先设计产品类：</p>
<pre><code class="language-java">//抽象产品
interface Button
{
    void display();
}

//具体产品
class SpringButton implements Button
{
    public void display()
    {
        System.out.println(&quot;春季皮肤按钮&quot;);
    }
}

//具体产品
class SummerButton implements Button
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤按钮&quot;);
    }
}

//抽象产品
interface TextField
{
    void display();
}

//具体产品
class SpringTextField implements TextField
{
    public void display()
    {
        System.out.println(&quot;春季皮肤文本框&quot;);
    }
}

//具体产品
class SummerTextField implements TextField
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤文本框&quot;);
    }
}

//抽象产品
interface ComboBox
{
    void display();
}

//具体产品
class SpringComboBox implements ComboBox
{
    public void display()
    {
        System.out.println(&quot;春季皮肤组合框&quot;);
    }
}

//具体产品
class SummerComboBox implements ComboBox
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤组合框&quot;);
    }
}
</code></pre>
<p>接着是工厂类：</p>
<pre><code class="language-java">//抽象工厂
interface SkinFactory
{
    Button createButton();
    TextField createTextField();
    ComboBox createComboBox();
}

//具体工厂
class SpringSkinFactory implements SkinFactory
{
    public Button createButton()
    {
        return new SpringButton();
    }

    public TextField createTextField()
    {
        return new SpringTextField();
    }

    public ComboBox createComboBox()
    {
        return new SpringComboBox();
    }
}

//具体工厂
class SummerSkinFactory implements SkinFactory
{
    public Button createButton()
    {
        return new SummerButton();
    }

    public TextField createTextField()
    {
        return new SummerTextField();
    }

    public ComboBox createComboBox()
    {
        return new SummerComboBox();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        SkinFactory factory = new SpringSkinFactory();
        factory.createButton().display();
        factory.createTextField().display();
        factory.createComboBox().display();
        
        factory = new SummerSkinFactory();
        factory.createButton().display();
        factory.createTextField().display();
        factory.createComboBox().display();
    }
}
</code></pre>
<h1 id="4-有关ocp">4 有关OCP</h1>
<p>虽然使用抽象工厂模式增加新的皮肤界面非常方便，但是如果增加一个UI元素，会修改大量的代码，需要修改抽象工厂以及每一个具体工厂类，也就是说，不能够在符合OCP（开放闭合原则）的前提下增加新的组件。</p>
<p>这是抽象工厂模式的最大缺点，<strong>尽管增加新的产品族（这里是皮肤）非常方便，但是增加新的产品等级结构（这里是UI元素）很麻烦。抽象工厂模式的这种性质叫做开闭原则的倾斜性</strong>。因此设计人员在设计之初需要全面考虑，否则新增产品结构会导致大量的代码修改。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>隔离：抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离更换一个具体工厂类变得很相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</li>
<li>同一产品族对象：当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加产品族容易：增加新的产品族容易，无须修改已有系统，符合OCP</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<p>主要缺点是增加新的产品等级结构麻烦，需要对系统进行大量的修改，违背了OCP。</p>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>一个系统不当应依赖与产品类实例如何被创建，组合和表达细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建以及使用解耦</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一皮肤下的按钮以及文本框，按钮与文本框没有直接联系，但是都属于同一皮肤</li>
<li>产品等级结构稳定，设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200728225937668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（五）：工厂方法模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
