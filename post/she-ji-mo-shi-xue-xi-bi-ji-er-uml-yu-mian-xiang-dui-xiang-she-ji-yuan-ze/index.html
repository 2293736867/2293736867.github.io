
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（二）：UML与面向对象设计原则 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-er-uml-yu-mian-xiang-dui-xiang-she-ji-yuan-ze.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（二）：UML与面向对象设计原则</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-11</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-uml">1 UML</a>
<ul>
<li><a href="#11-uml">1.1 UML</a></li>
<li><a href="#12-uml%E7%89%B9%E6%80%A7">1.2 UML特性</a></li>
<li><a href="#13-uml%E7%BB%93%E6%9E%84">1.3 UML结构</a>
<ul>
<li><a href="#131-%E8%A7%86%E5%9B%BE">1.3.1 视图</a></li>
<li><a href="#132-%E5%9B%BE">1.3.2 图</a></li>
<li><a href="#133-%E6%A8%A1%E5%9E%8B%E5%85%83%E7%B4%A0">1.3.3 模型元素</a></li>
<li><a href="#134-%E9%80%9A%E7%94%A8%E6%9C%BA%E5%88%B6">1.3.4 通用机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-uml%E7%B1%BB%E5%9B%BE">2 UML类图</a>
<ul>
<li><a href="#21-%E7%B1%BB%E5%9B%BE">2.1 类图</a>
<ul>
<li><a href="#211-%E7%B1%BB%E5%90%8D">2.1.1 类名</a></li>
<li><a href="#212-%E5%B1%9E%E6%80%A7">2.1.2 属性</a></li>
<li><a href="#213-%E6%93%8D%E4%BD%9C">2.1.3 操作</a></li>
</ul>
</li>
<li><a href="#22-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">2.2 类之间的关系</a></li>
</ul>
</li>
<li><a href="#3-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB">3 关联关系</a>
<ul>
<li><a href="#31-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94">3.1 双向关联</a></li>
<li><a href="#32-%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94">3.2 单向关联</a></li>
<li><a href="#33-%E8%87%AA%E5%85%B3%E8%81%94">3.3 自关联</a></li>
<li><a href="#34-%E5%A4%9A%E9%87%8D%E6%80%A7%E5%85%B3%E8%81%94">3.4 多重性关联</a></li>
<li><a href="#35-%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB">3.5 聚合关系</a></li>
<li><a href="#36-%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB">3.6 组合关系</a></li>
</ul>
</li>
<li><a href="#4-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">4 依赖关系</a></li>
<li><a href="#5-%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB">5 泛化关系</a></li>
<li><a href="#6-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB">6 接口与实现关系</a></li>
<li><a href="#7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">7 面向对象设计原则</a>
<ul>
<li><a href="#71-%E6%A6%82%E8%BF%B0">7.1 概述</a></li>
<li><a href="#72-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp">7.2 单一职责原则SRP</a></li>
<li><a href="#73-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99ocp">7.3 开闭原则OCP</a></li>
<li><a href="#74-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99lsp">7.4 里氏代换原则LSP</a></li>
<li><a href="#75-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99dip">7.5 依赖倒转原则DIP</a></li>
<li><a href="#76-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99isp">7.6 接口隔离原则ISP</a></li>
<li><a href="#77-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99crp">7.7 合成复用原则CRP</a>
<ul>
<li><a href="#771-%E7%BB%A7%E6%89%BF">7.7.1 继承</a></li>
<li><a href="#772-%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88">7.7.2 组合/聚合</a></li>
</ul>
</li>
<li><a href="#78-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99lod">7.8 迪米特法则LoD</a></li>
</ul>
</li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-uml">1 UML</h1>
<h2 id="11-uml">1.1 UML</h2>
<p>UML（Unified Modeling Language）是统一建模语言，1997年11月UML1.1版本提交给OMG并正式通过，成为建模语言的个那个也标准。2003年6月UML2.0获得正式通过。</p>
<h2 id="12-uml特性">1.2 UML特性</h2>
<ul>
<li><strong>U（Unified）：统一，UML融合了多种优秀的面向对象建模方法以及多种得到认可的软件工程方法，消除了因方法林立且相互独立而带来的种种不便，集众家之长，故名“统一”。通过统一的表示方法可以让不同知识背景的领域专家，系统分析设计人员以及开发人员可以方便地交流</strong></li>
<li><strong>M（Modeling）：UML是一种通用的可视化建模语言，不同与编程语言，UML通过一些标准的图形符号和文字来对系统进行建模，用于对软件进行描述，可视化处理，构造系统制品的文档。UML适用于各种软件开发方法，软件生命周期的各个阶段，各种应用领域以及各种开发工具</strong></li>
<li><strong>L（Language）：UML是一种语言，也就意味着它有属于自己的标准表达规则，不是一种类似Java，C++的编程语言，而是一种分析设计语言，一种建模语言</strong></li>
</ul>
<h2 id="13-uml结构">1.3 UML结构</h2>
<p>UML结构通常包括以下4个部分：视图，图，模型元素以及通用机制。</p>
<h3 id="131-视图">1.3.1 视图</h3>
<p>UML视图用于从不同的角度来表示待建模的系统。视图是由许多图形组成的一个抽象集合，在建立一个系统模型时，只有通过定义多个视图，每个视图显示该系统的一个特定方面，才能构造出该系统的完整蓝图。</p>
<p>UML视图包括：</p>
<ul>
<li>用户视图：以用户的观点表示系统的目标，是所有视图的核心，用于描述系统的需求</li>
<li>结构视图：系统的静态行为，描述系统的静态元素，比如包，类，对象以及它们之间的关系</li>
<li>行为视图：系统的动态行为，描述系统的组成元素在系统运行时的交互关系</li>
<li>实现视图：系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系</li>
<li>环境视图：系统中物理元素的分布，描述系统中硬件设备以及他们之间的关系</li>
</ul>
<h3 id="132-图">1.3.2 图</h3>
<p>UML图是描述UML视图内容的图形，UML2.0提供了13种图，分别是用例图，类图，对象图，包图，组合结构图，状态图，活动图，顺序图，通信图，定时图，交互概览图，组件图和部署图。其中：</p>
<ul>
<li>用例图对应用户视图</li>
<li>类图，对象图，包图和组合结构图对应结构视图</li>
<li>状态图，活动图，顺序图，通信图，定时图和交互概览图对应行为视图</li>
<li>组件图对应实现视图</li>
<li>部署图对应环境视图</li>
</ul>
<h3 id="133-模型元素">1.3.3 模型元素</h3>
<p>模型元素是指UML图中所使用的一些概念，对应于普通的面向对象概念，如类，对象，消息以及这些概念之间的关系，如关联关系，泛化关系等。</p>
<h3 id="134-通用机制">1.3.4 通用机制</h3>
<p>UML提供的通用机制为模型元素提供额外的注释，信息和语义，这些通用机制也提供了扩展机制，允许用户对UML进行扩展，如定义新的建模元素，扩展原有的语义，添加新的特殊信息来扩展模型元素的规则说明等，以便适用于特定的方法或过程，组织和用户。</p>
<h1 id="2-uml类图">2 UML类图</h1>
<h2 id="21-类图">2.1 类图</h2>
<p>类封装了数据和行为，是具有相同属性，操作，关系的对象集合的总称。类图是用出现在系统中不同类来描述系统的静态结构，主要描述不同的类以及它们之间的关系。</p>
<p>在UML中，类图包含类名，属性以及操作。如下面的Employee类：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200710201647414.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>类一般由三部分组成：</p>
<ul>
<li>类名</li>
<li>属性</li>
<li>操作</li>
</ul>
<h3 id="211-类名">2.1.1 类名</h3>
<p>类名就是类的名字，一个字符串。</p>
<h3 id="212-属性">2.1.2 属性</h3>
<p>类的成员变量，一般的格式为</p>
<pre><code class="language-bash">可见性 名称 : 类型 [ = 默认值]
</code></pre>
<p>可见性表示该属性对于类外的元素是否可见，包括：</p>
<ul>
<li>公有：<code>+</code></li>
<li>私有：<code>-</code></li>
<li>受保护：<code>#</code></li>
<li>包：<code>~</code></li>
</ul>
<h3 id="213-操作">2.1.3 操作</h3>
<p>UML规定操作的定义方式为：</p>
<pre><code class="language-bash">可见性 名称(参数列表)[ : 返回类型]
</code></pre>
<ul>
<li>可见性与属性可见性的定义一致</li>
<li>参数列表表示方法的参数，语法与属性定义类似，用<code>,</code>分隔</li>
</ul>
<h2 id="22-类之间的关系">2.2 类之间的关系</h2>
<p>UML提供了四种不同的方式表示类与类之间的关系：</p>
<ul>
<li>关联关系</li>
<li>依赖关系</li>
<li>泛化关系</li>
<li>接口与实现关系</li>
</ul>
<p>下面逐个看一下。</p>
<h1 id="3-关联关系">3 关联关系</h1>
<p>关联关系是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML中用实线连接有关联关系的类。可以在关联线上标注角色名，关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的，但可以使类之间的关系更加明确。</p>
<p>例如在一个登录界面类<code>LoginForm</code>包含一个<code>JButton</code>：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200710230718471.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>UML中关联通常包括以下六种形式：</p>
<ul>
<li>双向关联</li>
<li>单向关联</li>
<li>自关联</li>
<li>多重性关联</li>
<li>聚合关系</li>
<li>组合关系</li>
</ul>
<h2 id="31-双向关联">3.1 双向关联</h2>
<p>默认情况下关联是双向的，例如顾客购买商品并拥有商品，反之卖出的商品总是某个顾客与之相关联：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200710231216478.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-单向关联">3.2 单向关联</h2>
<p>关联也可以是单向的，在UML中关联用带箭头的实线表示，比如顾客拥有地址：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200710231436264.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-自关联">3.3 自关联</h2>
<p>系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系为自关联，常见于链表：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200710231728997.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="34-多重性关联">3.4 多重性关联</h2>
<p>多重性关联又称为多重性关联联系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或者一个数字范围来表示。常见的表示方式如下：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200710233413832.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>例如一个界面可以具有0个或多个按钮，但是一个按钮只能从属于一个界面：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200710233621254.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="35-聚合关系">3.5 聚合关系</h2>
<p>聚合关系表示整体与部分的关系，使用空心菱形表示。聚合关系中部分是整体的一部分，但是部分可以脱离整体独立存在，比如引擎是汽车的一部分，但是引擎可以独立于汽车存在：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200710234027538.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="36-组合关系">3.6 组合关系</h2>
<p>组合关系也表示整体与部分之间的关系，但是部分不能脱离整体存在。组合关系使用实心菱形表示。比如人的头和嘴巴是组合关系：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200710234310219.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-依赖关系">4 依赖关系</h1>
<p>依赖关系是一种使用关系，在需要表示“一个事物使用另一个事物”时使用依赖关系。UML中依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如驾驶员开车，开车需要车，也就是驾驶员依赖于车：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200710234731593.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-泛化关系">5 泛化关系</h1>
<p>泛化关系也就是继承关系，用于描述父类与子类之间的关系，父类又叫基类或者超类，子类又称作派生类。UML中泛化关系用带空心三角形的直线表示，箭头指向基类：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200710235324792.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-接口与实现关系">6 接口与实现关系</h1>
<p>很多语言比如Java，C#都有接口的概念，接口通常没有属性，所有是操作都是抽象的，只有操作的声明没有操作的实现。UML中使用<code>&lt;&lt;Interface&gt;&gt;</code>表示接口：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200710235919561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>类与接口之间的实现关系使用空心三角形+虚线表示：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200710235847382.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="7-面向对象设计原则">7 面向对象设计原则</h1>
<h2 id="71-概述">7.1 概述</h2>
<p>面向对象设计的目标之一是支持可维护性复用，一方面需要实现设计方案或者源代码的重用，一方面要确保系统能够易于扩展和修改，具有较好的灵活性。面向对象设计原则由此诞生，它们蕴含于很多设计模式中，是从许多方案总结出来的指导性原则。常见的7种面向对象设计原则如下：</p>
<ul>
<li>单一权责原则</li>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法则</li>
</ul>
<h2 id="72-单一职责原则srp">7.2 单一职责原则SRP</h2>
<p><strong>单一权责原则（Single Responsibility Principal）：一个类只负责一个功能领域中的相应职责。<br>
或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
<p>单一权责原则的核心思想是：一个类不能太“累”。一个类（大到模块，小到方法）承担的职责越多，被复用的可能性越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此需要将职责分离，封装在不同的类中，即将不同的变化原因封装在不同的类中。单一权责原则是实现高内聚，低耦合的指导方针。</p>
<h2 id="73-开闭原则ocp">7.3 开闭原则OCP</h2>
<p><strong>开闭原则（Open-Closed Principle）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量不修改原有代码的情况下进行扩展。</strong></p>
<p>其中软件实体可以是一个软件模块，一个由多个类组成的局部结构或者一个独立的类。</p>
<p>一个软件设计符合开闭原则，则可以非常方便地对其进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。</p>
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以通过接口，抽象类等定义抽象层，通过具体类进行扩展，修改系统的行为时无需修改抽象层，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<h2 id="74-里氏代换原则lsp">7.4 里氏代换原则LSP</h2>
<p><strong>里氏代换原则（Liskov Substitution Principle）：所有引用基类/父类的地方必须能透明地使用其子类的对象。</strong></p>
<p>简单地说就是父类出现的地方可以用子类代替，程序不会产生任何的错误和异常。使用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现父类中声明的方法，运行时，子类实例代替父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p>
<h2 id="75-依赖倒转原则dip">7.5 依赖倒转原则DIP</h2>
<p><strong>依赖倒转原则（Dependency Inversion Principal）：抽象不应该依赖具体细节，细节应当依赖于抽象，换言之要针对接口编程，而不是针对实现编程。</strong></p>
<p><strong>依赖倒转原则要求程序在源代码中传递参数时或者在关联关系中，尽量引用高层次的抽象层类，即使有接口和抽象类进行变量类型声明，参数类型声明，方法返回类型声明以及数据类型的转换等，而不是用具体类来做</strong>。一个具体类应该只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用在子类中新增的方法。</p>
<p>在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式包括：</p>
<ul>
<li><strong>构造注入：通过构造函数来传入具体类的对象</strong></li>
<li><strong>设值注入（setter注入）：通过setter来传入具体类对象</strong></li>
<li><strong>接口注入：通过实现在接口中声明的方法来传入具体类对象</strong></li>
</ul>
<p>上面的方法在定义时使用抽象类型，在运行时传入具体类型的对象，由子类对象来覆盖父类对象 。</p>
<h2 id="76-接口隔离原则isp">7.6 接口隔离原则ISP</h2>
<p><strong>接口隔离原则（Interface Segregation Principal）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖于那些它不需要的接口。</strong></p>
<p>也就是说，当一个接口太大时需要划分为更小的接口，使用该接口的客户端仅需知道与之相关的方法。每一个接口应该承担一种相对独立的角色，这里的接口有两层意思：</p>
<ul>
<li><strong>一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象</strong></li>
<li><strong>另一种是指某个语言具体接口的定义，有严格的定义和结构，比如Java中的interface</strong></li>
</ul>
<p>ISP对两种不同含义的表达方式有所不同：</p>
<ul>
<li><strong>当接口理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分，可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫“角色隔离原则”</strong></li>
<li><strong>把接口理解成狭义的特定语言的接口，ISP表达的意思是接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不提供大的总接口。接口应尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或者业务逻辑类）所需的方法即可，这种机制也叫“定制服务”</strong></li>
</ul>
<p>使用接口隔离原则时，注意控制接口的粒度：</p>
<ul>
<li><strong>接口太小导致接口泛滥，不利于维护</strong></li>
<li><strong>接口太大将违背ISP，灵活性差，使用不方便</strong></li>
</ul>
<p>一般而言接口中仅包含为某一类用户定制的方法即可。</p>
<h2 id="77-合成复用原则crp">7.7 合成复用原则CRP</h2>
<p><strong>合成复用原则（Composite Reuse Principal）：尽量使用对象组合而不是继承来达成复用目的。</strong></p>
<p>合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principal），就是在一个新对象中通过关联关系（组合/聚合）对对象进行重用而不是使用继承。</p>
<p>面向对象设计中，可以通过两种方法在不同环境中复用已有的设计和实现：</p>
<ul>
<li>继承</li>
<li>组合/聚合</li>
</ul>
<h3 id="771-继承">7.7.1 继承</h3>
<p>继承需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。<strong>继承主要带来的问题是会破坏系统的封装性，因为继承会将基类实现细节暴露给子类，由于基类内部细节对子类可见，因此叫“白箱复用”。</strong></p>
<p><strong>一般而言两个类之间的关系是“Is-A”关系就可以使用继承。</strong></p>
<h3 id="772-组合聚合">7.7.2 组合/聚合</h3>
<p>尽管可以通过继承来对代码进行复用，一般来说优先考虑组合/聚合。<strong>组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。由于新对象可以直接调用已有对象的功能，这样做可以使成员对象的内部实现细节对新对象不可见，所以这种复用叫“黑箱复用”。</strong></p>
<p><strong>一般而言两个类之间的关系是“Has-A”关系就可以使用组合/聚合。</strong></p>
<h2 id="78-迪米特法则lod">7.8 迪米特法则LoD</h2>
<p><strong>迪米特法则（Law of Demeter）：一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p>
<p>迪米特法则又叫最少知识原则（Least Knowledge Principal，LKP），<strong>迪米特法则会对软件实体之间通信的宽度与深度进行限制，可以降低系统的耦合度，使类与类之间保持松耦合。</strong></p>
<p>迪米特法则还有几种定义形式：不要和“陌生人”说话，只与直接朋友通信。对于一个对象“朋友”可以是以下几类：</p>
<ul>
<li>对象本身（this）</li>
<li>以参数形式传入的对象</li>
<li>成员对象</li>
<li>如果成员对象是一个集合，那么集合中的元素也是“朋友”</li>
<li>当前对象所创建的对象</li>
</ul>
<p>满足上述条件之一即是“朋友”，否则就是“陌生人”，不能和“陌生人”发生直接交互。</p>
<p>迪米特法则要求设计系统时尽量减少对象之间的交互，通过引入一个合理的中间类来降低现有对象之间的耦合度。应用迪米特法则时需要注意几点：</p>
<ul>
<li><strong>优先将类设计为不变类</strong></li>
<li><strong>类划分上尽量创建松耦合的类</strong></li>
<li><strong>类结构设计上尽量降低成员变量和成员函数的访问权限</strong></li>
<li><strong>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</strong></li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200711005605808.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200711094651100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/vue-xue-xi-bi-ji-yi/">
              <h3 class="post-title">
                下一篇：Vue学习笔记（一）
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
