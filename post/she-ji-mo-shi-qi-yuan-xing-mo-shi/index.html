
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（七）：原型模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-qi-yuan-xing-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（七）：原型模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-18</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%8E%9F%E5%9E%8B%E7%B1%BB">2.2 抽象原型类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9E%8B%E7%B1%BB">2.3 具体原型类</a>
<ul>
<li><a href="#231-%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">2.3.1 通用实现方法</a></li>
<li><a href="#232-clone">2.3.2 <code>clone</code></a></li>
</ul>
</li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%B1%BB">2.4 客户类</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86">4 浅克隆与深克隆</a>
<ul>
<li><a href="#41-%E6%B5%85%E5%85%8B%E9%9A%86">4.1 浅克隆</a></li>
<li><a href="#42-%E6%B7%B1%E5%85%8B%E9%9A%86">4.2 深克隆</a></li>
</ul>
</li>
<li><a href="#5-%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8">5 原型管理器</a>
<ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89">5.1 定义</a></li>
<li><a href="#52-%E5%AE%9E%E4%BE%8B">5.2 实例</a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>对于某些岗位来说，工作周报的内容会大同小异，如果用户每次都需要从空白的周报进行输入无疑会浪费用户很多的时间，如果周报能够按照用户的自定义来生成模板，或者从已有模板修改小部分得到新模板，这样用户的输入效率会大大提高。原型模式正是为解决这类问题而生。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>原型模式：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。</strong></p>
<p>原型模式是一种对象创建型模式。</p>
<p>原型模式的工作原理很简单，将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。原型模式是一种另类的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法实现。</p>
<p>通过克隆方法创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆多产生的对象进行的修改不会对原型对象造成任何的影响，每一个克隆的对象都是相互独立的，通过不同的方式对克隆对象进行修改之后，可以得到一系列相似但不完全相同的对象。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200717155947994.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Prototype</code>（抽象原型类）：声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，还能是具体实现类</strong></li>
<li><strong><code>ConcretePrototypr</code>（具体原型类）：实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</strong></li>
<li><strong><code>Client</code>（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象原型类：定义为接口/抽象类，至少需要定义一个类似<code>clone</code>的方法</li>
<li>定义具体原型类：实现/继承抽象原型类，核心是实现其中的<code>clone</code></li>
<li>定义客户类：针对抽象原型类编程，首先需要通过实例化或工厂方法等创建一个原型对象，接着通过其中的<code>clone</code>方法获取多个对象</li>
</ul>
<h2 id="22-抽象原型类">2.2 抽象原型类</h2>
<p>这里定义为接口：</p>
<pre><code class="language-java">interface Prototype
{
    Prototype clone();
    String getAttr();
    void setAttr(String attr);
}
</code></pre>
<h2 id="23-具体原型类">2.3 具体原型类</h2>
<p>实现抽象原型接口，核心在于如何实现<code>clone</code>，在Java中<code>clone</code>通常有两种实现方式：</p>
<ul>
<li>通用实现方法</li>
<li><code>clone()</code>方法</li>
</ul>
<h3 id="231-通用实现方法">2.3.1 通用实现方法</h3>
<p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证成员变量相同。</p>
<p>代码如下：</p>
<pre><code class="language-java">class ConcretePrototype implements Prototype
{
    private String attr;

    @Override
	public String getAttr() {
		return this.attr;
	}

    @Override
	public void setAttr(String attr) {
		this.attr = attr;
	}
	
    @Override
    public Prototype clone()
    {
        Prototype = new ConcretePrototype();
        prototype.setAttr(attr);
        return prototype;
    }
}
</code></pre>
<h3 id="232-clone">2.3.2 <code>clone</code></h3>
<p><code>java.lang.Object</code>提供了一个<code>clone()</code>，可以将一个Java对象克隆一份，利用<code>clone()</code>可以直接将对象克隆一份，但是必须实现<code>Cloneable</code>接口，否则<code>clone()</code>时会抛出<code>CloneNotSupportedException</code>。</p>
<p>代码如下：</p>
<pre><code class="language-java">class ConcretePrototype implements Prototype,Cloneable
{
    private String attr;

	public String getAttr() {
		return this.attr;
	}

	public void setAttr(String attr) {
		this.attr = attr;
    }
    
    public Prototype clone()
    {
        Object object = null;
        try 
        {
            object = super.clone();
        } 
        catch (Exception e) 
        {
            e.printStacktrace();
        }
        return (Prototype)object;
    }
}
</code></pre>
<p>一般而言，Java中的<code>clone()</code>满足：</p>
<ul>
<li>对任何对象<code>x</code>都有<code>x.clone() != x</code>，也就是克隆的对象与原型对象不是同一个对象</li>
<li>对任何对象<code>x</code>都有<code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样</li>
<li>如果<code>x</code>的<code>equals()</code>定义恰当，那么<code>x.clone().equals(x)</code>应该成立</li>
</ul>
<p>具体实现步骤如下：</p>
<ul>
<li>覆盖<code>clone()</code>，并声明为<code>public</code></li>
<li><code>clone()</code>中调用<code>super.clone()</code></li>
<li>派生类需要实现<code>Cloneable</code>接口</li>
</ul>
<h2 id="24-客户类">2.4 客户类</h2>
<p>客户类针对抽象原型类编程，通过实例化获取具体原型后，调用其中的<code>clone</code>进行克隆：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Prototype prototype1 = new ConcretePrototype();
        prototype1.setAttr(&quot;test&quot;);
        Prototype prototype2 = prototype1.clone();
        System.out.println(prototype1.getAttr() == prototype2.getAttr());
        System.out.println(prototype1 == prototype2);
    }
}
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>开发一个工作周报系统，工作周报的内容都大同小异，只有一些小地方存在差异，但是系统每次默认创建的都是空白报表，用户不断复制粘贴来填写重复内容。使用原型模式对其进行优化，快速创建相同或类似的工作周报。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象原型类：无（也可以认为是<code>Object</code>）</li>
<li>具体原型类：<code>WeeklyLog</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        WeeklyLog weeklyLog1 = new WeeklyLog();
        weeklyLog1.setContent(&quot;content&quot;);
        weeklyLog1.setName(&quot;Weekly log 1&quot;);
        weeklyLog1.setDateTime(LocalDateTime.now());

        System.out.println(weeklyLog1.getName());
        System.out.println(weeklyLog1.getContent());
        System.out.println(weeklyLog1.getDateTime());

        WeeklyLog weeklyLog2 = weeklyLog1.clone();
        weeklyLog2.setName(&quot;Weekly log 2&quot;);
        System.out.println(weeklyLog2.getName());
        System.out.println(weeklyLog2.getContent());
        System.out.println(weeklyLog2.getDateTime());
    }
}

class WeeklyLog implements Cloneable
{
    private String name;
    private LocalDateTime dateTime;
    private String content;

    //getter and setter
    //...

    public WeeklyLog clone()
    {
        Object obj = null;
        try
        {
            obj = super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return (WeeklyLog)obj;
    }
}
</code></pre>
<h1 id="4-浅克隆与深克隆">4 浅克隆与深克隆</h1>
<p>一般来说，工作周报可能会携带附件，使用上面的原型模式来进行工作周报的复制没有问题，但是附件（一般是另一个类）不会进行复制。这是因为浅克隆与深克隆的原因，下面具体来看一下。</p>
<h2 id="41-浅克隆">4.1 浅克隆</h2>
<p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象。（在Java中）值类型包括：</p>
<ul>
<li><code>int</code></li>
<li><code>double</code></li>
<li><code>byte</code></li>
<li><code>boolean</code></li>
<li><code>char</code></li>
<li><code>float</code></li>
<li><code>long</code></li>
<li><code>short</code></li>
</ul>
<p>也就是这些类型的值都会完整复制一份给克隆对象，对于引用类型，则将引用对象的地址复制一份给克隆对象。（在Java中）引用类型就是除了基本类型之外的所有类型，常见的有：</p>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
<p>对于引用类型，原型对象与克隆对象指向相同的内存地址，也就是其实并没有被复制，而是共享一份地址相同的值。<br>
在Java中可以通过<code>Object</code>的<code>clone()</code>实现浅克隆，也就是上面例子的做法。</p>
<h2 id="42-深克隆">4.2 深克隆</h2>
<p>在深克隆中，无论变量是值类型还是引用类型都会完整复制一份给克隆对象。</p>
<p>在Java中实现深克隆可以通过序列化等方式实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制品，而原对象仍然存在于内存中。想要进行序列化必须实现<code>Serializable</code>接口。</p>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        WeeklyLog weeklyLog1 = new WeeklyLog();
        WeeklyLog weeklyLog2 = null;
        Attachement attachement = new Attachement();
        weeklyLog1.setAttachement(attachement);
        try
        {
            weeklyLog2 = weeklyLog1.deepClone(); 
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(weeklyLog1 == weeklyLog2);
        System.out.println(weeklyLog1.getAttachement() == weeklyLog2.getAttachement());
    }
}

class Attachement implements Serializable
{
    private String name;
    //getter and setter
    //...
}

class WeeklyLog implements Serializable
{
    private String name;
    private LocalDateTime dateTime;
    private String content;
    private Attachement attachement;

    //getter and setter
    //...

    public WeeklyLog deepClone() throws IOException , ClassNotFoundException , OptionalDataException
    {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(this);

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

        return (WeeklyLog)objectInputStream.readObject();
    }
}
</code></pre>
<p>当然除了使用<code>ByteArrayOutput/InputStream</code>以及<code>ObjectInput/OutputStream</code>外，还可以利用以下工具类进行深克隆：</p>
<ul>
<li><code>org.apache.commons.lang3.SerializationUtils.clone()</code>：需要实现<code>Serializable</code>接口</li>
<li><code>Gson</code>：无需实现<code>Serializable</code>接口，<code>toJson()+fromJson()</code></li>
<li><code>Jackson</code>：也是无需实现<code>Serializable</code>接口，<code>readValue()+writeValueAsString()</code>等</li>
</ul>
<h1 id="5-原型管理器">5 原型管理器</h1>
<h2 id="51-定义">5.1 定义</h2>
<p>原型管理器是将多个原型对象存储在一个集合中供客户端使用的专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的克隆，可以通过复制集合中对应的原型对象来获取。在原型管理器中针对抽象原型类进行编程。<br>
结构图如下：<br>
<img src="https://img-blog.csdnimg.cn/2020071800411674.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-实例">5.2 实例</h2>
<blockquote>
<p>日常办公中会有许多公文需要创建，例如《可行性分析报告》，《立项建议书》，《软件需求规格说明书》，《项目进展报告》等，为了提高工作效率需要为各类公文创建模板，用户可以通过这些模板快速创建新的公文，这些公文模板进行统一的管理，系统根据用户的请求的不同生成不同的新公文。</p>
</blockquote>
<p>首先是抽象原型以及具体原型的代码：</p>
<pre><code class="language-java">interface OfficialDocument extends Cloneable
{
    OfficialDocument clone();
    void display();
}

//可行性分析报告
class FAR implements OfficialDocument 
{
    public OfficialDocument clone()
    {
        OfficialDocument far = null;
        try
        {
            far = (OfficialDocument)super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return far;
    }

    public void display()
    {
        System.out.println(&quot;可行性分析报告&quot;);
    }
}

//软件需求规格说明书
class SRS implements OfficialDocument
{
    public OfficialDocument clone()
    {
        OfficialDocument srs = null;
        try
        {
            srs = (OfficialDocument)super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return srs;
    }

    public void display()
    {
        System.out.println(&quot;软件需求规格说明书&quot;);
    }
}
</code></pre>
<p>接着是原型管理器的代码，使用枚举单例实现：</p>
<pre><code class="language-java">enum PrototypeManager 
{
    INSTANCE;

    private Hashtable&lt;String,OfficialDocument&gt; hashtable = new Hashtable&lt;&gt;();
    private PrototypeManager()
    {
        add(&quot;far&quot;,new FAR());
        add(&quot;srs&quot;,new SRS());
    }

    public void add(String key,OfficialDocument document)
    {
        hashtable.put(key, document);
    }

    public OfficialDocument get(String key)
    {
        return ((OfficialDocument)hashtable.get(key)).clone();
    }
}
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        PrototypeManager manager = PrototypeManager.INSTANCE;
        OfficialDocument document1,document2,document3,document4;

        document1 = manager.get(&quot;far&quot;);
        document1.display();

        document2 = manager.get(&quot;far&quot;);
        document2.display();
        System.out.println(document1 == document2);

        document3 = manager.get(&quot;srs&quot;);
        document3.display();

        document4 = manager.get(&quot;srs&quot;);
        document4.display();
        System.out.println(document3 == document4);
    }
}
</code></pre>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>简化创建过程：当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li>
<li>扩展性较好：由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对系统都没有任何影响</li>
<li>简化创建结构：原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无需专门的工厂类来创建产品</li>
<li>保存状态：可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>修改不方便：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造的时候，需要修改源代码，违背了OCP（开放闭合原则）</li>
<li>深克隆需要嵌套类支持：在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象都必须支持深克隆，实现起来可能比较麻烦</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>创建新对象成本较大，比如初始化需要较长时间，占用太多的CPU资源或网络资源，新的对象可以通过原型模式对已有对象进行复制获取，如果是相似对象可以对成员变量稍作修改</li>
<li>如果系统要保存对象的状态，而对象的变化状态很小，或者对象本身占用内存较少，可以使用原型模式配合备忘录模式</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个实例方便</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200729063842999.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-29-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第29期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
