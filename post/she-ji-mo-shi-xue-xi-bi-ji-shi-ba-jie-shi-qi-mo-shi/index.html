
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十八）：解释器模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi.jpeg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十八）：解释器模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-02</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">1.2 相关术语</a>
<ul>
<li><a href="#121-%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99">1.2.1 文法规则</a></li>
<li><a href="#122-bnf%E7%AC%A6%E5%8F%B7">1.2.2 BNF符号</a></li>
<li><a href="#123-%E7%BB%88%E7%BB%93%E7%AC%A6%E4%B8%8E%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6">1.2.3 终结符与非终结符</a></li>
<li><a href="#124-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91">1.2.4 抽象语法树</a></li>
</ul>
</li>
<li><a href="#13-%E5%AE%9A%E4%B9%89">1.3 定义</a></li>
<li><a href="#14-%E7%BB%93%E6%9E%84%E5%9B%BE">1.4 结构图</a></li>
<li><a href="#15-%E8%A7%92%E8%89%B2">1.5 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.2 环境类</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.3 抽象表达式</a></li>
<li><a href="#24-%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.4 终结符表达式</a></li>
<li><a href="#25-%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.5 非终结符表达式</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95">4 扩展</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>解释器模式是一种使用频率较低但是学习难度较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。某些情况下可能需要自定义一个新语言，这种语言具有自己的文法规则，这时可以使用解释器模式进行设计，比如模拟机器人的控制程序，每一条指令对应一个动作，通过解释输入的指令来实现对机器人的控制。下面先来看一些术语定义。</p>
<h2 id="12-相关术语">1.2 相关术语</h2>
<h3 id="121-文法规则">1.2.1 文法规则</h3>
<p>文法规则是用于描述语言的语法的规则，比如，汉语中一个句子的文法规则为：</p>
<pre><code class="language-bash">主 谓 宾
</code></pre>
<p>这就是句子的文法规则，同样计算机语言也有自己的文法规则。</p>
<h3 id="122-bnf符号">1.2.2 BNF符号</h3>
<p>BNF是<code>Backus-Naur Form</code>的缩写，是由<code>John Backus</code>以及<code>Peter Naur</code>首次引入的一种形式化符号来描述给定语言的语法，BNF中定义的部分符号如下：</p>
<ul>
<li><code>::=</code>：表示<code>定义为</code>，左边的语言单位可以通过右边进行说明和定义</li>
<li><code>|</code>：表示<code>或者</code></li>
<li><code>&quot;</code>或<code>'</code>：双引号或单引号里面的字符串表示字符串本身</li>
</ul>
<h3 id="123-终结符与非终结符">1.2.3 终结符与非终结符</h3>
<p>在以下的模拟描述机器人移动的文法规则中：</p>
<pre><code class="language-bash">expression ::= direction action distance | composite   //表达式
composite ::= expression 'and' expression              //复合表达式
direction ::= 'up' | 'down' | 'left'| 'right'          //移动方向
action ::= 'move' | 'run'                              //移动方式
distance ::= an integer                                //移动距离
</code></pre>
<p>定义了5条文法规则，对应5个语言单位，这些语言单位可以分为：</p>
<ul>
<li>终结符（也叫终结符表达式）：语言的最小组成单位，不能再拆分，比如上面的<code>direction</code>或<code>action</code></li>
<li>非终结符（也叫非终结符表达式）：一个完整的句子，包含一些列终结符或非终结符</li>
</ul>
<h3 id="124-抽象语法树">1.2.4 抽象语法树</h3>
<p>除了使用文法规则定义一个语言外，还能使用一种叫抽象语法树的直观方式表示，例如表达式：</p>
<pre><code class="language-bash">1 / 2 * 3 - 4 + 1
</code></pre>
<p>可以通过如下抽象语法树定义：<br>
<img src="https://img-blog.csdnimg.cn/20200801165057650.png" alt="在这里插入图片描述" loading="lazy"><br>
在该抽象语法树中，可以通过终结符<code>value</code>以及非终结符<code>operation</code>组成复杂的语句，终结符作为抽象语法树的叶子，非终结符作为非叶子节点，可以将终结符或者包含终结符与非终结符的节点作为子节点。</p>
<h2 id="13-定义">1.3 定义</h2>
<p><strong>解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。</strong></p>
<p>这里的语言指的是使用规定格式以及语法的代码。解释器模式是一种类行为型模式。</p>
<h2 id="14-结构图">1.4 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801195332936.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="15-角色">1.5 角色</h2>
<ul>
<li><strong><code>AbstractExpression</code>（抽象表达式）：声明了抽象的解释操作，是所有终结符表达式以及非终结符表达式的父类</strong></li>
<li><strong><code>TerminalExpression</code>（终结符表达式）：抽象表达式的子类，实现了与文法规则中的终结符相关联的解释操作，句子中的每一个终结符都是该类的一个实例，通常只有少数几个终结符表达式类</strong></li>
<li><strong><code>NonterminalExpression</code>（非终结符表达式）：也是抽象表达式的子类，实现了文法规则中非终结符的解释操作，由于非终结符表达式可以包含非终结符表达式以及终结符表达式，因此一般通过递归方式完成解释</strong></li>
<li><strong><code>Context</code>（环境类）：用于存储解释器之外的一些全局信息，通常它临时存储需要解释的语句</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>（可选）定义环境类：首先对环境类进行定义，使用集合存储相关的全局或公共信息，用于在具体解释时获取，如果无须全局信息则环境类可以省略</li>
<li>定义抽象表达式类：接口/抽象类，声明抽象解释操作</li>
<li>定义终结符表达式类：继承/实现抽象表达式，定义终结符的解释操作</li>
<li>定义非终结符表达式类：继承/实现抽象表达式，定义非终结符解释操作，一般通过递归处理</li>
</ul>
<h2 id="22-环境类">2.2 环境类</h2>
<p>这里暂时不需要环境类，为了兼容定义一个空类：</p>
<pre><code class="language-java">class Context{}
</code></pre>
<h2 id="23-抽象表达式">2.3 抽象表达式</h2>
<p>包含抽象解释操作方法：</p>
<pre><code class="language-java">interface AbstractExpression
{
    void interpret(Context context);
}
</code></pre>
<h2 id="24-终结符表达式">2.4 终结符表达式</h2>
<p>解释终结符表达式：</p>
<pre><code class="language-java">class TerminalExpression implements AbstractExpression
{
    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;终结符解析&quot;);
    }
}
</code></pre>
<h2 id="25-非终结符表达式">2.5 非终结符表达式</h2>
<pre><code class="language-java">class NonterminalExpression implements AbstractExpression
{
    private AbstractExpression left;
    private AbstractExpression right;

    public NonterminalExpression(AbstractExpression left,AbstractExpression right)
    {
        this.left = left;
        this.right = right;
    }

    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;非终结符解析&quot;);
        if(left != null)
            left.interpret(context);
        if(right != null)
            right.interpret(context);
    }
}
</code></pre>
<p>解释非终结符时一般需要递归处理，这里模拟了非终结符左右两边的表达式操作。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractExpression expression1 = new TerminalExpression();
    AbstractExpression expression2 = new TerminalExpression();
    AbstractExpression expression3 = new NonterminalExpression(expression1,expression2);
    expression3.interpret(null);
}
</code></pre>
<p>定义两个终结符表达式与一个非终结符表达式，最后对非终结符表达式进行解释。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>对机器人移动指令进行解释，移动的语法表达如下：方向 方式 距离，方向包括上下左右四个方向，方式包括跑以及一般移动，距离为一个整数，一条移动指令可以组合多条子移动指令，使用解释器模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：这里为空</li>
<li>抽象表达式类：<code>AbstractNode</code></li>
<li>终结符表达式类：<code>DirectionNode</code>+<code>ActionNode</code>+<code>DistanceNode</code></li>
<li>非终结符表达式类：<code>AndNode</code>+<code>SentenceNode</code></li>
</ul>
<p>抽象表达式类如下：</p>
<pre><code class="language-java">interface AbstractNode
{
    String interpret(String str);
}
</code></pre>
<p>终结符表达式类：</p>
<pre><code class="language-java">class DirectionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;up&quot;, &quot;向上&quot;);
        strs.put(&quot;down&quot;, &quot;向下&quot;);
        strs.put(&quot;left&quot;, &quot;向左&quot;);
        strs.put(&quot;right&quot;, &quot;向右&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class ActionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;move&quot;, &quot;移动&quot;);
        strs.put(&quot;run&quot;, &quot;快速移动&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class DistanceNode implements AbstractNode
{
    @Override
    public String interpret(String str)
    {
        return str;
    }
}
</code></pre>
<p>根据对应的字符串返回相应的字符串即可。</p>
<p>非终结符表达式类：</p>
<pre><code class="language-java">class SentenceNode implements AbstractNode
{
    private final AbstractNode direction = new DirectionNode();
    private final AbstractNode action = new ActionNode();
    private final AbstractNode distance = new DistanceNode();
    @Override
    public String interpret(String s)
    {
        String [] str = s.split(&quot; &quot;);
        return direction.interpret(str[0])+action.interpret(str[1])+distance.interpret(str[2]);
    }
}

class AndNode implements AbstractNode
{
    @Override
    public String interpret(String s)
    {
        if(s.contains(&quot;and&quot;))
        {
            int index = s.indexOf(&quot;and&quot;);
            String leftStr = s.substring(0, index-1);
            String rightStr = s.substring(index+4);
            AbstractNode left = (leftStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            AbstractNode right = (rightStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            return left.interpret(leftStr) + &quot; 再 &quot; + right.interpret(rightStr);
        }
        return new SentenceNode().interpret(s);
    }
}
</code></pre>
<p>其中<code>AndNode</code>采取了递归进行解释操作，如果分割后的字符串还含有<code>and</code>则赋值为<code>AndNode</code>，否则为<code>SentenceNode</code>。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractNode node = new AndNode();
    System.out.println(node.interpret(&quot;up move 5 and down run 10 and down move 10 and left run -9&quot;));
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200802015840189.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-扩展">4 扩展</h1>
<p>如果项目中需要对数据表达式进行分析与计算，可以直接使用现有的库，比如：</p>
<ul>
<li>Expression4J</li>
<li>MESP</li>
<li>Jep</li>
<li>Fel</li>
</ul>
<p>等等，下面以Jep为例演示该库的使用方法。Jep是<code>Java expression parser</code>的简称，即Java表达式分析器，它是一个用来转换和计算数学表达式的Java库，用户可以以字符串形式输入一个任意公式，然后快速计算出结果。Jep支持用户自定义变量，常量，函数，包括很多常用的数学函数以及常量。</p>
<p>首先<a href="http://www.singularsys.com/jep/download-trial.php">下载</a>JAR包依赖，例子如下：</p>
<pre><code class="language-java">import com.singularsys.jep.*;

public class Test
{
    public static void main(String[] args) throws Exception
    {
        Jep jep=new Jep();
        //定义要计算的数据表达式
        String interestOnDeposit=&quot;本金*利率*时间&quot;;
        //给相关变量赋值
        jep.addVariable(&quot;本金&quot;,10000);
        jep.addVariable(&quot;利率&quot;,0.038);
        jep.addVariable(&quot;时间&quot;,2);
        jep.parse(interestOnDeposit);     //解析表达式
        Object accrual=jep.evaluate();    //计算
        System.out.println(&quot;存款利息：&quot;+accrual);
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>扩展性好：由于解释器中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>便于实现语言：每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</li>
<li>实现文法容易：抽象语法树中每一个表达式节点类的实现方式都是类似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码</li>
<li>增加解释表达式方便：如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式，原有表达式类无须修改</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>复杂文法难以维护：在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则会导致类个数急增，导致系统难以管理和维护，可以考虑使用语法分析程序来取代解释器模式</li>
<li>执行效率低：由于解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时速度很慢，而且代码的调试过程也比较麻烦</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来描述</li>
<li>一个语言的文法较为简单</li>
<li>执行效率不是关键问题</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200802081552906.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（十七）：命令模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
