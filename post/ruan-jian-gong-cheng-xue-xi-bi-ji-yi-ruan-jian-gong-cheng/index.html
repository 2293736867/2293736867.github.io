
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>软件工程学习笔记(一):软件工程 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/ruan-jian-gong-cheng-xue-xi-bi-ji-yi-ruan-jian-gong-cheng.jpeg')">
            </div>
          
          <h2 class="post-title">软件工程学习笔记(一):软件工程</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-06-03</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/OQzDJDrvg/">
                    软件工程
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6">1 计算机软件</a>
<ul>
<li><a href="#11-%E8%BD%AF%E4%BB%B6">1.1 软件</a></li>
<li><a href="#12-%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9">1.2 软件特点</a></li>
<li><a href="#13-%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB">1.3 软件分类</a>
<ul>
<li><a href="#131-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">1.3.1 系统软件</a></li>
<li><a href="#132-%E6%94%AF%E6%92%91%E8%BD%AF%E4%BB%B6">1.3.2 支撑软件</a></li>
<li><a href="#133-%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">1.3.3 应用软件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80">2 软件语言</a>
<ul>
<li><a href="#21-%E9%9C%80%E6%B1%82%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80">2.1 需求定义语言</a></li>
<li><a href="#22-%E5%8A%9F%E8%83%BD%E6%80%A7%E8%AF%AD%E8%A8%80">2.2 功能性语言</a></li>
<li><a href="#23-%E8%AE%BE%E8%AE%A1%E6%80%A7%E8%AF%AD%E8%A8%80">2.3 设计性语言</a></li>
<li><a href="#24-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">2.4 程序设计语言</a></li>
<li><a href="#25-%E6%96%87%E6%A1%A3%E8%AF%AD%E8%A8%80">2.5 文档语言</a></li>
</ul>
</li>
<li><a href="#3-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">3 软件工程</a></li>
<li><a href="#4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">4 软件工程的基本原则</a>
<ul>
<li><a href="#41-%E9%80%82%E5%AE%9C%E7%9A%84%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">4.1 适宜的开发规范</a></li>
<li><a href="#42-%E5%90%88%E9%80%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">4.2 合适的设计方法</a></li>
<li><a href="#43-%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%94%AF%E6%8C%81">4.3 高质量的工程支持</a></li>
<li><a href="#44-%E6%9C%89%E6%95%88%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86">4.4 有效的软件工程管理</a></li>
</ul>
</li>
<li><a href="#5-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F">5 软件生存周期</a>
<ul>
<li><a href="#51-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B">5.1 计算机系统工程</a></li>
<li><a href="#52-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">5.2 需求分析</a></li>
<li><a href="#53-%E8%AE%BE%E8%AE%A1">5.3 设计</a></li>
<li><a href="#54-%E7%BC%96%E7%A0%81">5.4 编码</a></li>
<li><a href="#55-%E6%B5%8B%E8%AF%95">5.5 测试</a></li>
<li><a href="#56-%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4">5.6 运行与维护</a></li>
</ul>
</li>
<li><a href="#6-cmm">6 CMM</a>
<ul>
<li><a href="#61-%E5%88%9D%E5%A7%8B%E7%BA%A7">6.1 初始级</a></li>
<li><a href="#62-%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%BA%A7">6.2 可重复级</a></li>
<li><a href="#63-%E5%B7%B2%E5%AE%9A%E4%B9%89%E7%BA%A7">6.3 已定义级</a></li>
<li><a href="#64-%E5%B7%B2%E7%AE%A1%E7%90%86%E7%BA%A7">6.4 已管理级</a></li>
<li><a href="#65-%E4%BC%98%E5%8C%96%E7%BA%A7">6.5 优化级</a></li>
</ul>
</li>
<li><a href="#7-cmmi">7 CMMI</a>
<ul>
<li><a href="#71-%E9%98%B6%E6%AE%B5%E5%BC%8F%E6%A8%A1%E5%9E%8B">7.1 阶段式模型</a>
<ul>
<li><a href="#711-%E5%88%9D%E5%A7%8B%E7%9A%84">7.1.1 初始的</a></li>
<li><a href="#712-%E5%B7%B2%E7%AE%A1%E7%90%86%E7%9A%84">7.1.2 已管理的</a></li>
<li><a href="#713-%E5%B7%B2%E5%AE%9A%E4%B9%89%E7%9A%84">7.1.3 已定义的</a></li>
<li><a href="#714-%E5%AE%9A%E9%87%8F%E7%AE%A1%E7%90%86%E7%9A%84">7.1.4 定量管理的</a></li>
<li><a href="#715-%E4%BC%98%E5%8C%96%E7%9A%84">7.1.5 优化的</a></li>
</ul>
</li>
<li><a href="#72-%E8%BF%9E%E7%BB%AD%E5%BC%8F%E6%A8%A1%E5%9E%8B">7.2 连续式模型</a>
<ul>
<li><a href="#721-cl0">7.2.1 CL0</a></li>
<li><a href="#722-cl1">7.2.2 CL1</a></li>
<li><a href="#723-cl2">7.2.3 CL2</a></li>
<li><a href="#724-cl3">7.2.4 CL3</a></li>
<li><a href="#725-cl4">7.2.5 CL4</a></li>
<li><a href="#726-cl5">7.2.6 CL5</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">8 软件过程模型</a>
<ul>
<li><a href="#81-%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B">8.1 瀑布模型</a>
<ul>
<li><a href="#811-%E4%BC%98%E7%82%B9">8.1.1 优点</a></li>
<li><a href="#812-%E7%BC%BA%E7%82%B9">8.1.2 缺点</a></li>
</ul>
</li>
<li><a href="#82-%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B">8.2 增量模型</a>
<ul>
<li><a href="#821-%E4%BC%98%E7%82%B9">8.2.1 优点</a></li>
<li><a href="#822-%E7%BC%BA%E7%82%B9">8.2.2 缺点</a></li>
</ul>
</li>
<li><a href="#83-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B">8.3 原型模型</a>
<ul>
<li><a href="#831-%E4%BC%98%E7%82%B9">8.3.1 优点</a></li>
<li><a href="#832-%E7%BC%BA%E7%82%B9">8.3.2 缺点</a></li>
</ul>
</li>
<li><a href="#84-%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B">8.4 螺旋模型</a>
<ul>
<li><a href="#841-%E4%BC%98%E7%82%B9">8.4.1 优点</a></li>
<li><a href="#842-%E7%BC%BA%E7%82%B9">8.4.2 缺点</a></li>
</ul>
</li>
<li><a href="#85-%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B">8.5 喷泉模型</a>
<ul>
<li><a href="#851-%E4%BC%98%E7%82%B9">8.5.1 优点</a></li>
<li><a href="#852-%E7%BC%BA%E7%82%B9">8.5.2 缺点</a></li>
</ul>
</li>
<li><a href="#86-%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B">8.6 基于构件的开发模型</a>
<ul>
<li><a href="#861-%E4%BC%98%E7%82%B9">8.6.1 优点</a></li>
<li><a href="#862-%E7%BC%BA%E7%82%B9">8.6.2 缺点</a></li>
</ul>
</li>
<li><a href="#87-%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95%E6%A8%A1%E5%9E%8B">8.7 形式化方法模型</a>
<ul>
<li><a href="#871-%E4%BC%98%E7%82%B9">8.7.1 优点</a></li>
<li><a href="#872-%E7%BC%BA%E7%82%B9">8.7.2 缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="1-计算机软件">1 计算机软件</h1>
<h2 id="11-软件">1.1 软件</h2>
<p>计算机软件是指计算机系统中的程序以及文档,程序是计算任务处理对象和处理规则的描述.</p>
<h2 id="12-软件特点">1.2 软件特点</h2>
<ul>
<li>一种逻辑实体.</li>
<li>维护工作量大.</li>
<li>维护软件过程中会引入副作用.</li>
</ul>
<h2 id="13-软件分类">1.3 软件分类</h2>
<h3 id="131-系统软件">1.3.1 系统软件</h3>
<p>最靠近硬件的一层,比如操作系统.</p>
<h3 id="132-支撑软件">1.3.2 支撑软件</h3>
<p>软件开发,维护与运行的软件,比如各种IDE等.</p>
<h3 id="133-应用软件">1.3.3 应用软件</h3>
<p>应用于特定领域的软件.</p>
<h1 id="2-软件语言">2 软件语言</h1>
<p>软件语言主要包括需求定义语言,功能性语言,设计性语言,程序设计语言与文档语言.</p>
<h2 id="21-需求定义语言">2.1 需求定义语言</h2>
<p>用于书写软件需求定义的语言,包括功能需求与非功能需求.典型的语言有PSL.</p>
<h2 id="22-功能性语言">2.2 功能性语言</h2>
<p>书写软件功能规约的语言,描述软件做什么以及只做什么.典型语言有广谱语言,Z语言.</p>
<h2 id="23-设计性语言">2.3 设计性语言</h2>
<p>书写软件设计规约的语言,是软件设计的严格而完整的描述.典型语言有PDL.</p>
<h2 id="24-程序设计语言">2.4 程序设计语言</h2>
<p>即编程语言,可以分为低级语言与高级语言,过程式语言与非过程式语言,通用语言与专用语言,交互式语言与非交互式语言,顺序语言与并发语言与分布语言.</p>
<h2 id="25-文档语言">2.5 文档语言</h2>
<p>书写软件文档使用的语言,比如Z语言.</p>
<h1 id="3-软件工程">3 软件工程</h1>
<p>软件工程是建立和使用一套合理的工程原则,以便获得经济的软件,这种软件是可靠的,可以在实际机器上高效地运行.软件工程是应用计算机科学理论以及工程管理原则的方法,按预算与进度实现满足用户要求的软件产品的工程,或以此为研究对象的学科.</p>
<h1 id="4-软件工程的基本原则">4 软件工程的基本原则</h1>
<h2 id="41-适宜的开发规范">4.1 适宜的开发规范</h2>
<p>选用适宜的开发规范,以保证软件开发的可持续性,并使最终的软件产品满足客户的需求.</p>
<h2 id="42-合适的设计方法">4.2 合适的设计方法</h2>
<p>要考虑软件的模块化,信息隐藏,局部化,一致性以及适应性等问题,采用合适的设计方法有助于支持问题的解决与实现.</p>
<h2 id="43-高质量的工程支持">4.3 高质量的工程支持</h2>
<p>需要提供高质量的工程支持,例如配置管理,质量保证等.</p>
<h2 id="44-有效的软件工程管理">4.4 有效的软件工程管理</h2>
<p>软件工程的管理直接影响可用资源的有效利用,以提高软件组织的生产能力.</p>
<h1 id="5-软件生存周期">5 软件生存周期</h1>
<p>软件生存周期分为6个阶段:</p>
<h2 id="51-计算机系统工程">5.1 计算机系统工程</h2>
<p>计算机系统工程的任务是确定待开发软件的总体要求与范围,以及该软件与其他计算机系统元素之间的关系,进行成本估算,作出进度安排,并进行可行性分析.</p>
<h2 id="52-需求分析">5.2 需求分析</h2>
<p>需求分析主要解决待开发软件要做什么的问题,确定软件的功能,性能,数据,界面等要求,生成软件需求规约.</p>
<h2 id="53-设计">5.3 设计</h2>
<p>软件设计主要解决待开发软件怎么做的问题,通常可以分为系统设计与详细设计,系统设计的任务是设计软件系统的体系结构,详细设计的任务是设计各个组成成分的实现细节.</p>
<h2 id="54-编码">5.4 编码</h2>
<p>利用程序设计语言进行编码.</p>
<h2 id="55-测试">5.5 测试</h2>
<p>发现并纠正软件中的错误与缺陷,包括单元测试,集成测试,确认测试与系统测试.</p>
<h2 id="56-运行与维护">5.6 运行与维护</h2>
<p>软件运行期间需要进行维护,对软件进行修改.</p>
<h1 id="6-cmm">6 CMM</h1>
<p>CMM是能力成熟度模型,定义了5个软件过程成熟度等级,包括初始级,可重复级,已定义级,已管理级,优化级.</p>
<h2 id="61-初始级">6.1 初始级</h2>
<p>软件过程的特点是无秩序的,甚至是混乱的,几乎没有什么过程是经过妥善定义的.</p>
<h2 id="62-可重复级">6.2 可重复级</h2>
<p>建立了基本的项目管理过程来跟踪成本,进度与功能特性.制定了必要的过程纪律,能重复早先类似应用项目取得的成功.</p>
<h2 id="63-已定义级">6.3 已定义级</h2>
<p>已将管理和工程活动两方面的软件过程文档化,标准化,并综合成该组织的标准软件过程.所有项目均使用经批准,剪裁的标准软件过程来开发与维护软件.</p>
<h2 id="64-已管理级">6.4 已管理级</h2>
<p>收集对软件过程和产品质量的详细度量值,对软件过程和产品都有定量的理解与控制.</p>
<h2 id="65-优化级">6.5 优化级</h2>
<p>过程的量化反馈和先进的新思想,新技术促使过程不断改进.</p>
<h1 id="7-cmmi">7 CMMI</h1>
<p>CMMI是若干过程模型的综合与改进,是支撑多个工程学科和领域的系统的,一致的过程改进框架,能适应现代工程的特点与需要,能提高过程的质量与工作效率.CMMI有两种表示法:阶段式模型与连续式模型.</p>
<h2 id="71-阶段式模型">7.1 阶段式模型</h2>
<p>阶段式模型的结构类似于CMM,分为5个成熟度等级:</p>
<h3 id="711-初始的">7.1.1 初始的</h3>
<p>过程不可预测且缺乏控制.</p>
<h3 id="712-已管理的">7.1.2 已管理的</h3>
<p>过程为项目服务.</p>
<h3 id="713-已定义的">7.1.3 已定义的</h3>
<p>过程为组织服务.</p>
<h3 id="714-定量管理的">7.1.4 定量管理的</h3>
<p>过程已度量和控制.</p>
<h3 id="715-优化的">7.1.5 优化的</h3>
<p>集中与过程改进.</p>
<h2 id="72-连续式模型">7.2 连续式模型</h2>
<p>连续式模型关注每个过程域的能力,一个组织对不同的过程域可以达到不同的过程域能力等级.<br>
CMMI包含了6个过程域能力等级,等级号为0-5,能力等级表明了单个过程域中组织执行的好坏程度.能力等级包括共性目标及相关的共性实践,可以独立地应用于任何单独的过程域,各能力等级的含义:</p>
<h3 id="721-cl0">7.2.1 CL0</h3>
<p>未完成的,过程域未执行或未达到CL1中定义的所有目标.</p>
<h3 id="722-cl1">7.2.2 CL1</h3>
<p>已执行的,其共性目标是过程可以将标识的输入工作产品转换成可标识的输出工作产品,以实现支持过程域的特定目标.</p>
<h3 id="723-cl2">7.2.3 CL2</h3>
<p>已管理的,共性目标是集中于已管理的过程的制度化.根据组织政策规定过程的运作将使用哪个过程,项目遵循已文档化的计划和过程描述,所有正在工作的人都有权使用足够的资源,所有工作任务和工作产品都被监督,控制和评审.</p>
<h3 id="724-cl3">7.2.4 CL3</h3>
<p>已定义的,共性目标是集中于已定义的过程的制度化.过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的,还必须收集过程资产和过程的度量,并用于将来对该过程的改进上.</p>
<h3 id="725-cl4">7.2.5 CL4</h3>
<p>定量管理的,共性目标是集中于可定量管理的过程的制度化.使用测量与质量保证来控制和改进过程域,建立和使用关于质量和过程执行的定量目标作为管理准则.</p>
<h3 id="726-cl5">7.2.6 CL5</h3>
<p>优化的,使用量化手段改变和优化过程域,以应对客户的要求的改变与持续改进计划的过程域的功效.</p>
<h1 id="8-软件过程模型">8 软件过程模型</h1>
<p>软件过程模型习惯上也叫软件开发模型,是软件开发全部过程,活动和任务的结构框架.</p>
<h2 id="81-瀑布模型">8.1 瀑布模型</h2>
<p>1970年由W.Royce提出,给出了软件生存周期活动的固定顺序,上一阶段的活动完成后向下一阶段活动过渡,最终得到开发的软件产品.瀑布模型中上一阶段的活动完成并经过评审后才能开始下一阶段的活动,特征是:</p>
<ul>
<li>接受上一阶段活动的结果作为本阶段活动的输入.</li>
<li>依据上一阶段活动的结果实施本阶段应完成的活动.</li>
<li>对本阶段的活动进行评审.</li>
<li>将本阶段活动的结果作为输出,传递给下一阶段.</li>
</ul>
<h3 id="811-优点">8.1.1 优点</h3>
<p>最早出现应用最广泛的模型,确保软件开发的顺利进行,对提高软件项目的质量和开发效率起到重要作用.</p>
<h3 id="812-缺点">8.1.2 缺点</h3>
<ul>
<li>用户难以清晰描述所有需求,开发过程中需求也有可能发生改变.</li>
<li>发现错误时,为了改正错误要回到前一阶段,造成瀑布倒流.</li>
<li>在测试完成后才可以看到可运行的软件,发现问题的修改代价极大.</li>
</ul>
<h2 id="82-增量模型">8.2 增量模型</h2>
<p>增量模型将软件的开发过程分成若干个日程时间交错的线性序列,每个线性序列产生一个可发布的增量版本,后一个版本是对前一个版本的修改和补充,重复增量发布的过程,直至产生最终的完善产品.</p>
<h3 id="821-优点">8.2.1 优点</h3>
<p>适用于需求经常发生变化的软件开发,以后的增量中可以逐渐加入需求,另外可以有计划地管理技术风险.</p>
<h3 id="822-缺点">8.2.2 缺点</h3>
<p>需要良好的架构设计,避免加入的构件破坏已构造好的系统部分,需要对系统有好的全盘分析,否则容易退化成边做边改模型.</p>
<h2 id="83-原型模型">8.3 原型模型</h2>
<p>原型是预期系统的一个可执行版本,反映了系统性质的一个选定的子集.一个原型不必满足目标软件的所有约束,目的是可以快速,低成本地构建原型.步骤是:</p>
<pre><code class="language-mermaid">graph TB
定义总体目标 --&gt; 标识需求 
标识需求  --&gt; 指定原型开发计划
 指定原型开发计划 --&gt; 确定原型目标和范围
 确定原型目标和范围 --&gt; 快速设计建模
 快速设计建模 --&gt; 构建原型
 构建原型 --&gt; 交付使用
 交付使用 --&gt; 收集反馈意见
 收集反馈意见 --下一轮原型迭代开发--&gt; 定义总体目标
</code></pre>
<h3 id="831-优点">8.3.1 优点</h3>
<p>用户与开发者在原型上达成一致,减少错误,缩短开发周期,加快进度,降低成本.</p>
<h3 id="832-缺点">8.3.2 缺点</h3>
<p>不利于原型系统作为最终产品,原型被建造仅仅是用户用来定义需求,之后便会被部分或全部抛弃,准确的原型设计比较困难,不利于开发人员创新.</p>
<h2 id="84-螺旋模型">8.4 螺旋模型</h2>
<p>螺旋模型将原型实现的迭代特征与瀑布模型中的控制的和系统化的方面结合起来,增加了风险分析.螺旋模型沿着螺线自内向外旋转,4个任务区域(4个象限)内分别完成以下任务:</p>
<ul>
<li>第一象限:风险分析,评价所选方案,识别风险,清楚风险.</li>
<li>第二象限:制订计划,确定软件目标,选定实施方案,弄清项目开发的限制条件.</li>
<li>第三象限:客户评估,评价开发工作,提出修正建议.</li>
<li>第四象限:工程实施,实施软件开发,验证工作产品.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200104005230732.png" alt="在这里插入图片描述" loading="lazy"><br>
(图片来源:https://www.itread01.com/content/1544588849.html)</p>
<h3 id="841-优点">8.4.1 优点</h3>
<p>设计灵活,成本计算容易,客户始终参加每个阶段的开发,可以进行有效的互动.</p>
<h3 id="842-缺点">8.4.2 缺点</h3>
<p>周期长,需要丰富的风险评估经验以及专门知识,如果未能及时标识风险,势必造成重大损失.</p>
<h2 id="85-喷泉模型">8.5 喷泉模型</h2>
<p>喷泉模型是一种支持面向对象开发的过程模型.喷泉体现了面向对象的迭代与无间隙特性.<br>
<img src="https://img-blog.csdnimg.cn/2020010401573075.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="851-优点">8.5.1 优点</h3>
<p>各个阶段没有明显的边界,开发人员可以进行同步开发,提高软件项目的开发效率,节省开发时间.</p>
<h3 id="852-缺点">8.5.2 缺点</h3>
<p>不利于项目管理,要求严格编写文档,审核难度大.</p>
<h2 id="86-基于构件的开发模型">8.6 基于构件的开发模型</h2>
<p>利用预先包装的构件来构造应用系统.构件可以是内部开发的构件,也可以是商业化的构件.</p>
<h3 id="861-优点">8.6.1 优点</h3>
<p>构件可重用,易于维护,对提高软件生产率,提高软件质量,降低成本有很大的帮助.</p>
<h3 id="862-缺点">8.6.2 缺点</h3>
<p>很难找到100%合适的构件,就是现有的构件不一定很适合使用,但基于已有构件构造出的构件未必经过100%的测试,难以保证质量.</p>
<h2 id="87-形式化方法模型">8.7 形式化方法模型</h2>
<p>形式化方法是建立在严格的数学基础上的一种软件开发方法,用严格的数学语言和语义描述功能规约与设计规约,通过数学的分析与推导,易于发现需求的歧义性,不完整性与不一致性,易于对分析模型,设计模型和程序进行验证.通过数学的演算,使得从形式化功能规约到形式化设计规约,以及从形式化设计规约到程序代码的转换成为可能.</p>
<h3 id="871-优点">8.7.1 优点</h3>
<p>用数学语言解决了规格说明的二义性问题,提高了精确性用数学提供了确认手段,使得证明与验证软件按程序满足用户和系统的需求成为可能,可以可视化地模拟/执行模型.</p>
<h3 id="872-缺点">8.7.2 缺点</h3>
<p>形式化的方法比其他技术的抽象级别要低,容易陷入细节,需要提早确定系统边界,通常限于正确一致的模型,但大多数情况下模型并非正确与一致.</p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/win10-mei-hua-rang-ni-de-win10-du-yi-wu-er-yu-zhong-bu-tong/">
              <h3 class="post-title">
                下一篇：Win10美化,让你的Win10独一无二,与众不同!
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
