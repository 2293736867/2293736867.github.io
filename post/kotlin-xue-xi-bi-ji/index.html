
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Kotlin学习笔记 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/kotlin-xue-xi-bi-ji.jpg')">
            </div>
          
          <h2 class="post-title">Kotlin学习笔记</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-06-26</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/eB6hSy8EZ/">
                    Kotlin
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h1 id="1-概述">1 概述</h1>
<p>这篇文章首先会介绍Kotlin的特点，接着介绍Kotlin与Java的语法比较。</p>
<h1 id="2-kotlin特点">2 Kotlin特点</h1>
<ul>
<li>一门现代化的编程语言</li>
<li>可开发跨平台应用，web，Socket，安卓，js，NativeApp等</li>
<li>静态编程语言，性能基本与原声Java相当</li>
<li>100%兼容Java（说是兼容但实际上有些坑，可以<a href="https://blog.hlyue.com/2018/05/03/Kotlin-and-springboot/">戳这里</a>看看）</li>
<li>简洁：跟Java相比真的是简洁很多，语法糖特别舒服</li>
<li>安全：彻底解决写Java基本上都会遇到的著名的NullPointerException问题，结合编译器可以在编译截断发现几乎所有可能存在NPE问题的代码</li>
<li>互操作性：基于JVM，可以直接拿现有的Java库用</li>
<li>工具友好：和JetBrains的IDE结合简直舒服得不要不要的</li>
<li>支持函数式编程：比如Lambda表达式</li>
<li>支持协程：协程像是非常轻量级的县城，协程将复杂性放入库来简化异步编程，逻辑可以在协程中顺序表达，底层库负责解决异步性，很重要的一点是协程挂起不会阻塞其他线程。官方一个demo是开启10w个协程：<br>
<img src="https://user-gold-cdn.xitu.io/2020/6/26/172f0e691032f67b?w=640&amp;h=191&amp;f=png&amp;s=39706" alt="在这里插入图片描述" loading="lazy"></li>
<li>支持扩展函数：类似C#，能够扩展一个类的新功能而无需继承类或者使用装饰者这样的设计模式，Kotlin支持扩展函数和扩展属性</li>
<li>泛型：当然Java也支持泛型，但是Kotlin比Java支持得更好</li>
<li>不依赖XML</li>
</ul>
<p>下面进入Kotlin的语法部分。</p>
<h1 id="3-基本语法">3 基本语法</h1>
<ul>
<li>无<code>;</code>结尾</li>
<li><code>println()</code>代替<code>System.out.println();</code></li>
<li>输出语句中使用<code>$变量名</code>代替Java中的<code>+变量名</code>，比如<code>println(&quot;age:$age&quot;)</code>而不是<code>System.out.println(&quot;age:&quot;+age)</code></li>
<li>三引号（三个双引号连在一起）中的字符串不会进行转义</li>
</ul>
<h1 id="4-变量与常量">4 变量与常量</h1>
<ul>
<li><code>var</code>声明变量</li>
<li><code>val</code>声明常量</li>
<li>可以在<code>var</code>/<code>val</code>后面加上类型，比如<code>val a:Int</code></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172f0e6911d59e71?w=557&amp;h=281&amp;f=png&amp;s=119209" alt="在这里插入图片描述" loading="lazy"><br>
如上图提示<code>val</code>不能被赋值，提示改为<code>var</code>。<code>val</code>类似与Java中的<code>final</code>，虽然<code>val</code>引用自身不可变，但是指向的对象是可以改变的。</p>
<p><code>val</code>只能进行唯一一次初始化，如果编译器能确保只有唯一一条初始化语句被执行，可以根据条件进行不同的初始化操作：</p>
<pre><code class="language-kotlin">val a:Int
if (4&gt;3)
{
    a = 9
}
else
{
    a = 10
}
</code></pre>
<h1 id="5-表达式和语句">5 表达式和语句</h1>
<p>Java中所有的控制结构都是语句，在Kotlin中除了三大循环（<code>while</code>，<code>for</code>，<code>do while</code>）外，大多数控制结构都是表达式。比如<code>if</code>是表达式而不是语句。也就是说，<code>if</code>有值而不像Java里面一样没有值（语句）。<br>
例子：</p>
<pre><code class="language-kotlin">var a = if (3&gt;2) 3 else 2
</code></pre>
<pre><code class="language-kotlin">fun main()
{
    var a = max(4,9)
}

fun max(a:Int,b:Int): Int = if(a&gt;b) a else b
</code></pre>
<h1 id="6-枚举">6 枚举</h1>
<p>使用<code>enum class</code>而不是Java中的<code>enum</code>：</p>
<pre><code class="language-kotlin">fun main()
{
    val months = Months.May
    println(months.days)
}

enum class Months(val days:Int)
{
    May(31),
    Jun(30)
}
</code></pre>
<h1 id="7-when">7 when</h1>
<p><code>when</code>相当于Java中的<code>switch</code>：</p>
<pre><code class="language-kotlin">fun main()
{
    val months = Months.May
    when(months)
    {
        Months.May -&gt; print(&quot;May&quot;)
        Months.Jun -&gt; print(&quot;June&quot;)
    }
}

enum class Months(val days:Int)
{
    May(31),
    Jun(30),;
}
</code></pre>
<p>使用<code>-&gt;</code>进行了简化。</p>
<h1 id="8-循环">8 循环</h1>
<h2 id="81-while与do-while">8.1 while与do while</h2>
<p>与Java一样。</p>
<h2 id="82-for">8.2 for</h2>
<p>使用<code>..</code>表示区间，在<code>i</code>前面没有类型：</p>
<pre><code class="language-kotlin">for (i in 1..100)
	print(i)
</code></pre>
<p>注意区间是两边都包含的，也就是<code>1..100</code>表示<code>i</code>从1循环到100。</p>
<p>使用下标迭代：</p>
<pre><code class="language-kotlin">val arr = arrayListOf(&quot;1111&quot;,&quot;2222&quot;,&quot;333&quot;)
for ((i,e) in arr.withIndex())
	println(&quot;$i = $e&quot;)
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">0 = 1111
1 = 2222
2 = 333
</code></pre>
<h1 id="9-类">9 类</h1>
<h2 id="91-构造方法">9.1 构造方法</h2>
<pre><code class="language-kotlin">class Person(val name:String)
</code></pre>
<p>不需要像Java一样<code>this.xxx=xxx</code>。</p>
<h2 id="92-gettersetter">9.2 getter/setter</h2>
<p>因为<code>val</code>代表常量，而<code>var</code>代表变量，setter是用于改变值的，因此，使用<code>var</code>声明的属性具有getter与setter，使用<code>val</code>声明的属性只有getter。<br>
Kotlin没有提供直接操纵getter与setter的方式，通过使用<code>.属性名</code>进行修改属性或者获取属性：</p>
<pre><code class="language-kotlin">class Person
{
	var name = &quot;&quot;
	val id = &quot;&quot;
}
var person = Person()
person.name=&quot;111&quot;
person.id=&quot;222&quot; //编译不通过，id为val不可变
</code></pre>
<h2 id="93-自定义gettersetter">9.3 自定义getter/setter</h2>
<p>在相应的属性后面加上<code>get</code>/<code>set</code>即可自定义getter/setter：</p>
<pre><code class="language-kotlin">class Person
{
	var name=&quot;&quot;
	get()
	{
		return &quot;name&quot;+field
	}
	var id=&quot;&quot;
	set(id)
	{
		field = id
	}
}
</code></pre>
<p>在<code>get</code>/<code>set</code>中使用<code>field</code>表示字段，比如在上面例子中的get中，<code>field</code>表示<code>name</code>，而在下面的<code>set</code>中，<code>field</code>表示自己的<code>id</code>，<code>=</code>后面是参数的<code>id</code>。</p>
<h1 id="10-异常">10 异常</h1>
<h2 id="101-抛出异常">10.1 抛出异常</h2>
<p>直接<code>throw</code>，无需<code>new</code>：</p>
<pre><code class="language-kotlin">val age = 300
if(age !in 1..100)
	throw IllegalArgumentException(&quot;Out of range:$age&quot;)
</code></pre>
<h2 id="102-trycatch">10.2 try/catch</h2>
<pre><code class="language-kotlin">try 
{
	throw Exception(&quot;exception&quot;)
}
catch (e:Exception)
{
	e.printStackTrace()
}
</code></pre>
<h2 id="103-受检异常与不受检异常">10.3 受检异常与不受检异常</h2>
<p>Java中的异常有两类：</p>
<ul>
<li><code>Unchecked Exception</code>：不受检异常，可以不进行<code>try/catch</code>处理，包括<code>Runtime Exception</code>及其子类</li>
<li><code>Checked Exception</code>：受检异常，必须进行<code>try/catch</code>处理或者声明需要抛出，不属于不受检异常的异常都属于受检异常</li>
</ul>
<p>Kotlin不区分两者，也就是对于Java的受检异常可以不处理，比如：</p>
<pre><code class="language-kotlin">fun main()
{
    throw IllegalArgumentException(&quot;333&quot;)
}
</code></pre>
<p>可通过编译，而Java中的</p>
<pre><code class="language-java">public class Test
{
	public static void main(String []args)
	{
		throw new Exception(&quot;111&quot;);
	}
}
</code></pre>
<p>则无法通过编译。</p>
<h1 id="11-集合类">11 集合类</h1>
<pre><code class="language-kotlin">val arrayList = ArrayList&lt;Int&gt;()
arrayList.add(3)
arrayList.add(9)
arrayList.forEach { t-&gt; println(t) }

val hashSet = hashSetOf&lt;String&gt;()
hashSet.add(&quot;2222&quot;)
hashSet.add(&quot;99999&quot;)
hashSet.forEach{t-&gt; println(t)}

val list = listOf(3,5,5)
list.forEach{t-&gt; println(t)}

val map = mapOf(&quot;a&quot; to 1,&quot;b&quot; to 2)
map.forEach{(k,v)-&gt; println(&quot;$k to $v&quot;)}
</code></pre>
<p>可以直接使用集合类或者<code>xxxOf</code>创建，遍历使用<code>forEach</code>与Lambda，Kotlin风格的Lambda使用<code>{}</code>。</p>
<h1 id="12-函数">12 函数</h1>
<h2 id="121-基本语法">12.1 基本语法</h2>
<pre><code class="language-kotlin">fun printStr(str:String)
{
    println(str)
}

fun add(a:Int):Int
{
	return a+3
}
</code></pre>
<ul>
<li><code>fun</code>声明函数</li>
<li>形参类型在形参名称后</li>
<li>返回类型放在最后，前面需要带<code>：</code></li>
<li>函数不强制放在类中</li>
</ul>
<h2 id="122-默认参数">12.2 默认参数</h2>
<p>Java里面没有默认参数，实现类似功能需要重载去解决，而Kotlin的函数可以具有默认参数：</p>
<pre><code class="language-kotlin">fun main()
{
    println(add())
    println(add(1))
    println(add(1,2))
}
fun add(a:Int = 3,b:Int = 4):Int = a+b
</code></pre>
<p>可以省略的只有在末尾的参数，也就是默认参数从末尾开始确定默认值。</p>
<h2 id="123-命名参数">12.3 命名参数</h2>
<p>类似Python，调用函数时使用形参名称与值的方式调用而不是仅仅通过值调用，同时可以结合默认参数省略部分值。</p>
<pre><code class="language-kotlin">fun main()
{
    println(add(b=1))
    println(add(b=5,a=9))
}

fun add(a:Int = 3,b:Int = 4):Int = a+b
</code></pre>
<h2 id="124-可变参数">12.4 可变参数</h2>
<p>使用<code>vararg</code>：</p>
<pre><code class="language-kotlin">fun main()
{
    println(add(1,2,3,4))
}

fun add(vararg a:Int):Int = a.sum()
</code></pre>
<h1 id="13-顶层函数与顶层属性">13 顶层函数与顶层属性</h1>
<h2 id="131-顶层函数">13.1 顶层函数</h2>
<p>Kotlin中可以将函数放在代码文件的顶层，不用附属于任何类，但仍然是包内作用域，包外需要<code>import</code>，作用类似Java中的静态函数。</p>
<pre><code class="language-kotlin">fun add(vararg a:Int):Int = a.sum()
fun main()
{
    println(add(1,2,3,4))
}
</code></pre>
<p>Java中调用顶层函数时可以使用默认的Kotlin文件名作为默认包去调用，也可以使用<code>@file:JvmName</code>修改调用的包名，比如上面的文件名为<code>Test.kt</code>，则Java中调用的代码如下：</p>
<pre><code class="language-java">TestKt.add()
</code></pre>
<p>使用注解后：</p>
<pre><code class="language-kotlin">@file:JvmName(&quot;Test&quot;)
fun add(vararg a:Int):Int = a.sum
fun main()
{
    println(add(1,2,3,4))
}
</code></pre>
<p>Java调用方式改变如下：</p>
<pre><code class="language-java">Test.add()
</code></pre>
<h2 id="132-顶层属性">13.2 顶层属性</h2>
<p>与Java中的静态属性类似，有点像全局变量或全局常量，可以使用<code>var</code>，<code>val</code>，<code>const val</code>修饰：</p>
<pre><code class="language-kotlin">var a = 0
val b = 0
const val c = 0

fun main()
{
    println(++a)
    println(&quot;$b\n$c&quot;)
    test()
}

fun test()
{
    println(&quot;$a\n$b\n$c&quot;)
}
</code></pre>
<p><code>val</code>与<code>const val</code>的主要区别是：</p>
<ul>
<li><code>val</code>实质上相当与Java中的<code>private final static</code></li>
<li><code>const val</code>实质上相当于Java中的<code>public final static</code></li>
<li><code>const</code>相当于<code>@JvmField</code>，也就是说<code>const val a = 0</code>与<code>@JvmField val a = 0</code>等价：</li>
</ul>
<h1 id="14-参考">14 参考</h1>
<p>1、<a href="http://www.jicker.cn/5777.html">Kotlin语言的特点和优劣势</a><br>
2、<a href="https://www.cnblogs.com/fzqm/p/6803680.html">Java受检异常与不受检异常</a><br>
3、<a href="https://blog.csdn.net/mjb00000/article/details/79174831">Kotlin中的getter与setter</a><br>
4、<a href="https://blog.csdn.net/wangjiang_qianmo/article/details/88756728#t9">Kotlin与Java的异同</a><br>
5、<a href="https://www.jianshu.com/p/01aac645d003">Kotlin之const val与val</a></p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/kotlin-hello-world/">
              <h3 class="post-title">
                下一篇：Kotlin Hello World
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
