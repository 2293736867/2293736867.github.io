
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>每天AC系列(九):合并K个排序链表 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/mei-tian-ac-xi-lie-jiu-he-bing-k-ge-pai-xu-lian-biao.jpg')">
            </div>
          
          <h2 class="post-title">每天AC系列(九):合并K个排序链表</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-06-03</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/DZ5E1trvJ/">
                    AC
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode第23题</a>,合并k个有序的链表.<br>
<img src="https://img-blog.csdnimg.cn/20200130181741680.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-暴力法">2 暴力法</h1>
<p>直接遍历所有链表,取出所有节点的值,用数组存储,非降序排序,然后创建一个新链表用头插法依次插入节点.</p>
<pre><code class="language-java">List&lt;Integer&gt; s = new ArrayList&lt;&gt;();
for(ListNode x:lists)
{
    while(x != null)
    {
        s.add(x.val);
        x = x.next;
    }
}
s.sort((a,b) -&gt; {return a.compareTo(b);});
ListNode result = new ListNode(0);
ListNode t = result;
for(Integer x:s)
{
    t.next = new ListNode(x);
    t = t.next;
}
return result.next;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200130205630834.png" alt="在这里插入图片描述" loading="lazy"><br>
这里要注意一下,sort那里不能写成:</p>
<pre><code class="language-java">s.sort((a,b)-&gt;{return a&gt;b ? 1 : -1;});
</code></pre>
<p>没有考虑到等于的情况,所以用compareTo代替:</p>
<pre><code class="language-java">s.sort((a,b)-&gt;{return a.compareTo(b);});
</code></pre>
<h1 id="3-直接合并法">3 直接合并法</h1>
<p>每次遍历所有链表,取出首节点的值,各个比较然后得出最小值,将最小值插入新链表,然后移动最小值所在的链表的指针,直到所有链表为空.</p>
<pre><code class="language-java">ListNode result = new ListNode(0);
ListNode t = result;
int len = lists.length;
int nullNodeNums = 0;
for(boolean [] b = new boolean[len];nullNodeNums&lt;len;)
{
    int min = Integer.MAX_VALUE;
    int minIndex = -1;
    for(int index = 0;index&lt;len;++index)
    {
        ListNode x = lists[index];
        if(x == null)
        {
            if(!b[index])
            {
                b[index] = true;
                ++nullNodeNums;
            }
        }
        else if(x.val &lt; min)
        {
            min = x.val;
            minIndex = index;
        }
    }
    if(minIndex != -1)
    {
        t.next = new ListNode(min);
        t = t.next;
        lists[minIndex] = lists[minIndex].next;
    }
}
return result.next;
</code></pre>
<p>这里使用了一个布尔数组判断是否某个节点已经移动到尾部,即表示是否为空,为空的话跳过这个节点,不为空的话取其值,计算是否为最小值.得到最小值后,添加到结果节点中,并移动最小值所在链表的指针.<br>
<img src="https://img-blog.csdnimg.cn/20200131022403181.png" alt="在这里插入图片描述" loading="lazy"><br>
这个方法看起来慢得很啊.</p>
<h1 id="4-优先队列">4 优先队列</h1>
<p>优先队列是上两个方法的结合,遍历所有节点,取值并根据其值确定优先级添加到优先队列中,然后依次出队,将出队的值直接插入到新链表中.</p>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();
for(ListNode x:lists)
{
    while(x != null)
    {
        queue.add(x.val);
        x = x.next;
    }
}
ListNode s = new ListNode(0);
ListNode t = s;
while(!queue.isEmpty())
{
    t.next = new ListNode(queue.poll());
    t = t.next;
}
return s.next;
</code></pre>
<p>java的优先队列可以直接add即可,按照默认出队序列(对于整数是小的先出)使用尾插法插入到新链表中.<br>
<img src="https://img-blog.csdnimg.cn/20200131023647945.png" alt="在这里插入图片描述" loading="lazy"><br>
嗯,好像还可以的样子,但是还是不够快.</p>
<h1 id="5-两两合并法">5 两两合并法</h1>
<p>合并k个链表,相当于合并2个链表k-1次,利用递归的思想,每次合并两个链表,将合并后的链表后返回作为下一个要合并的链表继续合并.</p>
<pre><code class="language-java">public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0)
        return null;
    ListNode t = lists[0];
    for(int i=1;i&lt;lists.length;++i)
        t = merge(t, lists[i]);
    return t;
}
//public ListNode merge(ListNode a,ListNode b)
</code></pre>
<p>merge为直接合并两个链表的操作,不难,就不贴代码了,首先赋值t为第一个链表,然后依次合并t与剩下的n-1个链表.<br>
<img src="https://img-blog.csdnimg.cn/20200131025014753.png" alt="在这里插入图片描述" loading="lazy"><br>
好慢啊.</p>
<h1 id="6-分治法">6 分治法</h1>
<p>分治法是两两合并法的改进,两两合并每次合并两个链表,分治法每次合并一半数量的链表,总体思想是这样的:想要得到最终有序的链表,若左半部分的链表与右半部分的链表都有序,则相当于合并两个有序链表,为了得到左半部分的有序链表,需要继续对左半部分进行一半的分割,再次分成左半部分与右半部分,然后再分,直到某部分只有一个链表,然后返回,以合并两个普通有序链表的方式合并两个返回的链表.</p>
<pre><code class="language-java">public ListNode f(int start,int end)
{
    int len = end - start;
    if(len &lt;= 1)
        return lists[start];
    ListNode l = f(start,start+len/2);
    ListNode r = f(start+len/2,end);
    return merge(l, r);
}
</code></pre>
<p>代码非常简洁,一开始为判断递归的条件,区间长度小于等于1直接返回[start]的节点,然后递归合并左半部分与右半部分的节点.<br>
<img src="https://img-blog.csdnimg.cn/20200131031405559.png" alt="在这里插入图片描述" loading="lazy"><br>
一个字,舒服.<br>
真快.</p>
<h1 id="7-源码">7 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day9">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day9">码云</a></p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-ba-gua-hao-sheng-cheng/">
              <h3 class="post-title">
                下一篇：每天AC系列(八):括号生成
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
