
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十一）：组合模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-yi-zu-he-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十一）：组合模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-27</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E6%9E%84%E4%BB%B6">2.2 抽象构件</a></li>
<li><a href="#23-%E5%8F%B6%E5%AD%90%E6%9E%84%E4%BB%B6">2.3 叶子构件</a></li>
<li><a href="#24-%E5%AE%B9%E5%99%A8%E6%9E%84%E4%BB%B6">2.4 容器构件</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E9%80%8F%E6%98%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%89%E5%85%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">4 透明组合模式与安全组合模式</a>
<ul>
<li><a href="#41-%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81">4.1 如何简化代码</a></li>
<li><a href="#42-%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">4.2 默认实现</a></li>
<li><a href="#43-%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95">4.3 删除方法</a></li>
<li><a href="#44-%E9%80%8F%E6%98%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">4.4 透明组合模式</a></li>
<li><a href="#45-%E5%AE%89%E5%85%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">4.5 安全组合模式</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>对于树形结构，比如文件目录，一个文件夹中可以包含多个文件夹和文件，而一个文件中不能在包含子文件或者子文件夹，在这里可以称<strong>文件夹为容器</strong>，称<strong>文件为叶子</strong>。</p>
<p>在树形结构中，当容器对象（比如文件夹）的某个方法被调用时，将遍历整个文件夹，寻找也包含这个方法的成员对象（容器对象或叶子对象）并调用执行。由于容器对象以及叶子对象在功能上的区别，使用这些对象的代码中必须有区别对待容器对象以及叶子对象，但大多数情况下需要一致性处理它们。</p>
<p>组合模式为解决此类问题而生，它可以让叶子对象以及容器对象的使用具有一致性。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>组合模式：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</strong></p>
<p>组合模式又叫“部分-整体”模式，它是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200726093617721.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Component</code>（抽象构件）：可以是接口或者抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问以及管理它的子构件的方法，例如增加/删除/获取子构件</strong></li>
<li><strong><code>Leaf</code>（叶子构件）：表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为，对于访问以及管理子构件的方法，通常会抛出异常</strong></li>
<li><strong><code>Composite</code>（容器构件）：表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括访问以及管理子构件的方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<p>组合模式的关键是定义了一个抽象构件类，它既可以表示叶子也可以表示容器，客户端针对该抽象构件进行编程，无须知道到底是叶子还是容器，同时容器对象与抽象构件之间需要建立一个聚合关联关系，在容器对象中既可以包含叶子也可以包含容器，以此实现递归组合，形成树形结构。</p>
<p>因此首先需要定义抽象构件类，通用步骤如下：</p>
<ul>
<li>定义抽象构件：定义抽象构件类，添加四个基本方法：增加/删除/获取成员+业务方法，可以将抽象构件类定义为抽象类或者接口</li>
<li>定义叶子构件：继承或实现抽象构件类，覆盖或实现具体业务方法，同时对于管理或访问子构件的方法提供异常处理或错误提示</li>
<li>定义容器构件：继承或实现抽象构件类，覆盖或实现抽象构件中的所有方法，一般来说容器构件会包含一个集合私有成员用于保存抽象构件，在业务方法中对这个集合进行遍历从而实现递归调用</li>
</ul>
<h2 id="22-抽象构件">2.2 抽象构件</h2>
<p>抽象构件一般定义如下：</p>
<pre><code class="language-java">abstract class Component
{
    abstract void add(Component c);
    abstract void remove(Component c);
    abstract Component getChild(int i);
    abstract void operation();
}
</code></pre>
<h2 id="23-叶子构件">2.3 叶子构件</h2>
<pre><code class="language-java">class Leaf extends Component
{
    public void add(Component c)
    {
        //叶子构件不能访问该方法
        System.out.println(&quot;错误,不能访问添加构件方法!&quot;);
    }

    public void remove(Component c)
    {
        //叶子构件不能访问该方法
        System.out.println(&quot;错误,不能访问删除构件方法!&quot;);
    }

    public Component getChild(int i)
    {
        //叶子构件不能访问该方法
        System.out.println(&quot;错误,不能访问获取构件方法!&quot;);
        return null;
    }

    public void operation()
    {
        System.out.println(&quot;叶子业务方法&quot;);
    }
}
</code></pre>
<p>叶子构件只需要覆盖具体业务方法<code>opeartion</code>，对于管理子构件的方法可以提示错误或者抛出异常来处理。</p>
<h2 id="24-容器构件">2.4 容器构件</h2>
<pre><code class="language-java">class Composite extends Component
{
    private ArrayList&lt;Component&gt; list = new ArrayList&lt;&gt;();
    
    public void add(Component c)
    {
        list.add(c);
    }

    public void remove(Component c)
    {
        list.remove(c);
    }

    public Component getChild(int i)
    {
        return list.get(i);
    }

    public void operation()
    {
		list.forEach(Component::operation);
    }
}
</code></pre>
<p>容器构件只需要简单实现管理子构件的方法，对于业务方法一般需要对抽象构件集合进行遍历来实现递归调用。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<p>客户端针对抽象构件进行编程，根据需要添加叶子或者容器：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Component leaf1 = new Leaf();
    Component leaf2 = new Leaf();
    Component composite1 = new Composite();
    Component composite2 = new Composite();

    composite1.add(leaf1);
    composite2.add(leaf2);
    composite1.add(composite2);

    composite1.operation();
}
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>开发一个杀毒软件系统，可以对某个文件夹或单个文件进行杀毒，还能根据文件类型的不同提供不同的杀毒方式，比如文本文件和图像文件的杀毒方式有所差异，使用组合模式对该系统进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象构件类：<code>AbstractFile</code></li>
<li>容器构件类：<code>Folder</code></li>
<li>叶子构件类：<code>ImageFile</code>+<code>TextFile</code>+<code>VideoFile</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        AbstractFile file1,file2,file3,file4,folder1,folder2;
        file1 = new ImageFile(&quot;图像文件1号&quot;);
        file2 = new VideoFile(&quot;视频文件1号&quot;);
        file3 = new TextFile(&quot;文本文件1号&quot;);
        file4 = new ImageFile(&quot;图像文件2号&quot;);

        folder1 = new Folder(&quot;文件夹1&quot;);
        folder2 = new Folder(&quot;文件夹2&quot;);

        try
        {
            folder2.add(file1);
            folder2.add(file2);
            folder2.add(file3);
            folder1.add(file4);
            folder1.add(folder2);
        }
        catch(IllegalAccessException e)
        {
            e.printStackTrace();
        }
        
        folder1.killVirus();
        System.out.println();
        folder2.killVirus();
    }
}

//抽象构件类
abstract class AbstractFile
{
    protected String name;
    abstract void add(AbstractFile file) throws IllegalAccessException;
    abstract void remove(AbstractFile file) throws IllegalAccessException;
    abstract AbstractFile getChild(int i) throws IllegalAccessException;
    public void killVirus()
    {
        System.out.println(name+&quot; 杀毒&quot;);
    }
}

//叶子构件类
class ImageFile extends AbstractFile
{
    public ImageFile(String name)
    {
        this.name = name;
    }

    public void add(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;);
    }

    public void remove(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;);
    }

    public AbstractFile getChild(int i)
    {
        throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;);
    }
}

//叶子构件类
class TextFile extends AbstractFile
{
    public TextFile(String name)
    {
        this.name = name;
    }

    public void add(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;);
    }

    public void remove(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;);
    }

    public AbstractFile getChild(int i)
    {
        throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;);
    }
}

//叶子构件类
class VideoFile extends AbstractFile
{
    public VideoFile(String name)
    {
        this.name = name;
    }

	public void add(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;);
    }

    public void remove(AbstractFile c)
    {
        throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;);
    }

    public AbstractFile getChild(int i)
    {
        throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;);
    }
}

//容器构件类
class Folder extends AbstractFile
{
    private ArrayList&lt;AbstractFile&gt; list = new ArrayList&lt;&gt;();
    public Folder(String name)
    {
        this.name = name;
    }

    public void add(AbstractFile c)
    {
        list.add(c);
    }

    public void remove(AbstractFile c)
    {
        list.remove(c);
    }

    public AbstractFile getChild(int i)
    {
        return list.get(i);
    }

    public void killVirus()
    {
        System.out.println(&quot;对 &quot;+name+&quot; 进行杀毒&quot;);
        list.forEach(AbstractFile::killVirus);
    }
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200726090254345.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-透明组合模式与安全组合模式">4 透明组合模式与安全组合模式</h1>
<h2 id="41-如何简化代码">4.1 如何简化代码</h2>
<p>尽管组合模式的扩展性好，在上面的例子中增加新的文件类型无须修改原有代码，但是，由于抽象构件类<code>AbstractFile</code>声明了与叶子构件无关的构件管理方法，因此 需要实现这些方法，这样就会带来很多重复性的工作。</p>
<p>解决方案有两个：</p>
<ul>
<li>抽象构件提供默认实现：叶子构件中的构件管理方法转移到抽象构件中提供默认实现</li>
<li>抽象构件删除方法：在抽象构件中不提供管理构件的方法</li>
</ul>
<h2 id="42-默认实现">4.2 默认实现</h2>
<p>如果使用抽象构件提供默认实现的方法，则上述例子代码简化如下：</p>
<pre><code class="language-java">abstract class AbstractFile
{
    protected String name;
    public AbstractFile(String name)
    {
        this.name = name;
    }
    public void add(AbstractFile file) throws IllegalAccessException
    {
        throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;);
    }
    public void remove(AbstractFile file) throws IllegalAccessException
    {
        throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;);
    }
    public AbstractFile getChild(int i) throws IllegalAccessException
    {
        throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;);
    }
    public void killVirus()
    {
        System.out.println(name+&quot; 杀毒&quot;);
    }
}

class ImageFile extends AbstractFile
{
    public ImageFile(String name)
    {
        super(name);
    }
}

class TextFile extends AbstractFile
{
    public TextFile(String name)
    {
        super(name);
    }
}

class VideoFile extends AbstractFile
{
    public VideoFile(String name)
    {
        super(name);
    }
}
</code></pre>
<p>在叶子构件中只有构造方法（实际上业务方法应该是抽象的，在叶子构件中实现业务方法，这里的业务方法是<code>killVirus()</code>，这里是进行了简化），这样修改虽然简化了代码，但是总的来说为叶子构件提供这些方法是没有意义的，因为叶子不会再下一个层次的对象，这在编译阶段不会出错 ，但是在运行阶段可能会出错。</p>
<h2 id="43-删除方法">4.3 删除方法</h2>
<p>如果使用抽象构件删除方法的方式进行简化代码，则上述例子简化如下：</p>
<pre><code class="language-java">abstract class AbstractFile
{
    protected String name;
    public AbstractFile(String name)
    {
        this.name = name;
    }
    abstract void killVirus();
}

class ImageFile extends AbstractFile
{
    public ImageFile(String name)
    {
        super(name);
    }
    public void killVirus()
    {
        System.out.println(&quot;图像文件&quot;+name+&quot;杀毒&quot;);
    }
}

class TextFile extends AbstractFile
{
    public TextFile(String name)
    {
        super(name);
    }
    public void killVirus()
    {
        System.out.println(&quot;文本文件&quot;+name+&quot;杀毒&quot;);
    }
}

class VideoFile extends AbstractFile
{
    public VideoFile(String name)
    {
        super(name);
    }
    public void killVirus()
    {
        System.out.println(&quot;视频文件&quot;+name+&quot;杀毒&quot;);
    }
}
</code></pre>
<p>这样做叶子构件就无法访问管理构件的方法了，但是带来的坏处是客户端无法统一针对抽象构件类<code>AbstractFile</code>进行编程，修改之前代码如下：</p>
<pre><code class="language-java">AbstractFile file1,file2,file3,file4,folder1,folder2;
</code></pre>
<p>由于<code>AbstractFile</code>中删除了管理构件方法，因此客户端需要修改代码如下：</p>
<pre><code class="language-java">AbstractFile file1,file2,file3,file4;
Folder folder1,folder2;
</code></pre>
<h2 id="44-透明组合模式">4.4 透明组合模式</h2>
<p>透明组合模式就是第一种解决方案中的方法，在抽象构件中声明所有用于管理构件的方法，这样做的好处是确保所有的构件类都具有相同的接口，客户端可以针对抽象构件进行统一编程，结构图如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200726093555804.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一层次的对象，提供管理构件的方法是没有意义的，在编译阶段不会报错，但是在运行阶段可能会出错。</p>
<h2 id="45-安全组合模式">4.5 安全组合模式</h2>
<p>安全组合模式就是第二种方法的办法，安全组合模式中，抽象构件没有声明管理构件的方法，而是在容器构件中添加管理构件的方法，这种做法是安全的因为叶子对象不可能调用到这些方法。结构图如下：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200726094004258.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安全组合模式的缺点是不够透明，因为叶子构件与容器构件具有不同的方法，管理构件的方法在容器构件中定义，客户端不能完全针对抽象构件进行编程，必须有区别地对待叶子构件与容器构件。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>层次控制：组合模式可以清楚定义分层次的复杂对象，表示对象的全部或者部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制</li>
<li>一致使用构件：客户端可以一致地使用容器构件或者叶子构件，也就是能针对构件抽象层一致性编程</li>
<li>扩展性好：增加新的容器构件或者叶子构件都很方便，符合开闭原则</li>
<li>有效针对树形结构：组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子构件与容器构件的递归组合，可以形成复杂的树形结构，但控制树形结构却很简单</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>难以限制构件类型：增加新构件时难以限制构件类型，比如希望容器构件中只有某一特定类型的叶子构件，例如一个只能包含图片的文件夹，使用组合模式时不能依赖类型系统来施加这些约束，需要再运行时进行类型检查来实现，过程较为复杂</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性对待它们</li>
<li>处理树形结构</li>
<li>系统中能够分离出叶子构件以及容器构件，而且类型不固定，需要增加新的叶子构件或者容器构件</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200729131832481.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-39-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第39期
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
