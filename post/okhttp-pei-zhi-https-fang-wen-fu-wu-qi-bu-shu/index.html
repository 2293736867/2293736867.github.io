
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>OkHttp配置HTTPS访问+服务器部署 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('/post-images/okhttp-pei-zhi-https-fang-wen-fu-wu-qi-bu-shu.jpg')">
            </div>
          
          <h2 class="post-title">OkHttp配置HTTPS访问+服务器部署</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-06-03</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/bFNak4fnm/">
                    OkHttp
                    
                      ，
                    
                  </a>
                
                  <a href="https://2293736867.github.io/tag/tpJlWuxg-t/">
                    HTTPS
                    
                      ，
                    
                  </a>
                
                  <a href="https://2293736867.github.io/tag/orx4wZc0f/">
                    Tomcat
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-okhttp%E4%BB%8B%E7%BB%8D">2 OkHttp介绍</a></li>
<li><a href="#3-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">3 准备工作</a></li>
<li><a href="#4-okhttp%E9%83%A8%E5%88%86">4 OkHttp部分</a>
<ul>
<li><a href="#41-%E6%9A%B4%E5%8A%9B%E6%96%B9%E6%A1%88">4.1 暴力方案</a></li>
<li><a href="#42-%E6%8E%A8%E8%8D%90%E6%96%B9%E6%A1%88">4.2 推荐方案</a>
<ul>
<li><a href="#421-hostnameverifier">4.2.1 HostnameVerifier</a></li>
<li><a href="#422-x509trustmanager">4.2.2 X509TrustManager</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2">5 服务器部署</a>
<ul>
<li><a href="#51-%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B">5.1 上传工程</a></li>
<li><a href="#52-tomcat%E9%85%8D%E7%BD%AE">5.2 Tomcat配置</a></li>
</ul>
</li>
<li><a href="#6-%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%BA%90%E7%A0%81">6 验证与源码</a></li>
<li><a href="#7-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">7 常见问题</a>
<ul>
<li><a href="#71-tomcat-https%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE">7.1 Tomcat HTTPS无法访问</a></li>
<li><a href="#72-okhttp-https%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE">7.2 OkHttp HTTPS无法访问</a></li>
</ul>
</li>
<li><a href="#8-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">8 参考链接</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>OkHttp配置HTTPS访问,核心为以下三个部分:</p>
<ul>
<li>sslSocketFactory()</li>
<li>HostnameVerifier</li>
<li>X509TrustManager</li>
</ul>
<p>第一个是ssl套接字工厂,第二个用来验证主机名,第三个是证书信任器管理类.通过OkHttp实现HTTPS访问需要自己实现以上三部分.另外还简单提及了服务器端的部署,用的是Tomcat9,最后是一些常见问题的可能解决方案.</p>
<h1 id="2-okhttp介绍">2 OkHttp介绍</h1>
<p>OkHttp是一款开源的处理网络请求的轻量级框架,有Square公司贡献,用于替代HttpUrlConnection与Apache HttpClient,目前Github上有36.4k的star.优点有</p>
<ul>
<li>共享socket,HTTP/2支持所有连接到同一个主机的请求共享socket</li>
<li>连接池可以减少请求延迟</li>
<li>缓存响应数据减少重复的网络请求</li>
<li>自动处理gzip压缩</li>
</ul>
<p>总的来说OkHttp是一款支持get/post请求,支持文件上传/下载的优秀的HTTP框架.</p>
<h1 id="3-准备工作">3 准备工作</h1>
<ul>
<li>一台服务器</li>
<li>一个域名</li>
<li>一个证书</li>
</ul>
<p>什么?都没有?买!<br>
当然证书可以不用买,可以使用Openssl之类的工具生成,不过自签名的证书后面验证的时候会有点麻烦,建议还是购买.</p>
<h1 id="4-okhttp部分">4 OkHttp部分</h1>
<h2 id="41-暴力方案">4.1 暴力方案</h2>
<pre><code class="language-java">public static String test() {
	OkHttpClient client = new OkHttpClient.Builder()
        .sslSocketFactory(createSSLSocketFactory(), new TrustAllCerts())
        .hostnameVerifier(new TrustAllHostnameVerifier()).build();

	String url = &quot;https://xxxxxxx&quot;;   //修改成自己的url
    Request request = new Request.Builder().url(url).build();
    Call call = build.newCall(request);
    Response response = call.execute();
    if(response.body() != null)
    {
        String result = response.body().string();
        //处理result
    }
}

private static class TrustAllCerts implements X509TrustManager {
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
    public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[0];}
}

private static class TrustAllHostnameVerifier implements HostnameVerifier {
    public boolean verify(String hostname, SSLSession session) { return true; }
}

private static SSLSocketFactory createSSLSocketFactory() {
    SSLSocketFactory ssfFactory = null;
    try {
        SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);
        sc.init(null, new TrustManager[]{new TrustAllCerts()}, new SecureRandom());
        ssfFactory = sc.getSocketFactory();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ssfFactory;
}
</code></pre>
<p>这是一种暴力的方案,看类名就知道了,信任所有的证书与主机:</p>
<pre><code class="language-java">public boolean verify(String hostname, SSLSession session) { return true; }
</code></pre>
<p>这个方法直接返回true,也就是信任所有的主机.</p>
<pre><code class="language-java">public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
</code></pre>
<p>这里两个check函数没有做任何的工作,表示接受任意的客户端与服务端的证书.这样写的话相当于是使用了一个没用的TrustManager,这样还不如不加密,不推荐使用.</p>
<h2 id="42-推荐方案">4.2 推荐方案</h2>
<p>从两方面入手修改,一是从X509TrustManager入手,二是从HostnameVerifier入手.</p>
<h3 id="421-hostnameverifier">4.2.1 HostnameVerifier</h3>
<p>先说个简单的,这里主要是验证主机名,简单的话,可以如下实现:</p>
<pre><code class="language-java">HostnameVerifier hnv = new HostnameVerifier() {
	@Override
	public boolean verify(String hostname, SSLSession session) {
	    if(&quot;www.test.com&quot;.equals(hostname)){  
			return true;  
	    } 
	    else {  
			HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
			return hv.verify(hostname, session);
		}
	}
};
</code></pre>
<p>这里验证主机名是www.test.com就返回true(也可以使用服务器ip进行验证),实现得比较简单,业务复杂的话可以结合配置中心,黑/白名单等动态校验.</p>
<h3 id="422-x509trustmanager">4.2.2 X509TrustManager</h3>
<p>接着是X509TrustManager的处理,这里其实有两种方式,一种是以流的方式添加信任证书(来源:<a href="https://www.programcreek.com/java-api-examples/?class=java.security.cert.CertificateFactory&amp;method=generateCertificates">Java Code Example</a>):</p>
<pre><code class="language-java">private static X509TrustManager trustManagerForCertificates(InputStream in)
        throws GeneralSecurityException
{
    CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
    Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in);
    if (certificates.isEmpty()) {
        throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;);
    }

    char[] password = &quot;password&quot;.toCharArray(); // 这里可以使用任意密码
    KeyStore keyStore = newEmptyKeyStore(password);
    int index = 0;
    for (Certificate certificate : certificates) {
        String certificateAlias = Integer.toString(index++);
        keyStore.setCertificateEntry(certificateAlias, certificate);
    }

    // Use it to build an X509 trust manager.
    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
    keyManagerFactory.init(keyStore, password);
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init(keyStore);
    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager))
    {
        throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers));
    }
    return (X509TrustManager) trustManagers[0];
}
</code></pre>
<p>返回一个信任由输入流读取的证书的信任管理器,若证书没有被签名则抛出SSLHandsakeException,证书建议使用第三方签名的而不是自签名的（比如使用openssl生成）,特别是在生产环境中,例子的注释也提到:<br>
<img src="https://img-blog.csdnimg.cn/20200605153122874.png" alt="在这里插入图片描述" loading="lazy"><br>
完整代码见文末.这里把工具类的方法实现成了静态,调用时可以直接:</p>
<pre><code class="language-java">OKHTTP.send(&quot;https://xxxxx&quot;);
</code></pre>
<p>另一种方式是直接自定义一个TrustManager,重写里面的三个方法:</p>
<pre><code class="language-java">SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);
context.init(null, new TrustManager[]{
    new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain,String authType) throws CertificateException {}
        
        @Override
        public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
            for (X509Certificate cert : chain) {
                // Make sure that it hasn't expired.
                cert.checkValidity();
                // Verify the certificate's public key chain.
                try {
                    cert.verify(((X509Certificate) ca).getPublicKey());
                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (InvalidKeyException e) {
                    e.printStackTrace();
                } catch (NoSuchProviderException e) {
                    e.printStackTrace();
                } catch (SignatureException e) {
                    e.printStackTrace();
                }
            }
        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }
    }
}, null);
</code></pre>
<p>第一个方法为</p>
<pre><code class="language-java">@Override
public void checkClientTrusted(X509Certificate[] chain,String authType) throws CertificateException {}
</code></pre>
<p>该方法检查客户端的证书,由于不需要对客户端进行认证,默认即可.<br>
第二个方法为</p>
<pre><code class="language-java">@Override
public void checkServerTrusted(X509Certificate[] chain,String authType)
</code></pre>
<p>该方法检查服务器的证书,若不信任该证书则抛出异常,通过自己实现该方法可以信任任何自己指定的证书,不做任何处理的话,不会抛出任何异常,相当于信任所有证书.这里检查了证书是否过期以及证书的签名是否匹配.<br>
第三个方法为</p>
<pre><code class="language-java">@Override
public X509Certificate[] getAcceptedIssuers() {
    return new X509Certificate[0];
}
</code></pre>
<p>返回受信任的X509证书数组.<br>
这种方法笔者没有试过,仅供参考.</p>
<h1 id="5-服务器部署">5 服务器部署</h1>
<p>服务器用的是Tomcat,简单介绍一下部署.</p>
<h2 id="51-上传工程">5.1 上传工程</h2>
<p>后端处理用的Spring Boot的工程,就不演示了,使用IDEA打成war包后上传到webapps下即可.</p>
<h2 id="52-tomcat配置">5.2 Tomcat配置</h2>
<p>重点说一下Tomcat的配置,首先需要一个域名,修改conf/server.xml文件,找到默认的名叫localhost的Host:<br>
<img src="https://img-blog.csdnimg.cn/20200330012338899.png" alt="在这里插入图片描述" loading="lazy"><br>
然后直接复制Host标签,把name修改成自己的域名即可.<br>
<img src="https://img-blog.csdnimg.cn/20200330012446941.png" alt="在这里插入图片描述" loading="lazy"><br>
然后是证书的配置,笔者的证书在某某云上购买的,这里提供了几种格式的证书下载:<br>
<img src="https://img-blog.csdnimg.cn/20200330012635198.png" alt="在这里插入图片描述" loading="lazy"><br>
Tomcat的是两个文件,一个是pfx文件,一个是密码文件,把pfx文件上传到服务器的Tomcat后,继续修改server.xml,搜索8443找到如下位置(Tomcat版本9.0.33):<br>
<img src="https://img-blog.csdnimg.cn/20200330012945701.png" alt="在这里插入图片描述" loading="lazy"><br>
一些Tomcat8的高版本提供了HTTP/2的实现,默认使用apr实现的,这里使用的是HTTP/1.1,使用HTTP/2需要额外安装Apr,Apr-util以及Tomcat-native,因此这里采用HTTP/1.1实现.使用HTTP/2可以参考<a href="https://blog.csdn.net/qq_27525611/article/details/106557158">这里</a>.<br>
修改如下:<br>
<img src="https://img-blog.csdnimg.cn/20200330012834456.png" alt="在这里插入图片描述" loading="lazy"><br>
添加了scheme,secure,keystoreFile,keystoreType,keystorePass,clientAuth,sslProtocol配置,同时去掉里面的&lt;SSLHostConfig&gt;,keystoreFile是刚才的pfx文件,采用绝对路径,keystorePass是密码.<br>
另外默认的端口为8443,这里修改成了8123.<br>
如果想要更安全的话可以手动指定TLS的版本:</p>
<pre><code class="language-xml">&lt;Connector ...
sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1.3&quot;
&gt;
</code></pre>
<p>重启Tomcat后输入</p>
<pre><code class="language-bash">https://www.test.com:port
</code></pre>
<p>进行测试<br>
<img src="https://img-blog.csdnimg.cn/20200330013358932.png" alt="在这里插入图片描述" loading="lazy"><br>
这样就成功了.</p>
<h1 id="6-验证与源码">6 验证与源码</h1>
<p>这个因为没有完整的Demo很难做验证,具体来说前端用的OkHttp核心都介绍了,后端的话服务器Tomcat也介绍了,用Spring Boot做个Demo应该不难.<br>
这里只给出了工具类OKHTTP的源码:<br>
<a href="https://github.com/2293736867/OkHttp-HTTPS-demo">github</a></p>
<h1 id="7-常见问题">7 常见问题</h1>
<h2 id="71-tomcat-https无法访问">7.1 Tomcat HTTPS无法访问</h2>
<ul>
<li>证书文件错误,不过这个可能性比较少.</li>
<li>配置错误,请检查配置文件是否正确,可以ps -ef | grep tomcat查看Tomcat是否开启以及查看logs/catalina.out日志.</li>
<li>端口错误,访问的端口需要与&lt;Connector&gt;中的端口对应(Tomcat默认的HTTPS端口为8443,笔者居然看成了8433,然后netstat 无数次都没有看到被监听...)</li>
<li>安全组/防火墙问题,云服务器的话需要在安全组配置中开启相应端口,同时应查看有没有把某个ip列入黑名单导致无法访问.防火墙的话这里主要指iptables,如果没有开启的话不需要理会,如果开启的话需要开放对应端口.</li>
</ul>
<h2 id="72-okhttp-https无法访问">7.2 OkHttp HTTPS无法访问</h2>
<ul>
<li>无法读取证书文件:需要把证书文件放在工程对应路径下读取,比如AS中放在assets下然后使用getAssets().open(&quot;xxx.xxx&quot;)获取,Maven工程的话放在resources下直接使用FileInputStream获取.</li>
<li>singed fields invalid:<br>
<img src="https://img-blog.csdnimg.cn/20200330015552425.png" alt="在这里插入图片描述" loading="lazy"><br>
证书文件格式错误,使用.crt/.pem等证书.</li>
<li>Signature does not match:这个有可能是使用openssl自生成证书在验证的时候出现的异常,可能的解决办法是转换证书的格式,如果不行就重新生成一次证书.</li>
</ul>
<h1 id="8-参考链接">8 参考链接</h1>
<p>1.<a href="http://pingguohe.net/2016/02/26/Android-App-secure-ssl.html">苹果核 - Android App 安全的HTTPS 通信</a><br>
2.<a href="https://blog.csdn.net/guiying712/article/details/56301736">Android OkHttp实现HTTPS访问,支持Android 4.X系统HTTPS访问</a><br>
3.<a href="https://www.jianshu.com/p/475c0dc5c366">Android使用OkHttp请求自签名的https网站</a></p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/applicationproperties-ti-shi-cannot-resolve-configuration-property-xxxx/">
              <h3 class="post-title">
                下一篇：application.properties提示Cannot resolve configuration property &#39;xxxx&#39;
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
