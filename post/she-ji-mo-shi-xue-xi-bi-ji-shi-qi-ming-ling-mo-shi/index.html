
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十七）：命令模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi.jpeg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十七）：命令模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-02</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%91%BD%E4%BB%A4%E7%B1%BB">2.2 抽象命令类</a></li>
<li><a href="#23-%E8%B0%83%E7%94%A8%E8%80%85">2.3 调用者</a></li>
<li><a href="#24-%E6%8E%A5%E6%94%B6%E8%80%85">2.4 接收者</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%91%BD%E4%BB%A4%E7%B1%BB">2.5 具体命令类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97">4 命令队列</a></li>
<li><a href="#5-%E6%92%A4%E9%94%80%E4%B8%8E%E9%87%8D%E5%81%9A">5 撤销与重做</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>日常生活中，可以通过开关控制一些电器的开启和关闭，比如电灯和排气扇。可以将开关理解成一个请求发送者，电灯是请求的最红接收者以及处理者，开关与电灯之间不存在直接的耦合关系，两者通过电线连接在一起，使不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）既可对应不同的接收者（电器）。</p>
<p>软件开发中经常需要向某些对象发送请求，但是并不知道具体的接收者是谁，也不知道被请求的操作是哪个，此时希望以一种松耦合的方式来设计软件，使得请求发送者与请求接收者之间能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作，此时可以使用命令模式进行设计。</p>
<p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<h2 id="12-定义">1.2 定义</h2>
<p>命令模式：将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p>命令模式是一种对象行为型模式，别名为动作模式或者事务模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200731194318933.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Command</code>（抽象命令类）：抽象命令类一般是一个抽象类或者接口，在其中声明了用于执行请求的<code>execute()</code>方法，通过这些方法可以调用请求接收者的相关操作</strong></li>
<li><strong><code>ConcreteCommand</code>（具体命令类）：实现了抽象命令类中声明的方法，对应具体的接收者对象，将接收者对象的动作绑定其中，在实现<code>execute()</code>方法时，将调用接收者对象的相关操作</strong></li>
<li><strong><code>Invoker</code>（调用者）：调用者即请求发送者，通过命令对象来执行请求。一个调用者并不需要设计时确定接收者，因此它只与抽象命令类之间存在关联关系。程序运行时将具体命令对象注入，并调用其中的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作</strong></li>
<li><strong><code>Receiver</code>（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象命令类：定义执行请求的方法</li>
<li>定义调用者：在调用方法里面包含对具体命令的调用，同时需要包含一个对抽象命令的引用</li>
<li>定义接收者：定义接收请求的业务方法</li>
<li>定义具体命令类：继承/实现抽象命令类，实现其中执行请求方法，转发到接收者的接收方法</li>
</ul>
<h2 id="22-抽象命令类">2.2 抽象命令类</h2>
<p>这里实现为一个接口：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<h2 id="23-调用者">2.3 调用者</h2>
<pre><code class="language-java">class Invoker
{
    private Command command;

    public Invoker(Command command)
    {
        this.command = command;
    }

    public void call()
    {
        System.out.println(&quot;调用者操作&quot;);
        command.execute();
    }
}
</code></pre>
<p>调用者可以通过构造方法或者setter注入具体命令，对外提供一个调用方法<code>call</code>，当调用此方法时调用具体命令的<code>execute</code>。</p>
<h2 id="24-接收者">2.4 接收者</h2>
<pre><code class="language-java">class Receiver
{
    public void action()
    {
        System.out.println(&quot;接收者操作&quot;);
    }
}
</code></pre>
<p>这里的接收者只有一个<code>action</code>，表示接收方法。</p>
<h2 id="25-具体命令类">2.5 具体命令类</h2>
<pre><code class="language-java">class ConcreteCommand implements Command
{
    private Receiver receiver = new Receiver();
    @Override
    public void execute()
    {
        receiver.action();
    }
}
</code></pre>
<p>具体命令类中需要包含一个对接收者的引用，以便在<code>execute</code>中调用接收者。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Invoker invoker = new Invoker(new ConcreteCommand());
    invoker.call();
}
</code></pre>
<p>通过构造方法注入具体命令到调用者中，接着直接调用即可。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200731202157394.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>自定义功能键的设置，对于一个按钮，可以根据需要由用户设置为最小化/最大化/关闭功能，使用命令模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Button</code></li>
<li>接收者：<code>MinimizeHandler</code>+<code>MaximizeHandler</code>+<code>CloseHandler</code></li>
<li>具体命令类：<code>MinimizeCommand</code>+<code>MaximizeCommand</code>+<code>CloseCommand</code></li>
</ul>
<p>首先设计抽象命令类，实现为一个接口，仅包含<code>execute</code>方法：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<p>接着是调用者类，包含一个抽象命令的引用：</p>
<pre><code class="language-java">class Button
{
    private Command command;
    public Button(Command command)
    {
        this.command = command;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        command.execute();
    }
}
</code></pre>
<p>然后是接收者类：</p>
<pre><code class="language-java">class MinimizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最小化&quot;);
    }
}

class MaximizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最大化&quot;);
    }
}

class CloseHandler
{
    public void handle()
    {
        System.out.println(&quot;关闭&quot;);
    }
}
</code></pre>
<p>最后是具体命令类，对应包含一个接收者成员即可，实现其中的<code>execute</code>并转发到接收者的方法：</p>
<pre><code class="language-java">class MinimizeCommand implements Command
{
    private MinimizeHandler handler = new MinimizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class MaximizeCommand implements Command
{
    private MaximizeHandler handler = new MaximizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class CloseCommand implements Command
{
    private CloseHandler handler = new CloseHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Button button = new Button(new MinimizeCommand());
    button.onClick();

    button = new Button(new MaximizeCommand());
    button.onClick();

    button = new Button(new CloseCommand());
    button.onClick();
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/2020080100022354.png" alt="在这里插入图片描述" loading="lazy"><br>
如果需要新增一个命令，只需要命令接收者以及实现了<code>Command</code>的具体命令类，客户端再将具体命令注入请求发送者（<code>Button</code>），无须直接操作请求接收者。</p>
<h1 id="4-命令队列">4 命令队列</h1>
<p>有时候需要将多个请求排队，当一个请求发送者发送完成一个请求后，不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法完成对请求的处理。这种形式可以通过命令队列实现，实现命令队列很简单，一般是增加一个叫<code>CommandQueue</code>的类，由该类负责存储多个命令对象，不同的命令对象可以对应不同的请求接收者，比如在上面的例子中增加<code>CommandQueue</code>命令队列类：</p>
<pre><code class="language-java">class CommandQueue
{
    private ArrayList&lt;Command&gt; commands = new ArrayList&lt;&gt;();
    public void add(Command command)
    {
        commands.add(command);
    }

    public void remove(Command command)
    {
        commands.remove(command);
    }

    public void execute()
    {
        System.out.println(&quot;批量执行命令&quot;);
        commands.forEach(Command::execute);
    }
}
</code></pre>
<p>接着修改调用者类<code>Button</code>（只需将原来的<code>Command</code>改为<code>CommandQueue</code>）：</p>
<pre><code class="language-java">class Button
{
    private CommandQueue queue;
    public Button(CommandQueue queue)
    {
        this.queue = queue;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        queue.execute();
    }
}
</code></pre>
<p>最后是客户端定义命令队列并作为参数传入调用者的构造方法或者setter中，最后由调用者执行方法：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    CommandQueue queue = new CommandQueue();
    queue.add(new MinimizeCommand());
    queue.add(new MaximizeCommand());
    queue.add(new CloseCommand());
    Button button = new Button(queue);
    button.onClick();
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200801001917143.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-撤销与重做">5 撤销与重做</h1>
<blockquote>
<p>设计一个简易计算器，实现加法功能，还能够实现撤销以及重做功能，使用命令模式实现。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Calculator</code></li>
<li>接收者：<code>Adder</code></li>
<li>具体命令类：<code>AddCommand</code></li>
</ul>
<p>首先先不实现撤销以及重做功能：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        Calculator calculator = new Calculator(new AddCommand());
        calculator.add(3);
        calculator.add(9);
    }
}

interface Command
{
    int execute(int value);
}

class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }
}

class Adder
{
    private int num = 0;
    public int add(int value)
    {
        return num += value;
    }
}

class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }
}
</code></pre>
<p>代码与上面的实例类似，就不解释了。</p>
<p>这里关键的问题是如何实现撤销以及重做功能，撤销能够恢复到进行加法之前的状态，而重做能恢复到进行了加法之后的状态，而且这是有固定顺序的，因此可以联想到数组，使用下标表示当前状态，下标左移表示撤销，下标右移表示重做：<br>
<img src="https://img-blog.csdnimg.cn/2020080100442690.png" alt="在这里插入图片描述" loading="lazy"><br>
使用一个状态数组存储每次进行加法的状态，用下标表示当前状态，当撤销时，使下标左移，当重做时，使下标右移。</p>
<p>首先需要修改抽象命令类，添加撤销以及重做方法：</p>
<pre><code class="language-java">interface Command
{
    int execute(int value);
    int undo();
    int redo();
}
</code></pre>
<p>接着修改调用者类，添加撤销以及重做方法：</p>
<pre><code class="language-java">class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }

    public void undo()
    {
        System.out.println(command.undo());
    }

    public void redo()
    {
        System.out.println(command.redo());
    }
}
</code></pre>
<p>核心的实现位于接收者类<code>Adder</code>，使用了<code>List&lt;Integer&gt;</code>存储了状态，<code>index</code>表示下标，在撤销或重做之前首先判断下标位置是否合法，合法则进行下一步操作：</p>
<pre><code class="language-java">class Adder
{
    private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    private int index = 0;
    public Adder()
    {
        nums.add(0);
    }

    public int add(int value)
    {
        int result = nums.get(index)+value;
        nums.add(result);
        ++index;
        return result;
    }

    public int redo()
    {
        if(index + 1 &lt; nums.size())
            return nums.get(++index);
        return nums.get(index);
    }

    public int undo()
    {
        if(index - 1 &gt;= 0)
            return nums.get(--index);
        return nums.get(index);
    }
}
</code></pre>
<p>最后具体命令类简单添加撤销以及重做方法即可：</p>
<pre><code class="language-java">class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }

    @Override
    public int undo()
    {
        return adder.undo();
    }

    @Override
    public int redo()
    {
        return adder.redo();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Calculator calculator = new Calculator(new AddCommand());
    calculator.add(3);
    calculator.add(9);
    
    calculator.undo();
    calculator.undo();
    calculator.undo();
    calculator.undo();
    
    calculator.redo();
    calculator.redo();
    calculator.redo();
    calculator.redo();
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801005520961.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>降低耦合度：由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求可以对应不同的接收者，同样相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性</li>
<li>满足OCP：新的命令可以很容易添加到系统中，由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，满足OCP的要求</li>
<li>撤销+中作：为请求的撤销以及重做提供了一种设计和实现方案</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>过多具体命令类：使用命令模式可能会导致系统有过多的具体命令类，因为针对每一个请求接收者的调用操作都需要设计一个具体工具类，因此在某些系统中可能需要提供大量的具体命令类</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>系统需要将请求调用者和请求接受者解耦，使得调用者和接收者不直接交互，请求调用者无须知道接收者的存在，也无需知道接收者是谁，接收者也无须关心何时被调用</li>
<li>系统需要在不同时间指定请求，将请求排队和执行请求</li>
<li>系统需要支持撤销以及恢复操作</li>
<li>系统需要将一组操作组合一起形成宏命令，使用命令队列实现</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200801012404628.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第44期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
