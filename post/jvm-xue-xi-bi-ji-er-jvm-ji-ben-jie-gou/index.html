
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>JVM学习笔记（二）：JVM基本结构 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou.jpeg')">
            </div>
          
          <h2 class="post-title">JVM学习笔记（二）：JVM基本结构</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-03-03</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/hmN5f1Dgf/">
                    JVM
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-jvm%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></a></li>
<li><a href="#3-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">3 <code>JVM</code>基本结构</a></li>
<li><a href="#4-java%E5%A0%86">4 <code>Java堆</code></a></li>
<li><a href="#5-java%E6%A0%88">5 <code>Java栈</code></a>
<ul>
<li><a href="#51-%E7%AE%80%E4%BB%8B">5.1 简介</a></li>
<li><a href="#52-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">5.2 局部变量表</a>
<ul>
<li><a href="#521-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%AF%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.1 参数数量对局部变量表的影响</a></li>
<li><a href="#522-%E6%A7%BD%E4%BD%8D%E5%A4%8D%E7%94%A8">5.2.2 槽位复用</a></li>
<li><a href="#523-%E5%AF%B9gc%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.3 对<code>GC</code>的影响</a></li>
</ul>
</li>
<li><a href="#53-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%BA">5.3 操作数栈与帧数据区</a></li>
<li><a href="#54-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">5.4 栈上分配</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA">6 <code>方法区</code></a></li>
<li><a href="#7-java%E5%A0%86-java%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</a></li>
<li><a href="#8-%E5%B0%8F%E7%BB%93">8 小结</a></li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第二章</li>
</ul>
<p>本文是第二章的一些笔记整理。</p>
<h1 id="2-jvm基本参数-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></h1>
<p><code>java</code>命令的一般形式如下：</p>
<pre><code class="language-bash">java [-options] class [args..]
</code></pre>
<p>其中<code>-options</code>表示<code>JVM</code>启动参数，<code>class</code>为带有<code>main()</code>的<code>Java</code>类，<code>args</code>表示传递给<code>main()</code>的参数，也就是<code>main(String [] args)</code>中的参数。</p>
<p>一般设置参数在<code>-optinos</code>处设置，先看一段简单的代码：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        for(int i=0;i&lt;args.length;++i) {
            System.out.println(&quot;argument &quot;+(i+1)+&quot; : &quot;+args[i]);
        }
        System.out.println(&quot;-Xmx &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot; M&quot;);
    }
}
</code></pre>
<p>设置应用程序参数以及<code>JVM</code>参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2021030313324746.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输出：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210303133306902.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到<code>-Xmx32m</code>传递给<code>JVM</code>，使得最大可用堆空间为<code>32MB</code>，参数<code>a</code>作为应用程序参数，传递给<code>main()</code>，此时<code>args.length</code>的值为1。</p>
<h1 id="3-jvm基本结构">3 <code>JVM</code>基本结构</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210303134417147.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>各部分介绍如下：</p>
<ul>
<li><code>类加载子系统</code>：负责从文件系统或者网络中加载<code>Class</code>信息，加载的类信息存放在一个叫<code>方法区</code>的内存空间中</li>
<li><code>方法区</code>：除了包含加载的类信息之外，还包含运行时常量池信息，包括字符串字面量以及数字常量</li>
<li><code>Java堆</code>：在虚拟机启动时建立，是最主要的内存工作区域，几乎所有的<code>Java</code>对象实例都存在于<code>Java堆</code>中，<strong>堆空间是所有线程共享的</strong></li>
<li><code>直接内存</code>：是在<code>Java堆</code>外的，直接向系统申请的内存区域。<code>NIO</code>库允许<code>Java</code>程序使用<code>直接内存</code>，通常<code>直接内存</code>的访问速度要优于<code>Java堆</code>。另外由于<code>直接内存</code>在堆外，大小不会受限于<code>-Xmx</code>指定的堆大小，但是会受到操作系统总内存大小的限制</li>
<li><code>垃圾回收系统</code>：可以对<code>方法区</code>、<code>Java堆</code>和<code>直接内存</code>进行回收，<code>Java堆</code>是垃圾收集器的工作重点。对于不再使用的垃圾对象，<code>垃圾回收系统</code>会在后台默默工作、默默查找，标识并释放垃圾对象</li>
<li><code>Java栈</code>：每个<code>JVM</code>线程都有一个私有的<code>Java栈</code>，一个线程的<code>Java栈</code>在线程创建时被创建，保存着帧信息、局部变量、方法参数等</li>
<li><code>本地方法栈</code>：与<code>Java栈</code>类似，不同的是<code>Java栈</code>用于<code>Java</code>方法调用，<code>本地方法栈</code>用于本地方法（<code>native method</code>）调用，<code>JVM</code>允许<code>Java</code>直接调用本地方法</li>
<li><code>PC寄存器</code>：每个线程私有的空间，<code>JVM</code>会为每个线程创建<code>PC寄存器</code>，在任意时刻一个<code>Java</code>线程总是执行一个叫做<code>当前方法</code>的方法，如果<code>当前方法</code>不是本地方法，<code>PC</code>寄存器就会指向当前正在被执行的指令，如果<code>当前方法</code>是本地方法，那么<code>PC寄存器</code>的值就是<code>undefined</code></li>
<li><code>执行引擎</code>：负责执行<code>JVM</code>的字节码，现代<code>JVM</code>为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行</li>
</ul>
<p>下面重点说三部分：<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>。</p>
<h1 id="4-java堆">4 <code>Java堆</code></h1>
<p>几乎所有的对象都存在<code>Java堆</code>中，根据垃圾回收机制的不同，<code>Java堆</code>可能拥有不同的结构，最常见的一种是将整个<code>Java堆</code>分为<code>新生代</code>和<code>老年代</code>：</p>
<ul>
<li><code>新生代</code>：存放新生对象或年龄不大的对象，有可能分为<code>eden</code>、<code>s0</code>、<code>s1</code>，其中<code>s0</code>和<code>s1</code>分别被称为<code>from</code>和<code>to</code>区域，它们是两块大小相等、可以互换角色的内存空间</li>
<li><code>老年代</code>：存放老年对象，绝大多数情况下，对象首先在<code>eden</code>分配，在一次新生代回收后，如果对象还存活，会进入<code>s0</code>或<code>s1</code>，之后每经过一次新生代回收，如果对象存活则年龄加1。当对象年龄到达一定条件后，会被认为是老年对象，就会进入老年代</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210303134441993.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-java栈">5 <code>Java栈</code></h1>
<h2 id="51-简介">5.1 简介</h2>
<p><code>Java栈</code>是一块线程私有的内存空间，如果是<code>Java堆</code>与程序数据密切相关，那么<code>Java栈</code>和线程执行密切相关，线程执行的基本行为是函数调用，每次函数调用都是通过<code>Java栈</code>传递的。</p>
<p><code>Java栈</code>与数据结构中的<code>栈</code>类似，有<code>FIFO</code>的特点，在<code>Java</code>栈中保存的主要内容为<strong>栈帧</strong>，每次函数调用都会有一个对应的<code>栈帧</code>入栈，每次调用结束就有一个对应的<code>栈帧</code>出栈。栈顶总是当前的帧（当前执行的函数所对应的帧）。栈帧保存着<code>局部变量表</code>、<code>操作数栈</code>、<code>帧数据</code>等。</p>
<p>这里说一下题外话，相信很多读者对<code>StackOverflowError</code>不陌生，这是因为函数调用过多造成的，因为每次函数调用都会生成对应的栈帧，会占用一定的栈空间，如果栈空间不足，函数调用就无法进行，当请求栈深度大于最大可用栈深度时，就会抛出<code>StackOverflowError</code>。</p>
<p><code>JVM</code>提供了<code>-Xss</code>来指定线程的最大栈空间。</p>
<p>比如，下面这个递归调用的程序：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
            recursion();
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
        }
    }
}
</code></pre>
<p>指定<code>-Xss1m</code>，结果：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210303141441656.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss2m</code>：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210303141344772.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss3m</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210303141413662.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到调用深度随着<code>-Xss</code>的增加而增加。</p>
<h2 id="52-局部变量表">5.2 局部变量表</h2>
<p>局部变量表是栈帧的重要组成部分之一，用于保存函数的参数及局部变量。局部变量表中的变量只在当前函数调用中有效，函数调用结束后，函数栈帧销毁，局部变量表也会随之销毁。</p>
<h3 id="521-参数数量对局部变量表的影响">5.2.1 参数数量对局部变量表的影响</h3>
<p>由于局部变量表在栈帧中，如果函数的参数和局部变量表较多，会使局部变量表膨胀，导致栈帧会占用更多的栈空间，最终减少了函数嵌套调用次数。</p>
<p>比如：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(long a,long b,long c){
        long e=1,f=2,g=3,h=4,i=5,k=6,q=7;

        count++;
        recursion(a,b,c);
    }

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
//            recursion();
            recursion(0L,1L,2L);
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
            count = 0;
        }
    }
}
</code></pre>
<p>无参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210303145401403.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>带参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210303145451827.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到次数明显减少了，原因正是因为局部变量表变大，导致栈帧变大，从而次数减少。</p>
<p>下面使用<code>jclasslib</code>进一步查看，先在<code>IDEA</code>安装如下插件：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210303145242291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装后使用插件查看情况：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20210303145931511.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第一个函数是带参数的，可以看到最大局部变量表的大小为<code>20字</code>（注意不是字节），<code>Long</code>在局部变量表中需要占用2字。而相比之下不带参数的函数最大局部变量表大小为0：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210303150723100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-槽位复用">5.2.2 槽位复用</h3>
<p>局部变量表中的槽位是可以复用的，如果一个局部变量超过了其作用域，则在其作用域之后的局部变量就有可能复用该变量的槽位，这样能够节省资源，比如：</p>
<pre><code class="language-java">public static void localVar1(){
    int a = 0;
    System.out.println(a);
    int b = 0;
}

public static void localVar2(){
    {
        int a = 0;
        System.out.println(a);
    }
    int b = 0;
}
</code></pre>
<p>同样使用<code>jclasslib</code>查看：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210303151315773.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210303151328196.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到少了<code>localVar2</code>的最大局部变量大小为1字，相比<code>localVar1</code>少了1字，继续分析，<code>localVar1</code>第0个槽位为变量a，第1个槽位为变量b：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210303151544872.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而<code>localVar2</code>中的b复用了a的槽位，因此最大变量大小为1字，节约了空间。</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210303151611143.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="523-对gc的影响">5.2.3 对<code>GC</code>的影响</h3>
<p>下面再来看一下局部变量表对垃圾回收的影响，示例：</p>
<pre><code class="language-java">public class Main {
    public static void localGC1(){
        byte [] a = new byte[6*1024*1024];
        System.gc();
    }

    public static void localGC2(){
        byte [] a = new byte[6*1024*1024];
        a = null;
        System.gc();
    }

    public static void localGC3(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        System.gc();
    }

    public static void localGC4(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        int c = 10;
        System.gc();
    }

    public static void localGC5(){
        localGC1();
        System.gc();
    }

    public static void main(String[] args) {
        System.out.println(&quot;-------------localGC1------------&quot;);
        localGC1();
        System.out.println();
        System.out.println(&quot;-------------localGC2------------&quot;);
        localGC2();
        System.out.println();
        System.out.println(&quot;-------------localGC3------------&quot;);
        localGC3();
        System.out.println();
        System.out.println(&quot;-------------localGC4------------&quot;);
        localGC4();
        System.out.println();
        System.out.println(&quot;-------------localGC5------------&quot;);
        localGC5();
        System.out.println();
    }
}
</code></pre>
<p>输出（请加上<code>-Xlog:gc</code>参数）：</p>
<pre><code class="language-bash">[0.004s][info][gc] Using G1
-------------localGC1------------
[0.128s][info][gc] GC(0) Pause Full (System.gc()) 10M-&gt;8M(40M) 12.081ms

-------------localGC2------------
[0.128s][info][gc] GC(1) Pause Young (Concurrent Start) (G1 Humongous Allocation) 9M-&gt;8M(40M) 0.264ms
[0.128s][info][gc] GC(2) Concurrent Cycle
[0.133s][info][gc] GC(3) Pause Full (System.gc()) 16M-&gt;0M(14M) 2.799ms
[0.133s][info][gc] GC(2) Concurrent Cycle 4.701ms

-------------localGC3------------
[0.133s][info][gc] GC(4) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(14M) 0.203ms
[0.133s][info][gc] GC(5) Concurrent Cycle
[0.135s][info][gc] GC(5) Pause Remark 8M-&gt;8M(22M) 0.499ms
[0.138s][info][gc] GC(6) Pause Full (System.gc()) 8M-&gt;8M(22M) 2.510ms
[0.138s][info][gc] GC(5) Concurrent Cycle 4.823ms

-------------localGC4------------
[0.138s][info][gc] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation) 8M-&gt;8M(22M) 0.202ms
[0.138s][info][gc] GC(8) Concurrent Cycle
[0.142s][info][gc] GC(9) Pause Full (System.gc()) 16M-&gt;0M(8M) 2.861ms
[0.142s][info][gc] GC(8) Concurrent Cycle 3.953ms

-------------localGC5------------
[0.143s][info][gc] GC(10) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(8M) 0.324ms
[0.143s][info][gc] GC(11) Concurrent Cycle
[0.145s][info][gc] GC(11) Pause Remark 8M-&gt;8M(16M) 0.316ms
[0.147s][info][gc] GC(12) Pause Full (System.gc()) 8M-&gt;8M(18M) 2.402ms
[0.149s][info][gc] GC(13) Pause Full (System.gc()) 8M-&gt;0M(8M) 2.462ms
[0.149s][info][gc] GC(11) Concurrent Cycle 6.843ms
</code></pre>
<p>首行输出表示使用<code>G1</code>，下面逐个进行分析：</p>
<ul>
<li><code>localGC1</code>：并没有回收内存，因为此时<code>byte</code>数组被变量<code>a</code>引用，因此无法回收</li>
<li><code>localGC2</code>：回收了内存，因为<code>a</code>被设置为了<code>null</code>，<code>byte</code>数组失去强引用</li>
<li><code>localGC3</code>：没有回收内存，虽然此时<code>a</code>变量已经失效，但是仍然存在于局部变量表中，并且指向<code>byte</code>数组，因此无法回收</li>
<li><code>localGC4</code>：回收了内存，因为声明了变量<code>c</code>，复用了<code>a</code>的槽位，导致<code>byte</code>数组失去引用，顺利回收</li>
<li><code>localGC5</code>：回收了内存，虽然<code>localGC1</code>中没有释放内存，但是返回到<code>localGC5</code>后，<code>localGC1</code>的栈帧被销毁，也包括其中的<code>byte</code>数组失去了引用，因此在<code>localGC5</code>中被回收</li>
</ul>
<h2 id="53-操作数栈与帧数据区">5.3 操作数栈与帧数据区</h2>
<p>操作数栈也是栈帧的重要内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，也是一个<code>FIFO</code>的数据结构。</p>
<p>而帧数据区则保存着常量池指针，方便程序访问常量池，此外，帧数据区也保存着异常处理表，以便在出现异常后，找到处理异常的代码。</p>
<h2 id="54-栈上分配">5.4 栈上分配</h2>
<p>栈上分配是<code>JVM</code>提供的一项优化技术，基本思想是，将线程私有的对象打散分配到栈上，好处是函数调用结束后可以自动销毁，而不需要垃圾回收器的介入，从而提高系统性能。</p>
<p>栈上分配的一个技术基础是逃逸分析，逃逸分析目的是判断对象的作用域是否会逃逸出函数体，例子如下：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
    }

    public static void alloc(){
        User user = new User();
        user.id = 5;
        user.name = &quot;test&quot;;
    }

    public static void main(String[] args) {
        long b = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000000; i++) {
            alloc();
        }
        long e = System.currentTimeMillis();
        System.out.println(e-b);
    }
}
</code></pre>
<p>启动参数：</p>
<pre><code class="language-bash">-server # 开启Server模式，此模式下才能开启逃逸分析
-Xmx10m # 最大堆内存
-Xms10m # 初始化堆内存
-XX:+DoEscapeAnalysis # 开启逃逸分析
-Xlog:gc # GC日志
-XX:-UseTLAB # 关闭TLAB
-XX:+EliminateAllocations # 开启标量替换，默认打开，允许将对象打散分配在栈上
</code></pre>
<p>输出如下，没有<code>GC</code>日志：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210303161826251.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果关闭了标量替换，也就是添加<code>-XX:-EliminateAllocations</code>，就可以看到会频繁触发<code>GC</code>，因为这时候对象存放在堆上而不是栈上，堆只有10m空间，会频繁进行<code>GC</code>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210303161747610.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-方法区">6 <code>方法区</code></h1>
<p>与<code>Java堆</code>一样，<code>方法区</code>是所有线程共享的内存区域，用于保存系统的类信息，比如类字段、方法、常量池等，<code>方法区</code>的大小决定了系统可以保存多少个类，如果定义了过多的类，会导致<code>方法区</code>溢出，会直接<code>OOM</code>。</p>
<p>在<code>JDK6/7</code>中<code>方法区</code>可以理解成<code>永久区</code>，<code>JDK8</code>后，<code>永久区</code>被移除，取而代之的是<code>元数据区</code>，可以使用<code>-XX:MaxMetaspaceSize</code>指定，这是一块堆外的直接内存，如果不指定大小，默认情况下<code>JVM</code>会耗尽所有可用的系统内存。</p>
<p>如果<code>元数据区</code>发生溢出，<code>JVM</code>会抛出<code>OOM</code>。</p>
<h1 id="7-java堆-java栈以及方法区的关系">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</h1>
<p>看完了<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>，最后来一段代码来简单分析一下它们的关系：</p>
<pre><code class="language-java">class SimpleHeap{
    private int id;
    public SimpleHeap(int id){
        this.id = id;
    }

    public void show(){
        System.out.println(&quot;id is &quot;+id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
        s1.show();
        s2.show();
    }
}
</code></pre>
<p><code>main</code>中创建了两个局部变量<code>s1</code>、<code>s2</code>，则这两个局部变量存放在<code>Java栈</code>中。同时这两个局部变量是<code>SimpleHeap</code>的实例，这两个实例存放在<code>Java堆</code>中，而其中的<code>show</code>方法，则存放在<code>方法区</code>中，图示如下：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210303135915895.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="8-小结">8 小结</h1>
<p>本文主要讲述了<code>JVM</code>的基本结构以及一些基础参数，基本结构可以分成三部分：</p>
<ul>
<li>第一部分：<code>类加载子系统</code>、<code>Java堆</code>、<code>方法区</code>、<code>直接内存</code></li>
<li>第二部分：<code>Java栈</code>、<code>本地方法栈</code>、<code>PC寄存器</code></li>
<li>第三部分：执行引擎</li>
</ul>
<p>而重点讲了三部分：</p>
<ul>
<li><code>Java堆</code>：常见的结构为<code>新生代</code>+<code>老年代</code>结构，其中新生代可分为<code>edsn</code>、<code>s0</code>、<code>s1</code></li>
<li><code>Java栈</code>：包括局部变量表、操作数栈与帧数据区，还提到了一个<code>JVM</code>优化技术栈上分配，可以通过<code>-XX:+EliminateAllocation</code>开启（默认开启）</li>
<li><code>方法区</code>：所有线程共享区域，用于保存类信息，比如类字段、方法、常量等</li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-262-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第262期
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
