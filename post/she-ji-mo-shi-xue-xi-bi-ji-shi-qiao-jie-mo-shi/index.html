
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十）：桥接模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-qiao-jie-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十）：桥接模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-26</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%8E%A5%E5%8F%A3">2.2 抽象类与实现类接口</a></li>
<li><a href="#23-%E6%89%A9%E5%85%85%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%85%B7%E4%BD%93%E7%B1%BB%E5%AE%9E%E7%8E%B0">2.3 扩充抽象类以及具体类实现</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">4 主要优点</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">5 主要缺点</a></li>
<li><a href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6 适用场景</a></li>
<li><a href="#7-%E6%80%BB%E7%BB%93">7 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统变得更加符合SRP。</p>
<p>比如，设计一个跨平台的图像浏览系统，支持的图片格式包括：</p>
<ul>
<li>PNG</li>
<li>BMP</li>
<li>JPG</li>
<li>GIF</li>
</ul>
<p>等等，而支持的系统包括：</p>
<ul>
<li>Windows</li>
<li>Unix</li>
<li>Linux</li>
</ul>
<p>等等，这样，系统与图片格式就是两个不同的维度，可以利用桥接模式将这两个维度分离，使得它们可以独立变化，增加新的图片格式或者新的系统时，都不会对另一个维度造成任何影响。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>桥接模式：将抽象部分与其实现部分分离，使它们都可以独立地变化。</strong></p>
<p>它是一种对象结构型模式，又称为柄体模式或者接口模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200725072739377.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Abstraction</code>（抽象类）：用于定义抽象类的接口，一般是抽象类而不是接口，具有一个<code>Implementor</code>的成员，与<code>Implementor</code>为关联关系，既可以包含抽象的业务方法，也可以包含具体业务方法</strong></li>
<li><strong><code>RefinedAbstraction</code>（扩充抽象类）：扩充由<code>Abstraction</code>定义的接口，通常为具体类，实现了在<code>Abstraction</code>中的抽象业务方法，同时可以调用<code>Implementor</code>中的业务方法</strong></li>
<li><strong><code>Implementor</code>（实现类接口）：实现类的接口，相比起<code>Abstractoin</code>提供的更多更复杂的操作，<code>Implementor</code>一般只提供基本操作，具体实现交由子类处理</strong></li>
<li><strong><code>ConcreteImplementor</code>（具体实现类）：具体实现<code>Implementor</code>接口，不同的<code>ConcreteImplementor</code>提供不同实现的基本操作</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li><strong>识别维度：首先识别出系统中两个独立变化的维度，设计出抽象类以及实现类接口</strong></li>
<li><strong>建立抽象耦合：在抽象层建立一个抽象关联，也就是在抽象类以及实现类接口之间建立抽象关联</strong></li>
<li><strong>继承：识别出维度后，将它们设计为两个独立的继承等级结构，设计出扩充抽象类以及具体类实现</strong>，比如上面的图片格式以及系统，将图片格式与系统设为抽象层，而BMP，GIF等继承图片格式抽象层，Windows等具体系统集成系统抽象层</li>
<li><strong>扩展：建立抽象耦合后，根据需要对两个维度进行独立扩展</strong>，比如增加新的图片格式WBEP，增加新的操作系统Mac等</li>
</ul>
<h2 id="22-抽象类与实现类接口">2.2 抽象类与实现类接口</h2>
<p>首先对系统中独立变化的维度进行识别，比如有两个维度（A与B），其中A设计为抽象类，B设计为接口：</p>
<pre><code class="language-java">abstract class DimensionA{}
interface DimensionB{}
</code></pre>
<p>接着是建立抽象耦合，A维度包含一个B维度成员，将B维度作为setter参数传入A维度，同时定义两个普通方法：</p>
<pre><code class="language-java">abstract class DimensionA
{
    protected DimensionB dimensionB;
    public abstract void methodA();
    public void setDimensionB(DimensionB dimensionB)
    {
        this.dimensionB = dimensionB;
    }
}

interface DimensionB
{
    void methodB(String str);
}
</code></pre>
<h2 id="23-扩充抽象类以及具体类实现">2.3 扩充抽象类以及具体类实现</h2>
<p>接着是扩充抽象类以及具体类实现，维度A有三个具体类，维度B有两个具体类：</p>
<pre><code class="language-java">class A1 extends DimensionA
{
    @Override
    public void methodA()
    {
        dimensionB.methodB(&quot;A1&quot;);
    }   
}

class A2 extends DimensionA
{
    @Override
    public void methodA()
    {
        dimensionB.methodB(&quot;A2&quot;);
    }
}

class A3 extends DimensionA
{
    @Override
    public void methodA()
    {
        dimensionB.methodB(&quot;A3&quot;);
    }
}

class B1 implements DimensionB
{
    @Override
    public void methodB(String str)
    {
        System.out.println(&quot;B1---&quot;+str);
    }
}

class B2 implements DimensionB
{
    @Override
    public void methodB(String str)
    {
        System.out.println(&quot;B2---&quot;+str);
    }
}
</code></pre>
<h2 id="24-客户端">2.4 客户端</h2>
<p>针对抽象层（两个维度）进行编程，将B维度作为setter参数传入A维度，接着调用A维度的方法：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    DimensionA dimensionA = new A1();
    dimensionA.setDimensionB(new B1());
    dimensionA.methodA();
}
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>跨平台的图片浏览系统，支持的图片格式包括PNG，JPG，BMP，GIF等，支持的系统包括Linux，Unix，Windows等，使用桥接模式设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>两个维度：图片维度+系统维度</li>
<li>抽象类：<code>Image</code>，<code>Image</code>具有一个<code>ImageShow</code>的成员变量</li>
<li>扩充抽象类：<code>BMP</code>，<code>GIF</code>等继承<code>Image</code></li>
<li>实现类接口：<code>ImageShow</code></li>
<li>具体实现类：<code>Linux</code>，<code>Unix</code>，<code>Windows</code>实现图片显示接口<code>ImageShow</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Image image = new GIF();
        image.setImageShow(new Linux());
        image.show();
    }
}

//Image抽象类
abstract class Image
{
    protected ImageShow imageShow;
    public void setImageShow(ImageShow imageShow)
    {
        this.imageShow = imageShow;
    }
    public abstract show();
}

class BMP extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;BMP&quot;);
    }
}

class GIF extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;GIF&quot;);
    }
}

class PNG extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;PNG&quot;);
    }
}

class JPG extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;JPG&quot;);
    }
}

//图片显示接口
interface ImageShow
{
    void show(String name);
}

class Windows implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Windows show &quot;+name);
    }
}

class Linux implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Linux show &quot;+name);
    }
}

class Unix implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Unix show &quot;+name);
    }
}
</code></pre>
<p>更换图片格式只需要修改<code>Image</code>的父类：</p>
<pre><code class="language-java">Image image = new GIF();
Image image = new BMP();
Image image = new JPG();
Image image = new PNG();
</code></pre>
<p>而更换操作系统只需要修改传入setter的参数：</p>
<pre><code class="language-java">image.setImageShow(new Linux());
image.setImageShow(new Windows());
image.setImageShow(new Unix());
</code></pre>
<p>这样就可以把图片以及系统两个维度分离，并能够独立扩展，增加新的图片格式，只需要增加一个新的继承<code>Image</code>的类即可，增加新的系统只需实现<code>ImageShow</code>接口即可。</p>
<p>由于例子简单使用反射进行简化代码并增加了新的系统以及图片格式，代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Image image = new WBEP();
        image.setImageShow(new Mac());
        image.show();
    }
}

abstract class Image
{
    protected ImageShow imageShow;
    public void setImageShow(ImageShow imageShow)
    {
        this.imageShow = imageShow;
    }
    public void show()
    {
        imageShow.show(getClass().getName());
    }
}

class BMP extends Image{}
class GIF extends Image{}
class PNG extends Image{}
class JPG extends Image{}
class WBEP extends Image{}

interface ImageShow
{
    void show(String name);
}

abstract class ImageSystem implements ImageShow
{
    public void show(String name)
    {
        System.out.println(getClass().getName()+&quot; show &quot;+name);
    }
}

class Windows extends ImageSystem{}
class Linux extends ImageSystem{}
class Unix extends ImageSystem{}
class Mac extends ImageSystem{}
</code></pre>
<h1 id="4-主要优点">4 主要优点</h1>
<ul>
<li>低耦合：分离抽象接口及其实现部分，桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以按照各自的维度变化。也就是说，抽象和实现不再同一个继承层次中，而是让抽象作为父类，实现作为子类，这样就可以任意组合子类，从而获得多维度的组合对象</li>
<li>取代多重继承：很多情况下桥接模式可以取代多重继承，多重继承违反了SRP（单一权责原则），复用性差，而且类的个数多，桥接模式可以有效减少子类个数</li>
<li>提高扩展性：桥接模式提高了系统的扩展性，在两个维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则</li>
</ul>
<h1 id="5-主要缺点">5 主要缺点</h1>
<ul>
<li>增加理解难度：桥接模式会增加系统的理解以及设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计以及编程</li>
<li>需要正确识别抽象层：桥接模式要求正确识别系统中两个独立变化的维度，因此适用范围有一定局限，正确识别独立维度需要一定经验积累</li>
</ul>
<h1 id="6-适用场景">6 适用场景</h1>
<ul>
<li>如果一个系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</li>
<li>抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象类子类的对象和一个实现类子类的对象进行动态组合</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展</li>
<li>对于不希望使用继承或因为多重继承导致系统类的个数急剧增加的系统</li>
</ul>
<h1 id="7-总结">7 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200729090053291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-37-qi/">
              <h3 class="post-title">
                下一篇：每日分享 第37期
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
