
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（二十五）：模板方法模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615371949211">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615371949211" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（二十五）：模板方法模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-07</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
<li><a href="#15-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5 模板方法与基本方法</a>
<ul>
<li><a href="#151-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">1.5.1 模板方法</a></li>
<li><a href="#152-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5.2 基本方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E7%B1%BB">2.2 抽象类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%AD%90%E7%B1%BB">2.3 具体子类</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">4 主要优点</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">5 主要缺点</a></li>
<li><a href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6 适用场景</a></li>
<li><a href="#7-%E6%80%BB%E7%BB%93">7 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>模板方法模式是结构最简单的行为型设计模型，在其结构中只存在父类与之类之间的继承关系，通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</strong></p>
<p>模板方法模式是一种类行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804195920960.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>AbstractClass</code>（抽象类）：抽象类中定义了一系列基本操作，这些操作是具体的也可以是抽象的，每一个基本操作对应算法的一个步骤，在子类中可以重定义或实现这些步骤，同时抽象类实现了一个模板方法，定义一个算法的框架</strong></li>
<li><strong><code>ConcreteClass</code>（具体子类）：实现父类中的抽象基本方法，或者覆盖父类中具体基本操作</strong></li>
</ul>
<h2 id="15-模板方法与基本方法">1.5 模板方法与基本方法</h2>
<h3 id="151-模板方法">1.5.1 模板方法</h3>
<p>模板方法是在抽象类中定义的，把基本操作方法组合成一个总算法或总行为的方法。模板方法在抽象类中定义，并由子类不加以修改完全继承。模板方法是一个具体方法，给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。另外由于模板方法是具体方法，因此抽象层只能实现为抽象类而不能是接口。</p>
<h3 id="152-基本方法">1.5.2 基本方法</h3>
<p>基本方法是实现算法的各个步骤，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li>抽象方法：抽象方法就是在抽象类中声明并由子类实现的方法</li>
<li>具体方法：具体方法可以由抽象类实现，或者由子类覆盖实现</li>
<li>钩子方法：钩子方法可以由抽象类实现，子类可以加以扩展</li>
</ul>
<p>在模板方法模式中，钩子方法一般有两类：</p>
<ul>
<li>第一类钩子方法是可以与一些具体步骤挂钩，以实现在不同条件下执行模板方法的不同步骤，这类方法一般返回<code>boolean</code>，方法名一般为<code>isXXX</code></li>
<li>第二类钩子方法是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法</li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象类：声明模板方法以及基本方法</li>
<li>定义模板方法：模板方法是抽象类中的具体方法，按照实际需要将基本方法进行组合</li>
<li>定义基本方法：定义抽象方法，具体方法以及钩子方法，确定好哪些方法交由抽象类实现，哪些方法交由子类实现以及拥有哪些钩子方法</li>
<li>定义具体子类：实现抽象类的抽象方法，按照需要对钩子方法或者具体方法进行覆盖</li>
</ul>
<h2 id="22-抽象类">2.2 抽象类</h2>
<pre><code class="language-java">abstract class AbstractClass
{
    public void templateMethod()
    {
        primitiveOperation1();
        primitiveOperation2();
        if(primitiveOperation3())
            System.out.println(&quot;符合钩子方法条件&quot;);
        else
            System.out.println(&quot;不符合钩子方法条件&quot;);
        primitiveOperation4();
    }

    public void primitiveOperation1()
    {
        System.out.println(&quot;抽象类具体方法&quot;);
    }

    //抽象类抽象方法
    abstract public void primitiveOperation2();

    //第一类钩子方法
    public boolean primitiveOperation3()
    {
        return false;
    }
    
    //第二类钩子方法
    public void primitiveOperation4()
    {

    }
}
</code></pre>
<p>首先定义了模板方法，作为客户端操作的入口。模板方法中对基本方法进行了组合，这里声明了四个基本方法：</p>
<ul>
<li>第一个是抽象类的具体方法：这是所有子类都拥有的相同实现的方法，不应该被子类覆盖</li>
<li>第二个是抽象类的抽象方法：子类需要实现该方法以实现变化</li>
<li>第三个是第一类钩子方法：这类钩子方法返回一个<code>boolean</code>，可以用于控制是否执行某个步骤，子类可以通过这类钩子方法对模板方法的执行过程进行限制，比如如果不想执行某个步骤可以永远返回<code>false</code></li>
<li>第四个是第二类钩子方法：这类钩子方法中父类提供一个空实现，子类选择性进行覆盖</li>
</ul>
<h2 id="23-具体子类">2.3 具体子类</h2>
<pre><code class="language-java">class ConcreteClass extends AbstractClass
{
    public void primitiveOperation2()
    {
        System.out.println(&quot;子类具体方法&quot;);
    }

    public boolean primitiveOperation3()
    {
        return true;
        // 如果想钩子方法返回false可以不实现该方法
        // 因为父类默认返回false
        // return false;
    }

    public void primitiveOperation4()
    {
        System.out.println(&quot;子类覆盖父类第二类钩子方法&quot;);
    }
}
</code></pre>
<p>这里子类实现了抽象类的抽象方法，同时覆盖了两类钩子方法。</p>
<h2 id="24-客户端">2.4 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    AbstractClass class1 = new ConcreteClass();
    class1.templateMethod();
}
</code></pre>
<p>客户端调用很简单，创建一个具体类对象并执行其中的模板方法即可。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200805000357803.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>为银行业务开发一个利息计算模块，该计算模块拥有标准流程：系统验证用户信息，接着判断用户状态，正常状态用户能计算利息，受限制状态用户无法计算利息，最后显示利息，使用模板方法模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象类：<code>Account</code></li>
<li>具体方法：<code>validate(String name)</code></li>
<li>抽象方法：<code>calculate()</code></li>
<li>钩子方法：<code>canCalculate()</code>+<code>display()</code></li>
<li>具体子类：<code>NormalAccount</code>+<code>RestrictedAccount</code></li>
</ul>
<p>首先是抽象类的设计：</p>
<pre><code class="language-java">abstract class Account
{
    public void handle(String name)
    {
        if(validate(name))
        {
            if(canCalculate())
            {
                calculate();
            }
            display();
        }
        else
        {
            System.out.println(&quot;用户名非法&quot;);
        }
    }

    public boolean validate(String name)
    {
        return &quot;1&quot;.equals(name);
    }

    //抽象类抽象方法
    abstract public void calculate();

    //第一类钩子方法
    public boolean canCalculate()
    {
        return true;
    }
    
    //第二类钩子方法
    public void display()
    {

    }
}
</code></pre>
<p>首先通过<code>validate()</code>验证用户名，接着根据第一类钩子方法<code>canCalculate()</code>判断能否计算利息，然后调用抽象计算方法<code>calculate()</code>进行计算，最后无论能够计算利息都会调用第二类钩子方法<code>display()</code>。</p>
<p>具体子类代码如下：</p>
<pre><code class="language-java">class NormalAccount extends Account
{
    public void calculate()
    {
        System.out.println(&quot;正常状态用户计算利息&quot;);
    }

    public void display()
    {
        System.out.println(&quot;正常状态用户显示利息&quot;);
    }
}

class RestrictedAccount extends Account
{
    public boolean canCalculate()
    {
        return false;
    }

    public void calculate()
    {}

    public void display()
    {
        System.out.println(&quot;受限状态用户无法计算利息&quot;);
    }
}
</code></pre>
<p>正常状态用户中实现抽象方法<code>calculate()</code>，并覆盖第二类钩子方法<code>display()</code>，对于受限状态用户，覆盖了第一类钩子方法<code>canCalculate()</code>，永远返回<code>false</code>，同时对抽象方法<code>calculate</code>提供空实现，最后也对第二类钩子方法<code>display</code>进行了覆盖，提示<code>&quot;无法计算利息&quot;</code>。</p>
<h1 id="4-主要优点">4 主要优点</h1>
<ul>
<li>形式化算法：模板方法模式在父类中形式化地定义一个算法，而由子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li>
<li>代码复用：模板方法模式是一种代码复用技术，提取公共行为并放在父类中，通过子类实现不同的行为</li>
<li>实现反向控制：模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否执行</li>
<li>增加子类方便：模板方法模式中可通过子类覆盖父类的基本方法，不同子类可以提供基本方法的不同实现，更换以及增加新的子类很方便</li>
</ul>
<h1 id="5-主要缺点">5 主要缺点</h1>
<ul>
<li>子类数量多：模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
</ul>
<h1 id="6-适用场景">6 适用场景</h1>
<ul>
<li>对一些复杂算法进行分割，将其算法中固定不变的部分设计为模板方法和父类方法，而一些改变的细节由子类实现，也就是一次性实现算法中不变部分，并将可变部分交由子类实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>需要通过子类决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li>
</ul>
<h1 id="7-总结">7 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200805003325546.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-si-ce-lue-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（二十四）：策略模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
