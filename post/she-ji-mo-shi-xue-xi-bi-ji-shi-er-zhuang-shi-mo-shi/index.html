
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十二）：装饰模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi.jpeg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十二）：装饰模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-27</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E6%9E%84%E4%BB%B6%E7%B1%BB">2.2 抽象构件类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6%E7%B1%BB">2.3 具体构件类</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E8%A3%85%E9%A5%B0%E7%B1%BB">2.4 抽象装饰类</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E7%B1%BB">2.5 具体装饰类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E4%B8%8E%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0">4 透明装饰与半透明装饰</a>
<ul>
<li><a href="#41-%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">4.1 透明装饰模式</a></li>
<li><a href="#42-%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">4.2 半透明装饰模式</a></li>
</ul>
</li>
<li><a href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5 注意事项</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。比如，一张照片，不改变照片本身，增加一个相框。</p>
<p>装饰模式是一种用于替代继承的技术，无须定义子类即可给对象动态增加职责，使用对象之间的关联关系来代替继承关系，在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类方法，还可以增加新的方法，以扩充原有的类功能。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>装饰模式：动态地给对象增加一些额外的职责。</strong></p>
<p>就增加对象功能来说，装饰模式比生成子类实现更为灵活，装饰模式是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200726111630913.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong>Component（抽象构件类）：是具体构件以及抽象装饰类的父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰之后的对象，以实现客户端的透明操作</strong></li>
<li><strong>ConcreteComponent（具体构件类）：是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</strong></li>
<li><strong>Decorator（抽象装饰类）：用于给具体构件类增加职责，但是具体职责在子类实现。抽象装饰类维护一个指向抽象构件的引用，通过该引用可以调用装饰之前构件对象的方法，并通过子类扩展该方法以达到装饰的目的</strong></li>
<li><strong>ConcreteDecorator（具体装饰类）：负责向构件中添加新的职责，每一个具体装饰类都定义了一些新的行为，可以调用抽象装饰类中定义的方法，并可以增加新的职责用以扩充对象的行为</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象构件类：可以是抽象类或者接口，声明业务方法</li>
<li>定义具体构件类：继承或实现抽象构件，实现具体业务方法</li>
<li>定义抽象装饰类：继承或实现抽象构件，增加一个抽象构件私有成员，通过该成员可以调用装饰之前具体构件的方法</li>
<li>定义具体装饰类：继承抽象装饰类，并且增加装饰行为，在装饰之前调用具体构件方法，接着调用装饰方法</li>
</ul>
<h2 id="22-抽象构件类">2.2 抽象构件类</h2>
<p>简化只有一个业务方法：</p>
<pre><code class="language-java">abstract class Component
{
    abstract void operation();
}
</code></pre>
<h2 id="23-具体构件类">2.3 具体构件类</h2>
<p>继承抽象构件：</p>
<pre><code class="language-java">class ConcreteComponent extends Component
{
    public void operation()
    {
        System.out.println(&quot;具体构件方法&quot;);
    }
}
</code></pre>
<h2 id="24-抽象装饰类">2.4 抽象装饰类</h2>
<pre><code class="language-java">class Decorator extends Component
{
    private Component component;

    public Decorator(Component component)
    {
        this.component = component;
    }

    public void operation()
    {
        component.operation();
    }
}
</code></pre>
<p>抽象装饰类需要包含一个抽象构件的私有成员，以便可以通过setter或构造方法注入不同的具体构件，同时在业务方法中方便调用具体构件未装饰之前的方法。</p>
<h2 id="25-具体装饰类">2.5 具体装饰类</h2>
<pre><code class="language-java">class ConcreteDecorator extends Decorator
{
    public ConcreteDecorator(Component component)
    {
        super(component);
    }

    public void operation()
    {
        super.operation();
        newBehavior();
    }

    public void newBehavior()
    {
        System.out.println(&quot;装饰方法&quot;);
    }
}
</code></pre>
<p>继承抽象装饰类，在业务方法中首先调用父类（抽象装饰类）的方法再调用新的装饰方法。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Component component = new ConcreteComponent();
    Component decorator = new ConcreteDecorator(component);
    decorator.operation();
}
</code></pre>
<p>客户端针对抽象构件编程即可，无需指定具体装饰类或者具体构件类的类型，使用装饰器时，通过构造方法注入具体构件，直接调用业务方法即可。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个图形界面构件库，具体构件有窗体，文本框以及列表框，装饰方法包括添加滚动条与添加黑边框，使用装饰模式对系统进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象构件类：<code>Component</code></li>
<li>具体构件类：<code>Window</code>+<code>TextBox</code>+<code>ListBox</code></li>
<li>抽象装饰类：<code>Decorator</code></li>
<li>具体装饰类：<code>ScrollBarDecorator</code>+<code>BlackBorderDecorator</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Component component = new Window();
        Component decorator = new ScrollBarDecorator(component);
        decorator.display();
    }
}

abstract class Component
{
    abstract void display();
}

class Window extends Component
{
    public void display()
    {
        System.out.println(&quot;显示窗口&quot;);
    }
}

class TextBox extends Component
{
    public void display()
    {
        System.out.println(&quot;显示文本框&quot;);
    }
}

class ListBox extends Component
{
    public void display()
    {
        System.out.println(&quot;显示列表框&quot;);
    }
}

class Decorator extends Component
{
    private Component component;

    public Decorator(Component component)
    {
        this.component = component;
    }

    public void display()
    {
        component.display();
    }
}

class ScrollBarDecorator extends Decorator
{
    public ScrollBarDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        addScrollBar();
        super.display();
    }

    public void addScrollBar()
    {
        System.out.println(&quot;添加滚动条&quot;);
    }
}

class BlackBorderDecorator extends Decorator
{
    public BlackBorderDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        addBlackBorder();
        super.display();
    }

    public void addBlackBorder()
    {
        System.out.println(&quot;添加黑边框&quot;);
    }
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200726114715991.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>核心部分就是客户端的代码：</p>
<pre><code class="language-java">Component component = new Window();
Component decorator = new ScrollBarDecorator(component);
decorator.display();
</code></pre>
<p>创建具体构件后，再创建具体装饰器，把具体构件传入具体装饰器的构造方法中，这样具体装饰器就能在装饰之后（在添加滚动条之后）调用具体构件的方法（调用显示窗口）。</p>
<p>另外，如果向增加新的装饰方法，比如增加了滚动条后，再增加黑边框，只需要将”滚动条装饰器“本身再装饰一次：</p>
<pre><code class="language-java">Component component = new Window();
Component decorator = new ScrollBarDecorator(component);
decorator = new BlackBorderDecorator(decorator);
decorator.display();
</code></pre>
<p><strong>也就是把已经对具体构件进行装饰之后的具体装饰器，注入到另一个具体装饰器的构造方法再一次装饰。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200726115214121.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-透明装饰与半透明装饰">4 透明装饰与半透明装饰</h1>
<h2 id="41-透明装饰模式">4.1 透明装饰模式</h2>
<p>标准的装饰模式就是透明装饰，比如上述例子。在透明装饰模式中，要求客户端完全针对抽象构件编程，也就是将对象全部声明为抽象构件类型，而不是具体构件类型或具体装饰器类型。</p>
<p>透明装饰模式的优点如下：</p>
<ul>
<li>客户端透明地使用装饰前以及装饰后的对象，无须关心两者区别</li>
<li>能对已装饰过的对象进行多次装饰</li>
</ul>
<p>在实现透明装饰模式时，要求具体装饰类的业务方法覆盖抽象装饰类的业务方法，需要调用原有具体构件对象的业务方法以及新增装饰方法。</p>
<h2 id="42-半透明装饰模式">4.2 半透明装饰模式</h2>
<p>对于有时用户需要单独调用装饰方法，这时候需要使用具体装饰类型定义装饰后的对象，而具体构件对象还是可以使用抽象构件定义，这种装饰模式就叫半透明装饰模式。对于客户端来说：</p>
<ul>
<li>具体构件类型无需关心，是透明的</li>
<li>具体装饰类型必须指定，是不透明的</li>
</ul>
<p>例子如下，修改上面的滚动条具体装饰类：</p>
<pre><code class="language-java">class ScrollBarDecorator extends Decorator
{
    public ScrollBarDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        super.display();
    }

    public void addScrollBar()
    {
        System.out.println(&quot;添加滚动条&quot;);
    }
}
</code></pre>
<p>其中<code>addScrollBar</code>由客户端单独调用：</p>
<pre><code class="language-java">Component component = new Window();
ScrollBarDecorator decorator = new ScrollBarDecorator(component);
decorator.display();
decorator.addScrollBar();
</code></pre>
<p>半透明装饰可以带来更大的灵活性，使用起来更加方便，客户端可以单独调用装饰方法来进行装饰，但是缺点就是不能对同一个对象进行多次装饰。</p>
<h1 id="5-注意事项">5 注意事项</h1>
<ul>
<li>保持接口相同：尽量保持装饰类的接口与被装饰类的接口相同，这样对客户端而言装饰前/后的对象可以一致对待，也就是尽量使用透明装饰模式</li>
<li>减少具体构件行为：过多的行为不需要放在具体构件类中，通过具体装饰类进行扩展</li>
<li>去除抽象构件：如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类，也就是说将原来的抽象构件用具体构件代替</li>
</ul>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>动态扩展灵活：对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。通过选择不同的具体装饰类，可以动态扩展对象的行为</li>
<li>多次装饰：可以对一个对象进行多次装饰，使用不同的具体装饰类以及这些装饰类的排列组合，可以创造很多不同行为的组合</li>
<li>构件与装饰类独立变化：具体构件类以及具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类或者具体装饰类，无须修改原有代码，符合开闭原则</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>对象较多：使用装饰模式会产生很多小对象，这些对象的区别在于相互连接方式的不同，小对象过多会一定程度上影响性能</li>
<li>排查繁琐：尽管装饰模式比继承更加灵活，但也意味着比继承更加容易出错，排错也很困难，对于多次装饰后的对象可能需要逐级排查</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>在不影响其他对象的情况下，以动态和透明的方式给单个对象增加职责</li>
<li>在不能采用继承扩展系统或者采用继承不利于对系统扩展和维护时可以使用装饰模式</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200729132833584.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-yi-zu-he-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（十一）：组合模式
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
