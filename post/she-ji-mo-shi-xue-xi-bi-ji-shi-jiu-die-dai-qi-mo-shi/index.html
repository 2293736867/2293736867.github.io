
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十九）：迭代器模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi.jpg')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十九）：迭代器模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-08-02</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8">2.2 抽象迭代器</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%81%9A%E5%90%88%E7%B1%BB">2.3 抽象聚合类</a></li>
<li><a href="#24-%E5%85%B7%E4%BD%93%E8%81%9A%E5%90%88%E7%B1%BB">2.4 具体聚合类</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E8%BF%AD%E4%BB%A3%E5%99%A8">2.5 具体迭代器</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0">4 内部类实现</a></li>
<li><a href="#5-jdk%E8%BF%AD%E4%BB%A3%E5%99%A8">5 JDK迭代器</a>
<ul>
<li><a href="#51-iterator">5.1 <code>Iterator</code></a></li>
<li><a href="#52-listiterator">5.2 <code>ListIterator</code></a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在软件开发中，有一些类可以存储多个成员对象（元素），这些类通常称为聚合类，对应的对象称为聚合对象。聚合对象拥有两个职责，一个是存储数据，一个是遍历数据，前者是聚合对象的基本职责，后者是可以变化以及分离的，因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，又迭代器来提供遍历聚合对象内部数据的行为。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>迭代器模式：提供一种方法来访问对象，而不用暴露这个对象的内部表示，别名叫游标。</strong></p>
<p>迭代器模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801013759371.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Iterator</code>（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，比如<code>first</code>（获取第一个元素），<code>next</code>（获取下一个元素），<code>hasNext</code>（判断是否有下一个元素），<code>currentItem</code>（获取当前元素）</strong></li>
<li><strong><code>ConcreteIterator</code>（具体迭代器）：实现了抽象迭代器，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录聚合对象中所处的当前位置，通常游标是一个非负整数</strong></li>
<li><strong><code>Aggregate</code>（抽象聚合类）：用于存储和管理元素对象，声明一个<code>createIterator</code>方法创建一个迭代器对象，充当抽象迭代器的工厂角色</strong></li>
<li><strong><code>ConcreteAggregate</code>（具体聚合类）：实现了抽象聚合类中的<code>createIterator</code>方法，返回一个具体迭代器实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象迭代器：一般为接口，声明具体迭代器的方法</li>
<li>定义抽象聚合类：一般为接口，包含管理聚合元素的方法以及创建抽象迭代器的方法</li>
<li>定义具体聚合类：内部创建集合存储聚合元素，在创建迭代器方法中将集合作为构造方法参数注入到具体迭代器中并返回该具体迭代器</li>
<li>定义具体迭代器类：实现抽象迭代器的方法，一般包含一个来自具体聚合类的集合引用以及一个表示元素位置的整型的游标</li>
</ul>
<h2 id="22-抽象迭代器">2.2 抽象迭代器</h2>
<pre><code class="language-java">interface Iterator
{
    String first();
    String next();
    boolean hasNext();
    String currentItem();
}
</code></pre>
<h2 id="23-抽象聚合类">2.3 抽象聚合类</h2>
<pre><code class="language-java">interface Aggregate
{
    Iterator createIterator();
    void add(String s);
}
</code></pre>
<p>创建迭代器通过<code>createIterator</code>，<code>add</code>用于增添元素。</p>
<h2 id="24-具体聚合类">2.4 具体聚合类</h2>
<pre><code class="language-java">class ConcreteAggregate implements Aggregate
{
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator createIterator()
    {
        return new ConcreteIterator(list);
    }
    @Override
    public void add(String s)
    {
        list.add(s);
    }
}
</code></pre>
<p>在创建迭代器方法中，通过构造方法把集合对象注入到具体迭代器中。</p>
<h2 id="25-具体迭代器">2.5 具体迭代器</h2>
<pre><code class="language-java">class ConcreteIterator implements Iterator
{
    private int cursor;
    private List&lt;String&gt; list;
    public ConcreteIterator(List&lt;String&gt; list)
    {
        this.list = list;
        this.cursor = -1;
    }

    @Override
    public String first()
    {
        return list.size() &gt; 0 ?
        list.get(cursor = 0) :
        null;
    }

    @Override
    public String next()
    {
        return list.get(
            cursor + 1 &lt; list.size() ? ++cursor : cursor
        );
    }

    @Override
    public boolean hasNext()
    {
        return cursor+1 &lt; list.size();
    }

    @Override
    public String currentItem()
    {
        return list.get(cursor);
    }
}
</code></pre>
<p>具体迭代器中包含了一个游标，用于记录当前访问的位置。构造方法中将游标初始化为-1而不是初始化为0，这样第一次使用<code>next</code>时便会访问第一个元素。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Aggregate aggregate = new ConcreteAggregate();
    aggregate.add(&quot;111&quot;);
    aggregate.add(&quot;222&quot;);
    aggregate.add(&quot;jksdfjksdjkfk&quot;);
    aggregate.add(&quot;m,xcvm,xcm,v&quot;);
    Iterator iterator = aggregate.createIterator();
    while(iterator.hasNext())
    {
        System.out.println(iterator.next());
    }
}
</code></pre>
<p>客户端针对抽象聚合类以及抽象迭代器编程，通过聚合对象创建迭代器后，首先使用<code>haxNext</code>判断，接着使用<code>next</code>获取其中元素。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个系统对客户数据以及商品数据进行遍历，使用迭代器模式进行设计。</p>
</blockquote>
<p>这个例子和上面的其实差不多，不过是反向迭代器方法，另外为了更贴近实际环境使用，抽象迭代器以及聚合类都使用了泛型设计：</p>
<ul>
<li>抽象迭代器：<code>Iterator&lt;T&gt;</code></li>
<li>抽象聚合类：<code>AbstarctList&lt;T&gt;</code></li>
<li>具体聚合类：<code>ObjectList&lt;T&gt;</code></li>
<li>具体迭代器：<code>ObjectIterator&lt;T&gt;</code></li>
<li>模拟产品以及顾客类：<code>Product</code>+<code>Customer</code></li>
</ul>
<p>首先设计抽象迭代器：</p>
<pre><code class="language-java">interface Iterator&lt;T&gt;
{
    T next();
    boolean hasNext();
    String nextName() throws UnsupportedOperationException;
    boolean hasNextName() throws UnsupportedOperationException;
    void setProduct();
}
</code></pre>
<p><code>nextName()</code>以及<code>hasNextName()</code>方法是对<code>Customer</code>类型生效的，对于<code>Product</code>会抛出异常。<code>setProduct()</code>表示设置聚合元素的类型为<code>Product</code>。</p>
<p>接着是抽象聚合类的设计：</p>
<pre><code class="language-java">interface AbstractList&lt;T&gt;
{
    Iterator&lt;T&gt; iterator();
    Iterator&lt;T&gt; reversedIterator();
    void add(T s);
}
</code></pre>
<p>添加了一个反向迭代器实现。</p>
<p>然后是具体聚合类的设计：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator&lt;T&gt;(list,false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator&lt;T&gt;(list,true);
    }
}
</code></pre>
<p>内部还有一个<code>List</code>存储聚合元素，<code>iterator</code>返回正向迭代器，构造方法里面的布尔值表示是否为反向迭代器，<code>reversedIterator</code>表示返回一个单向迭代器，与正向的唯一不同就是传入具体迭代器的构造方法中的布尔值。<code>true</code>表示是反向迭代器，否则是正向。</p>
<p>最后是具体迭代器类：</p>
<pre><code class="language-java">class ObjectIterator&lt;T&gt; implements Iterator&lt;T&gt;
{
    private int cursor;
    private List&lt;T&gt; list;
    private boolean reversed;
    private boolean isProduct = false;
    public ObjectIterator(List&lt;T&gt; list,boolean reversed)
    {
        this.list = list;
        this.reversed = reversed;
        this.cursor = (reversed ? list.size() : -1);
    }

    @Override
    public void setProduct()
    {
        isProduct = true;
    }

    @Override
    public T next()
    {
        return list.get(
            reversed ? 
            ( cursor - 1 &gt;= 0 ? --cursor : cursor ) :
            ( cursor + 1 &lt; list.size() ? ++cursor : cursor )
        );
    }

    @Override
    public boolean hasNext()
    {
        return reversed ?
        cursor-1 &gt;= 0 :
        cursor+1 &lt; list.size();
    }

    @Override
    public String nextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return ((Customer)next()).getName();
    }

    @Override
    public boolean hasNextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return hasNext();
    }
}
</code></pre>
<p>构造方法中初始化聚合元素以及一个布尔值<code>reversed</code>，表示是否为反向迭代器，游标根据<code>reversed</code>设置为<code>-1</code>或<code>list.size()</code>。对于<code>next</code>以及<code>hasNext</code>方法，都需要判断是否为反向迭代器，返回对应的结果。对于<code>nextName</code>以及<code>hasNextName</code>，由于这两个方法仅对<code>Customer</code>类生效，因此如果是<code>Product</code>类直接抛出异常。</p>
<p>其他：</p>
<pre><code class="language-java">class Product
{
    private String id;
    private int num;

    public Product(){}

    public Product(String id,int num) {
        this.id = id;
        this.num = num;
    }

    public String getId() {
        return this.id;
    }

    public int getNum() {
        return this.num;
    }

    @Override
    public String toString()
    {
        return &quot;商品id:&quot;+id+&quot;\t商品数量:&quot;+num;
    }
}

class Customer
{
    private String id;
    private String name;

    public Customer(String id,String name)
    {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    @Override
    public String toString()
    {
        return &quot;顾客id:&quot;+id+&quot;\t顾客名字:&quot;+name;
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Customer customer1 = new Customer(&quot;id1&quot;,&quot;name1&quot;);
    Customer customer2 = new Customer(&quot;id2&quot;,&quot;name2&quot;);
    Customer customer3 = new Customer(&quot;id3&quot;,&quot;name3&quot;);
    AbstractList&lt;Customer&gt; customerList = new ObjectList&lt;&gt;();
    customerList.add(customer1);
    customerList.add(customer2);
    customerList.add(customer3);

    Iterator&lt;Customer&gt; customerIterator = customerList.iterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    System.out.println();

    customerIterator = customerList.iterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    System.out.println();
        
    Product product1 = new Product(&quot;product id 1&quot;,1);
    Product product2 = new Product(&quot;product id 2&quot;,2);
    Product product3 = new Product(&quot;product id 3&quot;,3);
    AbstractList&lt;Product&gt; productList = new ObjectList&lt;&gt;();
    productList.add(product1);
    productList.add(product2);
    productList.add(product3);

    Iterator&lt;Product&gt; productIterator = productList.iterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    productIterator = productList.reversedIterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    System.out.println();
    try
    {
        productIterator = productList.iterator();
        productIterator.setProduct();
        while(productIterator.hasNextName())
            System.out.println(productIterator.nextName());
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}
</code></pre>
<p>首先创建了三个<code>Customer</code>，接着添加到<code>customerList</code>中，从<code>customerList</code>中的<code>iterator</code>获取正向迭代器以及从<code>reversedIterator</code>获取正向迭代器，两种遍历方式的迭代器可以使用同样的语句实现遍历：</p>
<pre><code class="language-java">while(customerIterator.hasNext())
	System.out.println(customerIterator.next());
</code></pre>
<p>对于<code>Product</code>，由于<code>hasNextName</code>以及<code>nextName</code>声明了抛出异常，因此测试输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801135447573.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-内部类实现">4 内部类实现</h1>
<p>上面的例子可以看到在具体聚合类以及具体迭代器之间存在关联关系，具体迭代器需要维持一个对具体聚合对象（或里面的集合）的引用，除了使用关联关系外，还可以将迭代器设计为聚合类的内部类，比如JDK中的<code>AbstractList</code>：</p>
<pre><code class="language-java">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {
	//...
	private class Itr implements Iterator&lt;E&gt; {
		//...
	}
	//...
}
</code></pre>
<p>使用类似的方式重新设计上面的例子：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator(false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator(true);
    }

    private class ObjectIterator implements Iterator&lt;T&gt;
    {
        private int cursor;
        private boolean reversed;
        private boolean isProduct = false;
        public ObjectIterator(boolean reversed)
        {
            this.reversed = reversed;
            this.cursor = (reversed ? list.size() : -1);
        }
        //...
    }
}
</code></pre>
<p>改变的就是具体迭代器的构造方法，不需要注入聚合对象了，另外也取消了泛型的声明。</p>
<h1 id="5-jdk迭代器">5 JDK迭代器</h1>
<h2 id="51-iterator">5.1 <code>Iterator</code></h2>
<p>JDK（OpenJDK11.0.2）中的<code>Collection</code>方法摘录如下：</p>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
	//...
	Iterator&lt;E&gt; iterator();
	//...
}
</code></pre>
<p>该方法用于返回一个迭代器，以便遍历聚合类中的元素，其中<code>Iterator</code>定于如下：</p>
<pre><code class="language-java">public interface Iterator&lt;E&gt; {
	boolean hasNext();
	E next();
	default void remove() {
		//...
	}
	default void forEachRemaining(Consumer&lt;? super E&gt; action) {
		//...
	}
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>hasNext</code>：用于判断聚合对象是否存在下一个元素，需要在调用<code>next</code>之前调用</li>
<li><code>next</code>：将下标移至下一个元素，并返回游标所越过的那个元素的引用，也就是获取下一个元素</li>
<li><code>remove</code>：删除上一次<code>next</code>的返回的元素</li>
<li><code>forEachRemaining</code>：用于对剩余元素进行的操作，比如一个集合有10个元素，使用迭代器遍历了前5个，则使用该方法会遍历剩下的元素，也就是后5个</li>
</ul>
<p>Java迭代器原理如图：<br>
<img src="https://img-blog.csdnimg.cn/2020080115523623.png" alt="在这里插入图片描述" loading="lazy"><br>
第一个<code>next</code>被调用时，迭代器游标由0号位置移到1号位置，也就是移动到元素1以及元素2之间，接着返回游标越过的元素，也就是元素1。下一次调用<code>next</code>时，游标继续移动，从1号位置移动到2号位置，并返回越过的元素，也就是元素2。对于<code>remove</code>来说，删除上一次<code>next</code>返回的元素，也就是如果此时调用<code>remove</code>会删除元素2。</p>
<p>也就是在调用<code>remove</code>之前至少需要调用一次<code>next</code>，如果不调用<code>next</code>的话，会抛出异常：<br>
<img src="https://img-blog.csdnimg.cn/20200801155359430.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-listiterator">5.2 <code>ListIterator</code></h2>
<p>JDK中的<code>List</code>接口除了继承<code>Collection</code>接口的<code>iterator</code>外，还增加一个<code>listIterator</code>，专门用于创建<code>ListIterator</code>类型的迭代器。用于遍历集合已经有了<code>Iterator</code>，但是这个迭代器只能用于正向遍历，而<code>ListIterator</code>的出现能解决逆向遍历的问题，因为其中提供了<code>hasPrevious</code>以及<code>previous</code>等方法。例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;String&gt; s = new ArrayList&lt;&gt;();
    s.add(&quot;1111&quot;);
    s.add(&quot;2222&quot;);
    s.add(&quot;3333&quot;);
    ListIterator&lt;String&gt; it = s.listIterator();
    while(it.hasNext())
        System.out.println(it.next());
    System.out.println();
    while(it.hasPrevious())
        System.out.println(it.previous());
}
</code></pre>
<p>实现完整的逆向遍历时，需要先将游标移动到末尾，也就是不断调用<code>next</code>直到末尾，才能实现调用<code>previous</code>进行逆向遍历。</p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>多种遍历方式：支持以不同方式遍历聚合对象，在同一聚合对象上可以定义多种遍历方法，只需要用一个不同的聚合器替换原来的迭代器即可改变遍历算法</li>
<li>简化聚合类：原有的聚合对象不需要再自行提供数据遍历方法</li>
<li>满足OCP：由于引入了抽象层，增加新的聚合类以及迭代器类都很方便，无须修改源码</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>复杂度增加：迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，增加了复杂性</li>
<li>抽象迭代器较难设计：考虑到以后的扩展，抽象迭代器的设计难度可能非常大，比如JDK的内置迭代器<code>Iterator</code>就无法实现逆向遍历，设计一个考虑全面的抽象迭代器并不是一件容易的事</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据存储分离，使得访问聚合对象时无须了解内部实现细节</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020080116201951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（十八）：解释器模式
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
