
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Java实现操作系统中四种动态内存分配算法：BF+NF+WF+FF | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/java-shi-xian-cao-zuo-xi-tong-zhong-si-chong-dong-tai-nei-cun-fen-pei-suan-fa-bfnfwfff.jpg')">
            </div>
          
          <h2 class="post-title">Java实现操作系统中四种动态内存分配算法：BF+NF+WF+FF</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-11-21</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/-AktfIpz8/">
                    Java
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h1 id="1-概述">1 概述</h1>
<p>本文是利用<code>Java</code>实现操作系统中的四种动态内存分配方式 ，分别是：</p>
<ul>
<li><code>BF</code></li>
<li><code>NF</code></li>
<li><code>WF</code></li>
<li><code>FF</code></li>
</ul>
<p>分两部分，第一部分是介绍四种分配方式的概念以及例子，第二部分是代码实现以及讲解。</p>
<h1 id="2-四种分配方式">2 四种分配方式</h1>
<h2 id="21-概念">2.1 概念</h2>
<p>操作系统中有一个动态分区分配的概念，内存在初始化的时候不会划分区域，而是在进程装入的时候，根据所要装入的进程动态地对内存空间进行划分，以提高内存空间的利用率，降低碎片的大小，主要的方法有一下四种：</p>
<ul>
<li>首次适应算法（<code>First Fit</code>）：从空闲分区链首开始查找，直到找到一个满足其大小要求的空闲分区为止</li>
<li>循环首次适应算法（<code>Next Fit</code>）：从上次找到的空闲分区的下一个开始查找</li>
<li>最佳适应算法（<code>Best Fit</code>）：把空闲分区按大小递增的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
<li>最坏适应算法（<code>Worst Fit</code>）：与最佳适应算法相反，把空闲分区按大小递减的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
</ul>
<h2 id="22-例子">2.2 例子</h2>
<p>假设现在有<code>100MB</code>的内存空间，某一时刻先后分配了<code>20MB</code>、<code>4MB</code>、<code>10MB</code>内存，示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201121154826958.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>现在需要再分配<code>5MB</code>内存。</p>
<p>若采用<code>FF</code>，因为<code>FF</code>是直接按顺序分配内存，从低地址开始搜索空闲分区，因此便会从第一块空闲分区分配<code>5MB</code>（地址<code>0-5</code>），示意图：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020112115543974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>NF</code>，<code>NF</code>与<code>FF</code>类似，只不过<code>NF</code>是从上一次找到的空闲分区的下一块开始查找，因为上一次分配的是<code>10MB</code>，因此会从最后一块空闲分区（地址<code>80-100</code>）分配内存：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201121155703771.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>BF</code>，<code>BF</code>是遍历所有空闲分区并找到一个能满足要求的最小分区，也就会找到一个比<code>5MB</code>大的空闲分区，且该空闲分区是所有空闲分区中最小的，也就是地址为<code>64-70</code>的空闲分区：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201121155908288.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>WF</code>，<code>WF</code>与<code>BF</code>相反，总是从最大的空闲分区开始分配，因此会从地址为<code>30-60</code>的空闲分区进行分配：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201121160047113.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-代码实现">3 代码实现</h1>
<h2 id="31-总览">3.1 总览</h2>
<p>代码分成了四个类：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2020112116032076.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>Main</code>：测试</li>
<li><code>Print</code>：输出打印</li>
<li><code>Table</code>：表示每一个分区</li>
<li><code>TableList</code>：对分区进行控制，包括初始化，分配，回收等</li>
</ul>
<h2 id="32-main">3.2 <code>Main</code></h2>
<p><code>Main</code>是测试类，代码如下：</p>
<pre><code class="language-java">public class Main {

    private final static TableList list = new TableList(64);

    public static void main(String[] args) {
        list.useWF();
//        list.useBF();
//        list.useNF();
//        list.useFF();

        list.allocate(10);
        list.allocate(20);
        list.free(10);
        list.show();
        list.allocate(8);
        list.show();
        list.allocate(13);
        list.allocate(1);
        list.show();
        list.free(1);
        list.allocate(9);
        list.free(13);
        list.show();
        list.allocate(18);
        list.show();
        list.allocate(3);
        list.allocate(4);
        list.free(20);
        list.free(8);
        list.show();
        list.allocate(8);
        list.free(9);
        list.show();
        list.clear();
        list.show();
    }
}
</code></pre>
<p>通过<code>TableList</code>对内存进行分配以及释放，初始化分配<code>64MB</code>大小内存，切换分配算法时使用前四行的其中一行即可。</p>
<h2 id="33-table">3.3 <code>Table</code></h2>
<p><code>Table</code>类表示每一个分区，无论是空闲的还是已分配的，成员变量有四个，分别是：</p>
<ul>
<li>起始地址</li>
<li>大小</li>
<li>是否空闲（只有两种状态，空闲或分配）</li>
<li>是否是上一次分配（<code>NF</code>专用）</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">@AllArgsConstructor
public class Table {
    @Getter
    @Setter
    private int address;
    @Setter
    @Getter
    private int size;
    private boolean free;
    @Getter
    @Setter
    private boolean lastAllocated;

    public static Table freeTable(int address,int size)
    {
        return new Table(address,size,true,false);
    }

    public static Table allocatedTable(int address,int size)
    {
        return new Table(address,size,false,false);
    }

    public boolean isFree()
    {
        return free;
    }

    public boolean isAllocated()
    {
        return !isFree();
    }

    public void setFree()
    {
        free = true;
    }
}
</code></pre>
<p>只有一些<code>Getter</code>和<code>Setter</code>，为了方便提供了一个创建空闲分区或已分配分区的静态方法，指定起始地址和大小即可。</p>
<h2 id="34-tablelist">3.4 <code>TableList</code></h2>
<p><code>TableList</code>是整个算法的核心类，成员变量如下：</p>
<pre><code class="language-java">private final List&lt;Table&gt; list = new ArrayList&lt;&gt;();
private final int totalSize;
private boolean ff = false;
private boolean nf = false;
private boolean bf = false;
private boolean wf = false;
private boolean first = true;
private final static Print print = new Print();
</code></pre>
<p><code>list</code>就是所有的空闲分区与已分配分区组成的数组，<code>totalSize</code>是总大小，接着是四个控制算法的布尔变量，<code>first</code>表示是否是第一次分配内存，因为第一次的话四种算法都是固定的从地址为<code>0</code>处开始分配。</p>
<p>接下来就是内存分配算法以及释放算法。</p>
<h3 id="341-ff">3.4.1 <code>FF</code></h3>
<pre><code class="language-java">if (ff)
{
    for (int i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.add(i,allocated);
            return;
        }
    }
}
</code></pre>
<p><code>FF</code>的实现还是比较简单的，直接遍历列表，如果是空闲分区并满足大小要求，直接进行分配，修改空闲分区的起始地址和大小并插入一个新的已分配分区到列表中即可。</p>
<h3 id="342-nf">3.4.2 <code>NF</code></h3>
<pre><code class="language-java">else if (nf)
{
    int lastNFIndex = findLastAllocated();
    int i = lastNFIndex;
    do
    {
        if(i == list.size())
            i = 0;
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.get(lastNFIndex).setLastAllocated(false);
            table.setLastAllocated(true);
            list.add(i,allocated);
            return;
        }
        ++i;
    }
    while (i != lastNFIndex);
}
</code></pre>
<p><code>NF</code>的话需要提前记录上一次分配的位置，通过<code>Table</code>中的<code>lastAllocated</code>确定上一次分配的位置，找到后从该位置开始遍历列表，注意需要进行绕回处理，因为到末尾位置后有可能还没有能满足的空闲分区，此时需要将下标绕回到<code>0</code>并再次遍历直到到达上一次分配的位置。</p>
<h3 id="343-bfwf">3.4.3 <code>BF</code>+<code>WF</code></h3>
<p>由于<code>BF</code>与<code>WF</code>都需要遍历所有的空闲分区，只是前者是选择最小满足要求的，后者是选择最大满足要求的，因此两者的实现差别在于一个判断大小的符号，代码如下：</p>
<pre><code class="language-java">else
{
    int i;
    int target = -1;
    for (i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree())
        {
            if(table.getSize() &gt;= size)
            {
                if(target == -1)
                    target = i;
                else
                {
                    if(bf)
                    {
                        if(list.get(target).getSize() &gt; table.getSize())
                            target = i;
                    }
                    else
                    {
                        if(list.get(target).getSize() &lt; table.getSize())
                            target = i;
                    }
                }
            }
        }
    }
    if(target != -1)
    {
        Table table = list.get(target);
        int address = table.getAddress();
        table.setAddress(address+size);
        table.setSize(table.getSize()-size);
        list.add(target,Table.allocatedTable(address,size));
        return;
    }
}
</code></pre>
<p>首先遍历找到符合条件的空闲分区的下标，接着通过判断<code>target</code>，也就是目标空闲分区的下标，如果为<code>-1</code>表示没有找到符合条件的空闲分区，如果不为<code>-1</code>直接分配空间。</p>
<h3 id="344-释放算法">3.4.4 释放算法</h3>
<p>释放算法的设计是比较复杂的，代码如下：</p>
<pre><code class="language-java">public void free(int size)
{
    int index = 0;
    while(index &lt; list.size())
    {
        if(list.get(index).isAllocated() &amp;&amp; list.get(index).getSize() == size)
            break;
        ++index;
    }
    if(index &gt;= list.size())
    {
        print.freeFailed(size);
        return;
    }
    int address = list.get(index).getAddress();
    if(index == 0)
    {
        list.get(0).setFree();
        if(index+1 &lt; list.size())
        {
            Table nextTable = list.get(index+1);
            if(nextTable.isFree())
            {
                list.get(0).setSize(nextTable.getSize()+size);
                list.remove(index+1);
            }
        }
    }
    else if(index == list.size()-1)
    {
        list.get(index).setFree();
        Table lastTable = list.get(index-1);
        if(lastTable.isFree())
        {
            lastTable.setSize(lastTable.getSize()+size);
            list.remove(index);
        }
    }
    else
    {
        Table before = list.get(index-1);
        Table after = list.get(index+1);

        if(before.isFree() &amp;&amp; after.isFree())
        {
            before.setSize(before.getSize()+size+after.getSize());
            list.remove(index+1);
            list.remove(index);
        }
        else if(before.isFree() &amp;&amp; after.isAllocated())
        {
            before.setSize(before.getSize()+size);
            list.remove(index);
        }
        else if(before.isAllocated() &amp;&amp; after.isFree())
        {
            after.setSize(after.getSize()+size);
            after.setAddress(address);
            list.remove(index);
        }
        else
        {
            list.get(index).setFree();
        }
    }
}
</code></pre>
<p>主要考虑了六种情况（黄色代表需要释放的空间，橙色是已分配的内存空间）：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201121170701544.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>第一种情况就是需要释放首部的分区，此时需要修改后面空闲分区的起始地址和大小，并删除目标分区</li>
<li>第二种情况是释放尾部的分区，此时需要修改前面空闲分区的大小即可，无需修改起始地址，并删除目标分区</li>
<li>第三种情况是后面是已分配的分区，前面的空闲分区，需要修改前面空闲分区的大小，并删除目标分区</li>
<li>第四种情况是前面是已分配的分区，后面是空闲分区，需要修改后面的空闲分区的起始地址以及大小，并删除目标分区</li>
<li>第五种情况是前后都是已分配的分区，此时只需要修改目标分区的标志为空闲即可，无需额外操作</li>
<li>第六种情况是前后都是空闲分区，这种情况下需要进行连接操作，具体来说就是先修改前面空闲分区的大小，接着删除目标分区以及后面的空闲分区</li>
</ul>
<p>下面回到代码，首先是判断第一种情况：</p>
<pre><code class="language-java">if(index == 0)
{
    list.get(0).setFree();
    if(index+1 &lt; list.size())
    {
        Table nextTable = list.get(index+1);
        if(nextTable.isFree())
        {
            list.get(0).setSize(nextTable.getSize()+size);
            list.remove(index+1);
        }
    }
}
</code></pre>
<p>也就是需要释放首部的分区，通过<code>setFree()</code>设置标志位表示空闲状态，接着判断是否需要修改后面空闲分区的大小，因为有可能后面是一个已分配的分区而不是空闲分区。</p>
<pre><code class="language-java">else if(index == list.size()-1)
{
    list.get(index).setFree();
    Table lastTable = list.get(index-1);
    if(lastTable.isFree())
    {
        lastTable.setSize(lastTable.getSize()+size);
        list.remove(index);
    }
}
</code></pre>
<p>这里是判断第二种情况，也就是释放尾部的分区，同样需要判断前一个分区是已分配的分区还是空闲的分区，是空闲分区的话修改大小并移除目标分区。</p>
<pre><code class="language-java">else
{
    Table before = list.get(index-1);
    Table after = list.get(index+1);

    if(before.isFree() &amp;&amp; after.isFree())
    {
        before.setSize(before.getSize()+size+after.getSize());
        list.remove(index+1);
        list.remove(index);
    }
    else if(before.isFree() &amp;&amp; after.isAllocated())
    {
        before.setSize(before.getSize()+size);
        list.remove(index);
    }
    else if(before.isAllocated() &amp;&amp; after.isFree())
    {
        after.setSize(after.getSize()+size);
        after.setAddress(address);
        list.remove(index);
    }
    else
    {
        list.get(index).setFree();
    }
}
</code></pre>
<p>接下来是最后四种情况的判断，首先获取前一个以及后一个分区，接着按上面算法的思路进行判断即可。</p>
<h1 id="4-测试">4 测试</h1>
<p>以<code>WF</code>为例，默认大小<code>64MB</code>，测试顺序如下：</p>
<ul>
<li>分配<code>10MB</code></li>
<li>分配<code>20MB</code></li>
<li>释放<code>10MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>13MB</code></li>
<li>分配<code>1MB</code></li>
<li>打印结果</li>
<li>释放<code>1MB</code></li>
<li>分配<code>9MB</code></li>
<li>释放<code>13MB</code></li>
<li>打印结果</li>
<li>分配<code>18MB</code></li>
<li>打印结果</li>
<li>分配<code>3MB</code></li>
<li>分配<code>4MB</code></li>
<li>释放<code>20MB</code></li>
<li>释放<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>释放<code>9MB</code></li>
<li>打印结果</li>
<li>清空</li>
<li>打印结果</li>
</ul>
<p>输出：</p>
<pre><code class="language-java">Free           :      0-10MB
Allocated      :      10-30MB
Free           :      30-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Allocated      :      38-51MB
Allocated      :      51-52MB
Free           :      52-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Do nothing.
Allocated failed, out of memory
Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Free           :      4-38MB
Allocated      :      38-41MB
Free           :      41-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Allocated      :      4-12MB
Free           :      12-38MB
Allocated      :      38-41MB
Free           :      41-64MB

----------------------------------------------------------------

Free           :      0-64MB

----------------------------------------------------------------
</code></pre>
<p>读者可以自行画图验证。</p>
<h1 id="5-源码">5 源码</h1>
<ul>
<li><a href="https://github.com/2293736867/FourDynamicAllocatedAlgorithm">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/FourDynamicAllocatedAlgorithm">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/FourDynamicAllocatedAlgorithm">CODE.CHINA</a></li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/jie-jue-linux-wu-fa-du-xie-u-pan-zhong-de-ntfs-wen-ti/">
              <h3 class="post-title">
                下一篇：解决Linux无法读写U盘中的NTFS问题
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
