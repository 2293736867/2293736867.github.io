
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>设计模式学习笔记（十六）：职责链模式 | 氷泠&#39;s blog</title>
<meta name="description" content="我配不上你，
纵然很努力。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://2293736867.github.io/favicon.ico?v=1615370942909">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://2293736867.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://2293736867.github.io">
        <img class="avatar" src="https://2293736867.github.io/images/avatar.png?v=1615370942909" alt="" width="32px" height="32px">
      </a>
      <a href="https://2293736867.github.io">
        <h1 class="site-title">氷泠&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://2293736867.github.io/post-images/she-ji-mo-shi-xue-xi-bi-ji-shi-liu-zhi-ze-lian-mo-shi.png')">
            </div>
          
          <h2 class="post-title">设计模式学习笔记（十六）：职责链模式</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-07-31</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://2293736867.github.io/tag/Q0QnSl8as/">
                    设计模式
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%A4%84%E7%90%86%E8%80%85">2.2 抽象处理者</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%A4%84%E7%90%86%E8%80%85">2.3 具体处理者</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%88%86%E7%B1%BB">4 分类</a>
<ul>
<li><a href="#41-%E7%BA%AF%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">4.1 纯的职责链模式</a></li>
<li><a href="#42-%E4%B8%8D%E7%BA%AF%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">4.2 不纯的职责链模式</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>很多情况下，一个软件系统中可以处理某个请求的对象不知一个，比如采购单的审批，主任，副董事长，董事长，董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就叫职责链。</p>
<p>职责链可以是一条直线，一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行处理，客户端无须关系请求的处理细节以及具体的传递，只需要将请求发送到链上即可，实现请求发送者以及请求处理者的解耦。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>职责链模式：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</strong></p>
<p>职责链模式是一种行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200731111207364.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Handler</code>（抽象处理者）：定义一个处理请求的接口，一般为抽象类。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者的对象作为对下一个处理者的引用，通过该引用，处理者可以连成一条链</strong></li>
<li><strong><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，实现具体处理方法，在处理前需要判断是否具有处理权限，如果拥有权限则处理，没有则转发到下一个处理者</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象处理者：定义处理请求接口以及定义一个抽象处理者成员，作为下一个处理者的引用，一般为了让具体处理者方便调用，定义为<code>protected</code></li>
<li>定义具体处理者：处理/转发请求，处理请求前先判断是否具有权限 ，拥有则处理请求，否则转发请求</li>
<li>客户端创建职责链：职责链模式并不创建职责链，职责链交由客户端创建，根据实际需要定义职责链顺序</li>
</ul>
<h2 id="22-抽象处理者">2.2 抽象处理者</h2>
<pre><code class="language-java">abstract class Handler
{
    protected Handler successor;
    public void setSuccessor(Handler successor)
    {
        this.successor = successor;
    }

    public abstract void handleRequest(int num);
}
</code></pre>
<p>拥有一个设置下一处理者的对象，可以通过setter注入，同时声明抽象处理方法。</p>
<h2 id="23-具体处理者">2.3 具体处理者</h2>
<pre><code class="language-java">class ConcreteHandler1 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 10)
        {
            System.out.println(&quot;处理小于10的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}

class ConcreteHandler2 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 20)
        {
            System.out.println(&quot;处理大于等于10且小于20的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}

class ConcreteHandler3 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 30)
        {
            System.out.println(&quot;处理大于等于20且小于30的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}
</code></pre>
<p>继承抽象处理者，首先判断是否拥有权限处理（这里是一个简单的if判断），如果有就处理，没有的话通过<code>protected</code>对象，也就是转发给下一个处理者处理。</p>
<h2 id="24-客户端">2.4 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Handler handler = new ConcreteHandler1();
    Handler handler2 = new ConcreteHandler2();
    Handler handler3 = new ConcreteHandler3();
    handler.setSuccessor(handler2);
    handler2.setSuccessor(handler3);

    handler.handleRequest(3);
    handler.handleRequest(15);
    handler.handleRequest(22);
}
</code></pre>
<p>客户端针对抽象处理者编程，需要创建每一个具体处理者对象，并且自定义职责链：</p>
<pre><code class="language-java">handler.setSuccessor(handler2);
handler2.setSuccessor(handler3);
</code></pre>
<p>接着调用对应的处理者处理即可。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个采购单审批系统，分级进行，根据金额不同由不同层次的人员审批，主任可以审批5w以下的采购单，副董事长可以审批5w-10w，董事长可以审批10w-50w，50w以上需要由董事会审批，使用职责链模式设计该系统。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象处理者：<code>Approver</code></li>
<li>具体处理者：<code>Director</code>+<code>VicePresident</code>+<code>President</code>+<code>Congress</code></li>
<li>采购单请求类：<code>PurchaseRequest</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">//抽象处理者
abstract class Approver
{
    protected Approver successor;

    public void setSuccessor(Approver successor) {
        this.successor = successor;
    }

    public abstract void processRequest(PurchaseRequest request);
}

//具体处理者:主任
class Director extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 50000)
            System.out.println(&quot;主任审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:副董事长
class VicePresident extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 100000)
            System.out.println(&quot;副董事长审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:董事长
class President extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 500000)
            System.out.println(&quot;董事长审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:董事会
class Congress extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        System.out.println(&quot;董事会审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
    }
}

//请求类:采购单
class PurchaseRequest
{
    private double amount;
    private String id;
    private static final String STR = &quot;xcnvj232cvm&quot;;
    private static final Random random = new Random();

    public PurchaseRequest(double amount)
    {
        this.amount = amount;
        //简易的随机字符串
        this.id = STR.substring(0,random.nextInt(STR.length()-1)+1).repeat(random.nextInt(3)+2);
    }

    public double getAmount() {
        return this.amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Approver director = new Director();
    Approver vicePresident = new VicePresident();
    Approver president = new President();
    Approver congress = new Congress();

    director.setSuccessor(vicePresident);
    vicePresident.setSuccessor(president);
    president.setSuccessor(congress);

    director.processRequest(new PurchaseRequest(12345));
    director.processRequest(new PurchaseRequest(54321));
    director.processRequest(new PurchaseRequest(123456));
    director.processRequest(new PurchaseRequest(654321));
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200731134901882.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-分类">4 分类</h1>
<p>职责链模式可以分为纯的职责链模式与不纯的职责链模式。</p>
<h2 id="41-纯的职责链模式">4.1 纯的职责链模式</h2>
<p>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个，要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。</p>
<p>而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象接收，不能出现某个请求未被任何一个处理者对象处理的情况，比如前面的采购单例子。</p>
<h2 id="42-不纯的职责链模式">4.2 不纯的职责链模式</h2>
<p>在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其猴戏处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</p>
<p>在Java AWT 1.0中的事件处理模型应用就是不纯的职责链模式，基本原理如下：由于窗口组件一般位于容器组件中，当事件发生在窗口组件上时，先通过组件对象的<code>handleEvent()</code>方法传递给相应的事件处理方法，该事件处理方法将处理该事件，然后决定是否将该事件向上一级容器组件传播，上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，直到顶层容器组件为止。如果一直都没有处理方法则不处理该事件。</p>
<p>这种事件处理机制又叫事件浮升机制，JDK1.1后使用观察者模式来代理职责链模式处理事件。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>降低耦合：职责链模式使得一个对象无须知道是其他哪一个对象处理请求，对象仅需知道请求会被处理即可，接收者和发送者都没有对方明确信息，且链中对象不需要知道链的结构，由客户端负责链的创建，降低了系统耦合度</li>
<li>简化对象连接：请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有候选处理者的引用，可简化对象的相互连接</li>
<li>灵活的职责链：可以在运行时对链进行动态增加或者修改</li>
<li>符合OCP：系统增加一个新的具体处理者时无须修改源码，只需要客户端重建职责链，符合OCP</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>请求可能得不到处理：由于一个请求没有明确的接收者，因此请求不一定会被处理，也有可能因为职责链配置错误而得不到处理</li>
<li>性能受到影响：对于较长的职责链，请求的处理可能涉及多个处理对象，系统性能会受到一定影响，而且代码调试时可能不方便</li>
<li>死循环：如果职责链不当，可能会导致死循环调用</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理请求以及处理者之间的先后次序</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020073115020561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-wu-dai-li-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式学习笔记（十五）：代理模式
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">我配不上你，
纵然很努力。</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://2293736867.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '477bf133e6f4f92e3d3d',
        clientSecret: 'c917fc4292d22d69e98b9521ac1e6fca627fe54c',
        repo: '2293736867.github.io',
        owner: '2293736867',
        admin: ['2293736867'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
