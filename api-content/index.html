{"posts":[{"title":"后端spring boot+前端Android交互+mysql增删查改","content":" 1.概述 2.开发环境 3.后端 (1)新建一个spring boot项目 (2)Entity (3)Repository (4)Service (5)Controller 4.前端 (1)增 (2)删 (3)查 (4)改 (5)界面 (6)依赖与其他 (7)网络权限 5.测试 6.源码 1.概述 使用spring boot作为后端框架与Android端配合mysql进行基本的交互,包含了最基本的增删查改功能. 2.开发环境 win10 IDEA tomcat9.0.27 mysql8.0.17 spring boot 3.后端 (1)新建一个spring boot项目 可以看这里 (2)Entity 新建User类作为实体类: package com.test; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 这里其实使用的是(1)中的代码,里面有详细的解释. (3)Repository 新建UserRepository去实现增删查改: package com.test; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.query.Param; import org.springframework.stereotype.Repository; import org.springframework.web.bind.annotation.RequestParam; import java.util.List; @Repository public interface UserRepository extends CrudRepository&lt;User,Integer&gt; { @Query(value = &quot;select * from user where name = ?1&quot;,nativeQuery = true) public List&lt;User&gt; findByName(String name); @Modifying @Query(value = &quot;delete from user where name = ?1&quot;,nativeQuery = true) public int deleteByName(String name); } 由于CrudRepository中已经包含了&quot;增&quot;与&quot;改&quot;,所以按需要实现自己的&quot;查&quot;与&quot;删&quot;即可. CrudRepository的api很简单,官方文档在这里. &quot;增&quot;使用save即可,参数为实体类 &quot;删&quot;使用deleteById,通过主键删除,若不想通过主键删除可以自己编写sql,像上面一样 &quot;查&quot;使用findAll或findById,自定义查找的话需要自己编写sql. &quot;改&quot;也可使用save,注意需要设置主键. @Query用于设置sql,nativeQuery表示使用原生sql. (4)Service 新建一个MainService.java package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import javax.transaction.Transactional; import java.util.List; @Transactional @Service public class MainService { @Autowired private UserRepository userRepository; public Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } public List&lt;User&gt; findByName(String name) { return userRepository.findByName(name); } public boolean add(String name) { User user = new User(); user.setName(name); userRepository.save(user); return true; } public boolean modify(Integer id,String name) { User user = new User(); user.setName(name); user.setId(id); userRepository.save(user); return true; } public boolean deleteByName(String name) { return userRepository.deleteByName(name) != 0; } } getAllUsers()返回所有行,Iterable&lt;E&gt;类型 findByName()根据name返回所有name相同的行. add直接使用了save,由于save返回的是实体类,原本的代码是这样写的: return userRepository.save(user) != null; 但是文档说了不会为null,所以只能强制返回true了. modify使用了id与name作为参数,新建一个user,将其作为setter的参数,然后交给save. deleteByName使用了自定义的删除函数,返回的是int,在UserRepository中这个int代表sql影响的行数,删除成功则行数不为0,删除失败,或者没有这行数据则行数为0.因此将返回值与0进行比较. (5)Controller package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.List; @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private MainService mainService; @GetMapping(path = &quot;/getAll&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return mainService.getAllUsers(); } @PostMapping(path = &quot;/get&quot;) public @ResponseBody List&lt;User&gt; findByName(String name) { return mainService.findByName(name); } @PostMapping(path = &quot;/add&quot;) public @ResponseBody boolean add(@RequestParam String name) { return mainService.add(name); } @PostMapping(path = &quot;/modify&quot;) public @ResponseBody boolean modify(@RequestParam Integer id,@RequestParam String name) { return mainService.modify(id,name); } @PostMapping(path = &quot;/delete&quot;) public @ResponseBody boolean deleteByName(@RequestParam String name) { return mainService.deleteByName(name); } } Controller主要就是几个注解,除了getAllUsers使用Get外,其他的都是用Post.另外就是路径设置,直接在path中设置即可. 后端的话到这里就基本完成了,剩下的打包部署操作就..... 4.前端 什么新建工程之类的就不说了. 直接上MainActivity: package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.Looper; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import com.alibaba.fastjson.JSONArray; import com.example.myapplication.model.dao.*; import com.example.myapplication.model.entity.*; import java.io.IOException; import java.util.List; import okhttp3.FormBody; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button register = findViewById(R.id.register); register.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button login = findViewById(R.id.login); login.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button delete = findViewById(R.id.delete); delete.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button modify = findViewById(R.id.modify); modify.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); } } (1)增 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 使用okhttp,通过FormBody设置参数,然后创建Request通过OkHttpClient发送. 由于后端&quot;增&quot;的方法返回的是一个true,因此这里将response.body().string()转换成boolean判断是否操作成功. 稍微提一下, Looper.prepare(); Looper.loop(); 这两行可以在非UI线程中使用Toast. (2)删 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 删这部分也是差不多的,就是改一下url,然后....然后没有了....好像很简单的样子? (3)查 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 查这里注意一下后端返回的是List,这里借助阿里的fastjson转换成List. List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); 然后判断有没有的话就判断长度是否为0即可. (4)改 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 改的话只需一个额外的ID参数,在FormBody中add一个即可,不难. (5)界面 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/delete&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;280dp&quot; android:layout_marginTop=&quot;404dp&quot; android:text=&quot;删除&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/register&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;293dp&quot; android:text=&quot;注册&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/modify&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;404dp&quot; android:text=&quot;修改&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;EditText android:id=&quot;@+id/name&quot; android:layout_width=&quot;336dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;192dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:ems=&quot;10&quot; android:hint=&quot;请输入姓名&quot; android:inputType=&quot;textPersonName&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;EditText android:id=&quot;@+id/id&quot; android:layout_width=&quot;336dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;112dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:ems=&quot;10&quot; android:hint=&quot;请输入id&quot; android:inputType=&quot;textPersonName&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/login&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;293dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:text=&quot;登录&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 界面不详细说了,不难. (6)依赖与其他 注意一下依赖,还有设置java8. (7)网络权限 这个作者之前的文章有说. 请看这里. 5.测试 这是&quot;原本的&quot;数据库. 没办法为了测试. 注册一个. 看看数据库: 试试登录一个不存在的. 修改: 最后是删除: 删除一个不存在的会删除失败. 6.源码 github 码云 ","link":"https://2293736867.github.io/post/hou-duan-spring-bootqian-duan-android-jiao-hu-mysql-zeng-shan-cha-gai/"},{"title":"Spring boot+Mysql+Spring data JPA一个Web的Demo","content":" 1.概述 2.创建初始spring demo 3.配置数据源 (1)建库 (2)建用户 (3)用户授权 (4)配置application.properties a.none b.update c.create d.create-drop 4.创建实体类 5.创建Repository 6.创建控制器 7.IDE上测试 8.打包发布 9.完整代码 1.概述 因为要用spring boot,最近刚刚学习.这是一个web项目的配合mysq+Hibernate+tomcat的简单示例demo,很容易在此基础上扩展成自己的项目. 2.创建初始spring demo 作者用的IDE是IDEA,新建一个工程,选择Spring Initalizer. 下一步的话由于作者需要部署到服务器上面,选择了war.不需要的话可以选择jar. 选择spring web+spring Data JPA+Mysql Driver. 然后完成即可,首次运行的话配置依赖需要一点时间,请耐心等待. 3.配置数据源 配置数据源分为两部分,一部分是建表与建用户,另一部分是在application.properties中配置的. (1)建库 create database test; 注意这里不用创建表了,因为Hibernate从实体类自动创建一个同名的表. (2)建用户 create user 'db'@'%' identified by 'xxxxx'; (3)用户授权 grant all on test.* to 'db'@'%'; 这里建议授权all,因为后面Hibernate会用到建表权限,不能仅仅授权增删查改. (4)配置application.properties 配置四个属性: spring.jpa.hibernate.ddl-auto= spring.datasource.url= spring.datasource.username= spring.datasource.password= 第一个属性是可以取值 none update create create-drop a.none none是对mysql的默认值,不会改变数据库结构. b.update Hibernate会根据给出的实体类去改变数据库. c.create 创建数据库但是不会在关闭的时候删除. d.create-drop 创建数据库,当SessionFactory关闭时删除数据库.这个是对H2与其他嵌入式数据库的默认选项. 第一次运行时必须设置为update或create,因为还不知道确切的实体类,第一次运行后,可以设置为update或none. url的话对于mysql来说是 jdbc:mysql://ip:3306/database 剩下的两个为用户名与密码. 以下是作者的配置,供参考: 4.创建实体类 这里创建一个简单的User实体类,需要用到javax中的Entity,Id,GeneratedValue与GenerationType注解. Entity用于标识实体类,Id用于标识主键,GeneratedValue与GenerationType用于配置主键. package com.test; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 除了主键之外,可以加上自己想要的属性,还有setter与getter,Hibernate会自动将实体类制作成一个数据表. 5.创建Repository 创建仓库保存用户记录.需要继承CrudRepository&lt;T,ID&gt;,第一个类型为实体类,第二个类型为主键类型. package com.test; import org.springframework.data.repository.CrudRepository; public interface UserRepository extends CrudRepository&lt;User,Integer&gt; { } 6.创建控制器 控制器用于控制Http请求,在控制器中可以配置不同的路径实现不同的操作. package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private UserRepository userRepository; @PostMapping(path = &quot;/add&quot;) public @ResponseBody String addNewUser(@RequestParam String name) { User user = new User(); user.setName(name); userRepository.save(user); return &quot;Saved.&quot;; } @GetMapping(path = &quot;/all&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } } @RequestMapping中的值表示url以此值开头. @PostMapping是仅处理post请求的路径. @ResponseBody表示返回的类型. @RequestParam表示一个从get或post中获取的参数. getAllUsers()会返回一个json或者xml. 7.IDE上测试 首先输入 localhost:8080/demo/all 由于作者先前已经有一行数据所以有显示. 否则的话应该显示为[] 接下来可以添加数据: curl localhost:8080/demo/add -d name=123 回应: 接下来可以选择再次查看: 在看看数据库: 8.打包发布 Build-&gt;Build Artifacts. Build即可. 然后会在项目目录的target下有一个test-0.0.1-xxx的war文件,就是这个了. 改名字放到tomcat的webapps/下,比如作者改成了demo.war: 然后可以去访问了,注意路径,这里的路径是war的路径再加上@RequestMapping中的路径再加上 @PostMapping或 @GetMapping路径: 完成! 9.完整代码 github 码云 ","link":"https://2293736867.github.io/post/spring-bootmysqlspring-data-jpa-yi-ge-web-de-demo/"},{"title":"JDBC+C3P0+DBCP 基本使用","content":" 1.概述 2.mysql的处理 (1)新建用户 (2)建立数据表 (3)用户权限 2.JDBC (1)jar包 (2)连接 (3)Statement (4)PreparedStatement (5)事务 3.C3P0 (1)jar包 (2)配置文件 (3)工具类 4.DBCP (1)jar包 (2)配置文件 (3)工具类 5.源码 1.概述 这篇文章主要说了JDBC的基本使用,包括Statement,PreparedStatement,JDBC的连接,Mysql创建用户创建数据表,C3P0的连接与配置,DBCP的连接与配置. 2.mysql的处理 这里的JDBC使用Mysql作为DBMS,请先安装Mysql,未安装的请点击这里下载,安装教程在这里,作者使用的Mysql的8.0.17版本. (1)新建用户 随便新建一个用户,比如这里作者新建的是aa,密码是aa123bb. create user 'aa'@'localhost' identified by 'aa123bb' (2)建立数据表 建立测试用的数据表与数据库. create database db; use db; create table db ( id int PRIMARY key, name char(20) ); (3)用户权限 对刚才新建的用户授权: grant select,update,delete,insert on db.* to 'aa'@'localhost'; 2.JDBC (1)jar包 8.0.17版本在这里 各个版本的在这里下载 (2)连接 首先注册驱动,驱动需要一个url,用户名和密码,用户名和密码是上一步创建好的,url包含ip地址,端口和数据库的名字. private static final boolean mysqlVersionGreaterThen8 = true; private static final String driver = &quot;com.mysql&quot; + (mysqlVersionGreaterThen8 ? &quot;.cj&quot; : &quot;&quot;) + &quot;.jdbc.Driver&quot;; private static final String ip = &quot;127.0.0.1&quot;; private static final String port = &quot;3306&quot;; private static String databaseName = &quot;db&quot;; private static String url; private static String username = &quot;aa&quot;; private static String password = &quot;k041400r&quot;; private static Connection connection = null; public static Connection getConnection() { try { url = &quot;jdbc:mysql://&quot; + ip + &quot;:&quot; + port + &quot;/&quot; + databaseName; Class.forName(driver); return connection = DriverManager.getConnection(url, username, password); } catch (Exception e) { e.printStackTrace(); } return null; } 这里要注意以下旧版本的mysql的驱动叫com.mysql.jdbc.Driver,新版本的叫com.mysql.cj.jdbc.Driver.还有就是url的格式: jdbc:mysql://ip:port/database (3)Statement 获取数据库连接后,使用createStatement方法创建Statement 对于select,使用Statement的executeQuery(sql),返回ResultSet 对于update,delete,insert,使用Statement的executeUpdate(sql) 其中sql是要执行的sql语句,一个String. public void useStatement() { try { useStatementInsert(); useStatementSelect(); useStatementUpdate(); useStatementSelect(); useStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void useStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) { System.out.println(resultSet.getObject(i)); } } } public void useStatementUpdate() throws SQLException { Statement statement = connection.createStatement(); String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; statement.executeUpdate(sql); } 这里对ResultSet使用的getMetaData,可以获取结果集的各种类型信息,包括字段的类型,个数,等等. (4)PreparedStatement PreparedStatement与Statement使用基本一样.调用的时候先使用Connection的prepareStatement(sql)创建,然后 对于select,使用executeQuery(),返回一个ResultSet 对于update,delete,insert使用executeUpdate(). public void usePrepareStatement() { try { usePrepareStatementInsert(); usePrepareStatementSelect(); usePrepareStatementUpdate(); usePrepareStatementSelect(); usePrepareStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void usePrepareStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet resultSet = preparedStatement.executeQuery(); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) System.out.println(resultSet.getObject(i)); } } public void usePrepareStatementUpdate() throws SQLException { String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } (5)事务 Connection有一个setAutoCommit()方法,把它设置成false即可关闭自动提交,所有语句准备好后,一次性使用commit()提交即可. 实现回滚可以配合SavePoint使用. 3.C3P0 (1)jar包 两个: c3p0 mchange-commons (2)配置文件 src下创建一个叫c3p0.properties的文件: c3p0.driverClass=com.mysql.cj.jdbc.Driver c3p0.jdbcUrl=jdbc:mysql://127.0.0.1:3306/db c3p0.user=aa c3p0.password=aa123bb 这里按自己需要更改即可. (3)工具类 import com.mchange.v2.c3p0.ComboPooledDataSource; import java.sql.Connection; public class DbUtil { private static ComboPooledDataSource C3P0dataSource = new ComboPooledDataSource(&quot;c3p0.properties&quot;); public static void releaseConnection(Connection connection) { try { if(connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getC3P0Connection() { try { return C3P0dataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } } 4.DBCP (1)jar包 三个: commons-dbcp commons-logging commons-pool (2)配置文件 src下新建dbcp.properties: driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/db username=aa password=k041400r initialSize=10 maxActive=50 maxIdle=15 minIdle=10 maxWait=60000 connectionProperties=useUnicode=true;characterEncoding=utf8 defaultAutoCommit=true 分别是驱动,url,用户名,密码,初始化连接数,最大连接数,最大空闲连接数,最小空闲连接数,最大等待实际,连接属性(这里设置了编码),自动提交. (3)工具类 import org.apache.commons.dbcp2.BasicDataSourceFactory; import java.io.InputStream; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; public class DbUtil { private static DataSource DBCPdataSource; static { try { InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); DBCPdataSource = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getDBCPConnection() { try { return DBCPdataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void releaseConnection(Connection connection) { try { if (connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 首先加载属性文件,再使用Properties的load方法将其加载到一个Properties对象中,最后交给BasicDataSourceFactory处理. 5.源码 包含了jar包,配置文件,sql文件与测试代码. github 码云 ","link":"https://2293736867.github.io/post/jdbcc3p0dbcp-ji-ben-shi-yong/"},{"title":"从0开始自制计算器!","content":"先看看效果吧: 很炫酷吧? 想不想要? 想要吧. 当然作者知道你们肯定想. 不然也不会点进来对不对. 好.进入正题. 1.概述 2.新建工程 2.界面 (1) 按键 a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 d.复制制作好的button,布好局 e.改内容 f.整体修改大小,同时加上间隔 (2) 输出框 a.添加QLineEdit b.调整好大小,设置好背景颜色 c.设置字体,只读,对齐 (3) 标题栏 a.新建Horizontal Layout b.添加细节 (4)整体处理 a.标题栏 b.调整整体大小,同时添加透明度 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 b.最小化与关闭 B.按键 a.移入与移出事件 b.单击事件 (2)键盘事件 A.添加阴影 B.添加输出 4.整体细节再处理 (1)淡入效果 (2)设置固定尺寸 (3)淡出效果 5.表达式处理 (1)判断 a.去除所有空格 b.分类判断 c.加0 (2)计算 a.calc辅助类 b.计算部分 c.测试 6.整合 (1)设置界面的调用进程,并获取输出结果 (2)修改一些细节地方 a.鼠标键盘修改事件 b.exe中设置数字的格式 c.设置错误提示 d.可以考虑把错误处理整合过来 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 (3) 打包库文件 (4) 生成单个exe (5) 测试 8.源码 9.参考链接 10.最后 1.概述 这个是仿照win10自带的计算器制作的简化版本.是用Qt做的,直接把整个表达式输入然后得出计算结果. 主要分为三部分.界面部分,事件处理部分与表达式处理部分. 界面部分就是看到的计算器,包括标题栏,中间的输出框,还有各个按键. 事件处理就是处理对应的鼠标与键盘事件. 表达式处理部分就是处理整个输入的字符串,返回计算的结果,当然这个还支持错误判断功能. 2.新建工程 选择Widgets Application. 起名字. 一般只需MinGW. 这里默认即可,名字可以随便改 2.界面 (1) 按键 按键的话,基本上按着改就可以了.改布局,改颜色,改字体,主要就是这三个. 首先先打开.ui文件: a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 这里给出作者的参考style: border:1px groove rgb(220,220,220); background-color:rgb(243,243,243); 字体: 这里按个人喜好调整即可. d.复制制作好的button,布好局 e.改内容 这里不仅把里面的字符改变,还要把相应的对象名也改变. 再细调每一个按键,包括大小,字体与颜色,使总体效果更好. 数字要注意有&quot;加粗&quot;效果,符号的话尽量&quot;精细&quot;一点. f.整体修改大小,同时加上间隔 调整好间隔.注意细节. 下面是win10自带的计算器: 看到间隔了没? 作者要的就是这种效果. 可以先运行看看. 两边的间隔的话一会配合widget的大小调整即可. (2) 输出框 输出框很简单,就是一个QLineEdit. a.添加QLineEdit b.调整好大小,设置好背景颜色 作者的qss: border:0px groove rgb(243,243,243); background-color:rgb(245,245,245); c.设置字体,只读,对齐 (3) 标题栏 标题栏其实也很简单,一个QBoxLayout a.新建Horizontal Layout b.添加细节 QLabel输入标题,两个QPushButton表示最小化与关闭,同时加入两个Spacer,让标题与左边空出一些距离. 其实就是模仿win10的标题栏的效果 这里就不做最大化了.因为涉及到按钮的重新排布问题,这个可以自己选择实现. (4)整体处理 a.标题栏 把上一步做的标题栏移到合适的位置,同时删除自带的QMenuBar,QToolBar,QStatusBar. b.调整整体大小,同时添加透明度 调整好后大概就那样,透明度这里选择了0.9. 真是完美啊! 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 首先把本来那个标题栏去掉. setWindowFlags(windowFlags() | Qt::FramelessWindowHint); 再在protected中加入鼠标监听函数: void mousePressEvent(QMouseEvent *); void mouseMoveEvent(QMouseEvent *); 私有成员中加入两个QPoint.分别表示当前窗口坐标与光标的坐标. QPoint mousePoint; QPoint windowPoint; 第一个函数是鼠标按下时触发的,根据event-&gt;button()判断是否是左键,是的话获取mouse坐标,在设置window坐标. 当触发第二个函数时,即先判断是否按住左键不放,使用MainWindow的move方法移动窗口. event-&gt;globalPos()获取坐标后减去原来光标的坐标得到window坐标的变化量,再用原坐标加上这个变化量. void MainWindow::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton) { mousePoint = event-&gt;globalPos(); windowPoint = frameGeometry().topLeft(); } } void MainWindow::mouseMoveEvent(QMouseEvent *event) { if(event-&gt;buttons() &amp; Qt::LeftButton) { move(windowPoint + event-&gt;globalPos() - mousePoint); } } b.最小化与关闭 这里以最小化为例,关闭也一样的,改一下函数调用即可. 在最小化按钮中右键选择Go to slot: 选择clicked() 添加一个最小化函数: 下面是关闭的函数: B.按键 按键的鼠标事件包括两个: 光标移入与移出事件,为按键添加阴影,加深颜色等 单击事件,在输出框中增减对应的字符 a.移入与移出事件 这里的实现方式是通过事件过滤器实现的.增加一个eventFilter()函数 bool eventFilter(QObject *,QEvent *); 首先通过event-&gt;type()判断事件类型,如果是光标悬停,再判断对应的各个对象增加阴影效果. addNumButtonEffet(): void MainWindow::addNumButtonEffect(QPushButton *button,QGraphicsDropShadowEffect *shadow) { shadow-&gt;setEnabled(true); button-&gt;setStyleSheet( &quot;border:1px groove rgb(220,220,220);&quot; &quot;background-color:rgb(193,193,193);&quot; ); } 这里QGraphicsDropShadowEffect *shadow事先初始化好了. 然后在添加事件过滤器: 这里可以对比一下有没有阴影的效果: 没有阴影: 加上阴影: 呃....这里可能是截图工具的问题,看不来多大的效果,但是直接在机器上看是有比较大的区别的,建议还是加上阴影. b.单击事件 单击事件就是单击了某个按键然后用户可以在输出框中看到对应的反应. 依次选择按键,右键Go to slot: 选择clicked() 然后添加处理函数,作者这里自己实现了一个添加文本与清除焦点的函数,添加文本就是对应按键被光标单击后添加到输出框,至于为什么要清除焦点.... 因为... 因为空格. 因为作者的&quot;良好&quot;习惯,习惯在运算符前后加上空格 单击后会把焦点保留在这个按钮上,键盘上敲空格默认会帮你&quot;按一次&quot;这个按钮,因此如果不清除焦点的话,在光标单击了某个按钮,比如7,按空格就会在输出框上输出7,光标单击了8后,按空格就会在输出框上输出8. 这里添加文本时还要注意默认的起提示作用的0. void MainWindow::appendText(const QString &amp;s) { if(ui-&gt;box-&gt;text() == &quot;0&quot;) ui-&gt;box-&gt;setText(s); else ui-&gt;box-&gt;setText(ui-&gt;box-&gt;text()+s); } void MainWindow::appendTextAndClearFocus(QPushButton *button, const QString &amp;s) { appendText(s); button-&gt;clearFocus(); } (2)键盘事件 键盘事件就是主要处理各个按键按下时的阴影与输出框添加输出. 键盘事件通过以下两个函数处理: void keyPressEvent(QKeyEvent *); void keyReleaseEvent(QKeyEvent *); 第一个是按键按下时触发的,第二个是松开按键触发的. A.添加阴影 在按键按下时添加上阴影与颜色加深效果. 通过event-&gt;key()依次判断各个键. 键位可以看这里 然后添加在keyRealeseEvent()中把对应的阴影去掉: void MainWindow::keyReleaseEvent(QKeyEvent *event) { switch (event-&gt;key()) { case Qt::Key_0: case Qt::Key_1: case Qt::Key_2: case Qt::Key_3: case Qt::Key_4: case Qt::Key_5: case Qt::Key_6: case Qt::Key_7: case Qt::Key_8: case Qt::Key_9: case Qt::Key_Plus: case Qt::Key_Minus: case Qt::Key_Asterisk: case Qt::Key_Slash: case Qt::Key_AsciiCircum: case Qt::Key_Percent: case Qt::Key_ParenLeft: case Qt::Key_ParenRight: case Qt::Key_BraceLeft: case Qt::Key_BraceRight: case Qt::Key_BracketLeft: case Qt::Key_BracketRight: case Qt::Key_Backspace: case Qt::Key_Space: case Qt::Key_Period: case Qt::Key_Escape: case Qt::Key_Equal: case Qt::Key_Return: removeNumButtonEffect(ui-&gt;num0,num0_shadow); removeNumButtonEffect(ui-&gt;num1,num1_shadow); removeNumButtonEffect(ui-&gt;num2,num2_shadow); removeNumButtonEffect(ui-&gt;num3,num3_shadow); removeNumButtonEffect(ui-&gt;num4,num4_shadow); removeNumButtonEffect(ui-&gt;num5,num5_shadow); removeNumButtonEffect(ui-&gt;num6,num6_shadow); removeNumButtonEffect(ui-&gt;num7,num7_shadow); removeNumButtonEffect(ui-&gt;num8,num8_shadow); removeNumButtonEffect(ui-&gt;num9,num9_shadow); removeSignButtonEffect(ui-&gt;plus,plus_shadow); removeSignButtonEffect(ui-&gt;minus,minus_shadow); removeSignButtonEffect(ui-&gt;mutiply,mutiply_shadow); removeSignButtonEffect(ui-&gt;divide,divide_shadow); removeSignButtonEffect(ui-&gt;pow,pow_shadow); removeSignButtonEffect(ui-&gt;percent,percent_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;backspace,backspace_shadow); removeSignButtonEffect(ui-&gt;blank,space_shadow); removeSignButtonEffect(ui-&gt;dot,dot_shadow); removeSignButtonEffect(ui-&gt;C,c_shadow); removeSignButtonEffect(ui-&gt;equal,equal_shadow); break; } } 这里之所以没有一个个按键去判断是因为有可能同时多个按键按下,然后同时松开后发现某个按键还存在阴影,因此统一当其中一个按键释放时去除所有按键的阴影. B.添加输出 在输出框中添加输出,调用一个函数即可: 4.整体细节再处理 (1)淡入效果 看看效果: 这里实际使用了Qt的动画,针对透明度改变的动画. void MainWindow::fadeIn(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0); changeOpacity-&gt;setEndValue(0.91); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); } 第一行表示改变的是透明度,第二三行设置起始值与结束值,接下来设置动画时间(单位ms),然后开始动画. (2)设置固定尺寸 这里可以不设置最大尺寸,但一定要设置最小尺寸. 设置这个实际上禁止了拖拽去改变大小. (3)淡出效果 淡出效果与淡入效果类似. 不同的时需要添加计时处理,不能直接在exit(0)前调用fadeOut()函数,因为动画会在另一个线程启动,所以需要在主线程休眠指定秒数,等待淡出效果完成后,主线程再调用exit(0); void MainWindow::fadeOut(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0.9); changeOpacity-&gt;setEndValue(0); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); QTime start = QTime::currentTime().addMSecs(2500); while(QTime::currentTime() &lt; start) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } 其中addMSecs()表示要延迟的秒数,while循环体中表示处理本线程的事件,其中100表示处理事件最多100ms就返回本语句. 这里就不放淡出效果的图片了. 5.表达式处理 由于这是整个字符串作为表达式进行输入,需要先进行判断再计算.所以分为判断与计算两部分. 这里使用了一个新开的控制台工程,后面会把这个整合起来. (1)判断 使用了一个check类判断,由于只有10个数字按键,加减乘除,小数点,求余,求次幂,大中小括号,空格,所以可以分成这几类进行判断. a.去除所有空格 void removeAllBlank(void) { size_t i = 0; while((i = s.find(' ',i)) != string::npos) s.erase(i,1); } 首先把所有空格去除,避免之后的判断. b.分类判断 把表达式中的所有字符分成5类: 数字 小数点 运算符号 + - * / ^ % 左括号类 ( [ { 右括号类 ) ] } 然后就是针对每个类型判断它的下一个字符是否是允许的类型,不是的话返回false. 比如碰上了一个 ( 或 [ 或 { 则它的下一个不能是运算符号或者小数点,当然允许-与+,因为有 (-7) (+234) 这种情况. 然后把这个符号保存下来判断后面是否是对应的右括号. if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } braces.push(s[i]); } 整个判断函数如下: bool valid(void) { if(isSignOrDot(0) || isRightBrace(0)) return false; len = s.size(); stack&lt;char&gt; braces; for(size_t i=0;i&lt;len;++i) { if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } if(isRightBrace(i+1)) return false; braces.push(s[i]); } else if(isRightBrace(i)) { if(isDot(i+1) || isDigit(i+1) || isLeftBrace(i+1)) return false; if(isRightBrace(i+1)) { stack&lt;char&gt; braces_copy(braces); if(braces_copy.empty()) return false; braces_copy.pop(); if(braces_copy.empty()) return false; } if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i] != ')') || (brace == '[' &amp;&amp; s[i] != ']') || (brace == '{' &amp;&amp; s[i] != '}')) return false; braces.pop(); } else if(isSign(i)) { if(isSign(i+1) || isDot(i+1) || isRightBrace(i+1)) return false; } else if(isDot(i)) { if(isSignOrDot(i+1) || isBrace(i+1)) return false; } else if(isDigit(i)) { if(isRightBrace(i+1)) { if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i+1] != ')') || (brace == '[' &amp;&amp; s[i+1] != ']') || (brace == '{' &amp;&amp; s[i+1] != '}')) return false; } } } return braces.empty(); } 特别要注意下的就是碰到右括号的情况,除了要判断是否是单独存在的右括号,还有判断是否与前一个左括号匹配. c.加0 这是针对单目运算符-的情况,比如(-7),然后把它转化为(0-7): string getResult(void) { size_t len = s.size(); for(size_t i = 0;i&lt;len;++i) { if(s[i] == '(' &amp;&amp; (s[i+1] == '-' || s[i+1] == '+')) s.insert(i+1,&quot;0&quot;); } return s; } 在左小括号后判断是否是-或+,是的话对应位置插入0. (2)计算 a.calc辅助类 calc辅助类中使用了两个栈,运算符栈与操作数栈. private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; 其中有两个重要的方法: bool canCalculate(char sign); void calculate(void); 第一个方法将下一个准备进入的符号作为参数,判断是否可以计算操作数栈的前两个数,如果可以的话,使用第二个函数进行计算. calculate()会将出栈两个操作数与一个运算符,得出结果后在将其压回操作数栈. void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } 下面是calc类: class calc { private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; char getSign(void) { return operators.top(); } double getNum(void) { return operands.top(); } void popSign(void) { operators.pop(); } void popNum(void) { operands.pop(); } double popAndGetNum(void) { double num = getNum(); popNum(); return num; } char popAndGetSign(void) { char sign = getSign(); popSign(); return sign; } public: void push(double num) { operands.push(num); } void push(char sign) { operators.push(sign); } char get(void) { return getSign(); } void pop(void) { popSign(); } double result(void) { return getNum(); } void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } bool empty(void) { return operators.empty(); } }; private封装了一些简单的对两个栈进行操作的工具方法,公有的pop()与get()是对运算符栈进行的操作.因为外部不需要对操作数栈进行操作,由calculate()进行操作,公有的push重载了,可以push到操作数栈或运算符栈. b.计算部分 计算部分在这里直接放在了main中: int main(void) { check chk; while(!chk.inputAndCheck()) cout&lt;&lt;&quot;Error!Please input again.\\n&quot;; string s = chk.getResult(); size_t len = s.size(); calc c; for(size_t i=0;i&lt;len;++i) { if(isdigit(s[i])) { double num; size_t i1 = i+1; while(i1 &lt; len &amp;&amp; (isdigit(s[i1]) || s[i1] == '.')) ++i1; istringstream input(s.substr(i,i1)); input&gt;&gt;num; i = i1-1; c.push(num); } else if(s[i] == '}' || s[i] == ']' || s[i] == ')') { char sign; char start = (s[i] == '}' ? '{' : ( s[i] == ']' ? '[' : '(')); while((sign = c.get()) != start) c.calculate(); c.pop(); } else //s[i] is [ ( { + - * / ^ % { while(c.canCalculate(s[i])) c.calculate(); c.push(s[i]); } } while(!c.empty()) c.calculate(); cout&lt;&lt;&quot;result is &quot;&lt;&lt;c.result()&lt;&lt;endl; return 0; } 对表达式的每个字符逐个处理,若是数字,提取出来并压栈. 若是右括号类,不断从运算符栈中提取直到把这段括号内的表达式计算完成. 否则若是左括号或者是运算符,当可以计算的时候一直计算,提取两个操作数运算并压栈,再把新的运算符压栈. 最后使用result()获取结果. c.测试 这里就显示几个很长的例子算了 当然作者测试了很多的例子 6.6/{2.3+34.3*2.22-5%2+22%4*[2+3.4/5-(4.3+3.2*33.3)]+34.3} + 7.8*{2.4-6/6+0-0*[23.4-3.4/6+4*(2.2+3)]}+0 - 0 + 0.0 = 10.8569 3.4 - (+3.34) + 34.3 * (-2) / 3.34 + {[(-3.4)^2/3.4+3.4/3]-3.32+[3*(-3)]} = -28.2656 9^5-34.4^2.3+5%6-34+66%78-78%4 + (-3)*3.4 / {3*(-7)+[3*(-8)+3*(3.4+4.34)/9.3-3.2 + 0.0 - 0]+0.0 - 0}+3.4^4/6.888 = 55683.2 不信的话可以手工计算一下. 6.整合 这部分把界面部分与表达式处理部分整合起来. (1)设置界面的调用进程,并获取输出结果 计算表达式的程序叫MyCalc.exe,注意把它放在对应的工程文件夹下面,然后使用QProcess调用. 使用execute执行,表达式先去除所有的空格,然后作为命令行参数传递给计算程序,然后计算程序把计算结果写入到result.txt文件,Qt读取这个文件,如果读到#表示表达式输入错误,否则,则是正确的计算结果. 对于结果因为在计算程序中设置了fixed格式,因此对于 1+2 也会返回 3.000000 这步把多余的0去掉,还要注意小数点的情况. (2)修改一些细节地方 a.鼠标键盘修改事件 修改setText的内容,把结果传递过去. b.exe中设置数字的格式 设置fixed格式,否则的话显示的是科学计数法,对小数位数有要求的话可以设置setprecision. c.设置错误提示 这里出现错误时,输出&quot;#&quot;,然后主程序读取到就会提示&quot;表达式错误,请重新输入.&quot; 还有除数为0的错误提示,这个要注意一下: d.可以考虑把错误处理整合过来 比如输入了一个点,不能继续输入点,输入了一个乘号或者除号不能再继续输入另一个符号: 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 把Qt文件夹下的如图所示的bin添加到Path环境变量, (3) 打包库文件 使用windeployqt打包,首先把程序调成release模式,运行一次,生成release的exe,然后把exe复制到一个单独的文件夹,再用命令行进入到这个文件夹,运行 windelpoyqt xxx.exe 这个命令把需要的dll复制到当前所在文件夹. (4) 生成单个exe 打开Enigma Virtual Box,选择 第一个选择release的exe,第二个选择打包之后的文件夹,然后选择添加文件,选择递归添加,添加上一步生成的所有文件(夹). 这里选择压缩文件. 然后选择压缩等待完成即可. (5) 测试 点击运行. 大功告成!! 8.源码 1.github(里面包含完整可执行的单个exe) 注:由于使用了lfs上传大文件,所以clone的时候请使用 git lfs clone 2.码云 9.参考链接 1.Qt淡入 2.Qt按键 3.Qt标题栏 4.事件过滤器 5.Qt鼠标事件 6.Qt延时处理 7.Qt文件读写 8.Qt打包成单文件 10.最后 这个简单的计算器有很大的改进空间,比如可以添加各种&quot;数&quot;: 正弦函数,余弦函数,正切函数,反正弦函数,指数函数,对数函数,高阶导数,抽象函数,复合函数.心里没数 等等.另外还可以改进矩形的按钮,可以改成圆角矩形或者椭圆形. 另外,对于阴影的处理可以添加淡入淡出效果. 最后就是磨砂.因为win10的是有磨砂效果的,这个作者还不会.... 最后再上几个图,看看效果(由于动图大小的限制只是简单的表达式...): 希望你们也有一个属于自己的计算器! ","link":"https://2293736867.github.io/post/cong-0-kai-shi-zi-zhi-ji-suan-qi/"},{"title":"java多种文件复制方式以及效率比较","content":" 1.背景 2.概述 3.jar包 4.遍历 (1)listFiles() (2)list() (3)org.codehaus.plexus.util.FileUtils.getFiles (4)Commons.io工具包 (5)NIO--walkFileTree 5.复制 (1)FileInputStream+FileOutputStream A.read() B.read(b) C.read(b,off,len) (2)BufferedInputStream+BufferedOutputStream A.read(b) B.read(b,off,len) C.readAllBytes() (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)NIO--FileChannel (6)NIO--FileChannel+ByteBuffer (7)FileUtils.copyFile() (8)Files.copy() 6.其他 (1)swing布局 A.网格布局 B.居中 C.组件的添加与删除 (2)进度条 7.测试 (1)1G文件 (2)10G文件 (3)1G目录 (4)10G目录 8.源码 1.背景 java复制文件的方式其实有很多种,可以分为 传统的字节流读写复制FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStream 传统的字符流读写复制FileReader,FileWriter,BufferWriter,BufferedWriter,BufferedReader NIO系列的FileChannel FileChannel+缓冲 java.nio.Files.copy() 第三方包中的FileUtils.copy方法,比如org.apache.commons.io.FileUtils,org.codehaus.plexus.util.FileUtils等等. 所以呢,看看各种方法效率怎么样,主要衡量的标准就是时间,另外的一些标准包括大文件的复制时的内存溢出等问题. 2.概述 由于很多时候复制文件都包括了文件夹下的所有子目录及文件的复制,所以作者采用的遍历+复制方法去复制文件.就是把整个复制过程分为先遍历,遍历的过程中遇到文件夹就创建,遇到文件就调用不同的复制方法. 遍历的5种方法: (1)File.listFiles() (2)File.list() (3)org.codehaus.plexus.util.FileUtils.getFiles() (4)org.apache.commons.io.FileUtils.listFiles() (5)java nio中的java.nio.file.Files.walkFileTree 复制的8种方法: (1)FileInputStream+FileOutputStream (2)BufferedInputStream+BufferedOutputStream (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)FileChannel (6)FileChannel+buffer (7)org.apache.commons.io.FileUtils.copyFile() (8)java.nio.file.Files.copy() 另外作者不太想看控制台.....所以配合了一点swing使用. 3.jar包 1.org.apache.commons 2.org.codehaus.plexus 4.遍历 (1)listFiles() private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 通过srcFile的listFiles()获取所有的子文件与子文件夹,然后判断是否是目录 如果是目录,首先判断有没有这个文件(有时候本来是文件夹但是却存在同名的文件,就先删除),再创建文件夹,然后递归执行函数. 如果不是目录,直接把两个File作为参数进行文件复制,里面用什么方法后面会设置. (2)list() private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } list与第一种listFiles()类似,不过是String[],也是先判断目录,创建目录,不是目录直接复制 (3)org.codehaus.plexus.util.FileUtils.getFiles private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 这是用了别人的工具类进行遍历. org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); 返回的结果的java.util.List (4)Commons.io工具包 private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 使用org.apache.commons.io.FileUtils的listFiles方法，参数为要遍历的目录，一个null和一个false，第二个参数表示过滤器，表示过滤出特定后缀名的文件，类型为String [],第三个布尔参数表示是否递归访问子目录. (5)NIO--walkFileTree 利用FileVisitor这个接口.实际中常用SimpleFileVisitor. private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } FileVisitor接口定义了四个方法，分别为： public interface FileVisitor&lt;T&gt; { FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir前的操作，dir类型一般为java.nio.Path } FileVisitResult postVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir后的操作 } FileVisitResult visitFile(T file,BasicFileAttributes attrs) { //访问file时的操作 } FileVisitResult visitFileFailed(T file,BasicFileAttributes attrs) { //访问file失败时的操作 } } 在上面的例子中只是实现了visitFile，因为只是复制操作，首先判断是否是源目录的路径，不是的话创建文件夹再复制文件. 这里说一下返回值FileVisitResult.FileVisitResult是一个枚举类型，根据返回值判断是否继续遍历. FileVisitResult可取值: CONTINUE:继续 TERMINNATE:结束 SKIP_SIBLINGS:继续，跳过同一目录的节点 SKIP_SUBTREE:继续，跳过子目录，但会访问子文件 5.复制 (1)FileInputStream+FileOutputStream 首先是经典的字节流FileInputStream+FileOutputStream,这个比较简单,使用FileInputStream读取后使用FileOutputStream写入,不过效率嘛.....一般般. private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } 这里说一下三个read方法的区别,FileInputStream有三个read方法: input.read(); input.read(b); input.read(b,off,len); A.read() 逐个字节进行读取,返回int,写入时直接使用write(n); int n = input.read(); output.write(n); 这个可以说是三个read中最慢的....作者试了一个2G左右的文件,用了大概10分钟才复制160M...... B.read(b) 参数是一个byte [],将字节缓冲到其中,返回数组的字节个数,这个比read()快很多. byte [] b = new byte[1024]; while(input.read(b) != -1) output.write(b); C.read(b,off,len) 这个方法其实和read(b)差不多,read(b)相当于省略了参数的read(b,off,len). byte [] b = new byte[1024]; int n; while((n = input.read(b,0,1024))!=-1) output.write(b,0,n); public int read(byte b[], int off, int len) throws IOException { return readBytes(b, off, len); } public int read(byte b[]) throws IOException { return readBytes(b, 0, b.length); } 这两个都是调用一样的readBytes(): private native int readBytes(byte b[], int off, int len) throws IOException; 至于效率...可以看看结果(作者用的是10G内的小文件): 可以看到,没有哪个一定比另外一个更快(不过最后一个误差有点太大了?7G不够的文件.). 采用哪一个建议自己去测试,毕竟这存在很多误差,比如文件,java版本,机器本身等等,仅供参考. (2)BufferedInputStream+BufferedOutputStream 缓冲字节流BufferedInputStream+BufferedOutputStream,相比起FileInputStream,BufferedInputStream读取时会先从缓冲区读取数据,缓冲区无可读数据再从文件读取,所以会比FileInputStream快. private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } 这里也说一下BufferedInputStream的三个read(实际上还有,还有readN,与read(),read()肯定最慢,readN作者很少用,所以就没列出来了) read(b); read(b,off,len); readAllBytes(); A.read(b) 这个其实和FileInputStream的那个没啥区别,把一个字节数组仍进去就好了. B.read(b,off,len) 这个....也和FileInputStream那个没啥区别,不说了 C.readAllBytes() 这个一次可以读取所有的字节.不过用这个虽然省事,可以直接 output.write(input.readAllBytes()); 但是呢,有代价的: 会出现OutOfMemory错误,就是对于大文件还是老老实实分开吧,不要&quot;一口搞定&quot;,&quot;多吃几口&quot;. 看看效率: readAllBytes对于大文件(作者这个是5G内的文件)直接爆内存.... readAllBytes()又爆了.....这个才2G不到的文件...readAllBytes()看来不是很给力啊....不过对于小文件效率还可以接受. (3)FileReader+FileWriter 字符流读写FileReader+FileWriter,相比起字节流的read,基本上把byte[]换成char[]即可,因为是逐个字符读取,而字节流是逐个字节读取因此采用byte[]. 注意这个不能用来读取图片,音乐等文件,不然复制出来的文件打不开. private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (4)BufferedReader+BufferedWriter 缓冲字符流读写BufferedReader+BufferedWriter,BufferedReader相比起FileReader有一个readLine()方法,可以每行读入,会比FileReader快.对应的BufferedWriter提供了write(String)方法,当然也有write(String s,int off,int len).同样这个不能用来读取图片等. private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (5)NIO--FileChannel 通过FileChannel复制,首先通过FileInputStream与FileOutputStream打开流,再用getChannel()方法.最后使用transferTo()或transferFrom()进行复制,一条语句即可,十分方便,而且效率很高. private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } (6)NIO--FileChannel+ByteBuffer 在利用了FileInputStream与FileOutputStream打开了FileChannel的基础上,配合ByteBuffer使用. private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } flip的意思是&quot;翻转&quot;, buffer.flip(); 把Buffer从写模式变为读模式,接着write(buffer),再把buffer清空. 看看这两种方法效率: 另外作者发现transferTo的&quot;上限&quot;为2G,就是对于大于2G的单个文件最多最能复制2个G. 所以...对于大文件没有可比性了. (7)FileUtils.copyFile() 这是工具类,没啥好说的,参数是两个File,分别表示源与目标. private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } (8)Files.copy() 这是官方提供的Files工具类,前两个参数为Path,分别表示源与目标,可以设置第三个参数(或者省略),表示选项.例如可以设置 StandardCopyOption.REPLACE_EXISTING private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } 注意Files.copy会保持文件的隐藏属性,原来是隐藏的文件复制后也是隐藏的.以上7种则不会. 6.其他 (1)swing布局 A.网格布局 主JFrame采用了网格布局 setLayout(new GridLayout(3,1,5,3)); 三行一列，因为只要三个按钮，选择源文件(夹),选择目标文件夹,选择遍历方式. 选择遍历方式/复制方式的JFrame同样适用了网格布局: showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); B.居中 setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); 高400,宽400,利用ToolKit.getDefaultToolKit().getScreenSize()获取屏幕的高度和宽度实现居中. C.组件的添加与删除 由于在主JFrame中只有三个按钮,选择完遍历方式后需要更新这个组件,作者的做法是先删除这个组件在添加组件: traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); 设置它不可见再删除,再添加另一组件,再设置可见. (2)进度条 进度条这个东西把作者搞得很惨啊......其实就是新建一个线程就可以了. 核心代码为: new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); 作者的JProgressBar是直接添加在一个JFrame中的,不用什么太复杂的布局. 获取百分比后调用setValue(),一定要新建一个线程操作,不然不能正常显示进度条. 另外复制的操作建议使用SwingWorker. SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); 7.测试 说了那么多来点实际的. (以下所有的测试都是删除复制的文件后再进行新一次的复制.) (1)1G文件 1G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 20.189s 21.152s 18.249s 20.131s 21.782s BufferedInput/OuputStream 17.761s 23.786s 22.118s 19.646s 16.806s FileReader/Writer 61.334s 58.3s 58.904s 58.679s 55.762s BufferedReader/Writer 63.287s 59.546s 56.664s 58.212s 59.884s FileChannel 20.097s 22.272s 22.751s 22.765s 20.291s FileChannel+ByteBuffer 18.857s 22.489s 23.148s 22.337s 17.213s FileUtils.copyFile 25.398s 21.95s 22.808s 25.325s 22.483s Files.copy 16.272s 14.166s 17.057s 14.987s 10.653s 文件的话其实纵向比较即可,因为基本不用怎么遍历,横向比较可以勉强看作求平均值. 对于非文本文件,FileReader/Writer和BufferedReader/Writer没有太大的参考意义,比如复制视频文件是打不开的,而且复制出来的文件会变大.对于单文件Files.copy的性能非常好,java的nio果然厉害. (2)10G文件 10G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 171.427s 173.146s 172.611s 184.182s 250.251s BufferedInput/OuputStream 203.509s 174.792s 167.727s 177.451s 217.53s FileReader/Writer 187.55s 169.306s 226.571s 168.982s 218.303s BufferedReader/Writer 155.134s 165.883s 166.192s 176.488s 206.306s FileChannel 34.48s 35.445s 43.896s 41.827s 41.755s FileChannel+ByteBuffer 175.632s 167.091s 178.455s 182.977s 183.763s FileUtils.copyFile 203.997s 206.623s 201.01s 213.949s 208.739s Files.copy 209.898s 186.889s 244.355s 222.336s 244.68s 这个10G的文件是文本文件. 现在可以看看FileChannel的这一行,明显所花的时间要比其他要少,为什么呢? 因为文件大于2G.FileChannel的trasferTo方法只能写入最多2G的文件,所以对于大于2G的文件复制出来只有2G,因此FileChannel的这一行没有太大可比性.对于文本文件,BufferedReader/Writer的复制速度是最快的了,其次是FileInput/OutputStream.对于单个大文件,apache的FileUtils与NIO的Files.copy的速度比FileInputStream慢啊... (3)1G目录 1G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 23.549s 99.386s 143.388s 13.451s 10.773s BufferedInput/OuputStream 6.306s 59.458s 20.704s 6.668s 6.616s FileReader/Writer 49.059s 103.257s 51.995s 49.729s 51.509s BufferedReader/Writer 59.932s 127.359s 51.731s 51.418s 50.317s FileChannel 40.082s 71.713s 17.617s 15.782s 19.777s FileChannel+ByteBuffer 33.355s 83.845s 19.68s 10.288s 17.152s FileUtils.copyFile 24.163s 63.979s 8.277s 6.115s 19.513s Files.copy 14.528s 28.215s 6.578s 5.883s 7.502s 对于目录的话可以考虑放弃BufferedReader与FileReader了,除非全部是文本文件,否则推荐使用BufferedInput/OutputStream与Files.copy()进行复制,工具类FileUtils的复制方法表现还是不错的,但相比起java标准的Files.copy效率都差了. 对于FileChannel与配合缓冲使用的FileChannel,1G的话好像不相上下. 遍历方式的话...可以看到plexus的遍历方法表现差距很大,而apache的listFiles或者java nio的walkFileTree比较稳定且速度还可以,推荐使用这两种方式遍历目录. (4)10G目录 10G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 216.822s 228.792s 227.908s 240.042s 191.863s BufferedInput/OuputStream 218.599s 210.941s 207.375s 213.991s 167.614s FileReader/Writer 536.747s 550.755s 550.415s 548.881s 516.684s BufferedReader/Writer 587.612s 552.55s 549.716s 553.484s 498.18s FileChannel 115.126s 117.538s 117.456s 118.207s 97.626s FileChannel+ByteBuffer 225.887s 224.932s 222.077s 223.812s 180.177s FileUtils.copyFile 233.724s 230.199s 232.133s 223.286s 189.737s Files.copy 229.819s 227.562s 226.793s 226.78s 181.071s FileReader与BufferedReader这两行可以忽略了.对于小文件用FileChannel的话还是不错的,对于大文件一定要用FileChannel的话可以配合ByteBuffer使用,不过从数据上看效果比BufferedInput/OutputStream要低. 再看看org.apache.commons.io.FileUtils与java.nio.file.Files的copy,差别不太,效果接近,但在1G的时候差距有点大. 遍历方式的话,java nio的walkFileTrees最快. 当然这些测试仅供参考,具体使用哪一个要看看具体环境,另外这种方式把遍历与复制分开,apache的FileUtils有方法可以直接复制目录的,因此,使用哪个更合适还需要个人具体测试. 8.源码 作者比较偷懒全部仍在一个文件了.七百行. import java.awt.*; import javax.swing.*; import java.nio.*; import java.nio.channels.*; import java.io.*; import java.nio.file.*; import java.nio.file.attribute.*; import java.util.*; import org.apache.commons.io.*; public class Test extends JFrame { public static final long serialVersionUID = 12398129389122L; private JFrame showTraverseMethod = new JFrame(&quot;遍历方式&quot;); private JFrame showCopyMethod = new JFrame(&quot;复制方式&quot;); private JButton traverseMethodButton = new JButton(&quot;请选择遍历方式&quot;); private JButton copyMethodButton = new JButton(&quot;请选择复制方式&quot;); private JButton copyButton = new JButton(&quot;开始复制&quot;); private JButton traverseByListFiles = new JButton(&quot;File.listFiles()&quot;); private JButton traverseByList = new JButton(&quot;File.list()&quot;); private JButton traverseByGetFiles = new JButton(&quot;(plexus)getFiles()&quot;); private JButton traverseByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton traverseByNIO2 = new JButton(&quot;NIO2&quot;); private JButton copyByFileStream = new JButton(&quot;File stream&quot;); private JButton copyByBufferStream = new JButton(&quot;Buffer stream&quot;); private JButton copyByFileReader = new JButton(&quot;File reader&quot;); private JButton copyByBufferReader = new JButton(&quot;Buffer reader&quot;); private JButton copyByFileChannel = new JButton(&quot;File channel&quot;); private JButton copyByFileChannelWithBuffer = new JButton(&quot;File channel with buffer&quot;); private JButton copyByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton copyByFiles = new JButton(&quot;Files.copy&quot;); public Test() { JButton src = new JButton(&quot;选择源文件(夹)&quot;); src.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new Label(), &quot;选择文件(夹)&quot;); FilesCopy.setSrc(fileChooser.getSelectedFile()); } ); JButton des = new JButton(&quot;选择目标文件夹&quot;); des.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new JLabel(),&quot;选择文件夹&quot;); FilesCopy.setDes(fileChooser.getSelectedFile()); } ); traverseMethodButton.addActionListener( event -&gt; { traverseByListFiles.addActionListener( e-&gt; { FilesCopy.setTraverseByListFiles(); showTraverseMethod.dispose(); } ); traverseByList.addActionListener( e -&gt; { FilesCopy.setTraverseByList(); showTraverseMethod.dispose(); } ); traverseByGetFiles.addActionListener( e -&gt; { FilesCopy.setTraverseByGetfiles(); showTraverseMethod.dispose(); } ); traverseByCommonsIO.addActionListener( e -&gt; { FilesCopy.setTraverseByCommonsIO(); showTraverseMethod.dispose(); } ); traverseByNIO2.addActionListener( e -&gt; { FilesCopy.setTraverseByNIO2(); showTraverseMethod.dispose(); } ); showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showTraverseMethod.setTitle(&quot;遍历方式&quot;); showTraverseMethod.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showTraverseMethod.setVisible(true); showTraverseMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showTraverseMethod.add(traverseByListFiles); showTraverseMethod.add(traverseByList); showTraverseMethod.add(traverseByGetFiles); showTraverseMethod.add(traverseByCommonsIO); showTraverseMethod.add(traverseByNIO2); traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); } ); copyMethodButton.addActionListener( event -&gt; { copyByFileStream.addActionListener( e -&gt; { FilesCopy.setCopyByFileStream(); showCopyMethod.dispose(); } ); copyByBufferStream.addActionListener( e -&gt; { FilesCopy.setCopyByBufferStream(); showCopyMethod.dispose(); } ); copyByFileReader.addActionListener( e -&gt; { FilesCopy.setCopyByFileReader(); showCopyMethod.dispose(); } ); copyByBufferReader.addActionListener( e -&gt; { FilesCopy.setCopyByBufferReader(); showCopyMethod.dispose(); } ); copyByFileChannel.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannel(); showCopyMethod.dispose(); } ); copyByFileChannelWithBuffer.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannelWithBuffer(); showCopyMethod.dispose(); } ); copyByCommonsIO.addActionListener( e -&gt; { FilesCopy.setCopyByCommonsIO(); showCopyMethod.dispose(); } ); copyByFiles.addActionListener( e -&gt; { FilesCopy.setCopyByFiles(); showCopyMethod.dispose(); } ); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); showCopyMethod.setTitle(&quot;复制方式&quot;); showCopyMethod.setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showCopyMethod.setVisible(true); showCopyMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showCopyMethod.add(copyByFileStream); showCopyMethod.add(copyByBufferStream); showCopyMethod.add(copyByFileReader); showCopyMethod.add(copyByBufferReader); showCopyMethod.add(copyByFileChannel); showCopyMethod.add(copyByFileChannelWithBuffer); showCopyMethod.add(copyByCommonsIO); showCopyMethod.add(copyByFiles); copyMethodButton.setVisible(false); remove(copyMethodButton); add(copyButton); copyButton.setVisible(true); } ); copyButton.addActionListener( event -&gt; { if(FilesCopy.haveSelectedSrcAndDes()) { FilesCopy.copy(); copyButton.setVisible(false); remove(copyButton); add(traverseMethodButton); traverseMethodButton.setVisible(true); } else JOptionPane.showMessageDialog(null,&quot;请先选择源文件(夹)与目标文件夹!&quot;); } ); setLayout(new GridLayout(3,1,5,3)); setTitle(&quot;复制文件&quot;); setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); add(src); add(des); add(traverseMethodButton); } public static void main(String[] args) { new Test(); } } class FilesCopy { private static File src = null; private static File des = null; private static long desSize = 0; private static long srcSize = 0; private static boolean [] traverseMethod = {false,false,false,false,false,false}; private static boolean[] copyMethod = { false, false, false, false, false, false ,false,false}; private static JFrame showProgressBar = new JFrame(); private static JProgressBar copyProgressBar = new JProgressBar(); private static JTextField textField = new JTextField(); private static int index = 0; private static int getCopyPercent() { return (int)(desSize * 100.0 / srcSize); } private static void addCopySize() { desSize += 1024L; } public static void setTraverseByListFiles() { traverseMethod[0] = true; } private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByList() { traverseMethod[1] = true; } private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByGetfiles() { traverseMethod[2] = true; } private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByCommonsIO() { traverseMethod[3] = true; } private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByNIO2() { traverseMethod[4] = true; } private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } public static void setCopyByFileStream() { copyMethod[0] = true; } private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } public static void setCopyByBufferStream() { copyMethod[1] = true; } private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } public static void setCopyByFileReader() { copyMethod[2] = true; } private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByBufferReader() { copyMethod[3] = true; } private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByFileChannel() { copyMethod[4] = true; } private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } public static void setCopyByFileChannelWithBuffer() { copyMethod[5] = true; } private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } public static void setCopyByCommonsIO() { copyMethod[6] = true; } private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } public static void setCopyByFiles() { copyMethod[7] = true; } private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } public static void setSrc(File srcFile) { src = srcFile; if(srcFile.isDirectory()) srcSize = org.apache.commons.io.FileUtils.sizeOfDirectory(srcFile); else srcSize = src.length(); } public static void setDes(File desFile) { des = desFile; desSize = 0; } public static void setSrc(Path srcPath) { setSrc(srcPath.toFile()); } public static void setDes(Path desPath) { setDes(desPath.toFile()); } private static void copyFile(File srcFile,File desFile) throws IOException { if (copyMethod[0]) copyByFileStream(srcFile,desFile); else if (copyMethod[1]) copyByBufferStream(srcFile, desFile); else if (copyMethod[2]) copyByFileReader(srcFile, desFile); else if (copyMethod[3]) copyByBufferReader(srcFile, desFile); else if (copyMethod[4]) copyByFileChannel(srcFile, desFile); else if (copyMethod[5]) copyByFileChannelWithBuffer(srcFile, desFile); else if (copyMethod[6]) copyByCommonsIO(srcFile, desFile); else if (copyMethod[7]) copyByFiles(srcFile, desFile); else showMessage(&quot;复制失败,找不到复制方法.&quot;); } private static void showMessage(String message) { JOptionPane.showMessageDialog(null, message); } public static boolean haveSelectedSrcAndDes() { return src != null &amp;&amp; des != null; } public static void copy() { long start = System.currentTimeMillis(); if(haveSelectedSrcAndDes()) { if(src.isFile()) { des = new File(des.getAbsolutePath()+File.separator+src.getName()); } SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); if (!copyMethod[4] &amp;&amp; !copyMethod[6] &amp;&amp; !copyMethod[7]) { copyProgressBar.setMinimum(0); copyProgressBar.setMaximum(100); copyProgressBar.setValue(0); copyProgressBar.setVisible(true); copyProgressBar.setStringPainted(true); showProgressBar.add(copyProgressBar); showProgressBar.setTitle(&quot;复制进度&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 150, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 50, 300, 100); showProgressBar.setVisible(true); new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); } else { final String [] text = {&quot;.&quot;,&quot;..&quot;,&quot;...&quot;,&quot;....&quot;,&quot;.....&quot;,&quot;.......&quot;,&quot;......&quot;,&quot;.....&quot;,&quot;....&quot;,&quot;...&quot;,&quot;..&quot;,&quot;.&quot;}; textField.setVisible(true); textField.setHorizontalAlignment(JTextField.CENTER); textField.setEditable(false); showProgressBar.add(textField); showProgressBar.setTitle(&quot;复制中&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 120, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 40, 240, 80); showProgressBar.setVisible(true); new Thread( () -&gt; { while (getCopyPercent() &lt; 100) { try { Thread.sleep(400); } catch(InterruptedException e) { e.printStackTrace(); } if(index &lt; text.length) textField.setText(&quot;复制中&quot;+text[index++]); else index = 0; } } ).start(); } } } private static void finish(long start) { long end = System.currentTimeMillis(); showProgressBar.dispose(); showMessage(&quot;复制成功,用时:&quot; + (end - start) / 1000.0 + &quot;s&quot;); copyProgressBar.setVisible(false); showProgressBar.remove(copyProgressBar); textField.setVisible(false); showProgressBar.remove(textField); Arrays.fill(traverseMethod, false); Arrays.fill(copyMethod, false); des = src = null; desSize = srcSize; } } ","link":"https://2293736867.github.io/post/java-duo-chong-wen-jian-fu-zhi-fang-shi-yi-ji-xiao-lu-bi-jiao/"},{"title":"聊聊java中final那点事","content":" 1.final是什么 2.final有什么用 3.final修饰成员变量 (1)修饰静态变量 (2)修饰普通成员变量 4.final修饰局部变量 (1)修饰形参 (2)修饰局部变量 (3)final修饰引用变量 5.final修饰方法 6.final修饰类 1.final是什么 final是一个java关键字,一个修饰符,可用于修饰变量,方法,修饰类. 2.final有什么用 final可以修饰变量时,可以使其值不能改变 final修饰方法时使其不能被重写 final修饰类时,使其不能被继承. 3.final修饰成员变量 fianl最常见的用法时用来修饰成员变量,成员变量分为静态变量与普通变量. 对于final修饰的变量,不是不能被赋值,是其值不能被改变,可以理解成只能赋一次值.可以在定义时赋值,也可以在定义后在另外赋值,但无论何种方式只能被赋值一次. (1)修饰静态变量 修饰静态变量时,可以选择以下两种方式赋值: 在定义时赋值 静态初始化块内赋值 final static int a = 6; final static int b; static { b = 6; } (2)修饰普通成员变量 修饰普通成员变量时,可以选择以下三种方式赋值: 定义时赋值 初始化块内赋值 构造方法赋值 public class test { int c = 1; int d; int e; { d = 2; } public test() { e = 3; } } 根据&quot;静态&quot;不能访问&quot;非静态&quot;规则,就是说静态的方法不能访问非静态成员,static初始化块不能初始化非静态成员,普通初始化块也不能初始化静态变量. 但是,有一个&quot;bug&quot;就是java允许通过方法访问final成员,因此...有趣的事情发生了. public class test { final int a; { System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } 以上这段代码会报错,因为java不允许final成员未初始化前访问. 把上面那一行出错的代码注释后...居然通过了编译?! public class test { final int a; { //System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } printA()中只是用方法包装了一下输出函数,居然就通过了编译...有没有兴趣看一下结果? emmmmmm....final&quot;默认值&quot;为0.....总之就不要想这些歪门邪道去在final初始化之前访问final变量了 ,在使用final变量前初始化,初始化,初始化,重要的事情说三遍. 4.final修饰局部变量 final修饰局部变量其实也分两种,一种是修饰形参,一种是修饰方法内部的局部变量 (1)修饰形参 没什么好说的...就是形参的值不能改变. public void f(final int a) { a = 3;//报错. } (2)修饰局部变量 修饰局部变量时可以定义时赋值,也可以在定义后在赋值(仅一次). public void f() { final int a = 3; final int b; b = 2; } (3)final修饰引用变量 嗯.....这个是一个特别一点的例子,Talk is cheap.上代码. import java.util.Arrays; public class test { public static void main(String[] args) { final int[] arr = {1,2,3}; arr[1] = 5; Arrays.stream(arr).forEach(System.out::print); System.out.println(); final A a = new A(); a.setA(9); System.out.println(a.getA()); } } class A { private int a = 3; public void setA(int a) { this.a = a; } public int getA() { return a; } } 为什么final数组可以赋值???fianl对象的值被改变了???看看结果: final数组居然被改变了??final对象的值也被改变了?? 其实呢,因为数组是引用类型,final修饰引用类型时,只能保证这个变量永远&quot;指向&quot;那一段内存空间,保存的仅仅是一个引用,但是那段内存空间的值是可以改变的.修饰对象时也是一样的道理. 5.final修饰方法 final修饰的方法不能被重写,当然,不能&quot;配合&quot;private&quot;使用&quot;,因为private把方法变成了私有,相当于对子类不可见,子类都不知道父类&quot;还有这玩意&quot;,就可以进行所谓的&quot;重写&quot;了. class A { private final void f(){} } class B extends A { public final void f(){}//没毛病 } 因为B类的f()是属于B类的,不是从A类继承过来的. 6.final修饰类 final修饰类时表示该类不能被继承. final class A{} class B extends A{}//出错 ","link":"https://2293736867.github.io/post/liao-liao-java-zhong-final-na-dian-shi/"},{"title":"java自定义的getInstance()返回泛型","content":"1.背景 实际中经常使用getInstance()方法返回一个对象,对于工厂模式,传入对应的参数返回与之相对应的对象.但是,问题来了,返回的对象需要被强制转换,很麻烦. import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(&quot;test1&quot;); test2 t2 = factory.getInstance(&quot;test2&quot;); } } class factory { public static Object getInstance(String className) { try { return Class.forName(className).getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } 编译不通过,说类型不兼容. 因此加上强制类型转换,编译通过了. test1 t1 = (test1)factory.getInstance(&quot;test1&quot;); test2 t2 = (test2)factory.getInstance(&quot;test2&quot;); 2.如何处理 例子只有两个类,手动强制转换还可以,但如果多个类咋办啊?而且作者是那种非常懒的人,也不想手动去转换,因此,用大招-----泛型! 3.使用泛型 使用Class&lt;T&gt; 泛型可以避免强制转换从而更有效地偷懒 ,需要把返回类型改成&lt;T&gt; T,同时由于使用了T,必须修改传进来的参数. public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(test1.class); test2 t2 = factory.getInstance(test2.class); } } class factory { public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) { try { return t.getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } ","link":"https://2293736867.github.io/post/java-zi-ding-yi-de-getinstancefan-hui-fan-xing/"},{"title":"java反射Array的使用","content":" 1.什么是Array 2.Array有什么用 3.Array使用示例 (1)创建 (2)赋值 (3)获取值 (4)强制类型转换 4.完整代码 5.运行结果 1.什么是Array Array是一个类的简写,全限定类名是java.lang.reflect.Array. 2.Array有什么用 Array可以代表所有的数组,可以通过Array动态创建与修改里面的元素. 3.Array使用示例 (1)创建 使用静态方法newInstance()构造Object对象.方法如下: public static Object newInstance(Class&lt;?&gt; element, int ... length); 第一个参数是代表元素的类,剩下的参数表示维数,一个参数表示一维数组,两个参数表示二维数组(数组的数组),参数的值代表维数的长度. Object intArray = Array.newInstance(int.class,3); //int [3] Object stringArray = Array.newInstance(String.class,2,3); //String [2][3] (2)赋值 赋值使用静态方法set即可,参数为Array返回的Object对象,下标与对应的值. public static void set(Object array,int index,Object value); public static void setBoolean(Object array,int index,boolean b); public static void setXxxx(Object array,int index,xxx); 其中最后一个表示对应的基本类型,第二个为boolean类型的示例. Array.set(intArray,2,3); Array.set(stringArray,1,new String[]{&quot;123&quot;,&quot;456&quot;}); (3)获取值 使用静态方法get,参数为Array返回的Object对象与下标. public static Object get(Object array,int index); public static boolean getBoolean(Object array,int index); public static xxx getXxx(Object array,int index); 最后一个表示对应的基本类型,第二个为boolean类型的示例 System.out.println(Array.get(intArray,2)); System.out.println(Array.get(Array.get(stringArray,1),1)); (4)强制类型转换 可以通过强制类型转换使Array返回的Object对象转换为对应的数组. var castIntArray = (int [])intArray; var castStringArray = (String [][])stringArray; 这样可以当作一个普通数组使用. 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { var intArray = Array.newInstance(int.class, 3); var stringArray = Array.newInstance(String.class, 2,3); Array.set(intArray, 2, 3); Array.set(stringArray, 1, new String[] { &quot;123&quot;, &quot;456&quot; }); System.out.println(Array.get(intArray, 2)); System.out.println(Array.get(Array.get(stringArray,1),1)); System.out.println(&quot;-------cast-------&quot;); System.out.println(((int[]) intArray)[2]); System.out.println(((String [][])stringArray)[1][1]); } } 5.运行结果 ","link":"https://2293736867.github.io/post/java-fan-she-array-de-shi-yong/"},{"title":"log4j2入门hello world","content":" 1.什么是log4j2 (1)log4j (2)log4j2 3.VScode下使用log4j2(不用Maven) (1)准备jar包 (2)准备插件 (3)创建项目 (4)设置jar包路径 (5)新建测试文件 (6)运行 (7)创建配置文件使其输出更多信息 (8)再次运行 4.VScode下使用log4j2(带Maven) (1)创建maven项目 (2)在pom.xml配置依赖 (3)创建log4j2.xml (4)修改测试类 (5)测试 5.IDEA下使用log4j2(不用Maven) (1)创建项目 (2)添加jar包 (3)新建测试类 (4)新建log4j2.xml (5)测试 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 (2)配置依赖 (3)创建log4j2.xml (4)创建测试类 (5)测试 1.什么是log4j2 (1)log4j log4j是apache的一个开源项目,表示log for java.是一个日志工具,可以将日志信息输出到文件,控制台等其他地方 ,还可以定义日志的输出格式,另外还有日志级别的区分,可通过配置文件去配置输出格式,输出目的地等信息. (2)log4j2 log4j2从名字就知道了,是log4j的升级版本,性能有了很大提升,增加了很多新特性(如自定义级别,lambda表达式)与新的API,直接与tomcat等服务器集成. 3.VScode下使用log4j2(不用Maven) (1)准备jar包 点击这里下载 作者用的是win10,下载zip. (2)准备插件 搜索安装:Eclipse New Java Project (3)创建项目 ctrl+shift+p调出命令面板,输入new java project 项目名 JavaSE版本 创建完毕. (4)设置jar包路径 在项目根路径下新建lib文件夹,把下载的 这两个jar包放进去. 下一步设置.classpath. 添加 &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-api-2.12.1.jar&quot; /&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-core-2.12.1.jar&quot; /&gt; (5)新建测试文件 src下直接建立test.java test.java: import org.apache.logging.log4j.*; public class test { private final static Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (6)运行 点击main上的Run 结果: 输出了fatel与error信息. 另外还提示了没有找到log4j2配置文件,使用默认的配置文件,默认输出到控制台. (7)创建配置文件使其输出更多信息 src下创建log4j2.xml配置文件. log4j2的配置文件只能是.xml或.json或.jsn文件,默认会在classpath下寻找(在这里classpath相当于图中的src). 默认情况下系统选择配置文件的优先级如下: 1.classpath下名为 log4j-test.json 或者log4j-test.jsn文件 2.classpath下名为 log4j2-test.xml 3.classpath下名为 log4j.json 或者log4j.jsn文件 4.classpath下名为 log4j2.xml 这里使用log4j2. xml.log4j2.xml如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Logger三个主要的组件为 logger(记录器) appender(输出目的地) layout(布局,定义日志的格式) &lt;appenders&gt;了输出目的地,&lt;Console&gt;表示控制台,&lt;PatternLayout&gt;定义了布局,里面的布局表示时间格式(%d,HH:mm:ss.SSS),接着是日志线程名(%t),%-5表示最小长度为5左对齐,level表示输出日志级别. %logger表示输出logger名称. %m是%msg与%message的缩写,表示输出应用提供的与记录事件有关的信息. %n表示换行. &lt;loggers&gt;定义的logger与logger使用的appender.root为log默认的输出形式,如果一个类的没有明确loggers中的输出格式就会采用root的格式. (8)再次运行 没有之前的&quot;没有配置文件&quot;的提示了. 4.VScode下使用log4j2(带Maven) (1)创建maven项目 使用插件maven for java创建,命令面板(ctrl+shift+p)输入. 选择quickstart. 选择版本. 最后选择项目路径即可. 在控制台中vscode会下载相关文件,然后会提示以交互模式创建: 这里等一会就好了. 然后会提示输入一些值. ok. (2)在pom.xml配置依赖 在&lt;dependencies&gt;中添加如下代码: &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; 以下是完整的pom.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;/project&gt; 右键选择Update project configuration. (3)创建log4j2.xml 在java目录下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.App&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)修改测试类 修改默认的App.java. package com.example; import org.apache.logging.log4j.*; public class App { private static final Logger logger = LogManager.getLogger(App.class.getName()); public static void main( String[] args ) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 run即可. 5.IDEA下使用log4j2(不用Maven) (1)创建项目 什么也不用选,直接next. 勾选从模板创建项目. 选好路径与填好项目名即可. (2)添加jar包 选择刚才的lib目录,或者自己手动改成两个jar包(log4j-api-版本.jar,log4j-core-版本.jar). (3)新建测试类 项目结构如下: Main.java package com.test; import org.apache.logging.log4j.*; public class Main { private static final Logger logger = LogManager.getLogger(Main.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (4)新建log4j2.xml 在src下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.test.Main&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (5)测试 直接点击run按钮. 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 这里作者偷懒就直接在上面项目的基础上新建模块不新建项目了. 都不用选直接next. 填好GroupId与ArtifactId之后next. 最后选好位置. (2)配置依赖 pom.xml中加入: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下是完整的pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 右键选择同步pom.xml. 选择右下角弹出的提示中的Import Changes. (3)创建log4j2.xml 在target下的classes下创建log4j2.xml. log4j2.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)创建测试类 创建包与test.java. test.java package com.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class test { private static final Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 新建配置Application. 输入Main class与名字. run. 参考: 1.log4j2(1) 2.log4j2(2) 3.log4j2(3) 4.log4j2(4) 5.log4j2(5) ","link":"https://2293736867.github.io/post/log4j2-ru-men-hello-world/"},{"title":"java通过ServerSocket与Socket实现通信","content":" 1.ServerSocket (1) (2) (3) 2.Socket (1) (2) (3) (4) 3.服务器端 4.客户端 5.运行结果 6.Socket设置超时 首先说一下ServerSocket与Socket. 1.ServerSocket ServerSocket是用来监听客户端Socket连接的类,如果没有连接会一直处于等待状态. ServetSocket有三个构造方法: (1) ServerSocket(int port); 这个使用指定的端口去创建ServerSocket,IP地址使用默认的本地IP地址. (2) ServetSocket(int port,int backlog); 除了端口外,还有一个用来改变队列长度参数的backlog,指定当服务器繁忙时,可以与之保持连接请求的客户端数量,默认为50. (3) ServetSocket(int port,int backlog,InetAddress ip); 这个使用指定的端口,backlog,ip地址去创建ServerSocket. (这里简单提一下InetAddress,InetAddress没有构造方法,只有两个静态方法获取InetAddress对象,分别是 getByName(String hostName); getByAddress(byte[] address); ) 2.Socket Socket一般用来连接到服务器,程序通过Socket发出网络请求或应答网络请求. Socket有三个构造方法: (1) Socket(InetAddress address,int port); 使用指定IP与指定端口构造Socket,对于本地地址,默认使用本地ip,对于本地端口则动态分配. (2) Socket(String address,int port); 与(1)一样,使用String表示远程ip. (3) Socket(InetAddress address,int port,InetAddress localAddr,int localPort); 创建指定了远程ip,远程端口,本地ip,本地端口的Socket. (4) Socket(String address,int port,InetAddress localAddr,int localPort) 与(2)类似,使用String表示远程ip,用InetAddress表示本地ip. 了解了ServerSocket与Socket后可以编写实现简单的通信了. 3.服务器端 import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(12345);//这个端口自己随意,建议1024以上未使用的端口. while(true) { Socket socket = serverSocket.accept();//一直等待来自客户端的请求. PrintStream printStream = new PrintStream(socket.getOutputStream());//创建输出流 printStream.println(&quot;Server message.&quot;); printStream.close(); socket.close(); } } } 说一下ServetSocket的accept()方法: Socket accept(); 没有参数,返回一个Socket,如果接收到客户端的一个Socket,则返回,否则一直处于等待状态,线程也被阻塞. 4.客户端 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetAddress; import java.net.Socket; public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(&quot;This message comes from server:&quot;+bufferedReader.readLine()); bufferedReader.close(); socket.close(); } } Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); 表示创建一个本地地址,端口为12345的Socket,创建好了后服务器的.accept()方法就会接收到这个Socket,并创建输出流输出相应信息,然后客户端从Socket获取输入流进行读取,读取到了来自服务器的信息. 5.运行结果 (由于作者的漂亮终端不知道什么原因坏了....只能让用VScode的默认终端了....) 先运行服务器端的代码: 服务器端这边因为accept()方法会一直阻塞直到客户端发送请求. 客户端这边一运行就收到了来自服务器端的信息. 6.Socket设置超时 可以为Socket设置超时设置,当Socket超过这个时间没有连接上时系统会认为连接失败. Socket socket = new Socket(&quot;127.0.0.1&quot;,12345); socket.setToTimeout(10000);//单位:ms,在这里是10s 但是未连接上之前无法创建Socket对象,并且Socket没有提供指定超时的构造方法,因此常见的做法是先创建一个无连接的Socket,再调用connect()方法连接. Socket socket = new Socket(); socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,12345),12345); connect()方法其实有两个重载方法,分别是 void connect(SocketAddress endpoint); void connect(SocketAddress endpoint,int timeout); 对于第一个connect()官方文档没有提及超时之类的,就是直接连接. 对于第二个connect,timeout指定的超时时间,单位为ms,设置为0则为无限期等待. 参考链接 1.socket ","link":"https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/"},{"title":"java7与java9中的try-finally关闭资源","content":"1.java7中的try 在java7之前,对于一些需要使用finally关闭资源的操作,会显得很臃肿. try { // } catch(Exception e) { // } finally { if(xxxx != null) { xxxx.close(); } } 在java7中引入了可以在try中直接声明需要关闭的资源的功能,在try后的圆括号直接定义一个或多个资源即可. try( var xxx = new xxx(); var xxx = new xxx(); ) { // } 但是这些类都需要实现了Closeable或AutoCloseable接口,实现其中的close(). 2.Closeable接口 Closeable接口是AutoCloseable的子接口,其中的close()抛出了IOException异常,实现接口时要注意抛出的异常需是IOException异常或IOException子类异常. 3.AutoCloseable接口 AutoCloseable接口中的close()抛出的异常是Exception,实现接口时可以抛出任何类型的异常. java7几乎把所有的&quot;资源类&quot;(包括文件IO的各种类,JDBC编程的Connection,Statement等接口)进行了改写,改写后的资源都实现了AutoCloseable或Closeable接口.(引自&lt;&lt;疯狂Java讲义&gt;&gt;(第5版) P381) 4.java9中的try java9不像java7一样在try中定义资源,只需要自动关闭的资源有final修饰即可.也就是说,可以不在try中声明,在try前声明且使用final修饰即可. final var xxx = new xxx(); final var xxx = new xxx(); try(xxx;xxx) { // } ","link":"https://2293736867.github.io/post/java7-yu-java9-zhong-de-try-finally-guan-bi-zi-yuan/"},{"title":"一文带你理解脏读,幻读,不可重复读与mysql的锁,事务隔离机制","content":" 1 ACID (1) A:原子性(Atomicity) (2) C:一致性(Consistency) (3) I:隔离性(Isolation) (4) D:持久性(Durability) 2 Mysql的锁 (1) S锁与X锁 Ⅰ.S锁 Ⅱ.X锁 (2) 乐观锁与悲观锁 Ⅰ.乐观锁 Ⅱ.悲观锁 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 (2) 幻读 (3) 不可重复读 (4) 第一类丢失更新 (5) 第二类丢失更新 5 封锁协议与隔离级别 (1) 一级封锁协议 a.引发脏读 b.引发幻读 c.引发不可重复读 (2) 二级封锁协议 Ⅰ.Read committed a.避免脏读 b.引发幻读 c.引发不可重复读 Ⅱ.Repeatable read a.避免脏读 b.避免不可重复读 c.引发幻读 (3) 三级封锁协议 a.避免脏读 b.避免幻读 c.避免不可重复读 6 两段锁协议 (1) 加锁 (2) 解锁 首先说一下数据库事务的四大特性 1 ACID 事务的四大特性是ACID(不是&quot;酸&quot;....) (1) A:原子性(Atomicity) 原子性指的是事务要么完全执行,要么完全不执行. (2) C:一致性(Consistency) 事务完成时,数据必须处于一致的状态.若事务执行途中出错,会回滚到之前的事务没有执行前的状态,这样数据就处于一致的状态.若事务出错后没有回滚,部分修改的内容写入到了数据库中,这时数据就是不一致的状态. (3) I:隔离性(Isolation) 同时处理多个事务时,一个事务的执行不能被另一个事务所干扰,事务的内部操作与其他并发事务隔离. (4) D:持久性(Durability) 事务提交后,对数据的修改是永久性的. 2 Mysql的锁 Mysql的锁其实可以按很多种形式分类: 按加锁机制分,可分为乐观锁与悲观锁. 按兼容性来分,可分为X锁与S锁. 按锁粒度分,可分为表锁,行锁,页锁. 按锁模式分,可分为记录锁,gap锁,next-key锁,意向锁,插入意向锁. 这里主要讨论S锁,X锁,乐观锁与悲观锁. (1) S锁与X锁 S锁与X锁是InnoDB引擎实现的两种标准行锁机制.查看默认引擎可使用 show variables like '%storage_engine%'; 作者的mysql版本为8.0.17,结果如下: 先建好测试库与测试表,很简单,表就两个字段. create database test; use test; create table a ( id int primary key auto_increment, money int ); Ⅰ.S锁 S锁也叫共享锁,读锁,数据只能被读取不能被修改. 玩一下,上锁! lock table a read; 然后..... 只能读不能改,删,也不能增. Ⅱ.X锁 X锁也叫排他锁,写锁,一个事务对表加锁后,其他事务就不能对其进行加锁与增删查改操作. 设置手动提交,开启事务,上X锁. set autocmmmit=0; start transaction; lock table a write; 在开启另一个事务,使用select语句. set autocommit=0; start transaction; select * from a; 这里是阻塞select操作,因为一直都没释放X锁. 同样也不能再加锁,也是阻塞中. 回到原来那个加锁的事务,嗯,什么事也没有,正常读写. 释放锁后: unlock table; 在另一个事务中可以看到中断时间. (2) 乐观锁与悲观锁 Ⅰ.乐观锁 乐观锁就是总是假设是最好的情况,每次去操作的时候都不会上锁,但在更新时会判断有没有其他操作去更新这个数据,是一种宽松的加锁机制. mysql本身没有提供乐观锁的支持,需要自己来实现,常用的方法有版本控制和时间戳控制两种. 版本控制 版本控制就是为表增加一个version字段,读取数据时连同这个version字段一起读出来,之后进行更新操作,版本号加1,再将提交的数据的版本号与数据库中的版本号进行比较,若提交的数据的版本号大于数据库中的版本号才会进行更新. 举个例子,假设此时version=1,A进行操作,更新数据后version=2,与此同时B也进行操作,更新数据后version=2,A先完成操作,率先将数据库中的version设置为2,此时B提交,B的version与数据库中的version一样,不接受B的提交. 时间戳控制 时间戳控制与版本控制差不多,把version字段改为timestamp字段 还有一种实现方法叫CAS算法,这个作者不怎么了解,有兴趣可以自行搜索. Ⅱ.悲观锁 悲观锁就是总是假设最坏的情况,在整个数据处理状态中数据处于锁定状态,悲观锁的实现往往依靠数据库的锁机制.每次在拿到数据前都会上锁. mysql在调用一些语句时会上悲观锁,如(先关闭自动提交,开启事务): set autocommit=0; start transaction; 两个事务都这样操作,然后其中一个事务输入: select * from a where xxx for update; 在另一事务也这样输入: 这时语句会被阻塞,直到上锁的那个事务commit(解开悲观锁). 在另一事务中可以看到这个事务被阻塞了2.81s. *** lock in share mode. 也会加上悲观锁. 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 脏读是指一个事务读取到了另一事务未提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据,但没有提交,此时事务B却读取了,这时事务B就形成了脏读,一般事务A的后续操作是回滚,事务B读取到了临时数值. 事务A 事务B 开始事务 开始事务 更新X,旧值X=1,新值X=2 读取X,X=2(脏读) 回滚X=1 结束事务(X=1) 结束事务 (2) 幻读 幻读是指并不是指同一个事务执行两次相同的select语句得到的结果不同, 而是指select时不存在某记录,但准备插入时发现此记录已存在,无法插入,这就产生了幻读. 事务A 事务B 开始事务 开始事务 select某个数据为空,准备插入一个新数据 插入一个新数据 提交,结束事务 插入数据,发现插入失败,由于事务B已插入相同数据 结束事务 (3) 不可重复读 不可重复读指一个事务读取到了另一事务已提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据并且提交了,此时事务B却读取了,这时事务B就形成了不可重复读. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交,结束事务 读取X=2 结束事务 (4) 第一类丢失更新 第一类丢失更新就是两个事务同时更新一个数据,一个事务更新完毕并提交后,另一个事务回滚,造成提交的更新丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 修改X=2 修改X=3 提交,结束事务 回滚 结束事务(X=1) X=1,X本应为提交的3 (5) 第二类丢失更新 第二类丢失更新就是两个事务同时更新一个数据,先更新的事务提交的数据会被后更新的事务提交的数据覆盖,即先更新的事务提交的数据丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交事务,X=2,结束 更新X=3 提交事务,X=3,事务A的更新丢失,结束 5 封锁协议与隔离级别 封锁协议就是在用X锁或S锁时制定的一些规则,比如锁的持续时间,锁的加锁时间等.不同的封锁协议对应不同的隔离级别.事务的隔离级别一共有4种,由低到高分别是Read uncommitted,Read committed,Repeatable read,Serializable,分别对应的相应的封锁协议等级. (1) 一级封锁协议 一级封锁协议对应的是Read uncommitted隔离级别,Read uncommitted,读未提交,一个事务可以读取另一个事务未提交的数据,这是最低的级别.一级封锁协议本质上是在事务修改数据之前加上X锁,直到事务结束后才释放,事务结束包括正常结束(commit)与非正常结束(rollback). 一级封锁协议不会造成更新丢失,但可能引发脏读,幻读,不可重复读. 设置手动提交与事务隔离等级为read uncommited,并开启事务(注意要先设置事务等级再开启事务). set autocommit=0; set session transaction isolation level read uncommitted; start transaction; (中间有一行打多了一个t可以忽略.....) a.引发脏读 在一个事务中修改表中的值,不提交,另一个事务可以select到未提交的值. 出现了脏读. b.引发幻读 在一个事务中插入一条数据,提交. 另一事务中select时没有,准备insert,但是insert时却提示已经存在.引发幻读. c.引发不可重复读 未操作提交前: 另一事务修改并提交: 再次读: 引发不可重复读. (2) 二级封锁协议 二级封锁协议本质上在一级协议的基础上(在修改数据时加X锁),在读数据时加上S锁,读完后立即释放S锁,可以避免脏读.但有可能出现不可重复读与幻读.二级封锁协议对应的是Read committed与Repeatable Read隔离级别. 先设置隔离等级 set session transaction isolation level read committed; Ⅰ.Read committed Read committed,读提交,读提交可以避免脏读,但可能出现幻读与不可重复读. a.避免脏读 开启一个事务并更新值,在这个事务中money=100(更新后) 另一事务中money为未更新前的值,这就避免了脏读. 注意,事实上脏读在read committed隔离级别下是不被允许的,但是mysql不会阻塞查询,而是返回未修改之前数据的备份,这种机制叫MVCC机制(多版本并发控制). b.引发幻读 在一个事务中插入数据并提交. 另一事务中不能插入&quot;不存在&quot;的数据,出现幻读. c.引发不可重复读 事务修改并提交前: 事务修改并提交: 出现不可重复读. Ⅱ.Repeatable read Repeatable read比Read committed严格一点,是Mysql的默认级别,读取过程更多地受到MVCC影响,可防止不可重复读与脏读,但仍有可能出现幻读. a.避免脏读 在一个事务中修改数据,不提交. 另一事务中两次select的结果都不变,没有出现脏读. b.避免不可重复读 一个事务修改数据并提交. 另一事务中select的结果没有发生改变,即没有出现不可重复读. c.引发幻读 同理,一个事务插入一条数据并提交. 另一个事务插入时出现幻读. (3) 三级封锁协议 三级封锁协议,在一级封锁协议的基础上(修改时加X锁),读数据时加上S锁(与二级类似),但是直到事务结束后才释放S锁,可以避免幻读,脏读与不可重复读.三级封锁协议对应的隔离级别是Serializable. 先设置Serializable隔离级别 set session transaction isolation level serializable a.避免脏读 设置事务隔离等级后开启事务并update,发现堵塞.从而避免了脏读. b.避免幻读 插入时直接阻塞,避免了幻读. c.避免不可重复读 在脏读的例子中可以知道,update会被堵塞,都不能提交事务,因此也避免了不可重复读. 6 两段锁协议 事务必须分为两个阶段对数据进行加锁与解锁,两端锁协议叫2PL(不是2PC),所有的加锁都在解锁之前进行. (1) 加锁 加锁会在更新或者 select *** for update *** lock in share mode 时进行 (2) 解锁 解锁在事务结束时进行,事务结束包括rollback与commit. 参考链接 1:ACID1 2:ACID2 3:mysql的锁1 4:乐观锁与悲观锁1 5:乐观锁与悲观锁2 6:乐观锁与悲观锁3 7:mysql修改事务隔离等级 8:mysql三级封锁与二段锁 9:数据库封锁协议 10:mysql事务隔离机制1 11:mysql事务隔离机制2 12:mysql幻读 13:mysql脏读,不可重复读与幻读 14:mysql两段锁1 15:mysql两段锁2 ","link":"https://2293736867.github.io/post/yi-wen-dai-ni-li-jie-zang-du-huan-du-bu-ke-chong-fu-du-yu-mysql-de-suo-shi-wu-ge-chi-ji-zhi/"},{"title":"android通过web与后台数据库交互","content":" 1.背景 2.开发环境 3.相关资源 4.配置开发环境 一. 安装Mysql8.0.17 (1) 下载mysql (2) 安装mysql (3) 启动服务 (4) 查看初始化密码,用于下一步设置自己的root密码 (5) 本地使用root登录 (6) 更改密码 (7) 允许外部访问 (8) 配置防火墙(可选) 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 (2) 连接到服务器,解压压缩包 (3) 修改tomcat默认端口(可选) (4) 启动tomcat (5) 测试 (6)开机启动 5.建库建表 (1) 创建user.sql (2) 导入到数据库 6.后端部分 (1) 创建项目 (2) 添加jar包 (3) 创建包与类 (4) 先来处理DBUtils类 (5) 接下来处理User类 (6) 接下来是UserDao (7) servlet包的SignIn与SignUp类 (8) 添加servlet到web.xml (9) 最后添加一个叫Hello.html的html文件用于测试. 7.打包发布 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (6) 添加Hello.html与web.xml (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 (9) 测试 8.前端页面部分 (1) 新建工程 (2) MainActivity.java (3) UserService.java (4) activity_main.xml 9.测试 (1) 注册测试 (2) 登录测试 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 (2) 网络权限问题 (3) 防火墙问题 (4) 使用HTTP注意事项 * * * 1 使用HTTPS * 2 修改默认的AndroidManifest.xml使其允许HTTP连接 (5) 线程问题 (6) AVD问题 11 最后 1.背景 开发一个app与后台数据库交互,基于mysql+jdbc+tomcat,没有使用DBUtils或jdbc框架,纯粹底层jdbc实现. 以后逐步改用Spring框架,优化mysql,进一步部署tomcat等等,现在项目刚刚起步,还有很多不懂的东西,得慢慢来...... 这几天踩了很多坑,说得夸张点真是踩到我没有知觉,希望能帮助别人少踩坑... 2.开发环境 系统 : win10 IDE : Android Studio 3.5.1,IntelliJ IDEA 2019.02 DBMS : Mysql 8.0.17 web服务器: tomcat9 3.相关资源 1.相关jar包: mysqlV8.0.17驱动(注意这个要与自己的mysql版本对应) java-servlet-api-V4.0.1 其他版本可以来这里搜索下载 Maven仓库 2.github 这是源码地址,包括前后端与建表等所有代码. (欢迎star) 3.码云 这也是源码地址 4.配置开发环境 IDE就不说了,重点说一下mysql与tomcat9的安装 一. 安装Mysql8.0.17 这个是目前比较新的mysql版本. 服务器系统是centos 其他系统安装看这里 win10 ubuntu fedroa reahat centos使用yum命令安装(参考链接) (1) 下载mysql sudo yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm (2) 安装mysql sudo yum install mysql-community-server (3) 启动服务 sudo service mysqld start (4) 查看初始化密码,用于下一步设置自己的root密码 sudo grep 'temporary password' /var/log/mysqld.log (5) 本地使用root登录 mysql -u root -p 输入上一步看到的密码 (6) 更改密码 alter mysql.user 'root'@'localhost' identified by 'password'; 注意新版本的mysql不能使用太弱的密码 如果出现如下提示 则说明密码太弱了,请使用一个更高强度的密码 (7) 允许外部访问 use mysql; update user set host='%' where user='root'; 这个可以根据自己的需要去修改,host='%'表明允许所有的ip登录,也可以设置特定的ip,若使用host='%'的话建议新建一个用户配置相应的权限. (8) 配置防火墙(可选) 由于作者使用的是阿里云的服务器,没配置防火墙的话远程连接不上,因此需要手动配置,如图 其中授权对象可以根据自己的需要更改,0.0.0.0/0表示允许所有的ip. 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 作者使用的是scp命令,不会的可以看这里 scp apache-tomcat-xxxx.tar.gz username@xx.xx.xx.xx:/ 改成自己的用户名和ip (2) 连接到服务器,解压压缩包 mkdir /usr/local/tomcat mv apache-tomcat-xxxx.tar.gz /usr/local/tomcat tar -xzvf apache-tomcat-xxx.tar.gz (3) 修改tomcat默认端口(可选) 修改conf/server.xml文件,一般只需修改 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 中的8080端口,修改这个端口即可 这个懒的话(比如作者)可以不改 (4) 启动tomcat 运行bin目录下的startup.sh cd bin ./startup.sh (5) 测试 浏览器输入 服务器IP:端口 若出现 则表示成功. (6)开机启动 建议配置开机启动,修改/etc/rc.local文件 vim /etc/rc.local 添加 sh /usr/local/tomcat/bin/startup.sh 这个根据自己的tomcat安装路径修改,指定bin下的startup.sh即可 5.建库建表 创建用户表,这里简化操作(好吧我喜欢偷懒)就不创建新用户不授权了 这是一个在本地用root登录的示例,请根据实际情况创建并授权用户. (1) 创建user.sql CREATE DATABASE userinfo; USE userinfo; CREATE TABLE user ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NULL, password CHAR(30) NULL ); (2) 导入到数据库 mysql -u root -p &lt; user.sql 6.后端部分 (1) 创建项目 选择web application 选好路径,改好名字后finish (2) 添加jar包 创建一个叫lib的目录 添加两个jar包: mysql-connector-java-8.0.17.jar javax.servlet-api-4.0.1.jar 打开Project Structure Modules--&gt; + --&gt; JARs or directories 选择刚才新建的lib下的两个jar包 打勾,apply (3) 创建包与类 总共4个包 com.servlet 用于处理来自前端的请求,包含SignUp.java,SignIn.java com.util 主要功能是数据库连接,包含DBUtils.java com.entity 用户类,包含User.java com.dao 操作用户类的类,包含UserDao.java (4) 先来处理DBUtils类 这个是连接数据库的类,纯粹的底层jdbc实现,注意驱动版本. package com.util; import java.sql.*; public class DBUtils { private static Connection connection = null; public static Connection getConnection() { try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; connection = DriverManager.getConnection(url,usename,password); } catch (Exception e) { e.printStackTrace(); return null; } return connection; } public static void closeConnection() { if(connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 主要就是获取连接与关闭连接两个函数. String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; 这几行根据自己的用户名,密码,服务器ip和库名修改 注意,mysql8.0以上使用的注册驱动的语句是 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 旧版的是 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 注意对应. (5) 接下来处理User类 User类比较简单,就是就三个字段与getter,setter package com.entity; public class User { private int id; private String name; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } (6) 接下来是UserDao package com.dao; import com.entity.User; import com.util.DBUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class UserDao { public boolean query(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;select * from user where name = ? and password = ?&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); ResultSet resultSet = preparedStatement.executeQuery(); return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } public boolean add(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;insert into user(name,password) values(?,?)&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } } 主要就是查询与添加操作,查询操作中存在该用户就返回true,否则返回false 添加操作中使用executeUpdate()与getUpdateCount() != 0.注意不能直接使用 return preparedStatement.execute(); 去代替 preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; 咋一看好像没有什么问题,那天晚上我测试的时候问题可大了,android那边显示注册失败,但是数据库这边的却insert进去了.........我...... 好吧说多了都是泪,还是函数用得不够熟练. 一般来说select使用executeQuery() executeQuery()返回ResultSet,表示结果集,保存了select语句的执行结果,配合next()使用 delete,insert,update使用executeUpdate() executeUpdate()返回的是一个整数,表示受影响的行数,即delete,insert,update修改的行数,对于drop,create操作返回0 create,drop使用execute() execute()的返回值是这样的: 如果第一个结果是ResultSet对象,则返回true 如果第一个结果是更新计数或者没有结果则返回false 所以在这个例子中 return preparedStatement.execute(); 肯定返回false,所以才会数据库这边insert进去,但前端显示注册失败(这个bug作者找了很久......) (7) servlet包的SignIn与SignUp类 SingIn类用于处理登录,调用jdbc查看数据库是否有对应的用户 SignUp类用于处理注册,把user添加到数据库中 这两个使用的是http连接,后期作者会采用https加密连接. SignIn.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/SignIn&quot;) public class SingIn extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException, ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.query(user))//若查询失败 { httpServletResponse.sendError(204,&quot;query failed.&quot;);//设置204错误码与出错信息 } } } @WebServlet(&quot;/SignIn&quot;) 这行代码表示这是一个名字叫SignIn的servlet,可用于实现servlet与url的映射,如果不在这里添加这个注解,则需要在WEB-INF目录下的web.xml添加一个 &lt;servlet-mapping&gt; 叫servlet的映射 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 这行代码设置响应类型与编码 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); HttpServletRequest.getParameter(String name)方法表示根据name获取相应的参数 下面是SignUp.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.annotation.*; import javax.servlet.http.*; import javax.servlet.*; import java.io.IOException; @WebServlet(&quot;/SignUp&quot;) public class SignUp extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//设定编码防止中文乱码 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;);//根据name获取参数 String password = httpServletRequest.getParameter(&quot;password&quot;);//根据password获取参数 UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.add(user)) //若添加失败 { httpServletResponse.sendError(204,&quot;add failed.&quot;);//设置204错误码与出错信息 } } } (8) 添加servlet到web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SingIn&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignUp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SignUp&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;/web-app&gt; 要把刚才创建的Servlet添加进web.xml,在&lt;servlet&gt;中添加子元素&lt;servlet-name&gt;与&lt;servlet-class&gt; &lt;servlet-name&gt;是Servlet的名字,最好与类名一致. &lt;servlet-class&gt;是Servlet类的位置. 如果在Servlet类中没有添加 @WebServlet(&quot;/xxxx&quot;) 这个注解,则需要在web.xml中添加 &lt;servlet-mapping&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;url-pattern&gt;/SignIn&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中&lt;servlet-name&gt;与&lt;servlet&gt;中的子元素&lt;servlet-name&gt;中的值一致 &lt;url-pattern&gt;是访问的路径 (9) 最后添加一个叫Hello.html的html文件用于测试. &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello web. &lt;/body&gt; &lt;/html&gt; 7.打包发布 作者用的是IDEA,Eclipse的打包请看这里 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (那个lib文件夹被挡住了.....) (6) 添加Hello.html与web.xml web.xml这个需要在WEB-INF目录里,Hello.html在WEB-INF外面 (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 把打包好的.war文件上传到服务器的tomcat的/webapps目录下的 scp ***.war username@xxx.xxx.xxx.xxx:/usr/local/tomcat/webapps 注意改成自己的webapps目录. (9) 测试 在浏览器输入 服务器IP:端口/项目/Hello.html 作者是在本地上开了tomcat后测试的 8.前端页面部分 (1) 新建工程 (2) MainActivity.java package com.cx; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button signin = (Button) findViewById(R.id.signin); signin.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signIn(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); Button signup = (Button) findViewById(R.id.signup); signup.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signUp(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); } } 没什么好说的,就为两个Button绑定事件,然后设置两个Toast提示信息. (3) UserService.java package com.cx; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; public class UserService { public static boolean signIn(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } public static boolean signUp(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } } class MyThread extends Thread { private String path; private String name; private String password; private boolean result = false; public MyThread(String path,String name,String password) { this.path = path; this.name = name; this.password = password; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000);//设置连接超时时间 httpURLConnection.setReadTimeout(8000);//设置读取超时时间 httpURLConnection.setRequestMethod(&quot;POST&quot;);//设置请求方法,post String data = &quot;name=&quot; + URLEncoder.encode(name, &quot;utf-8&quot;) + &quot;&amp;password=&quot; + URLEncoder.encode(password, &quot;utf-8&quot;);//设置数据 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//设置响应类型 httpURLConnection.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;);//设置内容长度 httpURLConnection.setDoOutput(true);//允许输出 OutputStream outputStream = httpURLConnection.getOutputStream(); outputStream.write(data.getBytes(&quot;utf-8&quot;));//写入数据 result = (httpURLConnection.getResponseCode() == 200); } catch (Exception e) { e.printStackTrace(); } } public boolean getResult() { return result; } } MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); 这两行换成自己的ip,本地ip的话可以用ipconfig或ifconfig查看,修改了默认端口的话也把端口一起改了. 路径的话就是 端口/web项目名/Servlet名 web项目名是再打成war包时设置的,Servlet名在web.xml中的&lt;servlet&gt;的子元素&lt;servlet-name&gt;设置,与java源码中的@WebServlet()注解中的一致 另外一个要注意的就是线程问题,需要新开一个线程进行http的连接 (4) activity_main.xml 前端页面部分很简单,就两个button,用于验证功能. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;用户名&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etname&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;密码&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etpassword&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;注册&quot; android:id=&quot;@+id/signup&quot; /&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;登录&quot; android:id=&quot;@+id/signin&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 9.测试 (1) 注册测试 随便输入用户名与密码 查看数据库 这里没有加密保存,后期会添加加密保存 (2) 登录测试 perfect! 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 这个错误在加载驱动错误时也可能会出现这个错误,因此要确保打成war包时lib目录正确且jar包版本正确. 还有就是由于这个是jdbc的底层实现,注意手写的sql语句不能错 千万千万别像我这样: (2) 网络权限问题 这个需要在AndroidManifest.xml添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; (3) 防火墙问题 服务器的话一般会有相应的相应的网页界面配置,比如作者的是阿里云服务器,当然也可以手动配置iptables 修改/etc/sysconfig/iptables vim /etc/sysconfig/iptables 添加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启iptables service iptables restart (4) 使用HTTP注意事项 由于从Android P开始,google默认要求使用加密连接,即要使用HTTPS,所以会禁止使用HTTP连接 使用HTTP连接时会出现以下异常 W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 两种建议: 1 使用HTTPS 2 修改默认的AndroidManifest.xml使其允许HTTP连接 在res下新建一个文件夹xml,创建一个叫network_security_config.xml的文件,文件内容如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt; &lt;/network-security-config&gt; 然后在AndroidMainfest.xml中加入 &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; /&gt; 即可 另一种办法是直接加入一句 android:usesCleartextTraffic=&quot;true&quot; &lt;application android:usesCleartextTraffic=&quot;true&quot; /&gt; (5) 线程问题 从android4.0开始,联网不能再主线程操作,万一网络不好就会卡死,所以有关联网的操作都需要新开一个线程,不能在主线程操作. (6) AVD问题 这个bug作者找了很久,http连接没问题,服务器没问题,数据库没问题,前端代码没问题,然后去了stackoverflow,发现是AVD的问题,我....... 简单来说就是卸载了再重启AVD,居然成功了..... 11 最后 作者小白一枚,有什么不对的地方请大家指正,评论作者会好好回复的.最后分享一首歌希望你们喜欢. 薛之谦-暧昧 参考网站 1.Android 通过Web服务器与Mysql数据库交互 2.Android高版本联网失败 3.IDEA 部署Web项目 4.PreparedStatement的executeQuery、executeUpdate和execute 5.preparedstatement execute()操作成功！但是返回false 6.HttpServletResponse(一) 7.HttpServletResponse(二) 8.HttpServletRequest 9.HttpUrlConnection 10.java.net.socketexception ","link":"https://2293736867.github.io/post/android-tong-guo-web-yu-hou-tai-shu-ju-ku-jiao-hu/"},{"title":"强大的工具(一):Capslock+","content":" 基本功能 高级功能 Capslock+利用了键盘少用的Capslock键,实现了很多强大的操作。 Capslock+是开源的，源码在Github上，点击这里查看，不强制收费。 官网:Capslock+官网 基本功能 光标移动 capslock+e 光标向上 capslock+d 光标向下 capslock+s 光标向左 capslock+f 光标向右 capslock+a 光标向左跳过一个词 capslock+g 光标向右跳过一个词 使用a和g时汉字可能会整句跳过 capslock+y 光标向上5行 capslock+b 光标向下5行 capslock+= 光标向下移动一页 capslock+- 光标向上移动一页 capslock+p 光标到行首 capslock+; 光标向行尾 光标选择 capslock+i 光标向上选中 capslock+k 光标向下选中 capslock+j 光标向左选中 capslock+l(是字母L的小写) 光标向右选中 capslock+h 光标向左选中一个词 capslock+n 光标向右选中一个词 与a、g一样，h和n对于汉字可能会选择整句 capslock+0 光标向上选中5行 capslock+m 光标向下选中5行 capslock+u 光标向行首选中 capslock+o 光标向行尾选中 插入符号 capslock+9 插入() capslock+[ 插入{} capslock+' 插入&quot;&quot; capslock+, 插入&lt;&gt; 以上4项在选中文本时插入到文本两侧 其他修改操作 capslock+w 等于Backspace capslock+r 等于delete capslock+Backspace 删除光标所在的一行 capslock+z 撤销 连续按下capslock+z会交替撤销与重做 capslock+space 等于Enter capslock+Enter 不论光标是否在行尾，直接换行 capslock+c capslock+x capslock+v 与ctrl+c独立的一套剪切板 当选中文字时，对所选的文字操作 不选中文字时，对光标所在行的文字进行操作 翻译 capslock+t 翻译，默认使用有道翻译，可以选中或不选中翻译 不选中的话，若光标在整个句子或整个单词的右侧，或者光标在句子或单词的中间时，可以翻译光标所在的句子或单词 光标在句子或单词的左侧时，会翻译上一个句子或单词 建议英文不选中翻译，中文选中翻译 注意 1.翻译的面板可以修改，重新输入后按Enter可继续翻译 2.获取单词发送通过ctrl+c实现，请确保按下capslock+t的时候ctrl+c不会有额外操作 3.翻译功能通过有道API实现，请求频率限制为每小时1000次，也就是所有使用该翻译功能的人一小时内翻译次数不能超过1000次，突破限制的方法在下面介绍 与LAlt(左边的Alt键)结合 临时改变鼠标速度 按住capslock+LAlt可临时改变鼠标的速度，按住capslock+LAlt再配合滚轮上下滚动可以增加或减慢速度，一般是先配合滚轮设定速度，松开LAlt与capslock后再一起按从而临时改变速度 切换不同窗口 capslock+LAlt+e 切换当前窗口上面的窗口 capslock+LAlt+d 切换当前窗口下面的窗口 capslock+LAlt+s 切换当前窗口左边的窗口 capslock+LAlt+f 切换当前窗口右边的窗口 capslock+LAlt+a 切换当前窗口最左侧的窗口 capslock+LAlt+g 切换当前窗口最右侧的窗口 对窗口位置的判定是以当前窗口的横竖中线为依据 快速打开/关闭窗口 capslock+LAlt+j 把当前窗口最小化且记录当前窗口为capslock+LAlt+l(小写L)即将打开的窗口 capslock+LAlt+k 把当前窗口最小化且记录当前窗口为capslock+LAlt+l最后一个打开的窗口 这与队列差不多，capslock+LAlt+j把窗口放进队首，capslock+LAlt+k把窗口放进队尾 capslock+LAlt+l 打开队列中的第一个窗口，并将其移出队列 capslock+LAlt+h 清楚窗口队列的记录 切换标签 capslock+LAlt+w 等于ctrl+shift+tab capslock+LAlt+r 等于ctrl+tab 模拟光标滚动 capslock+LAlt+y 页面向上移动5行，光标不动 capslock+LAlt+b 页面向下移动5行，光标不动 capslock+LAlt+- 光标移动到页首 capslock+LAlt+= 光标移动到页尾 第三套剪切板 ctrl+x/c/v为第一套，capslock+x/c/v为第二套，capslock+LAlt+x/c/v为第三套 当选中文字时复制文字，不选中文字时复制光标所在行的文字 capslock+F12可关闭独立剪切板的功能，关闭后capslock+x/c/v与capslock+LAlt+x/c/v失效，capslock+F12可重新开启 F1-F6的功能 capslock+F1 打开帮助文档网页 capslock+F2 弹出计算面板 在计算面版被激活的情况下，若切换为大写，主键盘一部分被替换成小键盘，对应关系如下 u-----------8 i-----------9 o----------0 p-----------* [---------------/ j------------4 k----------5 l----------6 ;------------+ '---------------(减号) m----------1 ,-----------2 .-----------3 space----0 RAlt----------. shift+Enter会将计算结果输出到下一行，ctrl+Enter或capslock+space为换行 capslock+F3 下一首歌 capslock+F4 短按时将窗口变为半透明 长按时配合滚轮改变透明度 若当前窗口的透明度，不是完全不透明，或不是半透明，则先将窗口变为完全不透明 capslock+F5 重载capslock+ capslock+F6 置顶/解除置顶一个窗口，即若该窗口不是处于置顶的状态，则将该窗口置顶，若窗口处于置顶的状态，则解除窗口的置顶状态 高级功能 CapsLock+settings.ini中的[Global]全局设置 loadScript:要加载的JS文件(要放在loadScript文件夹里)，用逗号分隔 allowClipboard:是否允许使用独立剪切板，1为是，0为否，默认1 mouseSpeed:按下capslock+LAlt时鼠标的速度，范围1-20，默认3 autostart:是否开机启动，1为是，0为否，默认0 loadingAnimation:是否开启程序加载动画，1为是，0为否，默认1 capslock+Tab:补全+计算 1.补全 这个补全其实是将某一字符串替换成你自定义的字符串，需要在capslock+的位置下的CapsLock+settings.ini中进行设置 CapsLock+settings.ini中有三个字段有字符串替换功能，分别是[TabHotString]、[QRun]与[QWeb]，优先级是[TabHotString]&gt;[QRun]&gt;[QWeb]，也就是如果三个字段下都有相同的键名，会按优先级顺序替换，但最好不要重复键名，替换的最好都在[TabHotString]中设置 格式为:键名 = 要替换的字符串 2.计算(对于比较严格的计算，如金钱计算，慎用) 计算其实是运行相应的JavaScript代码，处理的是光标左边的字符，直到遇到第一个空格或行首，之间的字符串会被认为是表达式 当表达式不带=时，会替换掉原来的表达式，当表达式带=时，将结果输出到=右侧，计算不出结果时返回? 若表达式带有空格，则要先选中表达式或在表达式头部加上`，若表达式在跨越多行只能选中 用JS自定义函数 首先要编写自己的.js文件，把它放到capslock+文件夹下的loadScript文件夹，然后在CapsLock+settings.ini中的[Global]中，在loadScript=scriptDemo.js后面加上,在加上自己的js文件名，保存，capslock+F5重载capslock+，然后就可以使用了 scriptDemo.js中有一些定义好的函数和事例，可以参照一下 比如说我自己写的my.js中包含了如下两个函数(我不太会JS...以下只是模仿别人写的) 然后... 如果直接打函数名字的话会出现函数的源代码 还可以对多行字符串使用字符串函数，但要先选中 翻译的高级设置 由于有道API每小时只能翻译1000次，想要更多请前往有道智云申请一个独立的Key， 申请到后把key写进capslock+安装目录下的CapsLock+settings.ini下的[TTranslate]段 免费版的填apiType=0 apiKey=xxxx(你申请的key) KeyFrom=xxxx 收费版的填apiType=1 apiKey=xxxx(你申请的key) 窗口绑定 窗口绑定有三种模式： 第一种：直接绑定 capslock+LAlt+1-8,把当前的窗口绑定到相应按键 然后capslock+1-8，会激活绑定到相应按键的窗口 （1-8，capslock+9是插入括号，capslock+0是向上选中5行） 若当前窗口不是绑定的窗口则先切换到按键绑定的窗口，若当前窗口是按键绑定的窗口，则会最小化该窗口，或从最小化复原 另外，capslock+LAlt+反单引号(`，主键盘区数字1左边)也可绑定窗口，激活时capslock+反单引号 第二种：绑定多个窗口到同一按键（按两次） 先选中某一个窗口，capslock+LAlt+1绑定（按两次1），在选中另一个窗口后，再capslock+LAlt+两次1，然后capslock+1会按绑定次序打开窗口，多次按下时类似用Alt+tab切换绑定的窗口，会优先打开最常使用的窗口 第三种：把当前窗口所属程序的所有窗口绑定（按三次） 比如你打开了3个txt，切换到三个txt之一后，按capslock+LAlt+1（按三次1），然后三个txt都被绑定到capslock+1上，然后按capslock+1会在这三个txt之间切换，类似于Alt+tab，也会优先打开最常用的窗口 模式三类似于模式二，模式二可对不同程序的窗口绑定到同一按键，要分别绑定，模式三对同一程序的所有窗口绑定，只需绑定一次 Qbar Qbar是按capslock+q弹出的框，可以方便地浏览文件、打开文件、与打开网页或是用引擎搜索，Esc可关闭，重新按capslock+q可获得焦点，选中字符后按capslock+q会自动填入，选中文件会将路径填入。 输入cl set可以设置CapsLock+settings.ini文件 Qbar还能使用通配符，?表示单个，表示多个，如a?b匹配aab，abb，acb，adb等 ab匹配abb,abbb,accb等(不区分大小写) 可以按/或\\或tab进入下一层文件夹，按capslock+,返回上一层 Qbar中的QRun 可以在CapsLock+settings.ini中的[QRun]下添加想要快速运行的程序，只需在Qbar中键入相应名字即可，也可直接在Qbar中使用&quot; -&gt;run &quot;来设定，格式为： xxx -&gt; xxx 或 xxx -&gt;run xxx 注意第一种-&gt;两旁有空格，第二种-&gt;前面有空格，后面紧接run，run后面有空格 QRun也可设定用来打开文件的程序，比如在[QRun]下有aa = &quot;xxxx/xxx.exe&quot;，bb = &quot;xxx/xxxx&quot;，就会用aa打开bb Qbar中的QSearch 这个可以用搜索引擎快速搜索，内置了bd(百度)，wk（维基），g（谷歌），m（MDN），tb（淘宝），默认为百度 当然可以自定义... 例如改变默认搜索引擎，在CapsLock+settings.ini中的[QSearch]添加default=xxxxx) 也可以直接在Qbar中default -&gt; xxxx 这需要通过网址定位到搜索的关键词，并将关键词修改成{q} 添加自己的搜索引擎类似，CapsLock+settings.ini中的[QSearch]中添加，或在Qbar中使用 -&gt;search 添加 Qbar中的QWeb 打开网站，直接输入网址即可，可以在Qbar中使用-&gt;web 定义，也可在CapsLock+settings.ini中的[QWeb]下定义，xxx = xxxx ctrl+Enter可在前面加www.，后面加.com，如输入taobao，ctrl+Enter会打开www.taobao.com，对于含有.net，.com，.org，www.，http://，https://可以直接当作网址打开而不是用默认引擎去搜索，一些特定的网站可以加上web xxxx打开 自定义Qbar的样式 在CapsLock+settings.ini中的[QStyle]下设置 颜色可以是指定16种HTML基础颜色之一或6位的RGB颜色值(0x前缀可以省略)。例如：red、ffffaa、FFFFAA、0xFFFFAA。下面的颜色设置也一样。 borderBackgroundColor-----背景颜色，默认red borderRadius-------------------边框四角圆角程度，默认9 textBackgroundColor---------文字输入框的背景颜色，默认green textColor-------------------------输入文字的颜色，默认ffffff，白色 editFontName------------------输入文字的字体，默认Hiragino Sans GB W6 editFontSize--------------------输入文字大小，默认12 listFontName-------------------提示列表字体，默认consoals listFontSize---------------------提示列表字体大小，默认10 listBackgroundColor----------提示列表背景颜色，默认blue listColor--------------------------提示列表文字颜色，默认0x000000 listCount-------------------------提示列表行数，默认5 lineHeight-----------------------提示列表每行高度，默认19 progressColor------------------进度条颜色，默认0x00cc99 比如这是我的Qbar（好丑，对不对，好像比默认的还。。。） 自定义某些按键 在CapsLock+settings.ini中的[Keys]下可以改变一些capslock+按键的功能，也可以增加一些按键，capslock+支持的按键有: Capslock + (LALt + ) F1~F12 Capslock + (LALt + ) 0~9 Capslock + (LALt + ) a~z Capslock + (LALt + ) -=[];',./ Capslock + (LALt + ) Backspace, Tab, Enter, Space, RAlt keyFunc_volumeMute 静音 keyFunc_volumeDown 音量增大 keyFunc_volumeUp 音量减少 keyFunc_mediaPrev 上一首 keyFunc_mediaPlayPause 播放/暂停 以caps_开头，字母用小写表示，F1-F12用f1-f12表示，LALt用lalt表示，键位以keyFunc_开头，如caps_j=keyFunc_selectLeft，具体可用capslock+q输入cl CapsLock+settingsDemo.ini中查看 比如在CapsLock+settings.ini中的[Keys]下添加了caps_lalt_9=keyFunc_volumeMut，则按capslock+LAlt+9可以静音 ------------------------------------------------没有了---------------------------------------------------------- 这基本上就是capslock+的所有功能了，作者好像不怎么更新了，最新的版本是16年的 有一个问题就是其实capslock+e/d/s/f并不能完全代替上下左右的方向键，比如Alt+←是后退，但Alt+capslcok+s没有任何反应，当上下左右和其他键联合使用capslock还不能代替 ","link":"https://2293736867.github.io/post/qiang-da-de-gong-ju-yi-capslock/"}]}