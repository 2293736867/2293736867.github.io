{"posts":[{"title":"每日分享 第73期","content":"每日鸡汤 谁说我不会乐器？我退堂鼓打的可好了。 每日冷知识 西兰花是一种“人造”食物。从公元前6世纪开始，人们年复一年的在野生卷心菜植株间选择性育种，最后才诞生了如今的西兰花。事实上，西兰花的英语“broccoli”源于意大利语，意思是“卷心菜的花冠”。 每日诗词 明月照积雪，朔风劲且哀。 ——谢灵运《岁暮》 每日一句 自由不是你想干什么就干什么，而是你不想干什么就不干什么。 每日音乐 没那么喜欢-陈雪凝 清醒的悲伤 最残忍 思绪在 回忆里 生了根 生活冰冷的 多么艰深 也许你爱过 我的认真 你写的剧本 太逼真 让我在 酒精里 失了魂 用若无其事 的口吻 换最后一点 暧昧资本 我知道你 其实对我 没那么喜欢 才会连试探都那么心酸 你的浪漫 你的关怀 都与我无关 自作多情未免太难堪 你写的剧本 太逼真 让我在 酒精里 失了魂 用若无其事 的口吻 换最后一点 暧昧资本 我知道你 其实对我 没那么喜欢 才会连试探都那么心酸 你的浪漫 你的关怀 都与我无关 自作多情未免太难堪 多不堪 多不堪 与我无关 我知道你 只是对我 没那么喜欢 别再打乱我孤独的习惯 你的浪漫 你的关怀 夹杂着不安 再次相遇微笑着走散 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-73-qi/"},{"title":"每日分享 第72期","content":"每日鸡汤 好看的皮囊三千一晚，有趣的灵魂要车要房。 每日冷知识 在英国，鸽子屎都是皇家财产。这是因为鸽子屎能被用来做火药。出于这个原因，18世纪乔治一世宣布所有的鸽子屎都是皇家财产。 每日诗词 藕花珠缀，犹似汗凝妆。 ——阎选《临江仙·雨停荷芰逗浓香》 每日一句 绝望的人没有故乡。 每日音乐 桥豆麻袋-陈粒 请再等以下 还有臭美的飞雪 还有走失的浩劫 还有争气的我 哦耶 请再看一下 还有诈尸的蚯蚓 还有突发的爱情 还有从容的我 嗯哼 爬呀爬呀苦了自己 长路漫漫无目的 一步一步小心翼翼 一不小心丢了你 请再等以下 还有受伤的世界 还有弥留的热切 还有坚挺的我 哦耶 请再看一下 还有优雅的苔藓 还有鲁莽的时间 还有可爱的我 啊哈 是啊是啊来之不易 从今往后多珍惜 一步一步小心翼翼 一不小心丢了你 爬呀爬呀苦了自己 长路漫漫无目的 一步一步小心翼翼 一不小心丢了你 从今往后多珍惜 一步一步小心翼翼 一不小心丢了你 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-72-qi/"},{"title":"每日分享 第71期","content":" 每日鸡汤 我对生活充满向往，生活对我虽远必诛。 每日冷知识 字母E是英文中最常见的字母。所有单词中大约11%都有字母E，光原文这一句话里就出现了12次。 每日诗词 古今多少事，渔唱起三更。 ——陈与义《临江仙·夜登小阁忆洛中旧游》 每日一句 萤火之光看起来比平常更耀眼是错觉吗？今宵会成为永夜的吧。 每日音乐 活该-徐真真/花粥 最后我没有看不开 领悟着生活的无奈 我们计划的未来被现实冲淡我有一点遗憾 可是我从来都不乖 我也不会再让你猜 这不圆满的结果都是我活该 如果说开始的时候没有任何期待 那到了该死的那天可能只有依赖 当初同款发带配上同款AJ一代 有多少爱情最后都被欲望几百 只能把你送的礼物收进白色箱子里 装作若无其事其实只是不想伤自己 再多漂亮外壳都没法跟你的样子比 走遍了大街小巷也找不到你的相似体 曾和你一起憧憬未来有多灿烂 一次次错误选择后一切变黯淡 总是用骂战 掩饰着情感 却总在看清真相以后都会心软 最后我没有看不开 领悟着生活的无奈 我们计划的未来被现实冲淡我有一点遗憾 可是我从来都不乖 我也不会再让你猜 这不圆满的结果都是我活该 你说要认真在一起 一直在一起 我承认在这个世界没有人能真的代替你 没法真的忘记你 只好尽力骗自己 可惜一旦喝醉我的眼泪全部都是你 wooo 都怪我活该 把身体挪开 期待的色彩 只剩下空白 用力去破坏 崩溃的心态 相爱的两颗心为何要相互伤害 是否还有人在耳边给你忠告 是否还有人在凌晨给你拥抱 是否还能为了见你守在你的通道 还拎着打包好的中药 多年以后同样的秋风季 是否还能再和老去的你相遇 曾经的悲伤都已藏箱底 自由漫步在那金黄色阳光里 最后我没有看不开 领悟着生活的无奈 我们计划的未来被现实冲淡我有一点遗憾 可是我从来都不乖 我也不会再让你猜 这不圆满的结果都是我活该 你也活该 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-71-qi/"},{"title":"每日分享 第70期","content":" 每日鸡汤 命只有一条，但要命的事，可不止一件。 每日冷知识 新西兰其实是一块被海水淹没的更大面积大陆的一部分。这块大陆名为“西兰大陆”，知道人类进入太空后俯瞰地球时才发现。一些科学家认为它应该被正式称为世界的第八大陆。 每日诗词 香汗薄衫凉，凉衫薄汗香。 ——苏轼《菩萨蛮·回文夏闺怨》 每日一句 别人的幸福，你的地狱。 每日音乐 活该-谌宥 故事无法倒带不能重来 把时间锁起来却成空白 从开始到现在 我还期待死性不改 感情本来就是爱与被爱 但剧本的结尾缺了一块 你把我遗留在 灰色地带只剩阴霾 我拼了命去爱 换一句活该 只能埋头痛苦 像一个小孩 曾对你的依赖 和累积的伤害 该怎么去释怀 在旧梦里挣扎 我还醒不来 我不哭也不笑 已成为常态 不愿把手松开 去拥抱未来 是我活该 感情本来就是爱与被爱 但剧本的结尾缺了一块 你把我遗留在 灰色地带只剩阴霾 我拼了命去爱 换一句活该 只能埋头痛苦 像一个小孩 曾对你的依赖 和累积的伤害 该怎么去释怀 在旧梦里挣扎 我还醒不来 我不哭也不笑 已成为常态 不愿把手松开 去拥抱未来 是我活该 拼了命去爱 换一句活该 只能埋头痛苦 像一个小孩 曾对你的依赖 和累积的伤害 该怎么去释怀 在旧梦里挣扎 我还醒不来 我不哭也不笑 已成为常态 不愿把手松开 去拥抱未来 是我活该 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-70-qi/"},{"title":"每日分享 第69期","content":" 每日鸡汤 别说你一无所有，你还有一身债。 每日冷知识 有的鲨鱼寿命长达500年。格陵兰鲨是所有脊椎动物中已知寿命最长的动物，直到它们约150岁时才达到性成熟。 每日诗词 梧桐树，三更雨，不道离情正苦。 ——温庭筠《更漏子·玉炉香》 每日一句 我想拥有温柔，不仅仅止于表面的伪装。 每日音乐 辞九门回忆-冰幽/解忧草 一曲定重楼 一眼半生筹 看的全都是那诡谲云涌 入得此门不回首 无需宣之于口 我对案再拜那风雨飘泼的残陋 再聚首 戏子多秋 可怜一处情深旧 满座衣冠皆老朽 黄泉故事无止休 戏无骨难左右 换过一折又重头 只道最是人间不能留 误闯天家 劝余放下手中砂 张口欲唱声却哑 粉面披衣叫个假 怜余来安座下 不敢沾染佛前茶 只作凡人赴雪月风花 绕过胭脂楼 打散结发扣 唱的全都是那情深不寿 入得此门不回首 无需宣之于口 我对镜遮掩那风雨飘泼的残陋 碑已旧 戏子多秋 可怜一处情深旧 满座衣冠皆老朽 黄泉故事无止休 戏无骨难左右 换过一折又重头 只道最是人间不能留 误闯天家 劝余放下手中砂 送那人御街打马 才子佳人断佳话 怜余来苦咽下 求不得佛前茶 只留三寸土种二月花 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-69-qi/"},{"title":"每日分享 第68期","content":" 每日鸡汤 如果你不珍惜我，那么过了这个村，我在下一个村等你。 每日冷知识 去年今夜，同醉月明花树下。 ——吕本中《减字木兰花·去年今夜》 每日诗词 考拉的指纹各不相同，黑猩猩和大猩猩也是如此。不过考拉的指纹和人类的极为相似，就连经验最为老道的法医也得花点时间才能分辨哪个是考拉的指纹，哪个是人类的指纹。 每日一句 自己永远是孤单的，但你可以让其他人变得不孤单。 每日音乐 看穿-任然 本来是很普通的聚餐 因为你 竟然精心打扮 不过你大方问候 心突然混乱 竟然你还是一眼把我看穿 每个人毫不顾忌调侃 气氛温暖得让我有些心酸 好想你后来已经 把伤痕顺其自然 留我一个人进退两难 原来我这么勇敢 能安静接受答案 有些事没有 当初想象得那么难 两人的感情 怎么可以 一人追赶 故事早就该停在那次离散 Goodbye 每个人毫不顾忌调侃 气氛温暖得让我有些心酸 好像你后来已经 把伤痕顺其自然 原来我这么勇敢 能安静接受答案 有些事没有 当初想象得那么难 两人的感情 怎么可以 一人追赶 故事早就该停在那次离散 原来我这么勇敢 你平静我不哭喊 你已经自由 我何必再给你牵绊 记忆里那段 带着遗憾 陪我灿烂 在未来祝你能幸福美满 晚安 原来我这么勇敢 原来我这么勇敢 你平静我不哭喊 你已经自由 我何必再给你牵绊 记忆里那段 带着遗憾 陪我灿烂 在未来祝你能幸福美满 晚安 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-68-qi/"},{"title":"每日分享 第67期","content":" 每日鸡汤 每当我找到成功的钥匙，就发现有人把锁芯给换了。 每日冷知识 研究表明，人体中的细菌细胞（约39万亿个微生物细胞）比人类细胞（约30万亿个细胞）更多，甚至有多达40个人类基因被认为起源于细菌。 每日诗词 阴阴溪曲绿交加，小雨翻坪上浅沙。 ——晁冲之《春日》 每日一句 我们生活在阴沟里，但有人依然仰望星空。 每日音乐 无人之岛-任然 黑色的背后是黎明 以为来日方长所以别把梦吵醒 时间它继续飞行 下一站机场门外 拥抱你的背影 蓝色的背后是纯净 低下头俯瞰陆地上思念的眼睛 生命中有些事情 从没有原因说明 一刹那的寂静 如果云层是天空的一封信 能不能再听一听 听你的声音 就算是探秘(是贪玩而已) 跟着潘彼得去无人岛旅行 我不会怪你的 天空一望无际 是海洋的倒影 蓝色一望无际 我的你在哪里 加入迷路了一定(记得) 把思念装进漂流瓶(记得) 快寄给我别让人担心 蓝色的背后是纯净(云淡风轻) 低下头俯瞰陆地上思念的眼睛 生命中有些事情(不能透明) 从没有原因说明 一刹那的寂静 如果云层是天空的一封信 能不能再听一听 听你的声音 就算是探秘(是贪玩而已) 跟着潘彼得去无人岛旅行 我不会怪你的 天空一望无际 是海洋的倒影 蓝色一望无际 我的你在哪里 假如迷了路一定(记得) 把思念装进漂流瓶(记得) 快寄给我别让人担心 如果云层是天空的一封信 能不能再听一听 听你的声音 就算是探秘 跟着潘彼得去无人岛旅行 我不会怪你的 天空一望无际 是海洋的倒影 蓝色一望无际 我的你在哪里 加入迷了路一定(记得) 把思念装进漂流瓶(记得) 快寄给我别让我担心 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-67-qi/"},{"title":"本地+分布式Hadoop完整搭建过程","content":" 1 概述 2 术语介绍 3 环境 4 Hadoop部署模式 5 安装前准备 5.1 Hadoop 5.2 JDK 5.3 虚拟机 5.4 服务器 6 动手吧！ 7 结语 8 参考 1 概述 Hadoop在大数据技术体系中极为重要，被誉为是改变世界的7个Java项目之一（剩下6个是Junit、Eclipse、Spring、Solr、HudsonAndJenkins、Android），本篇文章以Hadoop 3.3.0官方文档为基础，首先会介绍Hadoop相关术语，包括HDFS，MapReduce等，接着会完整描述Hadoop的搭建过程，包括本地以及分布式集群的搭建。 2 术语介绍 Hadoop：Hadoop是Apache开发的分布式系统基础架构，用户可以在不了解分布式底层细节的情况下，开发分布式程序，充分利用集群的威力进行高速运算和存储 HDFS：全称Hadoop Distributed File System，Hadoop分布式文件系统，被设计成适合运行在通用硬件上的分布式文件系统，具有高度容错性的特点，能提供高吞吐量的数据访问 MapReduce：一个编程模型，用于大规模数据集的并行运算，是面向大数据并行处理的计算模型、架构以及平台。平台指的是允许使用普通商用服务器构成一个包含数十甚至数千个节点的分布和并行计算集群。架构指的是MapReduce提供了一个庞大但设计精良的并行计算软件框架，能自动完成计算任务的并行化处理，自动划分计算数据和计算任务。模型指的是借助于函数式编程语言的设计思想，提供了一种简便的并行程序设计方法 YARN：YARN是Hadoop的一种资源管理器，一个通用的资源管理系统，可以为上层应用提供统一的资源管理以及调度，基本思想是将JobTracker的两个主要功能（资源管理和作业调度/监控）分离 3 环境 操作环境：Manjaro 20.0.3 虚拟机环境：VirtualBox 6.1.10+CentOS-8.2.2004-x86_64-minimal × 3 Hadoop 3.3.0（aarch64+x86_64） OpenJDK 11（aarch64+x86_64） 服务器：CentOS 8 × 3（aarch64 × 1 + x86_64 × 2） 4 Hadoop部署模式 首先来看一下Hadoop支持的部署模式，Hadoop集群搭建支持以下三种模式： 本地模式：默认模式，运行在单一Java进程中 伪分布模式：运行在一个节点中但是在不同的Java进程中 完全分布模式：运行在不同机器上的标准集群模式，利用多台主机部署Hadoop 5 安装前准备 5.1 Hadoop 官网下载戳这里，本文采用目前最新的3.3.0版本，注意如果服务器的架构为aarch64需要下载对应版本。 5.2 JDK 关于JDK的选择，参考文末的链接： 3.3版本在运行时支持Java11，3.2（包括3.2）以下只支持Java8，另外也提到了现在Hadoop使用OpenJDK作为构建/测试以及发布的JDK，因此这里使用OpenJDK11，戳这里下载，如果服务器架构为aarch64可以使用yum install安装。 5.3 虚拟机 虚拟机用的是Virtual Box，6.1.10版本。 使用虚拟机是为了模拟搭建集群，就算有真实服务器也建议先在虚拟机上跑一遍大概流程。 5.4 服务器 部署Hadoop的真实服务器，这里使用了三台服务器进行搭建集群。 6 动手吧！ 准备工作做好后就开始动手吧！ 由于篇幅略长所以分成了四篇文章方便查看： （一）本地模式 （二）伪分布模式 （三）完全分布模式（虚拟机） （四）完全分布模式（服务器） 7 结语 本文讲述了搭建Hadoop集群的三种方式，如无意外就可以搭建一个基本的Hadoop集群了。 但是，一般来说，并不能直接投入生产环境中使用，因为需要配合ZooKeeper搭建HA（高可用）集群，本文限于篇幅就不再叙述了。本文的初衷是教会读者如何搭建，至于ZooKeeper，网上有不少文章可以参考。最后希望读者看完之后能够对Hadoop有一个大概的认识，了解Hadoop的组成部分以及基本工作原理。 8 参考 Hadoop3.3.0官方文档 Hadoop-Java版本 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/ben-di-fen-bu-shi-hadoop-wan-zheng-da-jian-guo-cheng/"},{"title":"Hadoop完整搭建过程（四）：完全分布模式（服务器）","content":" 1 概述 2 约定 3 （可选）本地Host 4 ssh 5 主机名 6 配置基本环境 6.1 JDK 6.2 Hadoop 6.2.1 hadoop-env.sh 6.2.2 core-site.xml 6.2.3 hdfs-site.xml 6.2.4 workers 6.2.5 复制配置文件 7 启动 7.1 格式化HDFS 7.2 hadoop-env.sh 7.3 启动 8 YARN 8.1 环境变量 8.2 YARN配置 8.3 开启YARN 8.4 测试 9 参考 1 概述 上一篇文章介绍了如何使用虚拟机搭建集群，到了这篇文章就是实战了，使用真实的三台不同服务器进行Hadoop集群的搭建。具体步骤其实与虚拟机的差不多，但是由于安全组以及端口等等一些列的问题，会与虚拟机有所不同，废话不多说，下面正式开始。 2 约定 Master节点的ip用MasterIP表示，主机名用master表示 两个Worker节点的ip用Worker1IP/Worker2IP表示，主机名用worker1/worker2表示 这里为了演示方便统一使用root用户登录，当然生产环境不会这样 3 （可选）本地Host 修改本地Host，方便使用主机名来进行操作： sudo vim /etc/hosts # 添加 MaterIP master Worker1IP worker1 Worker2IP worker2 4 ssh 本机生成密钥对后复制公钥到三台服务器上： ssh-keygen -t ed25519 -a 100 # 使用更快更安全的ed25519算法而不是传统的RSA-3072/4096 ssh-copy-id root@master ssh-copy-id root@worker1 ssh-copy-id root@worker2 这时可以直接使用root@host进行连接了： ssh root@master ssh root@worker1 ssh root@worker2 不需要输入密码，如果不能连接或者需要输入密码请检查/etc/ssh/sshd_config或系统日志。 5 主机名 修改Master节点的主机名为master，两个Worker节点的主机名为worker1、worker2： # Master节点 vim /etc/hostname master # Worker1节点 # worker1 # Worker2节点 # worker2 同时修改Host： # Master节点 vim /etc/hosts Worker1IP worker1 Worker2IP worker2 # Worker1节点 vim /etc/hosts MasterIP master Worker2IP worker2 # Worker1节点 vim /etc/hosts MasterIP master Worker1IP worker1 修改完成之后需要互ping测试： ping master ping worker1 ping worker2 ping不通的话应该是安全组的问题，开放ICMP协议即可： 6 配置基本环境 6.1 JDK scp上传OpenJDK 11，解压并放置于/usr/local/java下，同时修改PATH： export PATH=$PATH:/usr/local/java/bin 如果原来的服务器装有了其他版本的JDK可以先卸载： yum remove java 注意设置环境变量后需要测试以下java，因为不同服务器的架构可能不一样： 比如笔者的Master节点为aarch64架构，而两个Worker都是x86_64架构，因此Master节点执行java时报错如下： 解决办法是通过yum install安装OpenJDK11： yum install java-11-openjdk 6.2 Hadoop scp上传Hadoop 3.3.0，解压并放置于/usr/local/hadoop下，注意选择对应的架构： 解压后修改以下四个配置文件： etc/hadoop/hadoop-env.sh etc/hadoop/core-site.xml etc/hadoop/hdfs-site.xml etc/hadoop/workers 6.2.1 hadoop-env.sh 修改JAVA_HOME环境变量即可： export JAVA_HOME=/usr/local/java # 修改为您的Java目录 6.2.2 core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 具体选项与虚拟机方式的设置相同，这里不再重复叙述。 6.2.3 hdfs-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/datanode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 6.2.4 workers worker1 worker2 6.2.5 复制配置文件 # 如果设置了端口以及私钥 # 加上 -P 端口 -i 私钥 scp /usr/local/hadoop/etc/hadoop/* worker1:/usr/local/hadoop/etc/hadoop/ scp /usr/local/hadoop/etc/hadoop/* worker2:/usr/local/hadoop/etc/hadoop/ 7 启动 7.1 格式化HDFS 在Master中，首先格式化HDFS cd /usr/local/hadoop bin/hdfs namenode -format 如果配置文件没错的话就格式化成功了。 7.2 hadoop-env.sh 还是在Master中，修改/usr/local/hadoop/etc/hadoop/hadoop-env.sh，末尾添加： HDFS_DATANODE_USER=root HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 7.3 启动 首先Master开放9000以及9870端口（一般安全组开放即可，如果开启了防火墙firewalld/iptables则添加相应规则），并在Master节点中启动： sbin/start-dfs.sh 浏览器输入： MasterIP:9870 即可看到如下页面： 如果看到Live Nodes数量为0请查看Worker的日志，这里发现是端口的问题： 并且在配置了安全组，关闭了防火墙的情况下还是如此，则有可能是Host的问题，可以把Master节点中的： # /etc/hosts 127.0.0.1 master 删去，同样道理删去两个Worker中的： # /etc/hosts 127.0.0.1 worker1 127.0.0.1 worker2 8 YARN 8.1 环境变量 修改/usr/local/hadoop/etc/hadoop/hadoop-env.sh，添加： export YARN_RESOURCEMANAGER_USER=root export YARN_NODEMANAGER_USER=root 8.2 YARN配置 在两个Worker节点中修改/usr/local/hadoop/etc/hadoop/yarn-site.xml： &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; 8.3 开启YARN Master节点中开启YARN： cd /usr/local/hadoop sbin/start-yarn.sh 同时Master的安全组开放8088以及8031端口。 8.4 测试 浏览器输入： MasterIP:8088 应该就可以访问如下页面了： 至此集群正式搭建完成。 9 参考 博客园-HDFS之五：Hadoop 拒绝远程 9000 端口访问 How To Set Up a Hadoop 3.2.1 Multi-Node Cluster on Ubuntu 18.04 (2 Nodes) How to Install and Set Up a 3-Node Hadoop Cluster ","link":"https://2293736867.github.io/post/hadoop-wan-zheng-da-jian-guo-cheng-si-wan-quan-fen-bu-mo-shi-fu-wu-qi/"},{"title":"Hadoop完整搭建过程（三）：完全分布模式（虚拟机）","content":" 1 完全分布模式 2 虚拟机安装 2.1 镜像下载 2.2 安装 2.3 启动 3 ssh连接虚拟机 4 基本环境搭建 4.1 JDK 4.2 Hadoop 5 克隆 6 主机名+ip设置 7 Host设置 7.1 Master节点 7.2 Worker1节点 7.3 Worker2节点 7.4 互ping测试 8 配置ssh 8.1 sshd服务 8.2 复制公钥 8.3 测试 9 Master节点Hadoop配置 9.1 core-site.xml 9.2 hdfs-site.xml 9.3 workers 9.4 复制配置文件 10 HDFS格式化并启动 10.1 启动 10.2 测试 10.3 防火墙 11 配置YARN 11.1 YARN配置 11.2 开启YARN 11.3 测试 12 参考 1 完全分布模式 完全分布模式是比本地模式与伪分布模式更加复杂的模式，真正利用多台Linux主机来进行部署Hadoop，对集群进行规划，使得Hadoop各个模块分别部署在不同的多台机器上，这篇文章介绍的是通过三台虚拟机进行集群配置的方式，主要步骤为： 准备虚拟机：准备虚拟机基本环境 ip+Host配置：手动设置虚拟机ip以及主机名，需要确保三台虚拟机能互相ping通 ssh配置：生成密钥对后复制公钥到三台虚拟机中，使其能够实现无密码相互连接 Hadoop配置：core-site.xml+hdfs-site.xml+workers YARN配置：yarn-site.xml 2 虚拟机安装 需要使用到三台虚拟机，其中一台为Master节点，两台Worker节点，首先安装虚拟机并配置环境，最后进行测试。 2.1 镜像下载 使用VirtualBox进行虚拟机的安装，先去CentOS官网下载最新版本的镜像： 这里有三种不同的镜像： boot：网络安装版 dvd1：完整版 minimal：最小化安装版 这里为了方便选择最小化安装版的，也就是不带GUI的。 2.2 安装 下载后，打开Virtual Box并点击New，选择专家模式： 命名为CentOSMaster，作为Master节点，并且分配内存，这里是1G，如果觉得自己内存大的可以2G： 磁盘30G足够，其他可以保持默认： 创建好后从设置中的存储中，选择下载的镜像： 启动后会提示选择启动盘，确定即可： 好了之后会出现如下提示画面，选择第一个安装： 等待一会后进入安装界面： 接下来对安装位置以及时区进行配置，首先选择安装位置： 由于是虚拟的单个空磁盘，选择自动分区即可： 时区这里可以选择中国的上海： 接着选择网络，首先修改主机名为master： 接着点击Configure： 添加ip地址以及DNS服务器，ip地址可以参考本机，比如笔者的机器本地ip为192.168.1.7，则： 虚拟机的ip可以填192.168.1.8 子网掩码一般为255.255.255.0 默认网关为192.168.1.1 DNS服务器为114.114.114.114（当然也可以换其他的公共DNS比如阿里的223.5.5.5、百度的180.76.76.76等） 点击Save后应用主机名并开启： 没问题的话就可以安装了： 安装的时候设置root用户的密码以及创建用户： 用户这里采用一个叫hadoopuser的用户，后面的操作都直接基于该用户： 等待一段时间后安装完成重启即可。 2.3 启动 在启动之前首先把原来的镜像去掉： 启动后是黑框界面： 登录刚才创建的hadoopuser用户即可。 3 ssh连接虚拟机 默认的话是不能连接外网的，需要在菜单栏中的Devices中选择Network，设置为Bridged Adapter（桥接模式）： 使用ping测试： 接着可以测试能否ping通本地机器： 通了之后可以通过ssh连接虚拟机，像平时操作服务器一样，在本地终端中连接虚拟机，首先添加指纹： 接着输入密码连接即可： 如果想偷懒可以使用密钥连接的方式，在本地机器中： ssh-keygen -t ed25519 -a 100 ssh-copy-id -i ~/.ssh/id_ed25519.pub hadoopuser@192.168.1.8 4 基本环境搭建 基本环境搭建就是安装JDK以及Hadoop，使用scp上传OpenJDK以及Hadoop。 4.1 JDK 首先去下载OpenJDK，然后在本地机器上使用scp上传： scp openjdk-11+28_linux-x64_bin.tar.gz hadoopuser@192.168.1.8:/home/hadoopuser 接着在本地上切换到连接虚拟机的ssh中， cd ~ tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz sudo mv jdk-11 /usr/local/java 下一步是编辑/etc/profile，添加bin到环境变量中，在末尾添加： sudo vim /etc/profile # 没有vim请使用vi # 或安装：sudo yum install vim # 添加 export PATH=$PATH:/usr/local/java/bin 然后： . /etc/profile 测试： 4.2 Hadoop Hadoop的压缩包scp上传到虚拟机后，解压并移动到/usr/local： scp hadoop-3.3.0.tar.gz hadoopuser@192.168.1.8:/home/hadoopuser 虚拟机ssh终端： cd ~ tar -xvf hadoop-3.3.0.tar.gz sudo mv hadoop-3.3.0 /usr/local/hadoop 同时修改etc/hadoop/hadoop-env.sh配置文件，填入Java路径： sudo vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh # 填入 export JAVA_HOME=/usr/local/java # 修改为您的Java目录 5 克隆 因为需要一个Master节点以及两个Worker节点，将Master节点关机，并选择配置好的CentOSMaster，右键进行克隆： 并选择完全克隆： 克隆出CentOSWorker1以及CentOSWorker2。 6 主机名+ip设置 这里的两个Worker节点以Worker1以及Worker2命名，首先操作Worker1，修改主机名： sudo vim /etc/hostname # 输入 # worker1 对于ip，由于Master节点的ip为192.168.1.8，因此这里修改两个Worker的节点分别为： 192.168.1.9 192.168.1.10 sudo vim /etc/sysconfig/network-scripts/ifcfg-xxxx # 该文件因人而异 # 修改IPADDR IPADDR=192.168.1.9 修改完成后重启Worker1，对Worker2进行同样的修改主机名以及ip操作。 7 Host设置 需要在Master以及Worker节点进行Host设置： 7.1 Master节点 sudo vim /etc/hosts # 添加 192.168.1.9 worker1 # 与上面的ip对应一致 192.168.1.10 worker2 7.2 Worker1节点 sudo vim /etc/hosts # 添加 192.168.1.8 master 192.168.1.10 worker2 7.3 Worker2节点 sudo vim /etc/hosts # 添加 192.168.1.8 master 192.168.1.9 worker1 7.4 互ping测试 在三台虚拟机中的其中一台ping另外两台的ip或者主机名，测试通过后就可以进行下一步了，这里使用Worker1节点测试： 8 配置ssh 8.1 sshd服务 需要在三个节点（包括自身）之间配置ssh无密码（密钥）连接，首先使用 systemctl status sshd 检查sshd服务是否开启，没开启的使用 systemctl start sshd 开启。 8.2 复制公钥 三个节点都进行如下操作： ssh-keygen -t ed25519 -a 100 ssh-copy-id master ssh-copy-id worker1 ssh-copy-id worker2 8.3 测试 在其中一个节点中直接ssh连接其他节点，无需密码即可登录，比如在Master节点中： ssh master # 都是hadoopuser用户，所以省略了用户 ssh worker1 ssh worker2 9 Master节点Hadoop配置 在Master节点中，修改以下三个配置文件： HADOOP/etc/hadoop/core-site.xml HADOOP/etc/hadoop/hdfs-site.xml HADOOP/etc/hadoop/workers 9.1 core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; fs.defaultFS：NameNode地址 hadoop.tmp.dir：Hadoop临时目录 9.2 hdfs-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/data/datanode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; dfs.namenode.name.dir：保存FSImage的目录，存放NameNode的metadata dfs.datanode.data.dir：保存HDFS数据的目录，存放DataNode的多个数据块 dfs.replication：HDFS存储的临时备份数量，有两个Worker节点，因此数值为2 9.3 workers 最后修改workers，输入（与上面设置的主机名一致）： worker1 worker2 9.4 复制配置文件 把Master节点的配置复制到Worker节点： scp /usr/local/hadoop/etc/hadoop/* worker1:/usr/local/hadoop/etc/hadoop/ scp /usr/local/hadoop/etc/hadoop/* worker2:/usr/local/hadoop/etc/hadoop/ 10 HDFS格式化并启动 10.1 启动 在Master节点中： cd /usr/local/hadoop bin/hdfs namenode -format sbin/start-dfs.sh 运行后可以通过jps命令查看： 在Worker节点中： 10.2 测试 浏览器输入： master:9870 # 如果没有修改本机Host可以输入 # 192.168.1.8:9870 但是。。。 本以为做了这么多能看到成果了。 然后检查过了一遍本机+虚拟机Host，还有Hadoop的配置文件，都没有问题。 最后， 才定位到问题是 防火墙。 10.3 防火墙 CentOS8默认开启了防火墙，可以使用： systemctl status firewalld 查看防火墙状态。 由于是通过9870端口访问，首先查询9870是否开放，Master节点中输入： sudo firewall-cmd --query-port=9870/tcp # 或 sudo firewall-cmd --list-ports 如果输出为no： 则表示没有开放，手动开放即可： sudo firewall-cmd --add-port=9870/tcp --permanent sudo firewall-cmd --reload # 使其生效 再次在浏览器输入： master:9870 # 如果没有修改本地Host # 192.168.1.8:9870 可以看到一个友好的页面了： 但是，有一个问题就是这里没有显示Worker节点，上图中的Live Nodes数目为0 ，而Datanodes这里什么也没有显示： 但是在Worker节点中的确可以看到有Datanode的进程了： 查看Worker节点的日志（/usr/local/hadoop/logs/hadoop-hadoopuser-datanode-worker1.log）可以看到应该是Master节点9000端口的没有开启的问题： 回到Master节点，先执行stop-dfs.sh关闭，并开放9000端口后执行start-dfs.sh开启： /usr/local/hadoop/sbin/stop-dfs.sh sudo firewall-cmd --add-port=9000/tcp --permanent sudo firewall-cmd --reload /usr/local/hadoop/sbin/start-dfs.sh 再次在浏览器访问： master:9000 # 或 # 192.168.1.8:9000 这时候就可以看见Worker节点了： 11 配置YARN 11.1 YARN配置 在两个Worker节点中修改/usr/local/hadoop/etc/hadoop/yarn-site.xml： &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; 11.2 开启YARN Master节点中开启YARN： cd /usr/local/hadoop sbin/start-yarn.sh 同时开放8088端口为下面的测试做准备： sudo firewall-cmd --add-port=8088/tcp --permanent sudo firewall-cmd --reload 11.3 测试 浏览器输入： master:8088 # 或 # 192.168.1.8:8088 应该就可以访问如下页面了： 同样道理没有看到Worker节点，查看Worker节点的日志，发现也是端口的问题： Master节点先关闭YARN，开放8031端口，并重启YARN： /usr/local/hadoop/sbin/stop-yarn.sh sudo firewall-cmd --add-port=8031/tcp --permanent sudo firewall-cmd --reload /usr/local/hadoop/sbin/start-yarn.sh 再次访问： master:8088 # 或 # 192.168.1.8:8088 就可以看到Worker节点了： 至此，虚拟机组成Hadoop集群正式搭建完成。 12 参考 CSDN-GitChat·大数据 | 史上最详细的Hadoop环境搭建 How To Set Up a Hadoop 3.2.1 Multi-Node Cluster on Ubuntu 18.04 (2 Nodes) How to Install and Set Up a 3-Node Hadoop Cluster CSDN-virtualBox实现主机和虚拟机相互ping通,配置静态IP地址 ","link":"https://2293736867.github.io/post/hadoop-wan-zheng-da-jian-guo-cheng-san-wan-quan-fen-bu-mo-shi-xu-ni-ji/"},{"title":"Hadoop完整搭建过程（二）：伪分布模式","content":" 1 伪分布模式 2 Hadoop配置文件 2.1 core-site.xml 2.2 hdfs-site.xml 2.3 hadoop-env.sh 3 本地无密码ssh连接 4 运行 4.1 格式化HDFS 4.2 启动NameNode 4.3 测试 5 使用YARN配置 5.1 配置文件 5.1.1 mapred-site.xml 5.1.2 yarn-site.xml 5.2 运行 6 参考 1 伪分布模式 伪分布模式是运行在单个节点以及多个Java进程上的模式。相比起本地模式，需要进行更多配置文件的设置以及ssh、YARN相关设置。 2 Hadoop配置文件 修改Hadoop安装目录下的三个配置文件： etc/hadoop/core-site.xml etc/hadoop/hdfs-site.xml etc/hadoop/hadoop-env.sh 2.1 core-site.xml 首先修改core-site.xml： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; fs.defaultFS设置的是HDFS的地址，设置运行在本地的9000端口上 hadoop.tmp.dir设置的是临时目录，如果没有设置的话默认在/tmp/hadoop-${user.name}中，系统重启后会导致数据丢失，因此修改这个临时目录的路径 接着创建该临时目录： mkdir -p /usr/local/hadoop/tmp 2.2 hdfs-site.xml 接着修改hdfs-site.xml： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; dfs.replication设置的是HDFS存储的临时备份数量，因为伪分布模式中只有一个节点，所以设置为1。 2.3 hadoop-env.sh 修改该文件添加JAVA_HOME环境变量，就算JAVA_HOME在 ~/.bashrc ~/.bash_profile /etc/profile 等中设置了，运行时也是会提示找不到JAVA_HOME，因此需要手动在hadoop-env.sh中设置JAVA_HOME： 3 本地无密码ssh连接 下一步需要设置本地无密码ssh连接，首先先检查确保开启sshd服务： systemctl status sshd 开启后可以直接localhost连接： ssh localhost 输入自己的用户密码后就可以访问了，但是这里需要的是无密码连接，因此配置密钥认证连接的方式： ssh-keygen -t ed25519 -a 100 cat ~/.ssh/id_25519.pub &gt;&gt; ~/.ssh/authorized_keys chmod 0600 ~/.ssh/authorized_keys 这里生成公私钥后把公钥添加到authorized_keys中，并且修改权限，需要注意600权限，只能本用户有写权限。 然后直接ssh localhost就可以连接本地主机了。 4 运行 4.1 格式化HDFS 这里以单一节点的模式运行，首先格式化HDFS： # HADOOP为Hadoop安装目录 HADOOP/bin/hdfs namenode -format 格式化是对HDFS中的DataNode进行分块，统计所有分块后的初始元数据，存储在NameNode中。 格式化成功后会在上面配置文件中设置的临时目录中生成dfs目录，如下所示： 里面只有一个目录：dfs/name/current，其中tmp/dfs/name/current的文件如下： 文件说明如下： fsimage：NameNode元数据在内存满后，持久化保存到的文件 fsimage*.md5：校验文件，用于校验fsimage的完整性 seen_txid：存放transactionID文件，format之后为0,表示NameNode里面的edits_*文件的尾数 VERSION：保存创建时间，namespaceID、blockpoolID、storageType、cTime、clusterID、layoutVersion 关于VERSION的说明： namespaceID：HDFS唯一标识符，在HDFS首次格式化后生成 blockpoolID：标识一个block pool，跨集群全局唯一 storageType：存储什么进程的数据结构信息 cTime：创建时间 clusterID：系统生成或指定的集群ID，可以使用-clusterid指定 layoutVersion：表示HDFS永久性数据结构版本的信息 4.2 启动NameNode HADOOP/sbin/start-dfs.sh 然后可以通过 localhost:9870 访问NameNode： 4.3 测试 生成输入目录，并使用配置文件作为输入： bin/hdfs dfs -mkdir /user bin/hdfs dfs -mkdir /user/USER_NAME # USER_NAME为您的用户名 bin/hdfs dfs -mkdir input bin/hdfs dfs -put etc/hadoop/*.xml input 测试： bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.0.jar grep input output 'dfs[a-z.]+' 获取输出： bin/hdfs dfs -get output output # 复制输出到output目录 cat output/* 停止： sbin/stop-hdfs.sh 5 使用YARN配置 除了可以将单个节点以伪分布模式启动，还可以通过YARN统一调度，只需要适当修改配置文件。 5.1 配置文件 修改以下文件： HADOOP/etc/hadoop/mapred-site.xml HADOOP/etc/hadoop/yarn-site.xml 5.1.1 mapred-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; mapreduce.framework.name指定了MapReduce运行在YARN上 mapreduce.application.classpath指定了类路径 5.1.2 yarn-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; yarn.nodemanager.aux-services：运行在NodeManager上运行的附属服务 yarn.nodemanager.env-whitelist：环境变量通过从NodeManagers的容器继承的环境属性 5.2 运行 sbin/start-yarn.sh 运行后就可以通过 localhost:8088 访问： 停止： sbin/stop-yarn.sh 6 参考 Hadoop3.3.0官方文档 CSDN-GitChat·大数据 | 史上最详细的Hadoop环境搭建 CSDN-Hadoop Namenode元数据文件 Fsimage、editlog、seen_txid说明 ","link":"https://2293736867.github.io/post/hadoop-wan-zheng-da-jian-guo-cheng-er-wei-fen-bu-mo-shi/"},{"title":"Hadoop完整搭建过程（一）：本地模式","content":" 1 本地模式 2 准备工作 3 使用 4 输出 5 参考 1 本地模式 本地模式是最简单的模式，所有模块都运行在一个JVM进程中，使用本地文件系统而不是HDFS。 本地模式主要是用于本地开发过程中的运行调试用，下载后的Hadoop不需要设置默认就是本地模式。 2 准备工作 笔者喜欢把JDK放在/usr/local下，运行前请确保设置了JAVA_HOME，注意是在etc/hadoop/hadoop-env.sh中设置： tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz sudo mv openjdk-11+28_linux-x64_bin /usr/local/java sudo vim HADOOP/etc/hadoop/hadoop-env.sh # HADOOP为Hadoop安装目录 # 输入 export JAVA_HOME=/usr/local/java 3 使用 官网关于该模式没有太多的描述，只有一个使用默认配置文件作为输入，然后匹配正则表达式作为输出的简单例子： # HADOOP表示Hadoop安装目录 mkdir input cp HADOOP/etc/hadoop/*.xml input HADOOP/bin/hadoop jar HADOOP/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.0.jar grep input output 'dfs[a-z.]+' cat output/* 从下图的id可以看出是以本地模式工作的： 4 输出 输出文件夹output有两个文件： _SUCCESS：是个空文件，表示运行成功 part-r-00000：输出结果文件，词数统计 part-r-00000结果如上图所示。 实际上本地模式不需要特别的处理，因为默认就是本地模式。 5 参考 Hadoop3.3.0官方文档 ","link":"https://2293736867.github.io/post/hadoop-wan-zheng-da-jian-guo-cheng-yi-ben-di-mo-shi/"},{"title":"每日分享 第66期","content":" 每日鸡汤 如果你的前半声过得很坎坷，也不必太担心，下半生你就会适应的。 每日冷知识 德国空军曾在英吉利海峡安放了许多大型救生浮标，以供被击落的飞行员在其中生存下去。浮标内装有食物，酒精，衣物和纸牌游戏。 每日诗词 只知逐胜忽忘寒，小立春风夕照间。 ——杨万里《雪后晚晴四山皆青惟东山全白赋最爱东山晴后雪二绝句》 每日一句 我决定以人类的一个方法来感激你，我打算以身相许！ 每日音乐 赤伶-HITA 戏一折 水袖起落 唱悲欢离合 无关我 扇开合 锣鼓响又默 戏中情戏外人 凭谁说 惯将喜怒哀乐都融入粉墨 陈词唱穿又如何 白骨青灰皆我 乱世浮萍忍看烽火燃山河 位卑未敢忘忧国 哪怕无人知我 台下人走过 不见旧颜色 台上人唱着 心碎离别歌 情字难落墨 她唱须以血来和 戏幕起 戏幕落 谁是客 啊 浓情悔认真 回头皆幻景 对面是何人 戏一折 水袖起落 唱悲欢离合 无关我 扇开合 锣鼓响又默 戏中情戏外人 凭谁说 惯将喜怒哀乐都藏入粉墨 陈词唱穿又如何 白骨青灰皆我 乱世浮萍忍看烽火燃山河 位卑未敢忘忧国 哪怕无人知我 台下人走过 不见旧颜色 台上人唱着 心碎离别歌 情字难落墨 她唱须以血来和 戏幕起 戏幕落 终是客 你方唱罢我登场 莫嘲风月戏 莫笑人荒唐 也曾问青黄 也曾铿锵唱兴亡 道无情 道有情 怎思量 道无情 道有情 费思量 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-66-qi/"},{"title":"每日分享 第65期","content":" 每日鸡汤 穷你就努力啊！不努力折腾，你怎么负债百万。 每日冷知识 自2000年以来，归功于辛迪加特许权使用费，《老友记》演员阵容中的每位成员每年都可以赚取2000万美元。华纳兄弟每年可由此赚取将近10亿美元。 每日诗词 今宵酒醒何处，杨柳岸，晓风残月。 ——柳永《雨霖铃·寒蝉凄切》 每日一句 一个人的思想等于一个人的素养。 每日音乐 退-蒋蒋 我们乐此不疲 沉迷情感游戏 大雨总在纷纷扰扰中断句 往事今非昔比 回忆如一滩泥 陷入沼泽的你遇到了天敌 谎言变本加厉的说客 好多委屈无法平复的过客 后退 退到没了绝路我好狼狈 撑到最后我不敢再奉陪 流着眼泪装什么大无畏 现在尝到无路可退孤独的滋味 后退 退到悬崖绝壁我好心碎 粉身碎骨我不怕成野鬼 你的眼角为什么还有泪 终于明白我们都在黑夜里沉醉 沉醉 往事今非昔比 回忆如一滩泥 陷入沼泽的你遇到了天敌 谎言变本加厉的说客 好多委屈无法平复的过客 后退 退到没了绝路我好狼狈 撑到最后我不敢再奉陪 流着眼泪装什么大无畏 现在尝到无路可退孤独的滋味 后退 退到悬崖绝壁我好心碎 粉身碎骨我不怕成野鬼 你的眼角为什么还有泪 终于明白我们都在黑夜里沉醉 后退 退到没了绝路我好狼狈 撑到最后我不敢再奉陪 流着眼泪装什么大无畏 现在尝到无路可退孤独的滋味 后退 退到悬崖绝壁我好心碎 粉身碎骨我不怕成野鬼 你的眼角为什么还有泪 终于明白我们都在黑夜里沉醉 沉醉 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-65-qi/"},{"title":"每日分享 第64期","content":" 每日鸡汤 我的脑袋不是空的。我是要大作为的人，只是混沌初开。 每日冷知识 在安德鲁·朗格的另一版本《三只小猪》中，这些小猪被命名为：小棕，小白和小黑，敌人是一只狐狸而不是狼。 每日诗词 烟横水际，映带几点归鸦，东风销尽龙沙雪。 ——贺铸《石州引·薄雨初寒》 每日一句 冰雪林中著此身，不同桃李混芳尘。 每日音乐 炮火-郑子威 心死得不会痛 像个英雄 只管舍身去冲 为你心动 静默后患无穷 泪眼通红 锥心刻骨我懂 如迎着炮火 追赶你的脸庞 少不了痛楚 甘心放手一博 从泥泞踏过 看散落的花火 捉不到一角 末路乐极迷途 渐到荒芜 辗转反侧跌倒 未退一步 自问误入歧途 没听忠告 一心只等破土 如迎着炮火 充当炮灰的我 将所有结果 统统都抛给我 如同着了魔 勉强幸福好么 真心未够多 漠视着炮火 充当炮兵不过 想得到更多 得到太多沮丧 流言亦划破 你却让我搜索 找不到一个 只得我一个 怎么我一个 用苦闷陪我 就向着炮火 充当炮灰的我 少不免痛楚 撕心痛苦一个 从泥泞踏过 看散落的花火 捉不到半颗 别理会炮火 充当炮兵不过 想得到更多 得到太多沮丧 流言亦划破 你却让我搜索 他不会等我 道路上极疲劳 患上孤独 奄奄一息也好 亦要追逐 就是命运难逃 被你俘虏 早知一早结束 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-64-qi/"},{"title":"VirtualBox CentOS8 调整分辨率","content":"1 概述 VirtualBox安装完CentOS8后无法调节分辨率，需要安装额外的工具。 2 安装依赖包 首先确保虚拟机能正常连接网络，然后安装：kernel、kernel-core、kernel-modules、kernel-devel、gcc、make、perl、elfutils-libelf-devel： sudo yum install kernel kernel-core kernel-modules kernel-devel \\ gcc make perl elfutils-libelf-devel 检查kernel源码是否与内核版本是否一致： ls /usr/src/kernels uname -r 不一致是正常的： 因为此时需要重启选择新的内核版本： 然后再次检查： 3 下载增强工具 检查正确之后，下载对应版本的VirtualBox的增强工具镜像，链接戳这里，比如笔者的是这个： 4 安装 下载完成后挂载，点击菜单拦中的Devices下的Insert Guest Additions CD Images，然后会提示如下： 运行即可，出现下图输出则表示成功（如果失败请根据日志文件(/var/log/vboxadd-setup.log)定位问题并自行解决）： 然后就可以自由调节分辨率了。 ","link":"https://2293736867.github.io/post/virtualbox-centos8-diao-zheng-fen-bian-lu/"},{"title":"每日分享 第63期","content":" 每日鸡汤 再努力一点，你就能走向，人生癫疯。 每日冷知识 将近50%的巴西模特来自巴西的南里奥格兰德州，而巴西的总人口中只有6%居住在那个州。 每日诗词 楼头残梦五更钟，花底离愁三月雨。 ——晏殊《玉楼春·春恨》 每日一句 我命令你，喜欢我！ 每日音乐 飞鸟和婵-任然 你说青涩最搭初恋 如小雪落下海岸线 第五个季节某一天上演 我们有相遇的时间 你说空瓶适合许愿 在风暖月光的地点 第十三月你就如期出现 海之角不再遥远 你骄傲的飞远 我栖息的夏天 听不见的宣言 重复过很多年 北纬线的思念被季风吹远 吹远默念的侧脸 吹远鸣唱的诗篇 你骄傲的飞远 我栖息的叶片 去不同的世界 却从不曾告别 沧海月的想念羽化我昨天 在我成熟的笑脸 你却未看过一眼 你说空瓶适合许愿 在风暖月光的地点 第十三月你就如期出现 海之角也不再遥远 你骄傲的飞远 我栖息的夏天 听不见的宣言 重复过很多年 北纬线的思念被季风吹远 吹远默念的侧脸 吹远鸣唱的诗篇 你骄傲的飞远 我栖息的叶片 去不同的世界 却从不曾告别 沧海月的想念羽化我昨天 在我成熟的笑脸 你却未看过一眼 你骄傲的飞远 我栖息的夏天 听不见的宣言 重复过很多年 北纬线的思念被季风吹远 吹远默念的侧脸 吹远鸣唱的诗篇 你骄傲的飞远 我栖息的叶片 去不同的世界 却从不曾告别 沧海月的想念羽化我昨天 在我成熟的笑脸 你却未看过一眼 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-63-qi/"},{"title":"每日分享 第62期","content":" 每日鸡汤 其实表白未必是件好事，因为那样显得手黑。 每日冷知识 香蕉之所以具有弯曲的形状，是因为它们在生长时会趋向于阳光，这种独特的过程被称作“负向地性”。 每日诗词 接天莲叶无穷碧，映日荷花别样红。 ——杨万里《晓出净慈寺送林子方》 每日一句 在不同的遭遇里我发现你的瞬间，有种不可言说的温柔直觉。 每日音乐 唐人-孙子涵 一如昨日烛火 伴扁舟相随 哪有唐人不懂的陶醉 我孤舟 你窈窕 岸上有隐晦 一踏万里与谁相随 你穿错了嫁妆怎能有快乐 再上一层胭脂也华美 一声戛然而止庭前的鞭炮 妄想同你华发的心作废 你说不要自作自受自己创造伤悲 谁都可以彻底忘记谁 你说过往不及回首 别后悔了才会 想方设法地把你追回 你说孤独是诗人应该具有的体会 写歌的人就该有伤悲 我点一丝烛火一时泛滥了思念 写首小调名字叫后悔 你说不要自作自受自己创造伤悲 谁都可以彻底忘记谁 你说过往不及回首别后悔了才会 想方设法地把你追回 你说孤独是诗人应该具有的体会 写歌的人就该有伤悲 我点一丝烛火一时泛滥了思念 写首小调名字叫后悔 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-62-qi/"},{"title":"Linux终端更改字体","content":"1 概述 这里的终端是指通过F1-F6/F2-F7进入的纯命令终端。 修改字体可以通过setfont命令。 2 查看字体 可以通过查找目录consolefonts来确定本地机器上的字体位于哪里： find / -name consolefonts -type d updatedb locate consolefonts 比如笔者的Manjaro位于/usr/share/kbd/consolefonts，CentOS8则位于/usr/lib/kbd/consolefonts，而其他的一些可能位于/lib/usr/consolefonts，其中的文件如下： 一般为.cp.gz/.psfu.gz/psf.gz格式，后面的.gz表示gzip压缩，而其他的区别如下： .cp：CP字体是CPI（Code Page Information）的碎片（fragments）,通过连接CPEntryHeader、FontDataHeader、ScreenFontHeader、ScreenFontData得到 .psf/.psfu：PC Screen Fonts缩写，通常以.psfu形式存储 3 设置字体 很简单，使用setfont即可： setfont xxx.cp.gz/xxx.psfu.gz/xxx.psf.gz 对于psfu/psf文件名上面有字体大小，一般为8/14/16，对于.cp.gz字体需要指定大小，也是8/14/16。 4 安装额外字体 如果系统提供的字体过小可以选择安装额外的字体包Termius-fonts，戳这里下载。 接着需要编译安装： ./configure --prefix=/usr/local/consolefonts make -j n # n为CPU核心数 sudo make install 然后就可以在对应的文件夹（/usr/share/kbd/consolefonts等）看到新增的字体了： 这些字体以ter-开头，后面标注了大小，b表示粗体，n表示正常大小，提供了以下大小的字体： 6x12 8x14 8x16 10x18 10x20 11x22 12x24 14x28 16x32 使用setfont设置后即可看到效果。 ","link":"https://2293736867.github.io/post/linux-zhong-duan-geng-gai-zi-ti/"},{"title":"SpringBoot-如何设计优秀的后端接口?","content":" 1 概述 2 新建工程 3 参数校验 3.1 Hibernate Validator 3.1.1 介绍 3.1.2 使用 3.1.3 测试 3.2 校验模式设置 3.3 @Valid与@Validated 3.4 分组 3.5 组序列 3.6 自定义校验 3.6.1 自定义注解 3.6.2 自定义Validator 4 异常处理 4.1 基本使用 4.2 自定义异常 5 数据响应 5.1 统一响应体 5.2 响应码枚举 5.3 全局包装响应体 5.4 绕过全局包装 6 总结 7 源码 8 参考 1 概述 本篇文章以Spring Boot为基础，从以下三个方向讲述了如何设计一个优秀的后端接口体系： 参数校验：涉及Hibernate Validator的各种注解，快速失败模式，分组，组序列以及自定义注解/Validator 异常处理：涉及ControllerAdvice/@RestControllerAdvice以及@ExceptionHandler 数据响应：涉及如何设计一个响应体以及如何包装响应体 有了一个优秀的后端接口体系，不仅有了规范，同时扩展新的接口也很容易，本文演示了如何从零一步步构建一个优秀的后端接口体系。 2 新建工程 打开熟悉的IDEA，选择依赖： 首先创建如下文件： TestController.java： @RestController @RequestMapping(&quot;/&quot;) @CrossOrigin(value = &quot;http://localhost:3000&quot;) @RequiredArgsConstructor(onConstructor = @__(@Autowired)) public class TestController { private final TestService service; @PostMapping(&quot;test&quot;) public String test(@RequestBody User user) { return service.test(user); } } 使用了@RequiredArgsConstructor代替@Autowired，由于笔者使用Postwoman测试，因此需要加上跨域注解@CrossOrigin，默认3000端口（Postwoman端口）。 TestService.java： @Service public class TestService { public String test(User user) { if(StringUtils.isEmpty(user.getEmail())) return &quot;邮箱不能为空&quot;; if(StringUtils.isEmpty(user.getPassword())) return &quot;密码不能为空&quot;; if(StringUtils.isEmpty(user.getPhone())) return &quot;电话不能为空&quot;; // 持久化操作 return &quot;success&quot;; } } 业务层首先进行了参数校验，这里省略了持久化操作。 User.java： @Data public class User { private String phone; private String password; private String email; } 3 参数校验 首先来看一下参数校验，上面的例子中在业务层完成参数校验，这是没有问题的，但是，还没进行业务操作就需要进行这么多的校验显然这不是很好，更好的做法是，使用Hibernate Validator。 3.1 Hibernate Validator 3.1.1 介绍 JSR是Java Specification Requests的缩写，意思是Java规范提案，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。JSR-303是Java EE6中的一项子规范，叫作Bean Validation，Hibernate Validator是Bean Validator的参考实现，除了实现所有JSR-303规范中的内置constraint实现，还有附加的constraint，详细如下： @Null：被注解元素必须为null（为了节省篇幅下面用“元素”代表“被注解元素必须为”） @NotNull：元素不为null @AssertTrue：元素为true @AssertFalse：元素为false @Min(value)：元素大于或等于指定值 @Max(value)：元素小于或等于指定值 @DecimalMin(value)：元素大于指定值 @DecimalMax(value)：元素小于指定值 @Size(max,min)：元素大小在给定范围内 @Digits(integer,fraction)：元素字符串中的整数位数规定最大integer位，小数位数规定最大fraction位 @Past：元素是一个过去日期 @Future：元素是将来日期 @Pattern：元素需要符合正则表达式 其中Hibernate Validator附加的constraint如下： @Eamil：元素为邮箱 @Length：字符串大小在指定范围内 @NotEmpty：字符串必须非空（目前最新的6.1.5版本已弃用，建议使用标准的@NotEmpty） @Range：数字在指定范围内 而在Spring中，对Hibernate Validation进行了二次封装，添加了自动校验，并且校验信息封装进了特定的BindingResult中。下面看看如何使用。 3.1.2 使用 在各个字段加上@NotEmpty，并且邮箱加上@Email，电话加上11位限制，并且在各个注解加上message，表示对应的提示信息： @Data public class User { @NotEmpty(message = &quot;电话不能为空&quot;) @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;) private String phone; @NotEmpty(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;) private String password; @NotEmpty(message = &quot;邮箱不能为空&quot;) @Email(message = &quot;邮箱格式不正确&quot;) private String email; } 对于String来说有时候会使用@NotNull或@NotBlank，它们的区别如下： @NotEmpty：不能为null并且长度必须大于0，除了String外，对于Collection/Map/数组也适用 @NotBlank：只用于String，不能为null，并且调用trim()后，长度必须大于0，也就是必须有除空格外的实际字符 @NotNull：不能为null 接着把业务层的参数校验操作删除，并把控制层修改如下： @PostMapping(&quot;test&quot;) public String test(@RequestBody @Valid User user, BindingResult bindingResult) { if(bindingResult.hasErrors()) { for(ObjectError error:bindingResult.getAllErrors()) return error.getDefaultMessage(); } return service.test(user); } 在需要校验的对象上加上@Valid，并且加上BindingResult参数，可以从中获取错误信息并返回。 3.1.3 测试 全部都使用错误的参数设置，返回”邮箱格式不正确“： 第二次测试中除了密码都使用正确的参数，返回”密码必须为6-20位“： 第三次测试全部使用正确的参数，返回”success“： 3.2 校验模式设置 Hibernate Validator有两种校验模式： 普通模式：默认模式，会校验所有属性，然后返回所有的验证失败信息 快速失败模式：只要有一个验证失败就返回 使用快速失败模式需要通过HibernateValidateConfiguration以及ValidateFactory创建Validator，并且使用Validator.validate()进行手动验证。 首先添加一个生成Validator的类： @Configuration public class FailFastValidator&lt;T&gt; { private final Validator validator; public FailFastValidator() { validator = Validation .byProvider(HibernateValidator.class).configure() .failFast(true).buildValidatorFactory() .getValidator(); } public Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T user) { return validator.validate(user); } } 修改控制层的代码，通过@RequiredArgsConstructor注入FailFastValidator&lt;User&gt;，并把原来的在User上的@Valid去掉，在方法体进行手动验证： @RequiredArgsConstructor(onConstructor = @__(@Autowired)) public class TestController { private final TestService service; private final FailFastValidator&lt;User&gt; validator; @PostMapping(&quot;test&quot;) public String test(@RequestBody User user, BindingResult bindingResult) { Set&lt;ConstraintViolation&lt;User&gt;&gt; message = validator.validate(user); message.forEach(t-&gt; System.out.println(t.getMessage())); // if(bindingResult.hasErrors()) // { // bindingResult.getAllErrors().forEach(t-&gt;System.out.println(t.getDefaultMessage())); // for(ObjectError error:bindingResult.getAllErrors()) // return error.getDefaultMessage(); // } return service.test(user); } } 测试（连续三次校验的结果）： 如果是普通模式（修改.failFast(false)），一次校验便会连续输出三个信息： 3.3 @Valid与@Validated @Valid是javax.validation包里面的，而@Validated是org.springframework.validation.annotation里面的，是@Valid的一次封装，相当于是@Valid的增强版，供Spring提供的校验机制使用，相比起@Valid，@Validated提供了分组以及组序列的功能。下面分别进行介绍。 3.4 分组 当需要在不同的情况下使用不同的校验方式时，可以使用分组校验。比如在注册时不需要校验id，修改信息时需要校验id，但是默认的校验方式在两种情况下全部都校验，这时就需要使用分组校验。 下面以不同的组别校验电话号码长度的不同进行说明，修改User类如下： @Data public class User { @NotEmpty(message = &quot;电话不能为空&quot;) @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;,groups = {GroupA.class}) @Length(min = 12,max = 12,message = &quot;电话号码必须12位&quot;,groups = {GroupB.class}) private String phone; @NotEmpty(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;) private String password; @NotEmpty(message = &quot;邮箱不能为空&quot;) @Email(message = &quot;邮箱格式不正确&quot;) private String email; public interface GroupA{} public interface GroupB{} } 在@Length中加入了组别，GroupA表示电话需要为11位，GroupB表示电话需要为12位，GroupA/GroupB是User中的两个空接口，然后修改控制层： public String test(@RequestBody @Validated({User.GroupB.class}) User user, BindingResult bindingResult) { if(bindingResult.hasErrors()) { bindingResult.getAllErrors().forEach(t-&gt;System.out.println(t.getDefaultMessage())); for(ObjectError error:bindingResult.getAllErrors()) return error.getDefaultMessage(); } return service.test(user); } 在@Validated中指定为GroupB，电话需要为12位，测试如下： 3.5 组序列 默认情况下，不同组别的约束验证的无序的，也就是说，对于下面的User类： @Data public class User { @NotEmpty(message = &quot;电话不能为空&quot;) @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;) private String phone; @NotEmpty(message = &quot;密码不能为空&quot;) @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;) private String password; @NotEmpty(message = &quot;邮箱不能为空&quot;) @Email(message = &quot;邮箱格式不正确&quot;) private String email; } 每次进行校验的顺序不同，三次测试结果如下： 有些时候顺序并不重要，而有些时候顺序很重要，比如： 第二个组中的约束验证依赖于一个稳定状态运行，而这个稳定状态由第一个组来进行验证 某个组的验证比较耗时，CPU和内存的使用率相对较大，最优的选择是将其放在最后进行验证 因此在进行组验证的时候需要提供一种有序的验证方式，一个组可以定义为其他组的序列，这样就可以固定每次验证的顺序而不是随机顺序，另外如果验证组序列中，前面的组验证失败，则后面的组不会验证。 例子如下，首先修改User类并定义组序列： @Data public class User { @NotEmpty(message = &quot;电话不能为空&quot;,groups = {First.class}) @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;,groups = {Second.class}) private String phone; @NotEmpty(message = &quot;密码不能为空&quot;,groups = {First.class}) @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;,groups = {Second.class}) private String password; @NotEmpty(message = &quot;邮箱不能为空&quot;,groups = {First.class}) @Email(message = &quot;邮箱格式不正确&quot;,groups = {Second.class}) private String email; public interface First{} public interface Second{} @GroupSequence({First.class,Second.class}) public interface Group{} } 定义了两个空接口First和Second表示顺序，同时在Group中使用@GroupSequence指定了顺序。 接着修改控制层，在@Validated中定义组： public String test(@RequestBody @Validated({User.Group.class}) User user, BindingResult bindingResult) 这样就能按照固定的顺序进行参数校验了。 3.6 自定义校验 尽管Hibernate Validator中的注解适用情况很广了，但是有时候需要特定的校验规则，比如密码强度，人为判定弱密码还是强密码。也就是说，此时需要添加自定义校验的方式，有两种处理方法： 自定义注解 自定义Validator 首先来看一下自定义注解的方法。 3.6.1 自定义注解 这里添加一个判定弱密码的注解WeakPassword： @Documented @Constraint(validatedBy = WeakPasswordValidator.class) @Target({ElementType.METHOD,ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface WeakPassword{ String message() default &quot;请使用更加强壮的密码&quot;; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; } 同时添加一个实现了ConstraintValidator&lt;A,T&gt;的WeakPasswordValidator，当密码长度大于10位时才符合条件，否则返回false表示校验不通过： public class WeakPasswordValidator implements ConstraintValidator&lt;WeakPassword,String&gt; { @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) { return s.length() &gt; 10; } @Override public void initialize(WeakPassword constraintAnnotation) {} } 接着可以修改User如下，在对应的字段加上自定义注解@WeakPassword： @Data public class User { //... @WeakPassword(groups = {Second.class}) private String password; //... } 测试如下： 3.6.2 自定义Validator 除了自定义注解之外，还可以自定义Validator来实现自定义的参数校验，需要实现Validator接口： @Component public class WeakPasswordValidator implements Validator{ @Override public boolean supports(Class&lt;?&gt; aClass) { return User.class.equals(aClass); } @Override public void validate(Object o, Errors errors) { ValidationUtils.rejectIfEmpty(errors,&quot;password&quot;,&quot;password.empty&quot;); User user = (User)o; if(user.getPassword().length() &lt;= 10) errors.rejectValue(&quot;password&quot;,&quot;Password is not strong enough!&quot;); } } 实现其中的supports以及validate： support：可以验证该类是否是某个类的实例 validate：当supports返回true后，验证给定对象o，当出现错误时，向errors注册错误 ValidationUtils.rejectIfEmpty校验当对象o中某个字段属性为空时，向其中的errors注册错误，注意并不会中断语句的运行，也就是即使password为空，user.getPassword()还是会运行，这时会抛出空指针异常。下面的errors.rejectValue同样道理，并不会中断语句的运行，只是注册了错误信息，中断的话需要手动抛出异常。 修改控制层中的返回值，改为getCode()： if(bindingResult.hasErrors()) { bindingResult.getAllErrors().forEach(t-&gt; System.out.println(t.getCode())); for(ObjectError error:bindingResult.getAllErrors()) return error.getCode(); } return service.test(user); 测试： 4 异常处理 到这里参数校验就完成了，下一步是处理异常。 如果将参数校验中的BindingResult去掉，就会将整个后端异常返回给前端： //public String test(@RequestBody @Validated({User.Group.class}) User user, BindingResult bindingResult) public String test(@RequestBody @Validated({User.Group.class}) User user) 这样虽然后端是方便了，不需要每一个接口都加上BindingResult，但是前端不好处理，整个异常都返回了，因此后端需要捕捉这些异常，但是，不能手动去捕捉每一个，这样还不如之前使用BindingResult，这种情况下就需要用到全局的异常处理。 4.1 基本使用 处理全局异常的步骤如下： 创建全局异常处理的类：加上@ControllerAdvice/@RestControllerAdvice注解（取决于控制层用的是@Controller/@RestController，@Controller可以跳转到相应页面，返回JSON等加上@ResponseBody即可，而@RestController相当于@Controller+@ResponseBody，返回JSON无需加上@ResponseBody，但是视图解析器无法解析jsp以及html页面） 创建异常处理方法：加上@ExceptionHandler指定想要处理的异常类型 处理异常：在对应的处理异常方法中处理异常 这里增加一个全局异常处理类GlobalExceptionHandler： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) public String methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) { ObjectError error = e.getBindingResult().getAllErrors().get(0); return error.getDefaultMessage(); } } 首先加上@RestControllerAdvice，并在异常处理方法上加上@ExceptionHandler。 接着修改控制层，去掉其中的BindingResult： @PostMapping(&quot;test&quot;) public String test(@RequestBody @Validated({User.Group.class}) User user) { return service.test(user); } 然后就可以进行测试了： 全局异常处理相比起原来的每一个接口都加上BindingResult方便很多，而且可以集中处理所有异常。 4.2 自定义异常 很多时候都会用到自定义异常，这里新增一个测试异常TestException： @Data public class TestException extends RuntimeException{ private int code; private String msg; public TestException(int code,String msg) { super(msg); this.code = code; this.msg = msg; } public TestException() { this(111,&quot;测试异常&quot;); } public TestException(String msg) { this(111,msg); } } 接着在刚才的全局异常处理类中添加一个处理该异常的方法： @ExceptionHandler(TestException.class) public String testExceptionHandler(TestException e) { return e.getMsg(); } 在控制层进行测试： @PostMapping(&quot;test&quot;) public String test(@RequestBody @Validated({User.Group.class}) User user) { throw new TestException(&quot;出现异常&quot;); // return service.test(user); } 结果如下： 5 数据响应 在处理好了参数校验以及异常处理之后，下一步就是要设置统一的规范化的响应数据，一般来说无论响应成功还是失败都会有一个状态码，响应成功还会携带响应数据，响应失败则携带相应的失败信息，因此，第一步是设计一个统一的响应体。 5.1 统一响应体 统一响应体需要创建响应体类，一般来说，响应体需要包含： 状态码：String/int 响应信息：String 响应数据：Object/T（泛型） 这里简单的定义一个统一响应体Result： @Data @AllArgsConstructor public class Result&lt;T&gt; { private String code; private String message; private T data; } 接着修改全局异常处理类： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) { ObjectError error = e.getBindingResult().getAllErrors().get(0); return new Result&lt;&gt;(error.getCode(),&quot;参数校验失败&quot;,error.getDefaultMessage()); } @ExceptionHandler(TestException.class) public Result&lt;String&gt; testExceptionHandler(TestException e) { return new Result&lt;&gt;(e.getCode(),&quot;失败&quot;,e.getMsg()); } } 使用Result&lt;String&gt;封装返回值，测试如下： 可以看到返回了一个比较友好的信息，无论是响应成功还是响应失败都会返回同一个响应体，当需要返回具体的用户数据时，可以修改控制层接口直接返回Result&lt;User&gt;： @PostMapping(&quot;test&quot;) public Result&lt;User&gt; test(@RequestBody @Validated({User.Group.class}) User user) { return service.test(user); } 测试： 5.2 响应码枚举 通常来说可以把响应码做成枚举类： @Getter public enum ResultCode { SUCCESS(&quot;111&quot;,&quot;成功&quot;),FAILED(&quot;222&quot;,&quot;失败&quot;); private final String code; private final String message; ResultCode(String code,String message) { this.code = code; this.message = message; } } 枚举类封装了状态码以及信息，这样在返回结果时，只需要传入对应的枚举值以及数据即可： @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) { ObjectError error = e.getBindingResult().getAllErrors().get(0); return new Result&lt;&gt;(ResultCode.FAILED,error.getDefaultMessage()); } @ExceptionHandler(TestException.class) public Result&lt;String&gt; testExceptionHandler(TestException e) { return new Result&lt;&gt;(ResultCode.FAILED,e.getMsg()); } } 5.3 全局包装响应体 统一响应体是个很好的想法，但是还可以再深入一步去优化，因为每次返回之前都需要对响应体进行包装，虽然只是一行代码但是每个接口都需要包装一下，这是个很麻烦的操作，为了更进一步“偷懒”，可以选择实现ResponseBodyAdvice&lt;T&gt;来进行全局的响应体包装。 修改原来的全局异常处理类如下： @RestControllerAdvice public class GlobalExceptionHandler implements ResponseBodyAdvice&lt;Object&gt; { @ExceptionHandler(MethodArgumentNotValidException.class) public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) { ObjectError error = e.getBindingResult().getAllErrors().get(0); return new Result&lt;&gt;(ResultCode.FAILED,error.getDefaultMessage()); } @ExceptionHandler(TestException.class) public Result&lt;String&gt; testExceptionHandler(TestException e) { return new Result&lt;&gt;(ResultCode.FAILED,e.getMsg()); } @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return !methodParameter.getParameterType().equals(Result.class); } @Override public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { return new Result&lt;&gt;(o); } } 实现了ResponseBodyAdvice&lt;Object&gt;： supports方法：判断是否支持控制器返回方法类型，可以通过supports判断哪些类型需要包装，哪些不需要包装直接返回 beforeBodyWrite方法：当supports返回true后，对数据进行包装，这样在返回数据时就无需使用Result&lt;User&gt;手动包装，而是直接返回User即可 接着修改控制层，直接返回实体类User而不是响应体包装类Result&lt;User&gt;： @PostMapping(&quot;test&quot;) public User test(@RequestBody @Validated({User.Group.class}) User user) { return service.test(user); } 测试输出如下： 5.4 绕过全局包装 虽然按照上面的方式可以使后端的数据全部按照统一的形式返回给前端，但是有时候并不是返回给前端而是返回给其他第三方，这时候不需要code以及msg等信息，只是需要数据，这样的话，可以提供一个在方法上的注解来绕过全局的响应体包装。 比如添加一个@NotResponseBody注解： @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface NotResponseBody { } 接着需要在处理全局包装的类中，在supports中进行判断： @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) { return !( methodParameter.getParameterType().equals(Result.class) || methodParameter.hasMethodAnnotation(NotResponseBody.class) ); } 最后修改控制层，在需要绕过的方法上添加自定义注解@NotResponseBody即可： @PostMapping(&quot;test&quot;) @NotResponseBody public User test(@RequestBody @Validated({User.Group.class}) User user) 6 总结 7 源码 直接clone下来使用IDEA打开即可，每一次优化都做了一次提交，可以看到优化的过程，喜欢的话欢迎给个star： Github 码云 8 参考 1、UncleChen的博客-SpringBoot自定义请求参数校验 2、简书-@Valid和@Validated的总结区分 3、博客园-@Controller与@RestController的区别 4、简书-【项目实践】-SpringBoot三招组合拳，手把手教你打出优雅的后端接口 5、简书-【项目实践】后端接口统一规范的同时，如何优雅得扩展规范 ","link":"https://2293736867.github.io/post/springboot-ru-he-she-ji-you-xiu-de-hou-duan-jie-kou/"},{"title":"每日分享 第61期","content":" 每日鸡汤 失败不可怕，可怕的是，你还相信这句话。 每日冷知识 在一群小丑鱼中，只有一条雌鱼处于严格等级制度的顶部，只有两条小丑鱼通过外部受精进行繁殖。由于它们雌雄同体，因此当为首的雌鱼死亡后，最大，最占优势的雄鱼就会变成雌鱼。 每日诗词 阳羡溪声冷骇人，洞庭山翠晚凝神。 ——高蟾《秋》 每日一句 为什么要担心？如果努力了，担心不会让结果变得更好。 每日音乐 撕心-钟洁 来跟着我唱 好 咳 我想就这样牵着你的手不妨开 我想就这样 唉呀不是你那样的是我这样的 唉呀 我想就这样牵着你的手不妨开 我想就这样 你找打是吧 故意瞎唱 你还记得么 两年前 我们这么幸福快乐 一起唱着 可现在 你在哪里 牵着谁的手呢 沉默 是因为情绪的低落 考虑好久 才会选择分手 心好痛 是因为爱划了一道伤口 泪在流 声音开始颤抖 沉默 是因为找不到理由 冷战很久 最后还是开口 别难过 你会遇到给你幸福的人 原谅我 配不上你的温柔 你承诺爱我很久很久 怎么现在 你让我猜不透 对不起 我不能满足你所有 茫茫路口只能擦肩而过 爱停留 你离开以后我哭了很久 躲在房间 我看不到彩虹 夜太深 是谁还徘徊在门口 有些梦关了灯才能拥有 你的吻 开门 你别来找我了好吧 我不是已经对你讲过了我们已经分手了 哎你有毛病吧 谁答应跟你分手了 你不要再背着我去问我朋友我怎么怎么样 你能不能听我说两句啊 这就够了 就这样 好 你别后悔 拜拜 爱情 怎么让我百感交集 太多惊喜 害我措手不及 背着你 无时无刻打听你的消息 很爱你 所以不愿放弃 爱情 只会让人得意忘形 哭红眼睛 也躲不过伤心 仔细听 是回忆狠狠撕碎你的心 在梦里 却痛得好清醒 你离开以后我哭了很久 躲在房间 我看不到彩虹 夜太深 是谁还徘徊在门口 有些梦关了灯才能拥有 你的吻 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-61-qi/"},{"title":"每日分享 第60期","content":" 每日鸡汤 人都需要努力的，努力过后你就会发现，你还真的是很普通。 每日冷知识 米开朗基罗是第三位接手制造大卫雕像的雕刻家。这块卡拉拉大理石本身品质平庸，遭到第二位雕刻家嫌弃后废置约25年，最后由米开朗基罗出手将其雕刻成了杰作。 每日诗词 梧桐叶上三更雨，叶叶声声是别离。 ——周紫芝《鹧鸪天·一点红残欲尽时》 每日一句 农民家的孩子啊，他们的第一堂功课就是劳动！ 每日音乐 樱花樱花想见你-李蚊香/满汉全席 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ だいじょうぶ もう泣かないで 私は風 あなたを包んでいるよ 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ ありがとう ずっと大好き 私は星 あなたを見守り続ける あなたに出会えてよかった 本当に本当によかった ここにもういれなくなっちゃった もう行かなくちゃ ホントゴメンね 私はもう一人で遠いところに行かなくちゃ どこへ?って聞かないで なんで?って聞かないで ホントゴメンね 私はもうあなたのそばにいられなくなったの いつもの散歩道 桜並木を抜けてゆき よく遊んだ川面の上の 空の光る方へと もう会えなくなるけど 寂しいけど 平気だよ 生まれてよかった ホントよかった あなたに出会ってよかった 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ だいじょうぶ もう泣かないで 私は風 あなたを包んでいるよ 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ ありがとう ずっと大好き 私は星 あなたを見守り続ける あなたに出会えてよかった 本当に本当によかった あなたの帰りを待つ午後 あなたの足音 何げないこと 私はそう、一番の喜びを知りました あなたが話してくれたこと 一日のこと いろいろなこと 私はそう、一番の悲しみも知りました それはあなたの笑顔 あなたの涙 その優しさ 私の名を呼ぶ声 抱き締める腕 その温もり もう触れられないけど 忘れないよ 幸せだよ 生まれてよかった ホントよかった あなたに出会ってよかった 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ だいじょうぶだよ ここにいる 私は春 あなたを抱く空 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ ありがとう ずっと大好き 私は鳥 あなたに歌い続ける 桜の舞う空の彼方 目を閉じれば心の中 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ いいんだよ 微笑んでごらん 私は花 あなたの指先の花 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ ありがとう ずっと大好き 私は愛 あなたの胸に 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ だいじょうぶ もう泣かないで 私は風 あなたを包んでいるよ 『さくら さくら 会いたいよ いやだ 君に今すぐ会いたいよ ありがとう ずっと大好き 私は星 あなたを見守り続ける あなたに出会えてよかった 本当に本当によかった 本当に本当によかった ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-60-qi/"},{"title":"每日分享 第59期","content":" 每日鸡汤 离家不需要太大的勇气，回家才需要。 每日冷知识 1914年至1925年之间，伏特加酒的生产和销售在俄罗斯遭到禁止。沙皇之所以颁布此法令，是为了辅助动员俄罗斯参加第一次世界大战。 每日诗词 已是南楼曲断，纵疏花淡月，也只凄凉。 ——王沂孙《声声慢》 每日一句 知识有两种，一种是你知道的，一种是你知道在哪里能找到的！ 每日音乐 何必再忆-钟洁/小琼 何必在意 那些过去的记忆 只是不能自已 放不下了你 你又何必在意 受了那么多委屈 痛苦也回不去 忘记这记忆 曾经我和你 天真说要在一起 说要用时间证明我们的爱情 我不懂爱情 只是满口的答应 一时糊涂自己 不知道结局 只是又一天 我发现我并不爱你 以为是错觉 并没告诉你 只是多年后 我们一起去看流星 我告诉了你 我并不爱你 何必在意 那些过去的记忆 只是不能自已 放不下了你 你又何必在意 受了那么多委屈 痛苦也回不去 忘记这记忆 你还记得么 我在街上吻你的时候 然后你害羞的看着我 真的很可爱 但是 只是有一天 我发现我并不爱你 以为是错觉 并没告诉你 只是多年后 我们一起去看流星 我告诉了你 我并不爱你 何必在意 那些过去的记忆 只是不能自已 放不下了你 你又何必在意 受了那么多委屈 痛苦也回不去 忘记这记忆 何必在意 那些过去的记忆 只是不能自已 放不下了你 你又何必在意 受了那么多委屈 痛苦也回不去 忘记这记忆 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-59-qi/"},{"title":"每日分享 第58期","content":" 每日鸡汤 你就是个土豆思，又土又逗，又屌丝。 每日冷知识 1914年至1925年之间，伏特加的生产和销售在俄罗斯遭到禁止。沙皇之所以颁布此法令，是为了辅助动员俄罗斯参加第一次世界大战。 每日诗词 最爱湖东行不足，绿杨阴里白沙堤。 ——白居易《钱塘湖春行》 每日一句 谎话被歌颂，扮清醒的人作哑装聋。 每日音乐 几度梦回大唐-深七 几度梦回大唐 心中无限凄凉 昔日王者断肠 我弯弓齐射天狼 苍穹一轮朱轮回 我看破轮回梦相随 随风逐浪霸天国 那生死轮回震天锤 这一次我踏入语音 手持神兵天魔琴 我这一生独步武林 其实另类似龙吟 昔日将你打入深渊 随这时光的变迁 青龙火凤盘双肩 尽日我定杀破天 三届之中听我号令 携带神兵昆仑镜 势必拿下二郎狗命 还我帝都的安宁 违抗王者命 杀 犯上作乱者 杀 不忠不孝者 杀 不仁不义者 杀 望九幽 魔战群仙 销毁挥霍写诗篇 看天下我烽火狼烟 让我孤身斗苍天 王道没有那么短 苍天在为我逆转 这一次我要重返 天下为我来呐喊 就算如今一人走 不会提到我怒吼 当我站在暴风口 是否还会牵我手 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-58-qi/"},{"title":"每日分享 第57期","content":" 每日鸡汤 你们之所以喝鸡汤，是因为肉被别人吃光了。 每日冷知识 2016年，一名英国男子为一部长达十小时的油漆风干视频众筹了资金，以此迫使英国电影分类委员会（BBFC）观看该电影，这是对BBFC要求独立电影制片人为每次提交审核支付1000英镑的抗议。 每日诗词 桃花尽日随流水，洞在清溪何处边。 ——张旭《桃花溪》 每日一句 当你手里有了锤子，那么敌人就是钉子。 每日音乐 我的将军啊-半阳 狼烟风沙口 还请将军少饮酒 前方的路不好走 我在家中来等候 可愿柳下走 满头杨画共白首 十两相思二两酒 我才把爱说出口 狼烟风沙口 还请将军少饮酒 前方的路不好走 我在家中来等候 可愿柳下走 满头杨花共白首 十两相思二两酒 我才把爱说出口 他一路凶险一路漂泊 从未安静过活 也受过挫折依旧执着 也曾信仰过佛 她风月佳人傲骨温存 似桃花般撩人 也曾有座坟住着亡人 她说她不信神 可她等了有三载 她等到碧落沧海 她等到四季交换 她依旧死不悔改 她口口声声和雪中 只手掌着孤灯 她醉醉疯疯渺渺空空 终日敲着佛钟 她诵经 她敲钟 她扑空 她成疯 水成冰 风无声 雪冻松 她寿终 她最后也没等到他 他最后也没回家 她见到一朵彼岸花 她却说那好像他 我的将军啊 你究竟去了哪啊 你说你去把敌杀啊 何故你不回家 我的英雄啊 你爱上别人了吗 如果是的告诉我吧 让我随风飘吧 狼烟风沙口 还请将军少饮酒 前方的路不好走 我在家中来等候 可愿柳下走 满头杨花共白首 十两相思二两酒 我才把爱说出口 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-57-qi/"},{"title":"每日分享 第56期","content":" 每日鸡汤 两个人吵架，打他是解决不了问题的，但是解气啊。 每日冷知识 2016年，现存最老的闰年婴儿Daisy Belle Ward在她诞辰100周年时庆祝了自己的25岁生日。 每日诗词 阴阴夏木啭黄鹂，何处飞来白鹭立移时。 每日一句 结局需要的是一个开始。 没开始说什么都是废话。 每日音乐 一曲相思-半阳 这人间袅袅炊烟 和风花雪月浪漫 痴情人多半贪恋 爱恨情仇都好看 又让你痛不欲生 又让你趁醉装疯 终有天脱胎换骨 直到哭着笑才懂 欲问青天 这人生有几何 怕这去日苦多 往事讨一杯相思喝 倘若这回还像曾经执着 心执念你一个 那我可能是多情了 浊酒一杯 余生不悲不喜 何俱爱恨别离 一路纵马去斟酌 一曲相思 入江水与山河 在油伞下走过 悠然入梦却恍若昨 这人间袅袅炊烟 和风花雪月浪漫 痴情人多半贪恋 爱恨情仇都好看 又让你痛不欲生 又让你趁醉装疯 终有天脱胎换骨 直到哭着笑才懂 欲问青天 这人生有几何 怕这去日苦多 往事讨一杯相思喝 倘若这回 还像曾经执着 心执念你一个 那我可能是多情了 浊酒一杯 余生不悲不喜 何俱爱恨别离 一路纵马去斟酌 一曲相思 入江水与山河 在油伞下走过 悠然入梦却恍若昨 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-56-qi/"},{"title":"配置Jupyter环境：安装+补全+美化+常用库","content":"1 Jupyter简介 Jupyter Notebook是一个交互式笔记本，支持运行40多种编程语言，本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和Markdown。 2 安装 使用pip或pip3安装： # sudo pip install jupyter sudo pip3 install jupyter 3 简单自定义设置 首先生成默认配置： jupyter notebook --generate-config 接着会提示默认配置的位置，打开，找到c.NotebookApp.notebook.dir=''可以修改默认目录： 注意需要加上u前缀，表示Unicode字符串。 c.NotebookApp.browser可以修改默认浏览器，比如修改为Chrome： 需要加上%s参数，路径修改为对应路径。 其余配置请配合注释直接修改。 4 补全 补全需要安装nbextensions以及nbextensions_configurator： sudo pip3 install jupyter_contrib_nbextensions jupyter_nbextensions_configurator # sudo pip install jupyter_contrib_nbextensions jupyter_nbextensions_configurator jupyter contrib nbextension install --user jupyter nbextensions_configurator enable --user 若依赖缺失请安装对应依赖，安装成功后打开Jupyter： jupyter notebook 进入Nbextensions选项卡，去掉disable xxx的那个勾选，选择Hinterland即可： 5 美化 默认的UI真的不忍直视，在Github上有一个jupyter-themes的工具，可以对其进行美化。首先使用pip3/pip安装： sudo pip3 install jupyterthemes 5.1 主题 安装完成后，使用 jt -l 查看主题，携带的主题有7个： onedork grade3 oceans16 chesterish monokai solarizedl solarizedd 使用-t切换主题，比如： jt -t chesterish 5.2 字体 支持以下三种自定义字体： 代码字体：-f Notebook字体（界面字体）：-nf 普通文本/Markdown字体：-tf 其中代码字体（-f）支持如下： Notebook字体（-nf）/普通文本字体（-tf）/Markdown字体（-tf）支持如下： 支持以下六种自定义字体大小： 代码字体大小：-fs，默认11 Notebook字体大小：-nfs，默认13 普通文本/Markdown字体大小：-tfs，默认13 Pandas Dataframs字体大小：-dfs，默认9 输出区域字体大小：-ofs，默认8.5 Mathjax字体大小：-mathfs，百分比，默认100% 比如笔者喜欢Firacode字体，并且需要放大输出区域的字体，可以如下设置： jt -t chesterish -f firacode -fs 14 -ofs 12 5.3 Cell宽度与行距 可以手动控制Cell的宽度以及代码的行距，-cellw控制宽度（默认980），-lineh控制行距（默认170）。 jt -cellw 1800 -lineh 200 5.4 UI元素显示 工具栏显隐：-T 名称与Logo显隐：-N 内核Logo显隐：-kl 5.5 绘图风格 使用如下语句设置（需要在Jupyter内）： from jupyterthemes import jtplot jtplot.style() 其中style()的参数如下： theme：字符串类型，主题，可选值与jt -l显示一致 context：字符串类型，取值paper，notebook，talk，poster grid：布尔类型，表示是否包含网格线 gridlines：字符串类型，表示网格线的风格，比如--表示虚线 ticks：布尔类型，表示x/y轴上的坐标标线的显隐 spines：布尔类型，表示图像四周是否显示包围框 fscale：float类型，表示缩放字体，图例等等 figsize：元组类型，表示默认的Matplotlib图像的大小 笔者的参考配置： jt -t chesterish -f firacode -fs 14 -ofs 12 -cellw 1500 -lineh 200 -T 6 常用库安装 使用pip+离线方式安装，首先需要知道系统架构，可以使用： arch uname -m 等方式查看，比如笔者的是x86_64，戳这里进入下载，常用库列表如下： Numpy Scipy Scikit-learn Scikit-image Spark MLLib（叫作PySpark） Theano TensorFlow PyTorch Pandas Matplotlib 下面以numpy进行演示安装，搜索后点击第一个： 根据Python版本，系统以及架构选择对应的包，下载： 使用pip3或pip安装即可： 其余库安装类似，若缺失依赖请先安装依赖。 ","link":"https://2293736867.github.io/post/pei-zhi-jupyter-huan-jing-an-zhuang-bu-quan-mei-hua-chang-yong-ku/"},{"title":"每日分享 第55期","content":" 每日鸡汤 考试真是so easy，哪里不会考哪里！ 每日冷知识 根据一项研究表明，观看高质量的电视剧可以提高你的情商，并增强你读懂他人情绪的能力。 每日诗词 多少恨，昨夜梦魂中。 ——李煜《忆江南·多少恨》 每日一句 ——什么是孤独？ ——心里明明空荡荡的，却什么也装不下。 每日音乐 芳华绝代-梅艳芳/张国荣 你想不想 吻一吻 倾国倾城 是我大名 蒙罗丽莎 只是一幅画 如何艳压天下 皇朝外的 伊莉莎白 谁来跪拜她 梦露若果 庄重高雅 何来绝世佳话 红颜祸水 锦上添花 教你荡产倾家 唯独是 天资国色 不可一世 天生我高贵艳丽到底 颠倒众生 吹灰不费 收你做我的迷 你敢不敢 抱一抱 疯魔一时 是我罪名 罗兰自称 芳名苏菲亚 男孩就会倒下 如能获得 芭铎亲一下 铁塔亦会垮 怕你甚么 称王称霸 来臣服我之下 银河艳星 单人匹马 胜过漫天烟花 唯独是 天资国色 不可一世 天生我高贵艳丽到底 颠倒众生 吹灰不费 收你做我的迷 唯独是 天资国色 不可一世 天生我高贵艳丽到底 得我艳与天齐 唯独是 天资国色 不可一世 天生我高贵艳丽到底 颠倒众生 吹灰不费 收你做我的迷 唯独是 天资国色 不可一世 天生我高贵艳丽到底 颠倒众生 吹灰不费 得我艳与天齐 你想不想吻一吻 倾国倾城 是我大名 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-55-qi/"},{"title":"每日分享 第54期","content":" 每日鸡汤 我生平最讨厌一个字，略！尤其是题不会做时。 每日冷知识 自1950年以来，美国共发生了32起核武器事故，这些事故被称为“断箭”，其中多达6枚核弹已经丢失并且下落不明。前苏联丢失了41枚，找回数量不详。 每日诗词 料得年年场断处，明月夜，短松冈。 ——苏轼《江城子 乙卯正月二十日记梦》 每日一句 黎明前的黑暗，是最深不见底的黑暗。 每日音乐 卜卦-崔子格 风吹沙蝶恋花千古佳话 似水中月情迷着镜中花 竹篱笆木琵琶拱桥月下 谁在弹唱思念远方牵挂 那年仲夏你背上行囊离开家 古道旁我欲语泪先下 庙里求签我哭诉青梅等竹马 求菩萨保佑我俩 不停的猜猜猜又卜了一卦 吉凶祸福还是担惊受怕 对你的爱爱爱望断了天涯 造化弄人缘分阴错阳差 风吹沙蝶恋花千古佳话 似水中月情迷着镜中花 竹篱笆木琵琶拱桥月下 谁在弹唱思念远方牵挂 那年仲夏你背上行囊离开家 古道旁我欲语泪先下 庙里求签我哭诉青梅等竹马 求菩萨保佑我俩 不停的猜猜猜又卜了一卦 吉凶祸福还是担惊受怕 造化弄人缘分阴错阳差 猜猜猜又卜了一卦 是上上签可还是放不下 对你的爱爱爱挨过几个冬夏 日夜思念求别再变卦 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-54-qi/"},{"title":"每日分享 第53期","content":" 每日鸡汤 假期定了个Plan，半个暑假结束了只完成了P，因为lan。 每日冷知识 科学家们认为，西伯利亚北方森林中的云杉和松树之所以可在-60摄氏度的温度下存活，是因为其树木组织可以通过“硬化”过程的一部分变成玻璃。 每日诗词 昨夜个人曾有约，严城玉漏三更。 ——纳兰性德《临江仙·昨夜个人曾有约》 每日一句 前进吧，星星在你的头上闪耀哦！ 每日音乐 无名之辈-陈雪燃 城市黎明的灯火 总有光环在陨落 模仿者一个又一个 无人问津的角色 你选择去崇拜谁呢 怨恨谁呢 假装热情的冷落 假装自由的枷锁 你最后成为了什么 燃烧华丽的烟火 绽放一次就足够了 奢求什么 无名之辈 我是谁 忘了谁 也无所谓 谁不是 拼了命走到生命的结尾 也许很累一身狼狈 也许卑微一生无为 也许永远成为不了 你的光辉 无名之辈 我是谁 忘了谁 也无所谓 继续追 谁的光荣不是伴着眼泪 也许很累一身狼狈 也许卑微一生无为 谁生来不都是一样 尽管叫我无名之辈 假装热情的冷落 假装自由的枷锁 你最后成为了什么 燃烧华丽的烟火 绽放一次就足够了 奢求什么 无名之辈 我是谁 忘了谁 也无所谓 谁不是 拼了命走到生命的结尾 也许很累一身狼狈 也许卑微一生无为 也许永远也成为不了谁 无名之辈 我是谁 忘了谁 也无所谓 继续追 谁的光荣不是伴着眼泪 也许很累一身狼狈 也许卑微一生无为 谁生来不都是一样 尽管叫我无名之辈 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-53-qi/"},{"title":"每日分享 第52期","content":" 每日鸡汤 哪有什么感同身受的心，全是站着说话不腰疼的嘴。 每日冷知识 咖啡在土耳其文化中无比重要，以至于根据15世纪的法律规定，如果丈夫无法为自己提供足够的咖啡，则妻子有权与其丈夫离婚。 每日诗词 谁家今夜扁舟子，何处相思明月楼？ ——张若虚《春江花月夜》 每日一句 人没有回忆是无法活下去的哟 每日音乐 维也纳的忧伤-钟洁 维也纳的忧伤随着河静静流淌 我把心事写在了信纸上 折成船飘向远方 维也纳的广场夜晚下显得悲凉 我用泪光记叙这段感伤 一直哭到了天亮 静止的雕像 仿佛诉说着过往 表情上略带几分忧伤 是否曾经很迷茫 墙上的石板画 记录那一段时光 没能牵住恋人的双手 从此走向了绝望 忧郁的目光 显得安静而端详 隐约听到华丽的乐章 随着琴声在远望 旧旧的琴房 月光洒在了琴上 看见弹奏夜曲的肖邦 忧伤被悄悄释放 维也纳的忧伤随着河静静流淌 我把心事写在了信纸上 折成船飘向远方 维也纳的广场夜晚下显得悲凉 我用泪光记叙这段感伤 一直哭到了天亮 静止的雕像 仿佛诉说着过往 表情上略带几分忧伤 是否曾经很迷茫 墙上的石板画 记录那一段时光 没能牵住恋人的双手 从此走向了绝望 忧郁的目光 显得安静而端详 隐约听到华丽的乐章 随着琴声在远望 旧旧的琴房 月光洒在了琴上 看见弹奏夜曲的肖邦 哦 忧郁的目光 显得安静而端详 隐约听到华丽的乐章 随着琴声在远望 旧旧的琴房 月光洒在了钢琴上 看见弹奏夜曲的肖邦 忧伤被悄悄释放 维也纳的忧伤随着河静静流淌 我把心事写在了信纸上 折成船飘向远方 维也纳的广场夜晚下显得悲凉 我用泪光记叙这段感伤 一直哭到了天亮 维也纳的忧伤随着河静静流淌 我把心事写在了信纸上 折成船飘向远方 维也纳的广场夜晚下显得悲凉 我用泪光记叙这段感伤 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-52-qi/"},{"title":"GoF设计模式合集","content":" 1 概述 2 基础 2.1 设计模式概述 2.2 UML与面向对象设计原则 3 创建型模式 3.1 单例模式 3.2 简单工厂模式 3.3 工厂方法模式 3.4 抽象工厂模式 3.5 原型模式 3.6 建造者模式 4 结构型模式 4.1 适配器模式 4.2 桥接模式 4.3 组合模式 4.4 装饰模式 4.5 外观模式 4.6 享元模式 4.7 代理模式 5 行为型模式 5.1 职责链模式 5.2 命令模式 5.3 解释器模式 5.4 迭代器模式 5.5 中介者模式 5.6 备忘录模式 5.7 观察者模式 5.8 状态模式 5.9 策略模式 5.10 模板方法模式 5.11 访问者模式 1 概述 这篇文章是对GoF23种设计模式+1种非GoF模式的合集，由笔者自己的笔记整理而来，每个模式都详细描述了步骤，角色等，以及使用Java实现的具体的例子。 2 基础 2.1 设计模式概述 2.2 UML与面向对象设计原则 3 创建型模式 3.1 单例模式 3.2 简单工厂模式 3.3 工厂方法模式 3.4 抽象工厂模式 3.5 原型模式 3.6 建造者模式 4 结构型模式 4.1 适配器模式 4.2 桥接模式 4.3 组合模式 4.4 装饰模式 4.5 外观模式 4.6 享元模式 4.7 代理模式 5 行为型模式 5.1 职责链模式 5.2 命令模式 5.3 解释器模式 5.4 迭代器模式 5.5 中介者模式 5.6 备忘录模式 5.7 观察者模式 5.8 状态模式 5.9 策略模式 5.10 模板方法模式 5.11 访问者模式 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/gof-she-ji-mo-shi-he-ji/"},{"title":"设计模式学习笔记（二十六）：访问者模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象元素 2.3 具体元素 2.4 对象结构 2.5 抽象访问者 2.6 具体访问者 2.7 客户端 3 层次结构 3.1 新增访问者 3.2 新增具体元素 3.3 扩展总结 4 实例 5 分派 5.1 定义 5.2 静/动态分派 5.2.1 静态分派 5.2.2 动态分派 5.3 单/多分派 5.4 Java语言特性 5.5 伪动态双分派 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 患者就医时，医生开具处方后通常由药房工作人员准备药品，由划价人员根据药品数量计算总价，这里，可以将处方看作是一个药品信息的集合，里面包含了一种或多种不同类型的药品信息，不同类型的工作人员在操作同一个药品信息集合时将提供不同的处理方式，而且可能还会增加新类型的工作人员来操作处方单。 在软件开发中，有时候也需要处理像处方单这样的集合结构，在该对象结构中存储了多个不同类型的对象信息，而且对同一对象结构中的元素的操作方式不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式。这时候可以使用访问者模式进行处理。 访问者模式是一种较为复杂的行为型设计模式，它包含访问者与被访问者两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 1.2 定义 访问者模式：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式是一种对象行为型模式。 1.3 结构图 1.4 角色 Visitor（抽象访问者）：为每一个具体元素类声明一个具体访问者的操作 ConcreteVisitor（具体访问者）：实现抽象访问者中的操作 Element（抽象元素）：接口/抽象类，定义一个accept方法表示接受访问者的访问 ConcreteElement（具体元素）：实现了accept方法，在accept中调用访问者的访问方法完成对具体元素的访问 ObjectStructure（对象结构）：抽象元素的集合，用于存放抽象元素对象，提供了遍历内部元素的方法 2 典型实现 2.1 步骤 定义抽象元素：声明一个accept方法表示接受访问者访问，由具体元素实现具体访问操作 定义具体元素：实现抽象元素中的accept方法，同时定义访问属性的方法供访问者调用 定义对象结构：使用List或Set等存储抽象元素集合，包含管理集合元素的方法，同时也包含accept方法，该方法会遍历元素并调用每个元素的accept方法 定义抽象访问者：声明visit方法，作为对具体元素的访问方法，一般使用重载实现，也就是一个具体元素对应一个visit 定义具体访问者：实现抽象访问者中的访问具体元素方法 2.2 抽象元素 interface Element { void accept(Visitor visitor); } 这里实现为一个接口，包含一个accept方法，表示接受访问者的访问。 2.3 具体元素 class ConcreteElementA implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } public void show1() { System.out.println(&quot;用第一种方式访问具体元素A&quot;); } public void show2() { System.out.println(&quot;用第二种方式访问具体元素A&quot;); } } class ConcreteElementB implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } public void show1() { System.out.println(&quot;用第一种方式访问具体元素B&quot;); } public void show2() { System.out.println(&quot;用第二种方式访问具体元素B&quot;); } } 这里定义了两个具体元素，重点是其中的accept方法，通过参数visitor，将自身（具体元素类）作为参数调用visit方法，以表示该访问者（visitor）访问该元素（this）。这里涉及到了&quot;双分派&quot;，简单来说就是运行时确定抽象访问者（visitor）以及抽象元素（this）的具体类型，下面会有一小节详细说明分派的概念。 2.4 对象结构 class ObjectStructure { private List&lt;Element&gt; list = new ArrayList&lt;&gt;(); public void accept(Visitor visitor) { list.forEach(t-&gt;t.accept(visitor)); } public void add(Element element) { list.add(element); } } 使用一个集合存储所有的抽象元素，同时提供管理方法以注入或删除具体元素，也包含accept方法，接收一个抽象访问者参数，表示接受该访问者访问这个对象结构里面的所有具体元素。 2.5 抽象访问者 interface Visitor { void visit(ConcreteElementA element); void visit(ConcreteElementB element); } 这里重载了visit实现对不同具体元素的访问。注意一个具体元素类对应一个visit方法。 2.6 具体访问者 class ConcreteVisitorA implements Visitor { @Override public void visit(ConcreteElementA element) { element.show1(); } @Override public void visit(ConcreteElementB element) { element.show1(); } } class ConcreteVisitorB implements Visitor { @Override public void visit(ConcreteElementA element) { element.show2(); } @Override public void visit(ConcreteElementB element) { element.show2(); } } 实现抽象访问者中的访问方法，获取具体元素对象后，通过该元素对象的公有方法获取其中的内部数据，或者直接调用具体元素对象的某些公有方法。 2.7 客户端 public static void main(String[] args) { Element elementA = new ConcreteElementA(); Element elementB = new ConcreteElementB(); ObjectStructure elements = new ObjectStructure(); elements.add(elementA); elements.add(elementB); Visitor visitor = new ConcreteVisitorA(); elements.accept(visitor); visitor = new ConcreteVisitorB(); elements.accept(visitor); } 客户端只需要针对抽象元素以及抽象访问者进行编程，通过对象结构对元素进行统一的管理，添加具体元素到对象结构后，动态注入不同的访问者以不同的方式访问对象结构中的所有元素。 输出如下： 3 层次结构 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构： 访问者层次结构：提供了抽象访问者以及具体访问者 元素层次结构：提供了抽象元素以及具体元素 相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同方式的访问。 在访问者模式中： 新增具体访问者方便：继承/实现抽象访问者即可，同时定义访问不同具体元素的不同方法 新增具体元素类麻烦：增加新的具体元素类需要进行大幅度的修改，首先需要新增抽象访问者中对新具体元素的访问方法，其次，原有的具体访问者都需要对新方法进行实现，修改量极大 3.1 新增访问者 新增具体访问者很容易，在上面例子的基础上，只需要实现新增一个类实现抽象访问者接口即可： class ConcreteVisitorC implements Visitor { @Override public void visit(ConcreteElementA element) { element.show1(); } @Override public void visit(ConcreteElementB element) { element.show2(); } } 对于客户端只需要在对象结构中在accept中注入新的访问者即可： public static void main(String[] args) { Element elementA = new ConcreteElementA(); Element elementB = new ConcreteElementB(); ObjectStructure elements = new ObjectStructure(); elements.add(elementA); elements.add(elementB); Visitor visitor = new ConcreteVisitorC(); elements.accept(visitor); } 3.2 新增具体元素 新增具体元素会导致大量源码的修改，在上面例子的基础上，首先增加一个实现抽象元素接口的具体元素： class ConcreteElementC implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } public void show1() { System.out.println(&quot;用第一种方式访问具体元素C&quot;); } public void show2() { System.out.println(&quot;用第二种方式访问具体元素C&quot;); } } 这时IDE应该会提示visitor.visit(this)这行报错，因为抽象访问者接口没有针对新的具体元素类型的visit方法，也就是说此时需要修改抽象访问者，增加访问新的具体元素类型的visit方法： interface Visitor { void visit(ConcreteElementA element); void visit(ConcreteElementB element); void visit(ConcreteElementC element);//新增 } 但是此时IDE又会提示具体访问者有错误，因为这是抽象访问者是一个接口，而所有的具体访问者都实现了该接口，也就是下一步需要修改所有的具体访问者，增加新的接口方法： class ConcreteVisitorA implements Visitor { @Override public void visit(ConcreteElementA element) { element.show1(); } @Override public void visit(ConcreteElementB element) { element.show1(); } @Override public void visit(ConcreteElementC element) //新增 { element.show1(); } } class ConcreteVisitorB implements Visitor { @Override public void visit(ConcreteElementA element) { element.show2(); } @Override public void visit(ConcreteElementB element) { element.show2(); } @Override public void visit(ConcreteElementC element) //新增 { element.show2(); } } 对于客户端来说无须修改太多代码，同样创建具体元素后添加到对象结构中： public static void main(String[] args) { Element elementA = new ConcreteElementA(); Element elementB = new ConcreteElementB(); Element elementC = new ConcreteElementC(); ObjectStructure elements = new ObjectStructure(); elements.add(elementA); elements.add(elementB); elements.add(elementC); elements.accept(new ConcreteVisitorA()); } 3.3 扩展总结 新增访问者步骤如下： 新建一个实现/继承抽象访问者的具体访问者类 客户端中将新的具体访问者传入对象结构的访问方法中 新增元素步骤如下： 新建一个实现/继承抽象元素类的具体元素类 抽象访问者新增访问该具体元素的方法 原有的所有具体访问者新增访问该元素的方法 客户端中创建新元素对象后添加到对象结构中 总的来说，这和抽象工厂模式有点类似，对OCP（开闭原则）的支持具有倾斜性，新增访问者（产品族）很容易，新增元素（产品等级结构）需要修改大量代码。 4 实例 设计一个员工信息管理子系统，包括正式员工以及临时工，管理人员是人力资源部以及财务部的人员，两个部门的人员进行的操作不同，使用访问者模式进行设计。 设计如下： 抽象元素：Employee 具体元素：FulltimeEmployee+ParttimeEmployee 对象结构：EmployeeList 抽象访问者：Department 具体访问者：FADepartment+HRDepartment 首先是抽象元素的代码： interface Employee { void accept(Department department); } 只有一个accept表示接受抽象访问者访问的方法。 具体元素： class FulltimeEmployee implements Employee { private String name; public FulltimeEmployee(String name) { this.name = name; } public String getName() { return name; } @Override public void accept(Department department) { department.visit(this); } } class ParttimeEmployee implements Employee { private String name; public ParttimeEmployee(String name) { this.name = name; } public String getName() { return name; } @Override public void accept(Department department) { department.visit(this); } } 实现其中的accept方法，在里面调用抽象访问者的visit方法，将自身作为参数。 对象结构如下： class EmployeeList { private List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); public void add(Employee employee) { list.add(employee); } public void accept(Department department) { list.forEach(t-&gt;t.accept(department)); } } accept会遍历元素集合，实现访问者对每一个具体元素的访问。 抽象访问者如下： interface Department { void visit(FulltimeEmployee employee); void visit(ParttimeEmployee employee); } 两个参数不同的visit，分别表示对这两个不同具体元素的访问操作。 具体访问者： class FADepartment implements Department { @Override public void visit(FulltimeEmployee employee) { System.out.println(&quot;财务部访问全职员工&quot;+employee.getName()); } @Override public void visit(ParttimeEmployee employee) { System.out.println(&quot;财务部访问兼职员工&quot;+employee.getName()); } } class HRDepartment implements Department { @Override public void visit(FulltimeEmployee employee) { System.out.println(&quot;人力资源部访问全职员工&quot;+employee.getName()); } @Override public void visit(ParttimeEmployee employee) { System.out.println(&quot;人力资源部访问兼职员工&quot;+employee.getName()); } } 对于不同的具体元素，不同的具体访问者有不同的处理方法，这里简单处理只是进行输出。 测试： public static void main(String[] args) { Employee fulltimeEmployee = new FulltimeEmployee(&quot;A&quot;); Employee parttimeEmployee = new ParttimeEmployee(&quot;B&quot;); EmployeeList list = new EmployeeList(); list.add(fulltimeEmployee); list.add(parttimeEmployee); list.accept(new HRDepartment()); list.accept(new FADepartment()); } 客户端针对抽象元素以及抽象访问者编程，创建具体元素后添加到对象结构中，接着将具体访问者作为参数传入对象结构的访问方法中。 输出： 5 分派 在访问者模式中涉及到了“伪动态双分派”的概念，首先看一下什么是分派。 5.1 定义 变量被声明时的类型叫静态类型，变量所引用的类型叫实际类型。比如： List&lt;String&gt; list = new ArrayList&lt;&gt;(); 中，list的静态类型为List，实际类型为ArrayList。 根据对象的类型对方法进行的选择，就是分派。 分派按照分派的方式可以分为： 静态分派 动态分派 按照分派基于的宗量，可以分为： 单分派 多分派 先来看一下静/动态分派。 5.2 静/动态分派 5.2.1 静态分派 静态分派：发生在编译时期，分派根据静态类型信息发生，比如方法重载。 比如下面的例子： public class Test { public static void main(String[] args) { test(Integer.valueOf(1)); test(&quot;1&quot;); } public static void test(String s) { System.out.println(&quot;String&quot;); } public static void test(Integer i) { System.out.println(&quot;Integer&quot;); } } 对于test方法，会根据静态类型选择方法版本，依据test方法的参数类型和参数数量可以确定唯一一个重载方法版本。 5.2.2 动态分派 动态分派：发生在运行时期，动态置换掉某个方法，比如面向对象的多态特性。 与静态分派相反，动态分派在运行时确定具体方法，比如： public class Test { public static void main(String[] args) { A b = new B(); A c = new C(); b.test(); c.test(); } } interface A { void test(); } class B implements A { @Override public void test() { System.out.println(&quot;B方法&quot;); } } class C implements A { @Override public void test() { System.out.println(&quot;C方法&quot;); } } 例子的test方法，无法根据对象的静态类型去判断，因为都是同一接口，而是在运行时判断，这就是动态分派，运行时获取到对象的具体引用类型，再确定具体的方法。 5.3 单/多分派 在了解单/多分派之前，先了解一下宗量。 一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称为方法的宗量。 比如下面的Test类： public class Test { public void print(String str){} } print()属于Test对象，所以接收者就是Test对象，print()有参数str，类型为String。所以print的宗量有两个： 接收者Test 参数String str 根据分派基于多少种宗量，可以将分派划分为单分派与多分派： 单分派根据一个宗量的类型对方法进行选择 多分派根据多个宗量的类型对方法进行选择（双分派是多分派的一种形式，根据两个宗量的类型对方法进行选择） 5.4 Java语言特性 Java是静态多分派，动态单分派语言。 理由如下： 静态多分派：从上面方法重载的例子可以看到，静态时确定方法，而且选择方法的依据是多个宗量（方法接收者，方法参数，参数数量，参数顺序），因此可以说的静态多分派 动态单分派：从上面动态分派的例子可以知道，Java中动态分派仅仅考虑到方法的接收者，也就是只根据一个宗量（方法接收者）去选择方法，所以说是动态单分派 5.5 伪动态双分派 一个方法根据两个宗量的类型来决定执行不同的代码，这就是双分派。Java是动态单分派语言，也就是不支持动态双分派。但是使用访问者模式可以达到一种“动态双分派”的效果。因为这不是真正的动态双分派，所以加上了一个“伪”，这种“伪动态双分派”其实是通过两次“动态单分派”来实现。 访问者模式的双分派中，不仅要根据被访问者的运行时区别，还要根据访问者的运行时区别，在客户端中将具体访问者作为参数传递给被访问者（具体元素）： @Override public void accept(Department department) { department.visit(this); } 由于department是抽象访问者，运行时确定具体调用哪一个具体访问者的visit，这里完成第一次动态单分派。 另外visit接受抽象元素作为参数，把具体元素（this）作为参数传递，根据方法接收者宗量选择相应的visit方法，在这里完成第二次动态分派。 也就是说，访问者模式是首先根据访问者的动态单分派，再根据具体元素（被访问者）的动态单分派，来达到“动态双分派”的效果，由于这不是真正的动态双分派，而且Java是动态单分派语言，因此这种机制也叫“伪动态双分派”。 6 主要优点 新增访问操作方便：使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，符合开闭原则 集中访问行为：将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问 7 主要缺点 新增元素类困难：访问者模式中每新增一个元素类以为着抽象访问者角色需要增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了开闭原则 破坏封装：访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问 8 适用场景 一个对象结构中包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而且需要避免让这些操作“污染”这些对象的类，也不希望在新增操作时修改这些类。访问者模式将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者者类所使用，将对象本身于对象的访问操作分离 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/"},{"title":"设计模式学习笔记（二十五）：模板方法模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 1.5 模板方法与基本方法 1.5.1 模板方法 1.5.2 基本方法 2 典型实现 2.1 步骤 2.2 抽象类 2.3 具体子类 2.4 客户端 3 实例 4 主要优点 5 主要缺点 6 适用场景 7 总结 1 概述 1.1 引言 模板方法模式是结构最简单的行为型设计模型，在其结构中只存在父类与之类之间的继承关系，通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。 1.2 定义 模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。 模板方法模式是一种类行为型模式。 1.3 结构图 1.4 角色 AbstractClass（抽象类）：抽象类中定义了一系列基本操作，这些操作是具体的也可以是抽象的，每一个基本操作对应算法的一个步骤，在子类中可以重定义或实现这些步骤，同时抽象类实现了一个模板方法，定义一个算法的框架 ConcreteClass（具体子类）：实现父类中的抽象基本方法，或者覆盖父类中具体基本操作 1.5 模板方法与基本方法 1.5.1 模板方法 模板方法是在抽象类中定义的，把基本操作方法组合成一个总算法或总行为的方法。模板方法在抽象类中定义，并由子类不加以修改完全继承。模板方法是一个具体方法，给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。另外由于模板方法是具体方法，因此抽象层只能实现为抽象类而不能是接口。 1.5.2 基本方法 基本方法是实现算法的各个步骤，是模板方法的组成部分。基本方法又可以分为三种： 抽象方法：抽象方法就是在抽象类中声明并由子类实现的方法 具体方法：具体方法可以由抽象类实现，或者由子类覆盖实现 钩子方法：钩子方法可以由抽象类实现，子类可以加以扩展 在模板方法模式中，钩子方法一般有两类： 第一类钩子方法是可以与一些具体步骤挂钩，以实现在不同条件下执行模板方法的不同步骤，这类方法一般返回boolean，方法名一般为isXXX 第二类钩子方法是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法 2 典型实现 2.1 步骤 定义抽象类：声明模板方法以及基本方法 定义模板方法：模板方法是抽象类中的具体方法，按照实际需要将基本方法进行组合 定义基本方法：定义抽象方法，具体方法以及钩子方法，确定好哪些方法交由抽象类实现，哪些方法交由子类实现以及拥有哪些钩子方法 定义具体子类：实现抽象类的抽象方法，按照需要对钩子方法或者具体方法进行覆盖 2.2 抽象类 abstract class AbstractClass { public void templateMethod() { primitiveOperation1(); primitiveOperation2(); if(primitiveOperation3()) System.out.println(&quot;符合钩子方法条件&quot;); else System.out.println(&quot;不符合钩子方法条件&quot;); primitiveOperation4(); } public void primitiveOperation1() { System.out.println(&quot;抽象类具体方法&quot;); } //抽象类抽象方法 abstract public void primitiveOperation2(); //第一类钩子方法 public boolean primitiveOperation3() { return false; } //第二类钩子方法 public void primitiveOperation4() { } } 首先定义了模板方法，作为客户端操作的入口。模板方法中对基本方法进行了组合，这里声明了四个基本方法： 第一个是抽象类的具体方法：这是所有子类都拥有的相同实现的方法，不应该被子类覆盖 第二个是抽象类的抽象方法：子类需要实现该方法以实现变化 第三个是第一类钩子方法：这类钩子方法返回一个boolean，可以用于控制是否执行某个步骤，子类可以通过这类钩子方法对模板方法的执行过程进行限制，比如如果不想执行某个步骤可以永远返回false 第四个是第二类钩子方法：这类钩子方法中父类提供一个空实现，子类选择性进行覆盖 2.3 具体子类 class ConcreteClass extends AbstractClass { public void primitiveOperation2() { System.out.println(&quot;子类具体方法&quot;); } public boolean primitiveOperation3() { return true; // 如果想钩子方法返回false可以不实现该方法 // 因为父类默认返回false // return false; } public void primitiveOperation4() { System.out.println(&quot;子类覆盖父类第二类钩子方法&quot;); } } 这里子类实现了抽象类的抽象方法，同时覆盖了两类钩子方法。 2.4 客户端 public static void main(String[] args) { AbstractClass class1 = new ConcreteClass(); class1.templateMethod(); } 客户端调用很简单，创建一个具体类对象并执行其中的模板方法即可。 输出： 3 实例 为银行业务开发一个利息计算模块，该计算模块拥有标准流程：系统验证用户信息，接着判断用户状态，正常状态用户能计算利息，受限制状态用户无法计算利息，最后显示利息，使用模板方法模式进行设计。 设计如下： 抽象类：Account 具体方法：validate(String name) 抽象方法：calculate() 钩子方法：canCalculate()+display() 具体子类：NormalAccount+RestrictedAccount 首先是抽象类的设计： abstract class Account { public void handle(String name) { if(validate(name)) { if(canCalculate()) { calculate(); } display(); } else { System.out.println(&quot;用户名非法&quot;); } } public boolean validate(String name) { return &quot;1&quot;.equals(name); } //抽象类抽象方法 abstract public void calculate(); //第一类钩子方法 public boolean canCalculate() { return true; } //第二类钩子方法 public void display() { } } 首先通过validate()验证用户名，接着根据第一类钩子方法canCalculate()判断能否计算利息，然后调用抽象计算方法calculate()进行计算，最后无论能够计算利息都会调用第二类钩子方法display()。 具体子类代码如下： class NormalAccount extends Account { public void calculate() { System.out.println(&quot;正常状态用户计算利息&quot;); } public void display() { System.out.println(&quot;正常状态用户显示利息&quot;); } } class RestrictedAccount extends Account { public boolean canCalculate() { return false; } public void calculate() {} public void display() { System.out.println(&quot;受限状态用户无法计算利息&quot;); } } 正常状态用户中实现抽象方法calculate()，并覆盖第二类钩子方法display()，对于受限状态用户，覆盖了第一类钩子方法canCalculate()，永远返回false，同时对抽象方法calculate提供空实现，最后也对第二类钩子方法display进行了覆盖，提示&quot;无法计算利息&quot;。 4 主要优点 形式化算法：模板方法模式在父类中形式化地定义一个算法，而由子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序 代码复用：模板方法模式是一种代码复用技术，提取公共行为并放在父类中，通过子类实现不同的行为 实现反向控制：模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否执行 增加子类方便：模板方法模式中可通过子类覆盖父类的基本方法，不同子类可以提供基本方法的不同实现，更换以及增加新的子类很方便 5 主要缺点 子类数量多：模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象 6 适用场景 对一些复杂算法进行分割，将其算法中固定不变的部分设计为模板方法和父类方法，而一些改变的细节由子类实现，也就是一次性实现算法中不变部分，并将可变部分交由子类实现 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复 需要通过子类决定父类算法中某个步骤是否执行，实现子类对父类的反向控制 7 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/"},{"title":"设计模式学习笔记（二十四）：策略模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象策略类 2.3 具体策略类 2.4 环境类 2.5 客户端 3 实例 4 JDK中的策略模式 5 与状态模式的不同 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 在外出旅游时，很多时候的出行方式都不止一条，通常根据实际情况，比如目的地，预算，旅游时间等确定最适合的出行方式。在软件开发中，也常常会遇到类似的情况，实现某一个功能有多种途径，每一条途径对应一个算法，这时可以使用一种叫做策略模式的设计模式来进行设计。在策略模式中，可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法。 这里每一个封装的算法可以被称之为一种策略，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类作为规则的定义，每种具体算法对应于一个具体策略类。 策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合DIP（依赖倒转原则）。出现新算法时只需要定义一个新的具体策略类即可。 1.2 定义 策略模式：定义一系列算法类，将每一个算法封装起来，并让他们可以相互替换。 策略模式也叫政策模式，是一种对象行为型模式。 1.3 结构图 1.4 角色 Context（环境类）：使用算法的角色，解决了某个问题时可以采用的多种策略，在环境类维持一个抽象策略类的引用实例，用于定义所采用的策略 Strategy（抽象策略类）：为支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或具体类，也可以是接口，环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法 ConcreteStrategy（具体策略类）：实现了抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理 2 典型实现 2.1 步骤 定义抽象策略类：一般实现为接口，声明抽象算法 定义具体策略类：实现抽象策略类，实现其中的具体算法 定义环境类：维持一个对抽象策略类的引用，通过setter或构造函数注入具体策略类，调用时通过该抽象引用调用相应算法 2.2 抽象策略类 interface AbstarctStrategy { void algorithm(); } 这里定义为一个接口，只有一个抽象算法方法。 2.3 具体策略类 class ConcreteStrategy1 implements AbstarctStrategy { @Override public void algorithm() { System.out.println(&quot;具体策略1&quot;); } } class ConcreteStrategy2 implements AbstarctStrategy { @Override public void algorithm() { System.out.println(&quot;具体策略2&quot;); } } 定义两个具体策略类，分别表示不同的算法。 2.4 环境类 class Context { private AbstarctStrategy strategy; public void setStrategy(AbstarctStrategy strategy) { this.strategy = strategy; } public void algorithm() { strategy.algorithm(); } } 通过setter注入具体策略类，在调用环境类的方法时通过抽象策略类调用其中的具体策略类的算法。 2.5 客户端 public static void main(String[] args) { Context context = new Context(); context.setStrategy(new ConcreteStrategy1()); context.algorithm(); context.setStrategy(new ConcreteStrategy2()); context.algorithm(); } 3 实例 设计一个电影票打折系统，有三种不同的打折方式：学生可以享受8折优惠，10周岁以下儿童可以享受减免10元优惠，VIP可以享受半价优惠，使用策略模式进行设计。 设计如下： 环境类：MovieTicket 抽象策略类：Discount 具体策略类：StudentDiscount+VIPDiscount+ChildrenDiscount 首先是抽象策略类： interface Discount { double calculate(double price); } 包含一个计算折扣的方法，接着是具体策略类： class StudenDiscount implements Discount { @Override public double calculate(double price) { System.out.println(&quot;学生票&quot;); return price * 0.8; } } class ChildrenDiscount implements Discount { @Override public double calculate(double price) { System.out.println(&quot;儿童票&quot;); return price - 10.0; } } class VIPDiscount implements Discount { @Override public double calculate(double price) { System.out.println(&quot;VIP票&quot;); return price * 0.5; } } 三个不同的具体策略类表示三种不同的计算折扣方式，根据需要返回对应的折扣价格。 最后是环境类： class MovieTicket { private Discount discount; private double originalPrice; public void setPrice(double price) { this.originalPrice = price; } public void setDiscount(Discount discount) { this.discount = discount; } public double getDicountPrice() { return discount.calculate(originalPrice); } } 环境类通过setPrice设定电影票价格后，在通过setDiscount注入具体策略类，最后使用getDiscountPrice获取折扣后的价格。 测试： public static void main(String[] args) { MovieTicket movieTicket = new MovieTicket(); movieTicket.setPrice(100.0); movieTicket.setDiscount(new StudenDiscount()); System.out.println(movieTicket.getDicountPrice()); movieTicket.setDiscount(new VIPDiscount()); System.out.println(movieTicket.getDicountPrice()); movieTicket.setDiscount(new ChildrenDiscount()); System.out.println(movieTicket.getDicountPrice()); } 客户端需要明确知道这三种折扣，也就是打折方式由客户端指定，输出如下： 4 JDK中的策略模式 策略模式实用性强，扩展性好，是使用频率较高的设计模式，下面来看看JDK中的典型应用。 Java SE容器布局管理器就是策略模式的一个经典应用案例，基本结构如下： JavaSE中用户需要对容器对象Container进行布局，在程序运行期间由客户端动态决定一个Container对象如何布局，Java提供了几种不同的布局方式：BorderLayout，FlowLayout，GridLayout，GridBagLayout，CardLayout。在上图结构中： Container充当了环境角色Context LayoutManager充当了抽象策略角色 LayoutManager的各个子类充当了具体策略类 Container针对LayoutManager进行编程，无须关心具体布局是什么，这样的设计符合里氏替换原则。 5 与状态模式的不同 状态模式与策略模式很像，下面是两者的结构图： 两者的结构图很相似，但是实际上也有很多的不同： 意图不同：策略模式让客户端指定更换具体策略算法，而状态模式是状态在满足一定条件自动切换，用户无法手动设置状态 负责范围不同：状态模式负责不同状态下对象行为的处理，而策略模式负责具体算法或策略的处理，对于算法来说都有一个明确的目标，都是在做一件事情，比如上面的电影票打折例子，无论选择何种策略，都是为了打折，但是状态模式在不同的状态下做的事情可能不同 封装内容不同：状态模式封装了对象的状态，而策略模式封装了具体的算法或策略 重用性不同：状态是跟对象密切相关的，不能重用，而策略模式的具体策略可以分离出来重用 Context的使用不同：状态模式中每个状态持有Context引用，实现状态切换，但是每个策略不持有Context引用，策略只是被Context使用 客户端需要考虑的情况不同：对于状态模式来说，状态模式依赖于其内部状态的变化时内部的行为发生变化，状态是系统自身固有的，由系统本身控制，状态对客户端不透明，客户端不需要考虑系统的状态，也不能直接指定或改变系统的状态切换。但是对于策略模式来说，客户端需要知道所有的策略类，明确各种策略的利弊，对其进行权衡并选择策略，也就是策略需要对客户端透明，需要由客户端考虑使用何种策略 6 主要优点 完美支持OCP：策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为，也可以灵活提供新的算法或行为 易于管理和复用算法：策略模式提供了管理相关的算法族的办法，策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共代码移到抽象策略类中以简化代码，同时由于算法单独封装在具体策略类中，可以方便复用这些算法 替换继承：策略模式提供了一种替换继承关系的方法，不使用策略模式的话环境类可能有子类，造成算法的使用和定义混在一起，而且使用继承的话无法实现算法或行为在运行时动态切换 避免多重else if：多重选择语句不易维护，因为将选择算法的逻辑以及算法本事实现逻辑混在一起，硬编码在一个巨大的if/else if中，使用策略模式可以避免这种结构 7 主要缺点 策略类需要对客户端透明：客户端必须知道所有的策略类，并自行决定哪一个策略类，也就是客户端需要理解这些算法的区别以便选择适当的算法 策略类数量多：策略模式会造成系统产生很多具体策略类，任何细小的变化都会导致系统增加一个新的具体策略类 客户端无法使用多个策略类：客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩下的功能 8 适用场景 一个系统需要动态在几种算法中选择一种，这些算法类均有统一的接口 一个对象有很多行为，使用策略模式可以将这些行为转移到相应具体策略类中 不希望客户端知道复杂的，与算法相关的数据结构，在具体策略类中对其进行封装 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-si-ce-lue-mo-shi/"},{"title":"设计模式学习笔记（二十三） 状态模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 环境类 2.3 抽象状态类 2.4 具体状态类 2.5 客户端 3 实例 4 共享状态 5 环境类实现状态切换 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。 状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何处状态对象，客户端都可以一致性地处理。 1.2 定义 状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类。 状态模式是一种对象行为型模式。 1.3 结构图 1.4 角色 Context（环境类）：环境类角色又称上下文类，是拥有多种状态的对象，环境类的状态存在多样性且在不同状态下对象的行为有所不同。在环境类中维护一个抽象状态类State的实例，定义当前状态，实现时将具体状态类注入其中 State（抽象状态类）：声明各种不同状态对应的方法，封装具体状态类的共同方法 ConcreteState（具体状态类）：抽象状态类的子类，实现其中的具体状态行为方法 2 典型实现 2.1 步骤 定义环境类：环境类包含一个抽象状态成员，可以通过构造方法或者setter注入具体状态，同时包含业务方法，该业务方法会调用抽象状态类的处理状态方法 定义抽象状态类：声明状态处理方法，使用环境类作为参数 定义具体状态类：实现/继承抽象状态类，按实际需要实现其中的状态处理方法 2.2 环境类 class Context { private State state = new ConcreteState1(); public void setState(State state) { this.state = state; } public void request() { state.handle(this); } } 具有默认初始化状态，可以通过setter修改状态，request为环境类业务方法，其中调用了抽象状态类的状态处理方法。 2.3 抽象状态类 interface State { void handle(Context context); } 这里设计为接口，使用环境类作为参数。 2.4 具体状态类 class ConcreteState1 implements State { @Override public void handle(Context context) { System.out.println(&quot;具体状态1方法&quot;); context.setState(new ConcreteState2()); } } class ConcreteState2 implements State { @Override public void handle(Context context) { System.out.println(&quot;具体状态2方法&quot;); context.setState(new ConcreteState1()); } } 两个具体状态类，执行完具体状态类里面的代码后，通过环境类参数将环境类切换到另一个状态。 2.5 客户端 public static void main(String[] args) { Context context = new Context(); context.request(); context.request(); } 客户端直接调用环境类业务方法，输出如下： 3 实例 设计一个银行账户，账户允许不同的状态，余额大于0处于正常状态，余额大于-2000小于0处于透支状态，余额小于等于-2000处理受限状态。根据余额不同状态可发生转换，使用状态模式进行设计。 设计如下： 环境类：Account 抽象状态类：State 具体状态类：NormalState+OverdraftState+RestrictedState 首先是环境类： class Account { private State state = new NormalState(this); private double balance = 0.0; public void setState(State state) { this.state = state; } public void deposit(double amount) { balance += amount; state.check(); } public void withdraw(double amount) { balance -= amount; state.check(); } public double getBalance() { return balance; } @Override public String toString() { return &quot;当前状态:&quot;+state; } } 初始化为正常状态，余额为0，在存款/取款中调用抽象状态类的状态检查方法，也就是状态转换交由状态类处理。 接着是抽象状态类： abstract class State { protected Account account; public abstract void check(); } 拥有一个环境类的引用，以便使用环境类的setState改变状态方法。 最后是具体状态类： class NormalState extends State { public NormalState(Account account) { this.account = account; } @Override public void check() { if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0) account.setState(new OverdraftState(account)); else if(account.getBalance() &lt; -2000) account.setState(new RestrictedState(account)); } @Override public String toString() { return &quot;正常状态&quot;; } } class OverdraftState extends State { public OverdraftState(Account account) { this.account = account; } @Override public void check() { if(account.getBalance() &gt;= 0) account.setState(new NormalState(account)); else if(account.getBalance() &lt; -2000) account.setState(new RestrictedState(account)); } @Override public String toString() { return &quot;透支状态&quot;; } } class RestrictedState extends State { public RestrictedState(Account account) { this.account = account; } @Override public void check() { if(account.getBalance() &gt;= 0) account.setState(new NormalState(account)); else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0) account.setState(new OverdraftState(account)); } @Override public String toString() { return &quot;受限状态&quot;; } } 三个具体状态类分别表示三种不同状态，在其中的check方法中进行状态检查以及切换状态。 测试： public static void main(String[] args) { Account account = new Account(); account.deposit(1000); System.out.println(account); account.withdraw(2000); System.out.println(account); account.withdraw(2000); System.out.println(account); account.deposit(10000); System.out.println(account); } 客户端不需要理会具体状态，按正常流程操作即可，下面是输出： 4 共享状态 有时候多个环境对象可能需要共享同一个状态，这时需要将状态对象定义为环境类的静态成员，例子如下： 某个系统要求两个开关对象必须处于一样的状态，要么同时关，要么同时开，开关可以自由切换状态，使用状态模式进行设计。 设计如下： 环境类：Switch 抽象状态类：State 具体状态类：OffState+OnState 环境类： class Switch { private State state; private static final State onState; private static final State offState; private String name; static { onState = new OnState(); offState = new OffState(); } public Switch(String name) { this.name = name; this.state = offState; } public String getName() { return name; } public void setState(State state) { this.state = state; } public static State getOnState() { return onState; } public static State getOffState() { return offState; } public void on() { state.on(this); } public void off() { state.off(this); } } 环境类初始化两个静态的开与关状态，在on以及off中调用状态方法。 抽象状态： interface State { void on(Switch s); void off(Switch s); } 具体状态： class OnState implements State { @Override public void on(Switch s) { System.out.println(&quot;开关&quot;+s.getName()+&quot;已经打开&quot;); } @Override public void off(Switch s) { System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;); s.setState(Switch.getOffState()); } } class OffState implements State { @Override public void on(Switch s) { System.out.println(&quot;开关&quot;+s.getName()+&quot;开启&quot;); s.setState(Switch.getOnState()); } @Override public void off(Switch s) { System.out.println(&quot;开关&quot;+s.getName()+&quot;已经关闭&quot;); } } 实现抽象状态的开关方法，处于关状态时调用on会切换到开状态，调用off则不处理，处于开状态同理。 测试： public static void main(String[] args) { Switch a = new Switch(&quot;A&quot;); Switch b = new Switch(&quot;B&quot;); a.on(); b.on(); a.off(); b.off(); a.on(); b.on(); } 输出： 5 环境类实现状态切换 在上面的例子中，都是通过具体状态类进行状态切换，比如： class RestrictedState extends State { //... @Override public void check() { if(account.getBalance() &gt;= 0) account.setState(new NormalState(account)); else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0) account.setState(new OverdraftState(account)); } } class OnState implements State { //... @Override public void off(Switch s) { System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;); s.setState(Switch.getOffState()); } } 状态切换也可以由环境类进行统一处理，但是如果增加新的状态类可能需要修改环境类代码。例子如下： 设计一个放大镜工具，单击一次放大一倍，单击两次再放大一杯，第三次就恢复默认大小，使用状态模式进行设计。 设计如下： 环境类：Screen 抽象状态类：State 具体状态类：NormalState+LargerState+LargestState 环境类： class Screen { private State state; private static final State normalState; private static final State largerState; private static final State largestState; static { normalState = new NormalState(); largerState = new LargerState(); largestState = new LargestState(); } public Screen() { this.state = normalState; } public void onClick() { if(state == normalState) state = largerState; else if(state == largerState) state = largestState; else state = normalState; state.display(); } } 首先初始化各个状态，然后在onClick()中由环境类控制状态切换。 状态类： interface State { void display(); } class NormalState implements State { @Override public void display() { System.out.println(&quot;正常大小&quot;); } } class LargerState implements State { @Override public void display() { System.out.println(&quot;两倍大小&quot;); } } class LargestState implements State { @Override public void display() { System.out.println(&quot;四倍大小&quot;); } } 测试： public static void main(String[] args) { Screen screen = new Screen(); screen.onClick(); screen.onClick(); screen.onClick(); } 输出如下： 6 主要优点 封装转换规则：状态模式中可以将状态的转换代码封装在环境类或具体状态类中，可以将状态转换代码进行集中管理，而不是分散在一个个业务方法中 通过注入状态修改行为：将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境拥有不同的行为 状态转换逻辑与状态对象一体化：允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起 7 主要缺点 增大运行开销：使用状态模式会增加系统中类和对象的个数 实现复杂：状态模式的程序结构实现复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计难度 对OCP支持不好：增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态，而且修改某个状态类的行为也需要修改对应的源代码 8 适用场景 对象的行为依赖于它的状态，状态的改变会导致行为的变化 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合度增强 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-san-zhuang-tai-mo-shi/"},{"title":"每日分享 第51期","content":" 每日鸡汤 相信你一定不会被生活打倒，因为你的体重，超过了生活的预料。 每日冷知识 任天堂64游戏系统中的标志性游戏Goldeneye 007由只有9个人的团队开发，其中8个人以前从未涉足过电子游戏。 每日诗词 绿竹含新粉，红莲落故衣。 ——王维《山居即事》 每日一句 从开始的第一天起，就回不去了。 每日音乐 假装-陈雪凝 红了樱桃 绿了芭蕉 你走你的独木桥 我唱我调 谁的孤独它像似把刀 杀了我的外婆桥 别再犯傻 再剪短发 你送的鞋子合脚它又怎会掉 谁的无情它像似毒药 喝下不煎熬 我想留在你的身边 深情款款多么可怜 你无辜的像演员 边说边声泪俱下表现 故事开始总是很甜 岁月流逝人心转变 这是最后一支烟 你信誓旦旦说着谎言 红了樱桃 绿了芭蕉 你走你的独木桥 我唱我调 谁的孤独 它像似把刀 杀了我的外婆桥 别再犯傻 再剪短发 你送的鞋子合脚它又怎会掉 谁的无情它像似毒药 喝下不煎熬 在我身后开了一枪 鲜血淋漓渲染了墙 用最后一丝余光 我已释然你何必假装 红了樱桃 绿了芭蕉 你走你的独木桥 我唱我调 谁的孤独它像似把刀 杀了我的外婆桥 别再犯傻 再剪短发 你送的鞋子合脚它又怎会掉 谁的无情它像似毒药 喝下不煎熬 当初炽热的心已凉 一朝一夕笑我痴狂 所有苦痛我一人扛 假装坚强 你难过的太假装 你凭什么念念不忘 人一定要学会成长 别再犯傻 再剪短发 你送的鞋子合脚它又怎会掉 谁的无情它像似毒药 喝下不煎熬 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-51-qi/"},{"title":"每日分享 第50期","content":" 每日鸡汤 少年加油吧！只要你努力工作，你的老板一定会成功的。 每日冷知识 每辆劳斯莱斯汽车上的腰线都由英国前乡村广告牌绘制者Mark Court手工绘制。这是车辆制造过程中的最后一步，而且必须完美无暇，因为油漆会瞬间与车身粘合，并且无法擦除。 每日诗词 大漠风尘日色昏，红旗半卷出辕门。 ——王昌龄《从军行七首》 每日一句 路这么宅，好难过啊！ 每日音乐 你说-钟洁 如果吹蜡烛前许愿能灵验 那么你还能把喜欢我当作生日礼物吗? 你说关上灯一人独自承受寂寞 闭上眼睛却看到他嘲笑我失落 你说我们不适合你说分了更好过 要我如何不会难过你说 没有你陪着我变得失魂落魄 我的快乐遗失在你转身的那一刻 我想说的话很多我们之间的承诺 永远一起你忘了吗你说 我的房间你的照片碎的誓言断了永远 你的身边它很显眼牵着的手触动心弦 不想难过假装沉默他的挑衅算是什么 我不想说 你只说了抱歉 我和你的从前 我不爱了又何必多说 你说关上灯一人独自承受寂寞 闭上眼睛却看到他嘲笑我失落 你说我们不适合 你说分了更好过 要我如何不会难过你说 没有你陪着我变得失魂落魄 我的快乐遗失在你转身那一刻 我想说的话很多我们之间的承诺 永远一起你忘了吗你说 我的房间你的照片碎的誓言断了永远 你的身边他恨显眼牵着的手触痛心弦 不想难过假装沉默他的挑衅算是什么 我不想说 你只说了抱歉 我和你的从前 我不爱了又何必多说 你说关上灯一人独自承受寂寞 闭上眼睛却看到他嘲笑我失落 你说我们不适合 你说分了更好过 要我如何陪着我变得失魂落魄 我的快乐遗失在你转身那一刻 我想说的话很多我们之间的承诺 永远一起你忘了吗你说 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-50-qi/"},{"title":"每日分享 第49期","content":" 每日鸡汤 不要担心，一切都是最烂的安排。 每日冷知识 刺客虫会将其猎物的外骨骼穿在身上，以此作为可去除式盔甲。该盔甲具有多种用途，即可用来威吓比自己更大的捕食者，也可以在另一个虫子试图对自己发起攻击时，与盔甲分离以金婵脱壳。 每日诗词 细雨春芜上林苑，颓垣夜月洛阳宫。 ——陆游《书愤二首》 每日一句 或许人与人之间的缘分，都是注定的。 每日音乐 BigBang-Blue I'm singing my blues 파란 눈물에 파란 슬픔에 길들여져 I'm singing my blues 뜬구름에 날려보낸 사랑 oh oh 같은 하늘 다른 곳 너와나 위험하니까 너에게서 떠나주는 거야 님이란 글자에 점하나 비겁하지만 내가 못나 숨는 거야 잔인한 이별은 사랑의 말로 그 어떤 말도 위로 될 수는 없다고 아마 내 인생의 마지막 멜로 막이 내려오네요 이제 태어나서 널 만나고 죽을 만큼 사랑하고 파랗게 물들어 시린 내 마음 눈을 감아도 널 느낄 수 없잖아 겨울이 가고 봄이 찾아오죠 우린 시들고 그리움 속에 맘이 멍들었죠 I'm singing my blues 파란 눈물에 파란 슬픔에 길들여져 I'm singing my blues 뜬구름에 날려보낸 사랑 oh oh 심장이 멎은 것 만 같아 전쟁이 끝나고 그 곳에 얼어 붙은 너와나 내 머릿속 새겨진 trauma 이 눈물 마르면 촉촉히 기억하리 내 사랑 괴롭지도 외롭지도 않아 행복은 다 혼잣말 그 이상에 복잡한 건 못 참아 대수롭지 아무렇지도 않아 별수없는 방황 사람들은 왔다 간다 태어나서 널 만나고 죽을 만큼 사랑하고 파랗게 물들어 시린 내 마음 너는 떠나도 난 그대로 있잖아 겨울이 가고 봄이 찾아오죠 우린 시들고 그리움 속에 맘이 멍들었죠 오늘도 파란 저 달빛아래에 나 홀로 잠이 들겠죠 꿈속에서도 난 그대를 찾아 헤매이며 이 노래를 불러요 I'm singing my blues 파란 눈물에 파란 슬픔에 길들여져 I'm singing my blues 뜬구름에 날려보낸 사랑 I'm singing my blues 파란 눈물에 파란 슬픔에 길들여져 I'm singing my blues 뜬구름에 날려보낸 사랑 oh oh ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-49-qi/"},{"title":"每日分享 第48期","content":" 每日鸡汤 有时候别人对你很冷淡，可能并不是你的问题。他也许只是不喜欢丑而已。 每日冷知识 在香水中，海狸香是一种温暖，肉欲且类似皮革的香味，目前已经可以人工合成，这种香最初来自于成年北美海狸的腺囊，海狸会将其与粪便结合使用以标记领土。 每日诗词 夜饮东坡醒复醉，归来仿佛三更。 ——苏轼《临江仙·夜饮东坡醒复醉》 每日一句 没有回忆就去创造回忆，没有道路就去开辟道路。 每日音乐 游戏关系-钟洁 你放心我在学会我忘记 不再自作多情我选择放弃 这是我给你留下最后的赠礼 再见了 关于你的回忆 删除也已经来不及 努力的不去想起 却无能为力 总是在夜深人静 默默的想你 和我在一起 排队买奶茶一起 看电影一起 打游戏一起 如此而已 可是那又怎么样 就算我们在一起 他的电话响起 你会音量降低 然后说要回去 我都知道 你以为我蒙在鼓里 你的家在他那里 我无能为力拥有你 我无能为力拥抱你 我无能为力挽留你 我无能为里忘记你 所以啊直觉啊 这个东西还是挺准的 所以在你回家之前 在你胸前吻了很多草莓印 接到你男朋友的电话 他问我这么晚了找你干吗 你不知道当时我的内心多么痛 可你却是在旁一句话都不说 其实我还是抱有一丝幻想 以为你会放弃他跟我走 结果你就回了一个字&quot;我...&quot; 我放弃了这次我没有熬夜也没喝酒 这首歌不是送给你的 我只是在发泄我的情绪 我无能为力拥有你 我无能为力拥抱你 我无能为力挽留你 我无能为力忘记你 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-48-qi/"},{"title":"每日分享 第47期","content":" 每日鸡汤 你以为向生活低头就好了？生活是想让你跪下。 每日冷知识 新年之夜，意大利人会穿上红色内衣裤以为自己带来好运。这是一种可以追溯到中世纪的传统，当时男人们会在腹股沟披上红帘以保护珍贵的子孙根免遭女巫毒手。 每日诗词 飞絮飞花何处是，层冰积雪摧残，疏疏一树五更寒。 ——纳兰性德《临江仙·寒柳》 每日一句 忘羡一曲远，曲终人不散。 每日音乐 为龙-河图 手心上 亘古的月光 那道伤 一笑而过的苍凉 翘首觐向 你伫立一方 是你生而为龙的猖狂 谨记你的姓名是炎黄 烽燧上 战地的残阳 断刃旁 岁月悄然的流淌 十二章纹 你遥祭四望 血脉奔腾的黄河长江 是你与生俱来的张扬 风雨打尽红墙和绿瓦 丹青留下明日的黄花 汉字里墨香温存的一笔一划 世代传承的表达 盛衰荣辱斑驳了脸颊 千载过后洗净了铅华 一直坚守的土壤在你脚下 至死不渝的回答 烽燧上 战地的残阳 断刃旁 岁月悄然的流淌 十二章纹 你遥祭四望 血脉奔腾的黄河长江 是你与生俱来的张扬 风雨打尽红墙和绿瓦 丹青留下明日的黄花 汉字里温存的一笔一划 世代传承的表达 盛衰荣辱斑驳了脸颊 千载过后洗净了铅华 一直坚守的土壤在你脚下 至死不渝的回答 风雨打尽红墙和绿瓦 丹青留下明日的黄花 汉字里墨香温存的一笔一划 世代传承的表达 盛衰荣辱斑驳了年华 千载过后洗净了铅华 一直坚守的土壤在你脚下 至死不渝的回答 藏心上 亘古的月光 怀中殇 不再回眸的苍凉 翘首觐向 你伫立此方 谨记生而为龙的模样 谨记我的姓名是炎黄 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-47-qi/"},{"title":"设计模式学习笔记（二十二）：观察者模式","content":"1 概述 1.1 引言 观察者模式使用频率很高，用于建立一种对象之间的依赖关系，当一个对象发生改变时自动通知其他对象，其他对象将做出相应反应。在观察者模式中，发生改变的对象叫做观察目标，也叫被观察者，而被通知的对象叫做观察者。 一个观察目标可以对应多个观察者，而且这些观察者之间没有任何相互关联，可以根据需要增加和删除观察者，使得系统便于扩展。 1.2 定义 观察者模式：定义对象之间的一种一对多依赖关系，使得每一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新。 观察者模式是一种对象行为型模式。 1.3 结构图 1.4 角色 Subejct（抽象目标）：又叫主题，指被观察的对象，也就是被观察者，在目标中定义了一个观察者集合，同时提供一系列方法来增加或者删除观察者对象，也定义了通知方法notify ConcreteSubject（具体目标）：抽象目标的子类，通常包含有经常改变的数据，当状态发生改变时，向各个观察者发出通知，同时还实现了目标类中定义的抽象业务逻辑，如果无须扩展抽象目标类则可以省略具体目标类 Observer（抽象观察者）：对观察目标作出响应，一般定义为接口 ConcreteObserver（具体观察者）：具体观察者中维护一个指向具体目标的引用，存储具体观察者的有关状态，这些状态需要与具体目标的状态保持一致，同时实现了抽象观察者的update方法 2 典型实现 2.1 步骤 定义抽象观察者：接口/抽象类，声明状态更新方法 定义具体观察者：继承/实现抽象观察者，实现状态更新方法 定义抽象目标：包含一个存储抽象观察者的集合，与一个类似notifyObserver的通知观察者的抽象方法 定义具体目标：继承抽象目标类，实现其中通知观察者的方法 2.2 抽象观察者 interface Observer { void update(String state); } 这里实现为一个接口，update方法供抽象目标，也就是供被观察者调用。 2.3 具体观察者 class ConcreteObserver implements Observer { public String state; public ConcreteObserver(String state) { this.state = state; } @Override public void update(String state) { System.out.println(&quot;观察者状态更新为&quot;+state); } } 实现其中的update方法，这里只是简单将状态输出。 2.4 抽象目标类 abstract class Subject { private List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public void attach(Observer observer) { list.add(observer); } public void detach(Observer observer) { list.remove(observer); } public void notifyObservers(String state) { list.forEach(t-&gt;t.update(state)); } public abstract void change(String newState); } 抽象目标类负责管理观察者集合，使用List存储抽象观察者，包含添加/删除观察者方法。notifyObservers中通知了所有的观察者，将状态作为具体参数进行传递。change作为被观察者的状态改变函数，将新状态作为参数传入。 2.5 具体目标类 class ConcreteSubject extends Subject { private String state; public String getState() { return state; } @Override public void change(String newState) { state = newState; System.out.println(&quot;被观察者状态为:&quot;+newState); notifyObservers(newState); } } 具体目标类负责实现抽象目标的change方法，保存新状态后，通过抽象目标的notifyObservers通知所有观察者。 2.6 客户端 public static void main(String[] args) { Observer observer1 = new ConcreteObserver(&quot;111&quot;); Observer observer2 = new ConcreteObserver(&quot;111&quot;); Observer observer3 = new ConcreteObserver(&quot;111&quot;); Subject subject = new ConcreteSubject(); subject.attach(observer1); subject.attach(observer2); subject.attach(observer3); subject.change(&quot;2222&quot;); } 客户端针对抽象观察者以及抽象目标进行编程，定义好各个观察者后，添加到抽象目标中进行管理，接着更新被观察者的状态。 输出如下： 3 实例 一个多人联机游戏中，拥有战队机制，当基地受到攻击时，将通知该战队所有成员进入警戒状态，使用观察者模式进行设计。 设计如下： 抽象观察者：Observer 具体观察者：Player 抽象目标：Subject 具体目标：Base 抽象观察者： interface Observer { void update(String state); } 包含一个供抽象目标调用的update()方法。 接着是具体观察者： class Player implements Observer { public String state; public String name; public Player(String name,String state) { this.name = name; this.state = state; } @Override public void update(String state) { System.out.println(&quot;战队成员&quot;+name+&quot;状态更新为&quot;+state); } } 在update中输出更新的状态。 抽象目标如下： abstract class Subject { private List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public void attach(Observer observer) { list.add(observer); } public void detach(Observer observer) { list.remove(observer); } public void notifyObservers(String state) { System.out.println(&quot;基地通知所有战队成员&quot;); list.forEach(t-&gt;t.update(state)); } public abstract void change(String newState); } 使用List存储所有战队成员，在通知方法中通知所有的观察者，change定义为抽象方法供子类实现。 具体目标（被观察者）如下： class Base extends Subject { private String state; public String getState() { return state; } @Override public void change(String newState) { state = newState; System.out.println(&quot;基地状态更新为:&quot;+newState); notifyObservers(newState); } } 实现抽象目标的change方法，里面需要调用notifyObservers方法通知所有观察者。 测试： public static void main(String[] args) { Observer player1 = new Player(&quot;A&quot;,&quot;无警戒状态&quot;); Observer player2 = new Player(&quot;B&quot;,&quot;无警戒状态&quot;); Observer player3 = new Player(&quot;C&quot;,&quot;无警戒状态&quot;); Subject subject = new Base(); subject.attach(player1); subject.attach(player2); subject.attach(player3); subject.change(&quot;警戒状态&quot;); } 输出如下： 4 推/拉模型 在观察者模式中，可以分为推模型以及拉模型。 4.1 推模型 推模型是被观察者向观察者推送观察目标的详细信息，不管观察者是否需要，推送的信息通常是被观察者对象的全部或部分数据。像上面的例子就是推模型，被观察者（基地）主动把状态数据推送给观察者（战队成员）。 4.2 拉模型 4.2.1 概述 拉模型当被观察者通知观察者时，只传递少量信息，如果观察者需要更加详细的信息，由观察者主动到观察目标中获取，相当于时观察者从主题对象中拉去数据。这种方式一般把被观察者自身通过update传递给观察者，获取数据时时直接通过这个被观察者引用获取。 4.2.2 实例 可以将上面的基地例子修改从推模型修改为拉模型，首先修改观察者中的update()参数： interface Observer { void update(Subject subject); } 接着修改具体观察者： class Player implements Observer { public String state; public String name; public Player(String name,String state) { this.name = name; this.state = state; } @Override public void update(Subject subject) { System.out.println(&quot;战队成员&quot;+name+&quot;状态更新为&quot;+subject.getState()); } } 主要的不同是原来的推模型直接把状态作为参数传递，现在传递一个抽象目标对象，需要具体观察者从中主动获取数据。 然后是抽象目标： abstract class Subject { private String state; private List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public void attach(Observer observer) { list.add(observer); } public void detach(Observer observer) { list.remove(observer); } public void notifyObservers() { System.out.println(&quot;基地通知所有战队成员&quot;); list.forEach(t-&gt;t.update(this)); } public String getState() { return state; } public void setState(String state) { this.state = state; } public abstract void change(String newState); } 主要改变是多了一个state成员，同时去掉notifyObservers()中的参数。 最后是具体目标： class Base extends Subject { @Override public void change(String newState) { setState(newState); System.out.println(&quot;基地状态更新为:&quot;+newState); notifyObservers(); } } 客户端代码无须任何修改，测试输出结果一致： 4.3 两者比较 推模型是假定被观察者知道观察者需要的数据，主动推送相关的数据，但是当不同的观察者需要不同的数据时候会出现麻烦，因为不能根据每一个不同的观察者提供不同的数据，或者提供新的update方法 拉模型是直接把被观察者的引用传递，观察者按需要从中获取数据，适用情况比推模型要广 5 Java中的观察者 5.1 Observer与Observable 观察者模式在Java中非常重要，JDK的java.util提供了Observer以及Observable接口作为对观察者模式的支持。 5.1.1 Observer java.util.Observer接口充当抽象观察者，只声明了一个方法： void update(Observable o,Object arg); 当观察目标的状态发生变化时，该方法会被调用，在Observer子类实现update，不同的具体观察者具有不同的更新行为，当调用Observable的notifyObservers()时，将执行update方法。 update的接口两个参数中，一个表示被观察者，一个表示调用notifyObservers的参数，换句话说，这样设计能同时支持推模型与拉模型： 使用推模型时，被观察者在notifyObervers()中传入arg参数，也就是update中的arg参数 使用拉模型时，被观察者不需要在notifyObservers中传入参数，但是需要在被观察者中声明获取状态或数据的方法，方便在update中通过被观察者引用o进行强制类型转换后调用 5.1.2 Observable java.util.Observable充当抽象目标类，其中定义了一个Vector存储观察者对象，包含的方法（OpenJDK11.0.2）如下： public class Observable { private boolean changed = false; private Vector&lt;Observer&gt; obs; public Observable() { //构造函数，初始化 obs } public synchronized void addObserver(Observer o) { //注册观察者到obs中 } public synchronized void deleteObserver(Observer o) { //删除obs中的某个观察者 } public void notifyObservers() { //通知方法，内部调用每一个观察者的update() } public void notifyObservers(Object arg) { //类似上面的通知方法，带参数调用update() } public synchronized void deleteObservers() { //删除所有观察者 } protected synchronized void setChanged() { //设置changed为true，表示观察目标的状态发生变化 } protected synchronized void clearChanged() { //清除changed的状态，表示观察目标状态不再发生改变 //或者已经通知了所有的观察者 } public synchronized boolean hasChanged() { //返回changed，表示观察对象是否发生改变 } public synchronized int countObservers() { //返回观察者数量 } } 5.1.3 例子 将上面基地的例子用Observable以及Observer实现如下： public class Test { public static void main(String[] args) { Observer player1 = new Player(&quot;A&quot;,&quot;无警戒状态&quot;); Observer player2 = new Player(&quot;B&quot;,&quot;无警戒状态&quot;); Observer player3 = new Player(&quot;C&quot;,&quot;无警戒状态&quot;); Base base = new Base(); base.addObserver(player1); base.addObserver(player2); base.addObserver(player3); base.change(&quot;警戒状态&quot;); } } class Player implements Observer { private String name; private String state; public Player(String name,String state) { this.name = name; this.state = state; } @Override public void update(Observable o,Object arg) { System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+arg); } } class Base extends Observable { public void change(String state) { setChanged(); notifyObservers(state); } } 具体观察者Player实现Observer接口，具体目标Base（被观察者）继承Observable，注意需要在notifyObservers之前，使用Observable的setChanged表示被观察者状态改变，这样使用notifyObservers才能生效，否则认为被观察者没有发生状态改变： 查看源码发现notifyObservers中先对changed内部布尔变量进行了判断，如果具体目标没有使用setChanged方法，将导致无法通知观察者。 这里使用了推模型实现，具体目标在notifyObservers中传递状态参数： class Player implements Observer { //... @Override public void update(Observable o,Object arg) { System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+arg); } } class Base extends Observable { public void change(String state) { setChanged(); notifyObservers(state); } } 使用拉模型修改如下： class Player implements Observer { //... public void update(Observable o,Object arg) { System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+((Base)o).getState()); } } class Base extends Observable { private String state; public String getState() { return state; } public void change(String state) { this.state = state; setChanged(); notifyObservers(); } } 具体观察者的update中由原来的从arg获取状态变为从Observable中通过getter获取状态，同时具体目标增加了state成员，在notifyObservers中不需手动传入状态参数。 5.2 新API——Flow API 虽然使用JDK的Observable以及Observer实现观察者模式很容易，不需要定义抽象目标以及抽象观察者，但是很遗憾的是从Java9开始标记为过时了（看着一条条横线也挺难受的）： 查了一下原因，标记为过时主要是因为： 提供的事件模型不够完善：它们不能提供一个完善的事件模型，比如只能告知观察者某些东西被改变了，但是没有告知什么东西改变了 不能序列化：Observable没有实现序列化接口 非线程安全：事件可能在不同的线程中以不同的顺序进行通知 6 Flow API 为了克服原来的缺点，从JDK9开始出现了Flow API，位于java.util.concurrent下。 在讲Flow API之前，先看一下响应式编程。 6.1 响应式编程 响应式编程可以理解为一种处理数据项的异步流，即在数据产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）以及数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。 在该模式中，还引入了一个更高级的特性：数据处理器（Processor），用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程遇到的困难，基于这个模型实现的有Java 9 Flow API，RxJava，Reactor等。 6.2 Flow API Flow是一个final类，里面定义了四个接口： Publisher&lt;T&gt;：数据发布者接口 Subscriber&lt;T&gt;：数据订阅者接口 Subscription：发布者和订阅者之间的订阅关系 Processor&lt;T,R&gt;：数据处理器 public static int defaultBufferSize()：返回缓冲区长度，默认256。当发布者发送速率高于接收速率时，数据接收者缓冲区将会被填满，当缓冲区填满后，发布者会停止发送数据，直到订阅者有空闲位置时，发布者才会继续发布数据 6.2.1 Publisher&lt;T&gt; Publisher源码如下： @FunctionalInterface public static interface Publisher&lt;T&gt; { public void subscribe(Subscriber&lt;? super T&gt; subscriber); } 这是一个函数式接口，只包含一个subscribe方法，通过该方法将数据发布出去。 6.2.2 Subscriber&lt;T&gt; Subscriber源码如下： public static interface Subscriber&lt;T&gt; { public void onSubscribe(Subscription subscription); public void onNext(T item); public void onError(Throwable throwable); public void onComplete(); } 方法解释如下： onSubscribe：订阅成功的回调方法，用于初始化Subscription，表明可以开始接收订阅数据了 onNext ：接收下一项订阅数据的回调方法 onError：在Publisher或Subscriber遇到不可恢复的错误时会调用该方法，Subscriber不再接收订阅信息 onComplete：接收完所有订阅数据，并且发布者已经关闭后会回调该方法 6.2.3 Subscription Subscription源码如下： public static interface Subscription { public void request(long n); public void cancel(); } 方法解释如下： request：用于向数据发布者请求n个数据项 cancel：取消消息订阅，订阅者不再接收数据 6.2.4 Processor&lt;T,R&gt; Processor源码如下： public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {} 这是一个空接口，继承了Subscriber以及Publisher，它既能发布数据也能订阅数据，基于这个特性它可以充当数据转换的角色，先从数据发布者接收数据，经过处理后发布给数据订阅者。 6.2.5 简例 public class Test { public static void main(String[] args) { //JDK9自带的数据发布者,实现了Publisher&lt;T&gt; SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); //创建订阅者,用于接收发布者消息 Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { //通过Subscription和发布者保持订阅关系 //并用它来给发布者反馈 this.subscription = subscription; //请求一个数据 this.subscription.request(1); } @Override public void onNext(String item) { //接收发布者发布的信息 System.out.println(&quot;订阅者接收消息:&quot;+item); //接收后再次请求一个数据 this.subscription.request(1); //如果不想接收直接调用cancel // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { //异常回调 System.out.println(&quot;订阅者接收数据异常:&quot;+throwable); throwable.printStackTrace(); this.subscription.cancel(); } @Override public void onComplete() { //发布者发送的数据都被接收了 //并且发布者关闭后就会回调该方法 System.out.println(&quot;订阅者接收数据完毕&quot;); } }; //建立发布者与订阅者的关系 publisher.subscribe(subscriber); //发布数据 for(int i=0;i&lt;10;++i) { String message = &quot;flow api &quot;+i; System.out.println(&quot;发布者发布消息:&quot;+message); publisher.submit(message); } //发布结束后关闭发布者 publisher.close(); //main延迟关闭,否则订阅者没接收完消息线程就被关闭 try { Thread.currentThread().join(2000); } catch(Exception e) { e.printStackTrace(); } } } 步骤： 建立消息发布者：使用SubmissionPublisher&lt;String&gt;作为消息发布者 建立消息订阅者：实现Subscriber&lt;String&gt;作为消息订阅者 建立订阅关系：通过publisher.subscribe(subsciber)建立 发布数据：发布者通过submit发布数据 收尾工作：如果没有出现异常需要调用发布者的close()关闭发布者，同时会回调订阅者的onComplete方法 输出如下： 注意例子中最后需要延迟关闭main线程，如果没有这个操作，订阅者就不能完全接收所有信息： 可以从输出看到，订阅者接收到第8条消息后，线程就被关闭了。 6.2.6 模拟缓冲区填满 前面说过Flow中有一个静态方法返回缓冲区大小，下面进行模拟填满，在订阅者中的订阅方法中，加入延迟： @Override public void onNext(String item) { //模拟接收数据缓慢填满缓冲池 try { TimeUnit.MILLISECONDS.sleep(300); } catch(InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;订阅者接收消息:&quot;+item); //接收后再次请求一个数据 this.subscription.request(1); } 因为默认的缓冲区大小为256，因此，发布256条信息后，可以看到不再发送，直到等到订阅者处理才继续发布： 6.2.7 Processor Processor就是Publisher+Subscriber，通常是用作接收发布者发布的信息，进行相应处理后，再将数据发布，供消息者订阅接收，下面是一个简例： public class Test { public static void main(String[] args) { //JDK9自带的数据发布者,实现了Publisher&lt;T&gt; SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); //创建订阅者,用于接收发布者消息 TestProcessor processor = new TestProcessor(); Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { this.subscription = subscription; this.subscription.request(1); } @Override public void onNext(String item) { System.out.println(&quot;订阅者接收消息:&quot;+item); this.subscription.request(1); } @Override public void onError(Throwable throwable) { System.out.println(&quot;订阅者接收异常&quot;); throwable.printStackTrace(); this.subscription.cancel(); } @Override public void onComplete() { System.out.println(&quot;订阅者接收完毕&quot;); } }; publisher.subscribe(processor); processor.subscribe(subscriber); //发布数据 for(int i=0;i&lt;10;++i) { String message = &quot;flow api &quot;+i; System.out.println(&quot;发布者发布消息:&quot;+message); publisher.submit(message); } //发布结束后关闭发布者 publisher.close(); //main延迟关闭,否则订阅者没接收完消息线程就被关闭 try { Thread.currentThread().join(2000); } catch(Exception e) { e.printStackTrace(); } } } class TestProcessor extends SubmissionPublisher&lt;String&gt; implements Processor&lt;String,String&gt; { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { //通过Subscription和发布者保持订阅关系 //并用它来给发布者反馈 this.subscription = subscription; //请求一个数据 this.subscription.request(1); } @Override public void onNext(String item) { //模拟接收数据缓慢填满缓冲池 System.out.println(&quot;处理器处理消息:&quot;+item); item = &quot;经过处理器处理的消息:&quot;+item; //接收后再次请求一个数据 this.submit(item); this.subscription.request(1); } @Override public void onError(Throwable throwable) { //异常回调 System.out.println(&quot;处理器处理数据异常:&quot;+throwable); throwable.printStackTrace(); this.subscription.cancel(); } @Override public void onComplete() { System.out.println(&quot;处理者处理数据完毕&quot;); this.close(); } } 步骤： 建立消息发布者：同上使用SubmissionPublisher&lt;String&gt; 建立消息处理者：这里使用了一个继承SubmissionPublisher&lt;String&gt;并实现Processor&lt;String,String&gt;的类，在其中的onNext方法中对消息进行处理并调用submit发布给订阅者，在其中的onComplete调用close()关闭处理器 建立消息订阅者：同上实现了Subscriber&lt;String&gt; 建立订阅关系：处理者订阅发布者，订阅者订阅处理者，也就是处理者相当于中介角色，将消息处理后交给订阅者 发布消息：发布者发布消息 收尾工作：首先由于处理者订阅了发布者，因此处理者处理完数据后处理者先关闭，接着订阅者订阅完处理后的数据后订阅者再关闭 输出： 6.2.8 使用Flow API实现例子 讲了这么多Flow API的例子，下面来看看如何使用Flow API实现基地的例子。 public class Test { public static void main(String[] args) { Base base = new Base(); Player player1 = new Player(&quot;A&quot;, &quot;非戒备状态&quot;); Player player2 = new Player(&quot;B&quot;, &quot;非戒备状态&quot;); Player player3 = new Player(&quot;C&quot;, &quot;非戒备状态&quot;); base.add(player1); base.add(player2); base.add(player3); base.changed(&quot;戒备状态&quot;); base.close(); } } class Base { SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); private List&lt;Player&gt; players = new ArrayList&lt;&gt;(); public void add(Player player) { publisher.subscribe(player); players.add(player); } public void remove(Player player) { player.cancel(); players.remove(player); } public void changed(String state) { System.out.println(&quot;基地正在遭受攻击&quot;); publisher.submit(state); } public void close() { publisher.close(); try { Thread.currentThread().join(2000); } catch(Exception e) { e.printStackTrace(); } } } class Player implements Subscriber&lt;String&gt; { private Subscription subscription; private String name; private String state; public Player(String name,String state) { this.name = name; this.state = state; } @Override public void onSubscribe(Subscription subscription) { this.subscription = subscription; this.subscription.request(1); } @Override public void onNext(String item) { System.out.println(&quot;战队成员&quot;+name+&quot;更新状态:&quot;+item); this.subscription.request(1); } @Override public void onError(Throwable throwable) { System.out.println(&quot;战队成员接收异常&quot;); throwable.printStackTrace(); this.subscription.cancel(); } public void cancel() { this.subscription.cancel(); } @Override public void onComplete() { System.out.println(&quot;战队成员接收完毕&quot;); } } 大部分代码都与上面的例子相同，就不解释了，贴一下输出： 7 主要优点 分离表示层与逻辑层：定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色 降低耦合：在抽象目标以及抽象观察者之间建立了一个抽象耦合，观察目标只需要维持一个抽象观察者的集合，无须了解具体观察者，由于观察目标和观察者没有紧密耦合在一起，因此它们可以属于不同的抽象层次 广播：观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多的系统设计难度 满足OCP：观察者模式满足开放闭合原则的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者之间与观察目标之间不存在关联关系的情况下，增加新的观察目标很方便 8 主要缺点 通知费时：如果有很多观察者，通知需要耗费较多时间 循环依赖导致崩溃：如果观察者模式与观察目标之间存在循环依赖，观察目标会导致触发它们之间进行循环调用，可能导致崩溃 不明确变化内容：观察者模式只是让观察者知道观察目标发生了变化，但是不知道变化的内容是什么 9 适用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在一个独立的对象中使它们可以独立地改变和复用 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象发生改变，也不知道这些对象是谁 需要在系统中创建一个触发链，A对象的行为会影响B对象，B对象的行为会影响C对象，可以使用观察者模式创建一种链式触发机制 10 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-er-guan-cha-zhe-mo-shi/"},{"title":"设计模式学习笔记（二十一）：备忘录模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 原发器 2.3 备忘录 2.4 负责人 2.5 客户端 3 实例 4 备忘录封装 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 在手机上玩象棋时，往往会提供一个悔棋的功能，实际上，悔棋就是恢复到某个历史状态，很多软件中称之为撤销，实现撤销时，需要先保存历史状态，这样撤销时，取出某个历史状态并覆盖当前状态。备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态恢复。 1.2 定义 备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 备忘录模式是一种对象行为型模式，别名为Token。 1.3 结构图 1.4 角色 Originator（原发器）：一个普通类，可以创建一个备忘录，并存储当前内部状态，也可以使用备忘录恢复内部状态，一般为需要保存内部状态的类 Memento（备忘录）：存储原发器内部状态，根据原发器决定保存哪些内部状态。除了原发器以及负责人以外，备忘录不能供其他对象直接使用 Caretaker（负责人）：又叫管理者，负责保存备忘录，可以存储一个或多个备忘录，只负责保存备忘录对象，不能修改备忘录 2 典型实现 2.1 步骤 定义原发器：原发器是需要保存内部状态的类，提供一个从当前状态创建备忘录的方法以及一个从备忘录中恢复内部状态的方法 定义备忘录：存储原发器内部状态，需要考虑封装性，不能被除原发器以及负责人以外的类访问，否则失去备忘录意义 定义负责人：保存备忘录对象，一般使用集合存储多个备忘录 2.2 原发器 class Originator { private String state; public String getState() { return this.state; } public void setState(String state) { this.state = state; } public Memento save() { return new Memento(state); } public void restore(Memento memento) { this.state = memento.getState(); } } 原发器中相应的字段表示内部状态，save()返回一个将内部状态封装为备忘录的对象，restore()获取备忘录中的内部状态并进行恢复。 2.3 备忘录 class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return this.state; } } 简单的保存内部状态的类，需要保证封装性，不允许除原发器以及负责人外的类访问。 不同语言实现机制不同，比如C++中可以通过friend友元实现，Java中可通过将备忘录或者原发器防置同一个包或者将备忘录作为原发器的内部类实现。 2.4 负责人 class Caretaker { private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;(); public Memento get() { return mementos.remove(0); } public void add(Memento memento) { mementos.add(0,memento); } } 负责人使用一个LinkedList保存多个备忘录，由于恢复操作是逐步进行的，也就是不能一次恢复到“撤销两次”的历史状态，只能恢复到“撤销一次”的历史状态，因此可以考虑栈来保存备忘录。 2.5 客户端 public static void main(String[] args) { Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(&quot;状态1&quot;); caretaker.add(originator.save()); originator.setState(&quot;状态2&quot;); caretaker.add(originator.save()); originator.setState(&quot;状态3&quot;); caretaker.add(originator.save()); originator.restore(caretaker.get()); System.out.println(originator.getState()); originator.restore(caretaker.get()); System.out.println(originator.getState()); originator.restore(caretaker.get()); System.out.println(originator.getState()); } 对于客户端，每修改一次原发器的状态就通过负责人保存一次生成的备忘录，需要时从负责人获取备忘录并恢复到相应的状态。 输出： 3 实例 象棋悔棋的实现，使用备忘录模式进行设计。 设计如下： 原发器：Chessman 备忘录：Memento 负责人：Caretaker 原发器如下： class Chessman { private String label; private int x; private int y; public Chessman(int x,int y,String label) { this.x = x; this.y = y; this.label = label; } public Memento save() { return new Memento(x,y,label); } public void restore(Memento memento) { this.x = memento.getX(); this.y = memento.getY(); this.label = memento.getLabel(); } //setter+getter... @Override public String toString() { return &quot;x:&quot;+x+&quot;\\ty:&quot;+y+&quot;\\tlabel:&quot;+label; } } 原发器的两个核心方法就是save()与restore，save()将内部状态保存为备忘录，而restore()根据备忘录参数恢复到之前的内部状态。 备忘录如下： class Memento { private int x; private int y; private String label; public Memento(int x,int y,String label) { this.x = x; this.y = y; this.label = label; } //getter... } 属性与原发器一致，最后是负责人： class Caretaker { private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;(); public Memento get() { return mementos.remove(0); } public void add(Memento memento) { mementos.add(0,memento); } } 使用LinkedList模拟栈的操作，get获取栈顶的状态。 测试： public static void main(String[] args) { Chessman chessman = new Chessman(1,2,&quot;车&quot;); Caretaker caretaker = new Caretaker(); caretaker.add(chessman.save()); chessman.setX(8); caretaker.add(chessman.save()); chessman.setY(5); caretaker.add(chessman.save()); chessman.restore(caretaker.get()); System.out.println(chessman); chessman.restore(caretaker.get()); System.out.println(chessman); chessman.restore(caretaker.get()); System.out.println(chessman); } 输出： 4 备忘录封装 备忘录是一个特殊的对象，只有原发器对它拥有控制权力，负责人只负责管理备忘录，其他类无法直接访问备忘录，因此需要对备忘录进行封装。在Java中可以使用内部类对备忘录进行封装，比如上面的例子可以封装内部类如下： class Chessman { //... public class Memento { private int x; private int y; private String label; public Memento(int x,int y,String label) { this.x = x; this.y = y; this.label = label; } public int getX() { return this.x; } public int getY() { return this.y; } public String getLabel() { return this.label; } } //... } 这样可以最大程度地限制外部类对于备忘录的访问，如果想进一步的完全限制，可以将备忘录设置为私有内部类，将负责人类也作为原发器的内部类，这样外部类就完全不能访问备忘录： class Chessman { //... private class Memento { //... } public class Caretaker { private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;(); public Memento get() { return mementos.remove(0); } public void add(Memento memento) { mementos.add(0,memento); } } public Caretaker getCaretaker() { return new Caretaker(); } } 5 主要优点 状态恢复：备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史状态 多次撤销：备忘录实现了对信息的封装，保存了原发器的状态，配合列表，堆栈等集合可以实现多次撤销操作 6 主要缺点 资源消耗大：如果需要保存的原发器状态太多，将会占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源 7 适用场景 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时就能恢复到先前的状态，实现撤销操作 防止外界对象破坏一个对象历史状态的封装性，避免将历史状态的实现细节暴露给外部对象 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-yi-bei-wang-lu-mo-shi/"},{"title":"设计模式学习笔记（二十）：中介者模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象同事类 2.3 具体同事类 2.4 抽象中介者 2.5 具体中介者 2.6 客户端 3 实例 4 扩展中介者与同事类 4.1 方法1 4.2 方法2 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 如果一个系统中对象之间的联系呈现为网状结构，存在大量的多对多联系，将导致系统非常复杂，比如，一个GUI窗口中，通过一个按钮更新了文本框，也更新了组合框，更新组合框的同时反过来需要更新文本框以及按钮。 这些对象既会影响别的对象，也会被别的对象所影响，这些对象称为同事对象，它们之间通过彼此相互作用实现系统的行为，几乎每一个对象都需要与其他对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合，这将导致一个过度耦合的系统。 中介者模式可以使对象之间的关系急剧减少，通过引入中介者对象，可以将系统的网状结构： 转化为以中介者为中心的星型结构： 在这个星型结构中，同事对象不再直接与其他的同事对象联系，通过中介者对象与另一个对象发生相互作用，中介者对象的存在保证了结构上的稳定，也就是说，系统的结构不会因为新对象的引入带来大量的修改工作。 如果一个系统中对象之间存在多对多的相互关系，可以将对象之间的一些交互行为从各个对象之间分离出来，并集中封装在一个中介者对象中，由中介者进行统一的协调，这样对象之间多对多的复杂关系就转变为相对简单的一对多关系，通过引入中介者来简化对象之间的复杂交互。 1.2 定义 中介者模式：用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其松散耦合，而且可以独立地改变它们之间的交互。 中介者模式又叫调停者模式，是一种对象行为型模式。 1.3 结构图 1.4 角色 Mediator（抽象中介者）：定义了与各同事类之间进行通信的方法 ConcreteMediator（具体中介者）：抽象中介者的子类，协调各个同事对象实现协作行为，维持对各个同事对象的引用 Colleague（抽象同事类）：定义各个同事类的公有方法，并声明一些抽象方法来提供子类实现，同事维持一个抽象中介者的引用，子类可以通过该引用与中介者通信 ConcreteColleague（具体同事类）：抽象同事的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信，在具体同事类中实现了在抽象同事类中声明的抽象方法 2 典型实现 2.1 步骤 定义抽象同事类：声明具体同事类的方法，包含一个抽象中介者成员 定义具体同事类：继承/实现抽象同事类，添加一个数据更改以及数据更新的方法，其中数据更改方法供客户端调用，表示更改了具体同事类的某项数据，并且在其中调用抽象中介者的通知其他同事类更新的方法。数据更新方法供抽象中介者调用，当其他同事类修改数据时，抽象中介者通过该方法更新该同事类的数据 定义抽象中介者：包含一个抽象同事类的集合，存储具体同事类对象，同时声明一个通知其他同事类更新的方法 定义具体中介者：继承抽象中介者，根据需要实现业务方法， 其中第二步可能比较难理解，下面会有详细说明。 2.2 抽象同事类 abstract class Colleague { //抽象中介者引用 protected Mediator mediator; public Colleague(Mediator mediator) { this.mediator = mediator; } //数据更新方法 public abstract void update(); //数据更改方法 public abstract void changed(); } 抽象同事类包含一个抽象中介者的引用，声明了数据更新方法以及数据更改方法。 至于为什么需要声明这两个方法，首先可以假设有两个同事类：两个文本框，其中一个文本框表示长度，用米作单位，另一个用千米做单位，当其中一个修改时，也就是changed()被调用时，通过中介者调用另一个文本框的update()使另一个文本框更新。 2.3 具体同事类 class ConcreteColleague1 extends Colleague { public ConcreteColleague1(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新同事类1&quot;); } @Override public void changed() { System.out.println(&quot;同事类1数据更改&quot;); mediator.operation(this); } } class ConcreteColleague2 extends Colleague { public ConcreteColleague2(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新同事类2&quot;); } @Override public void changed() { System.out.println(&quot;同事类2数据更改&quot;); mediator.operation(this); } } 具体同事类中通过构造方法注入抽象中介者，维持一个抽象中介者的引用。另外在数据更改方法中，需要通过中介者通知其他同事类进行更新，也就是执行其他同事类的update()方法。 2.4 抽象中介者 abstract class Mediator { protected ArrayList&lt;Colleague&gt; colleagues = new ArrayList&lt;&gt;(); public void add(Colleague colleague) { colleagues.add(colleague); } public abstract void operation(Colleague colleague); } 抽象中介者使用集合存储所有的具体同事类，其中的operation方法是通知其他同事类修改的方法，在此方法里面统一协调所有的同事类，从而避免各个同事类之间直接调用，降低耦合度。 2.5 具体中介者 class ConcreteMediator extends Mediator { @Override public void operation(Colleague colleague) { if(colleague instanceof ConcreteColleague1) colleagues.get(1).update(); else if(colleague instanceof ConcreteColleague2) colleagues.get(0).update(); } } 实现抽象中介者的业务方法，这里是传入一个抽象同事类参数，判断具体是哪一个同事类，按需要更新具体同事类即可。 2.6 客户端 public static void main(String[] args) { Mediator mediator = new ConcreteMediator(); Colleague colleague1 = new ConcreteColleague1(mediator); Colleague colleague2 = new ConcreteColleague2(mediator); mediator.add(colleague1); mediator.add(colleague2); colleague1.changed(); colleague2.changed(); } 客户端针对抽象中介者以及抽象同事类进行编程，先创建具体中介者，通过构造方法注入到各个具体同事类中，以便同事类调用对应中介者的方法，接着还需要将各个同事类添加到抽象中介者的集合成员中，以便抽象中介者对具体同事类进行统一的管理，最后调用具体同事类的方法。 输出如下： 3 实例 设计一个客户信息管理窗口，其中包含按钮，列表框，文本框，组合框组件，使用中介者模式进行设计。 设计如下： 抽象同事类：Component 具体同事类：Button+ListBox+TextBox+ComboBox 抽象中介者：Mediator 具体中介者：ConcreteMediator 首先是抽象同事类，包含一个抽象中介者引用，以及数据更改和更新方法。 abstract class Component { protected Mediator mediator; public Component(Mediator mediator) { this.mediator = mediator; } public abstract void update(); public abstract void changed(); } 接着是具体同事类： class Button extends Component { public Button(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新按钮&quot;); } @Override public void changed() { System.out.println(&quot;按钮数据更改&quot;); mediator.notifyAllComponent(this); } } class ListBox extends Component { public ListBox(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新列表框&quot;); } @Override public void changed() { System.out.println(&quot;列表框数据更改&quot;); mediator.notifyAllComponent(this); } } class ComboBox extends Component { public ComboBox(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新组合框&quot;); } @Override public void changed() { System.out.println(&quot;组合框数据更改&quot;); mediator.notifyAllComponent(this); } } class TextBox extends Component { public TextBox(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新文本框&quot;); } @Override public void changed() { System.out.println(&quot;文本框数据更改&quot;); mediator.notifyAllComponent(this); } } 一共四个具体同事类，每一个具体同事类代表一个UI组件，实现了其中的数据更新以及数据更改方法。 接着是抽象中介者类，为了更好地管理组件（具体同事对象）引入了一个组件管理类，以便在抽象中介者中可以统一使用put添加组件： enum ComponentName { BUTTON,LIST_BOX,TEXT_BOX,COMBO_BOX; } class AllComponent { private Map&lt;ComponentName,Component&gt; map = new HashMap&lt;&gt;(); public void put(Component component) { if(component instanceof Button) map.put(ComponentName.BUTTON, component); else if(component instanceof ListBox) map.put(ComponentName.LIST_BOX, component); else if(component instanceof ComboBox) map.put(ComponentName.COMBO_BOX, component); else if(component instanceof TextBox) map.put(ComponentName.TEXT_BOX, component); } public Component get(ComponentName name) { return map.containsKey(name) ? map.get(name) : null; } } abstract class Mediator { protected AllComponent allComponent = new AllComponent(); public void put(Component ... components) { for(Component component:components) allComponent.put(component); } public abstract void notifyAllComponent(Component Component); } 引入组件类的另一个原因是方便日后扩展组件，这样就不需要修改抽象中介者的代码，抽象中介者只需要维持一个组件管理类的引用。组件管理类使用一个Map存储所有同事类对象，根据对应的具体同事类类型，使用枚举设置相应的键值。 另外抽象中介者中包含一个重要的notifyAllComponent方法，该方法在某个组件的数据改变时调用，通知其他所有组件进行相应的更新。 最后是具体中介者类： class ConcreteMediator extends Mediator { private Component button = null; private Component listBox = null; private Component comboBox = null; private Component textBox = null; @Override public void notifyAllComponent(Component component) { if(button == null) button = allComponent.get(ComponentName.BUTTON); if(listBox == null) listBox = allComponent.get(ComponentName.LIST_BOX); if(comboBox == null) comboBox = allComponent.get(ComponentName.COMBO_BOX); if(textBox == null) textBox = allComponent.get(ComponentName.TEXT_BOX); if(component instanceof Button) { listBox.update(); textBox.update(); comboBox.update(); } else if(component instanceof ListBox) { textBox.update(); comboBox.update(); } else if(component instanceof TextBox) { button.update(); listBox.update(); } else if(component instanceof ComboBox) { textBox.update(); listBox.update(); } } } 首先获取同事类对象，然后判断具体同事类的类型，按实际需要进行选择性更新同事类即可。 测试： public static void main(String[] args) { Mediator mediator = new ConcreteMediator(); Component button = new Button(mediator); Component listBox = new ListBox(mediator); Component textBox = new TextBox(mediator); Component comboBox = new ComboBox(mediator); mediator.put(button,listBox,textBox,comboBox); System.out.println(&quot;按钮更改事件:&quot;); button.changed(); System.out.println(); System.out.println(&quot;列表框更改事件:&quot;); listBox.changed(); System.out.println(); System.out.println(&quot;文本框更改事件:&quot;); textBox.changed(); System.out.println(); System.out.println(&quot;组合框更改事件:&quot;); comboBox.changed(); System.out.println(); } 客户端针对抽象中介者以及抽象同事类进行编程，创建完同事类后统一添加到抽象中介者中，最后更新对应同事类即可。 输出如下： 4 扩展中介者与同事类 在上面例子的基础上，现在系统需要增加一个Label组件，也就是增加一个具体同事类，由于建立了抽象层，增加具体同事类很容易，对于如何在中介者中扩展有以下两种方法： 在原有具体中介者中增加一个Label成员并在对应方法添加else if判断 继承原有具体中介者 4.1 方法1 首先增加一个Label类： class Label extends Component { public Label(Mediator mediator) { super(mediator); } @Override public void update() { System.out.println(&quot;更新文本标签&quot;); } @Override public void changed() { System.out.println(&quot;文本标签数据更改&quot;); mediator.notifyAllComponent(this); } } 接着需要修改组件管理类： enum ComponentName { BUTTON,LIST_BOX,TEXT_BOX,COMBO_BOX,LABEL; } class AllComponent { //... public void put(Component component) { if(component instanceof Button) map.put(ComponentName.BUTTON, component); else if(component instanceof ListBox) map.put(ComponentName.LIST_BOX, component); else if(component instanceof ComboBox) map.put(ComponentName.COMBO_BOX, component); else if(component instanceof TextBox) map.put(ComponentName.TEXT_BOX, component); else if(component instanceof Label) map.put(ComponentName.LABEL, component); } //... } 添加一条else if即可，最后修改具体中介者类： class ConcreteMediator extends Mediator { private Component button = null; private Component listBox = null; private Component comboBox = null; private Component textBox = null; private Component label = null; @Override public void notifyAllComponent(Component component) { if(button == null) button = allComponent.get(ComponentName.BUTTON); if(listBox == null) listBox = allComponent.get(ComponentName.LIST_BOX); if(comboBox == null) comboBox = allComponent.get(ComponentName.COMBO_BOX); if(textBox == null) textBox = allComponent.get(ComponentName.TEXT_BOX); if(label == null) label = allComponent.get(ComponentName.LABEL); //... } } 其他无须修改，客户端一样可以针对抽象中介者以及抽象同事类进行编程。这样就顺利添加一个具体同事类了，代码需要改动的部分不多。 4.2 方法2 方法2也是需要像方法1一样新建一个Label类以及修改组件管理类的代码，但是为了不修改具体中介者的代码，从具体中介者继承了一个新的具体中介者，代码如下： class SubConcreteMediator extends ConcreteMediator { private Component label = null; @Override public void notifyAllComponent(Component component) { if(label == null) label = allComponent.get(ComponentName.LABEL); if(component instanceof Label) { Component textBox = allComponent.get(ComponentName.TEXT_BOX); if(textBox != null) textBox.update(); } else super.notifyAllComponent(component); } } 客户端需要将原来的具体中介者修改为新的具体中介者： Mediator mediator = new SubConcreteMediator(); Component button = new Button(mediator); Component listBox = new ListBox(mediator); Component textBox = new TextBox(mediator); Component comboBox = new ComboBox(mediator); Component label = new Label(mediator); mediator.put(button,listBox,textBox,comboBox,label); label.changed(); 继承是另一个达到目的的方法。事实上这两种方法本质上没有任何的区别，都是增加了一个Label对象以及一条else if，但是，由于方法2不需要修改原有的具体中介者类，符合开闭原则，因此推荐使用方法2，也就是对于新增具体同事类可以使用继承具体中介者类的方式进行处理。 5 主要优点 简化交互：中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事的多对多交互，一对多容易理解和扩展，将原本难以理解的网状结构转换为星型结构 解耦同事对象：中介者模式可将各个同事对象解耦，有利于各同事之间的松耦合，可以独立改变和复用每一个同事和中介者，增加新的中介者和新的同事类都很方便，更好地符合开闭原则 减少同事子类个数：中介者将原本分布于多个对象间的行为集中起来，改变这些行为只需要生成新的中介者子类即可，这使得各个同事类可以被重用，无须对同事类进行扩展 6 主要缺点 中介者类复杂：由于具体中介者中包含了大量的同事之间的交互细节，可能会导致具体中介者类变得非常复杂，使得系统难以维护 7 适用场景 系统对象之间存在复杂的引用关系，系统结构混乱且难以理解 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象 想通过一个中间类来封装多个类的行为，而又不想生成太多的子类 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-zhong-jie-zhe-mo-shi/"},{"title":"每日分享 第46期","content":" 每日鸡汤 你要相信明天，一定会更好的，更好的把你虐成狗。 每日冷知识 当德国连锁超市ALDI的首席执行官西奥·阿尔布雷希特被绑架后，他不但向绑架者给自己的赎金砍了假，还在获释后在法庭上宣称这笔款项为可抵税商务开支。 每日诗词 荷花五寸荷花娇，贴波不碍画船摇。 ——石涛《荷花》 每日一句 因为痛苦太有价值，因为回忆太珍贵，所以我们更要继续往前走。 每日音乐 это ли счастье? - Rauf &amp; Faik В мире не осталось искренних чувств Я теперь иду и тут каждую боюсь Это ли счастье? Тут все погасло Это не счастье Не счастье Не счастье Это ли счастье? Тут все погасло Это не счастье Не счастье Ты мне говоришь «Люблю» На это в голове много мыслей у меня Что, если тебе не даю Я не даю то, что хочешь от меня В мире только подлость и грусть Тебе важны мои деньги, бери мои деньги Я тебя не люблю Уходи от меня, не возвращайся сюда В мире не осталось искренних чувств Я теперь иду и тут каждую боюсь Ты мне говоришь «Люблю» На это в голове много мыслей у меня Что, если тебе не даю Я не даю то, что хочешь от меня В мире только подлость и грусть Тебе важны мои деньги, бери мои деньги Я тебя не люблю Уходи от меня, не возвращайся сюда Ты мне говоришь «Люблю» На это в голове много мыслей у меня Что, если тебе не даю Я не даю то, что хочешь от меня В мире только подлость и грусть Тебе важны мои деньги, бери мои деньги Я тебя не люблю Уходи от меня, не возвращайся сюда Не возвращайся сюда Не возвращайся сюда Не возвращайся сюда Не возвращайся сюда ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-46-qi/"},{"title":"每日分享 第45期","content":" 每日鸡汤 条条大路通罗马，每条都有收费站。 每日冷知识 美国的阿拉斯加州，亚利桑那州，印第安纳州，肯塔基州，宾夕法尼亚州，田纳西州，犹他州和西维吉尼亚州都拥有自己的官方州枪，分别从淡动式左轮手枪到半自动狙击步枪不一。 每日诗词 但满目京尘，东风竟日吹露桃。 ——周邦彦《忆旧游·记愁横浅黛》 每日一句 我不要你忘记他，我只要你记得我。 每日音乐 树藤-林欣彤 优雅的眼妆沿十条裂纹在割下 我听见指甲尖在额头磨灭计划 绝望能绝吗 愿望难道能望吗 三千青丝一刹变白 我不信天国一到海会枯顽石会烂 我只信心瘾一到便亡命投入劫难 若罪名是贪 但树藤何曾未贪 高攀不起孤立亦难 Take on me this misery 私有得彻底 情愿吸干你一切 La la la la la la la la la la Cry for me and I'm sorry 死结捆到底 情愿烧光我躯体 飞灰撒下烂泥才高贵 舍弃一切换不到美丽 得到安慰变不出地位 我像蝼蚁 不知道千秋更替蔷薇藏后世 于你枝干盛开的瑰丽 伴随灵欲兴衰的姿势 那样华贵 扑灭前望你十秒便记住约誓 凄美的血丝沿十条泪痕在抹下 脑中有千个天使在扬善提示放下 道别能别吗 独活难道能活吗 一堆枯骨飞不出一刹那 我不信天国一到海会枯顽石会烂 我只信心瘾一到便亡命投入劫难 若罪名是贪 但树藤何曾未贪 Da la la la la la la la Take on me this misery 私有得彻底 情愿吸干你一切 La la la la la la la la la la Cry for me say I'm sorry 死结捆到底 情愿烧光我躯体 飞灰撒下烂泥才高贵 舍弃一切换不到美丽 得到安慰变不出地位 我像蝼蚁 不知道千秋更替蔷薇藏后世 于你枝干盛开的瑰丽 伴随灵欲兴衰的姿势 那样华贵 扑灭前望你十秒便记住约誓 任由萤火将我净化带着你牵挂 或能尘归土种下世花 不顾一切什么都美丽 给你刻上最深的毒誓 我像蝼蚁 不知道千秋更替明媚留不低 于你枝干盛开的瑰丽 伴随灵欲兴衰的姿势 那样华贵 扑灭前望你十秒便记住约誓 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-45-qi/"},{"title":"设计模式学习笔记（十九）：迭代器模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象迭代器 2.3 抽象聚合类 2.4 具体聚合类 2.5 具体迭代器 2.6 客户端 3 实例 4 内部类实现 5 JDK迭代器 5.1 Iterator 5.2 ListIterator 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 在软件开发中，有一些类可以存储多个成员对象（元素），这些类通常称为聚合类，对应的对象称为聚合对象。聚合对象拥有两个职责，一个是存储数据，一个是遍历数据，前者是聚合对象的基本职责，后者是可以变化以及分离的，因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，又迭代器来提供遍历聚合对象内部数据的行为。 1.2 定义 迭代器模式：提供一种方法来访问对象，而不用暴露这个对象的内部表示，别名叫游标。 迭代器模式是一种对象行为型模式。 1.3 结构图 1.4 角色 Iterator（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，比如first（获取第一个元素），next（获取下一个元素），hasNext（判断是否有下一个元素），currentItem（获取当前元素） ConcreteIterator（具体迭代器）：实现了抽象迭代器，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录聚合对象中所处的当前位置，通常游标是一个非负整数 Aggregate（抽象聚合类）：用于存储和管理元素对象，声明一个createIterator方法创建一个迭代器对象，充当抽象迭代器的工厂角色 ConcreteAggregate（具体聚合类）：实现了抽象聚合类中的createIterator方法，返回一个具体迭代器实例 2 典型实现 2.1 步骤 定义抽象迭代器：一般为接口，声明具体迭代器的方法 定义抽象聚合类：一般为接口，包含管理聚合元素的方法以及创建抽象迭代器的方法 定义具体聚合类：内部创建集合存储聚合元素，在创建迭代器方法中将集合作为构造方法参数注入到具体迭代器中并返回该具体迭代器 定义具体迭代器类：实现抽象迭代器的方法，一般包含一个来自具体聚合类的集合引用以及一个表示元素位置的整型的游标 2.2 抽象迭代器 interface Iterator { String first(); String next(); boolean hasNext(); String currentItem(); } 2.3 抽象聚合类 interface Aggregate { Iterator createIterator(); void add(String s); } 创建迭代器通过createIterator，add用于增添元素。 2.4 具体聚合类 class ConcreteAggregate implements Aggregate { List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override public Iterator createIterator() { return new ConcreteIterator(list); } @Override public void add(String s) { list.add(s); } } 在创建迭代器方法中，通过构造方法把集合对象注入到具体迭代器中。 2.5 具体迭代器 class ConcreteIterator implements Iterator { private int cursor; private List&lt;String&gt; list; public ConcreteIterator(List&lt;String&gt; list) { this.list = list; this.cursor = -1; } @Override public String first() { return list.size() &gt; 0 ? list.get(cursor = 0) : null; } @Override public String next() { return list.get( cursor + 1 &lt; list.size() ? ++cursor : cursor ); } @Override public boolean hasNext() { return cursor+1 &lt; list.size(); } @Override public String currentItem() { return list.get(cursor); } } 具体迭代器中包含了一个游标，用于记录当前访问的位置。构造方法中将游标初始化为-1而不是初始化为0，这样第一次使用next时便会访问第一个元素。 2.6 客户端 public static void main(String[] args) { Aggregate aggregate = new ConcreteAggregate(); aggregate.add(&quot;111&quot;); aggregate.add(&quot;222&quot;); aggregate.add(&quot;jksdfjksdjkfk&quot;); aggregate.add(&quot;m,xcvm,xcm,v&quot;); Iterator iterator = aggregate.createIterator(); while(iterator.hasNext()) { System.out.println(iterator.next()); } } 客户端针对抽象聚合类以及抽象迭代器编程，通过聚合对象创建迭代器后，首先使用haxNext判断，接着使用next获取其中元素。 3 实例 设计一个系统对客户数据以及商品数据进行遍历，使用迭代器模式进行设计。 这个例子和上面的其实差不多，不过是反向迭代器方法，另外为了更贴近实际环境使用，抽象迭代器以及聚合类都使用了泛型设计： 抽象迭代器：Iterator&lt;T&gt; 抽象聚合类：AbstarctList&lt;T&gt; 具体聚合类：ObjectList&lt;T&gt; 具体迭代器：ObjectIterator&lt;T&gt; 模拟产品以及顾客类：Product+Customer 首先设计抽象迭代器： interface Iterator&lt;T&gt; { T next(); boolean hasNext(); String nextName() throws UnsupportedOperationException; boolean hasNextName() throws UnsupportedOperationException; void setProduct(); } nextName()以及hasNextName()方法是对Customer类型生效的，对于Product会抛出异常。setProduct()表示设置聚合元素的类型为Product。 接着是抽象聚合类的设计： interface AbstractList&lt;T&gt; { Iterator&lt;T&gt; iterator(); Iterator&lt;T&gt; reversedIterator(); void add(T s); } 添加了一个反向迭代器实现。 然后是具体聚合类的设计： class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt; { List&lt;T&gt; list = new ArrayList&lt;&gt;(); @Override public Iterator&lt;T&gt; iterator() { return new ObjectIterator&lt;T&gt;(list,false); } @Override public void add(T s) { list.add(s); } @Override public Iterator&lt;T&gt; reversedIterator() { return new ObjectIterator&lt;T&gt;(list,true); } } 内部还有一个List存储聚合元素，iterator返回正向迭代器，构造方法里面的布尔值表示是否为反向迭代器，reversedIterator表示返回一个单向迭代器，与正向的唯一不同就是传入具体迭代器的构造方法中的布尔值。true表示是反向迭代器，否则是正向。 最后是具体迭代器类： class ObjectIterator&lt;T&gt; implements Iterator&lt;T&gt; { private int cursor; private List&lt;T&gt; list; private boolean reversed; private boolean isProduct = false; public ObjectIterator(List&lt;T&gt; list,boolean reversed) { this.list = list; this.reversed = reversed; this.cursor = (reversed ? list.size() : -1); } @Override public void setProduct() { isProduct = true; } @Override public T next() { return list.get( reversed ? ( cursor - 1 &gt;= 0 ? --cursor : cursor ) : ( cursor + 1 &lt; list.size() ? ++cursor : cursor ) ); } @Override public boolean hasNext() { return reversed ? cursor-1 &gt;= 0 : cursor+1 &lt; list.size(); } @Override public String nextName() throws UnsupportedOperationException { if(isProduct) throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;); return ((Customer)next()).getName(); } @Override public boolean hasNextName() throws UnsupportedOperationException { if(isProduct) throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;); return hasNext(); } } 构造方法中初始化聚合元素以及一个布尔值reversed，表示是否为反向迭代器，游标根据reversed设置为-1或list.size()。对于next以及hasNext方法，都需要判断是否为反向迭代器，返回对应的结果。对于nextName以及hasNextName，由于这两个方法仅对Customer类生效，因此如果是Product类直接抛出异常。 其他： class Product { private String id; private int num; public Product(){} public Product(String id,int num) { this.id = id; this.num = num; } public String getId() { return this.id; } public int getNum() { return this.num; } @Override public String toString() { return &quot;商品id:&quot;+id+&quot;\\t商品数量:&quot;+num; } } class Customer { private String id; private String name; public Customer(String id,String name) { this.id = id; this.name = name; } public String getId() { return this.id; } public String getName() { return this.name; } @Override public String toString() { return &quot;顾客id:&quot;+id+&quot;\\t顾客名字:&quot;+name; } } 测试类： public static void main(String[] args) { Customer customer1 = new Customer(&quot;id1&quot;,&quot;name1&quot;); Customer customer2 = new Customer(&quot;id2&quot;,&quot;name2&quot;); Customer customer3 = new Customer(&quot;id3&quot;,&quot;name3&quot;); AbstractList&lt;Customer&gt; customerList = new ObjectList&lt;&gt;(); customerList.add(customer1); customerList.add(customer2); customerList.add(customer3); Iterator&lt;Customer&gt; customerIterator = customerList.iterator(); while(customerIterator.hasNext()) System.out.println(customerIterator.next()); customerIterator = customerList.reversedIterator(); while(customerIterator.hasNext()) System.out.println(customerIterator.next()); System.out.println(); customerIterator = customerList.iterator(); while(customerIterator.hasNextName()) System.out.println(customerIterator.nextName()); customerIterator = customerList.reversedIterator(); while(customerIterator.hasNextName()) System.out.println(customerIterator.nextName()); System.out.println(); Product product1 = new Product(&quot;product id 1&quot;,1); Product product2 = new Product(&quot;product id 2&quot;,2); Product product3 = new Product(&quot;product id 3&quot;,3); AbstractList&lt;Product&gt; productList = new ObjectList&lt;&gt;(); productList.add(product1); productList.add(product2); productList.add(product3); Iterator&lt;Product&gt; productIterator = productList.iterator(); while(productIterator.hasNext()) System.out.println(productIterator.next()); productIterator = productList.reversedIterator(); while(productIterator.hasNext()) System.out.println(productIterator.next()); System.out.println(); try { productIterator = productList.iterator(); productIterator.setProduct(); while(productIterator.hasNextName()) System.out.println(productIterator.nextName()); } catch(Exception e) { e.printStackTrace(); } } 首先创建了三个Customer，接着添加到customerList中，从customerList中的iterator获取正向迭代器以及从reversedIterator获取正向迭代器，两种遍历方式的迭代器可以使用同样的语句实现遍历： while(customerIterator.hasNext()) System.out.println(customerIterator.next()); 对于Product，由于hasNextName以及nextName声明了抛出异常，因此测试输出如下： 4 内部类实现 上面的例子可以看到在具体聚合类以及具体迭代器之间存在关联关系，具体迭代器需要维持一个对具体聚合对象（或里面的集合）的引用，除了使用关联关系外，还可以将迭代器设计为聚合类的内部类，比如JDK中的AbstractList： public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; { //... private class Itr implements Iterator&lt;E&gt; { //... } //... } 使用类似的方式重新设计上面的例子： class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt; { List&lt;T&gt; list = new ArrayList&lt;&gt;(); @Override public Iterator&lt;T&gt; iterator() { return new ObjectIterator(false); } @Override public void add(T s) { list.add(s); } @Override public Iterator&lt;T&gt; reversedIterator() { return new ObjectIterator(true); } private class ObjectIterator implements Iterator&lt;T&gt; { private int cursor; private boolean reversed; private boolean isProduct = false; public ObjectIterator(boolean reversed) { this.reversed = reversed; this.cursor = (reversed ? list.size() : -1); } //... } } 改变的就是具体迭代器的构造方法，不需要注入聚合对象了，另外也取消了泛型的声明。 5 JDK迭代器 5.1 Iterator JDK（OpenJDK11.0.2）中的Collection方法摘录如下： public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; { //... Iterator&lt;E&gt; iterator(); //... } 该方法用于返回一个迭代器，以便遍历聚合类中的元素，其中Iterator定于如下： public interface Iterator&lt;E&gt; { boolean hasNext(); E next(); default void remove() { //... } default void forEachRemaining(Consumer&lt;? super E&gt; action) { //... } } 其中： hasNext：用于判断聚合对象是否存在下一个元素，需要在调用next之前调用 next：将下标移至下一个元素，并返回游标所越过的那个元素的引用，也就是获取下一个元素 remove：删除上一次next的返回的元素 forEachRemaining：用于对剩余元素进行的操作，比如一个集合有10个元素，使用迭代器遍历了前5个，则使用该方法会遍历剩下的元素，也就是后5个 Java迭代器原理如图： 第一个next被调用时，迭代器游标由0号位置移到1号位置，也就是移动到元素1以及元素2之间，接着返回游标越过的元素，也就是元素1。下一次调用next时，游标继续移动，从1号位置移动到2号位置，并返回越过的元素，也就是元素2。对于remove来说，删除上一次next返回的元素，也就是如果此时调用remove会删除元素2。 也就是在调用remove之前至少需要调用一次next，如果不调用next的话，会抛出异常： 5.2 ListIterator JDK中的List接口除了继承Collection接口的iterator外，还增加一个listIterator，专门用于创建ListIterator类型的迭代器。用于遍历集合已经有了Iterator，但是这个迭代器只能用于正向遍历，而ListIterator的出现能解决逆向遍历的问题，因为其中提供了hasPrevious以及previous等方法。例子如下： public static void main(String[] args) { List&lt;String&gt; s = new ArrayList&lt;&gt;(); s.add(&quot;1111&quot;); s.add(&quot;2222&quot;); s.add(&quot;3333&quot;); ListIterator&lt;String&gt; it = s.listIterator(); while(it.hasNext()) System.out.println(it.next()); System.out.println(); while(it.hasPrevious()) System.out.println(it.previous()); } 实现完整的逆向遍历时，需要先将游标移动到末尾，也就是不断调用next直到末尾，才能实现调用previous进行逆向遍历。 6 主要优点 多种遍历方式：支持以不同方式遍历聚合对象，在同一聚合对象上可以定义多种遍历方法，只需要用一个不同的聚合器替换原来的迭代器即可改变遍历算法 简化聚合类：原有的聚合对象不需要再自行提供数据遍历方法 满足OCP：由于引入了抽象层，增加新的聚合类以及迭代器类都很方便，无须修改源码 7 主要缺点 复杂度增加：迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，增加了复杂性 抽象迭代器较难设计：考虑到以后的扩展，抽象迭代器的设计难度可能非常大，比如JDK的内置迭代器Iterator就无法实现逆向遍历，设计一个考虑全面的抽象迭代器并不是一件容易的事 8 适用场景 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据存储分离，使得访问聚合对象时无须了解内部实现细节 需要为一个聚合对象提供多种遍历方式 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/"},{"title":"设计模式学习笔记（十八）：解释器模式","content":" 1 概述 1.1 引言 1.2 相关术语 1.2.1 文法规则 1.2.2 BNF符号 1.2.3 终结符与非终结符 1.2.4 抽象语法树 1.3 定义 1.4 结构图 1.5 角色 2 典型实现 2.1 步骤 2.2 环境类 2.3 抽象表达式 2.4 终结符表达式 2.5 非终结符表达式 2.6 客户端 3 实例 4 扩展 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 解释器模式是一种使用频率较低但是学习难度较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。某些情况下可能需要自定义一个新语言，这种语言具有自己的文法规则，这时可以使用解释器模式进行设计，比如模拟机器人的控制程序，每一条指令对应一个动作，通过解释输入的指令来实现对机器人的控制。下面先来看一些术语定义。 1.2 相关术语 1.2.1 文法规则 文法规则是用于描述语言的语法的规则，比如，汉语中一个句子的文法规则为： 主 谓 宾 这就是句子的文法规则，同样计算机语言也有自己的文法规则。 1.2.2 BNF符号 BNF是Backus-Naur Form的缩写，是由John Backus以及Peter Naur首次引入的一种形式化符号来描述给定语言的语法，BNF中定义的部分符号如下： ::=：表示定义为，左边的语言单位可以通过右边进行说明和定义 |：表示或者 &quot;或'：双引号或单引号里面的字符串表示字符串本身 1.2.3 终结符与非终结符 在以下的模拟描述机器人移动的文法规则中： expression ::= direction action distance | composite //表达式 composite ::= expression 'and' expression //复合表达式 direction ::= 'up' | 'down' | 'left'| 'right' //移动方向 action ::= 'move' | 'run' //移动方式 distance ::= an integer //移动距离 定义了5条文法规则，对应5个语言单位，这些语言单位可以分为： 终结符（也叫终结符表达式）：语言的最小组成单位，不能再拆分，比如上面的direction或action 非终结符（也叫非终结符表达式）：一个完整的句子，包含一些列终结符或非终结符 1.2.4 抽象语法树 除了使用文法规则定义一个语言外，还能使用一种叫抽象语法树的直观方式表示，例如表达式： 1 / 2 * 3 - 4 + 1 可以通过如下抽象语法树定义： 在该抽象语法树中，可以通过终结符value以及非终结符operation组成复杂的语句，终结符作为抽象语法树的叶子，非终结符作为非叶子节点，可以将终结符或者包含终结符与非终结符的节点作为子节点。 1.3 定义 解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。 这里的语言指的是使用规定格式以及语法的代码。解释器模式是一种类行为型模式。 1.4 结构图 1.5 角色 AbstractExpression（抽象表达式）：声明了抽象的解释操作，是所有终结符表达式以及非终结符表达式的父类 TerminalExpression（终结符表达式）：抽象表达式的子类，实现了与文法规则中的终结符相关联的解释操作，句子中的每一个终结符都是该类的一个实例，通常只有少数几个终结符表达式类 NonterminalExpression（非终结符表达式）：也是抽象表达式的子类，实现了文法规则中非终结符的解释操作，由于非终结符表达式可以包含非终结符表达式以及终结符表达式，因此一般通过递归方式完成解释 Context（环境类）：用于存储解释器之外的一些全局信息，通常它临时存储需要解释的语句 2 典型实现 2.1 步骤 （可选）定义环境类：首先对环境类进行定义，使用集合存储相关的全局或公共信息，用于在具体解释时获取，如果无须全局信息则环境类可以省略 定义抽象表达式类：接口/抽象类，声明抽象解释操作 定义终结符表达式类：继承/实现抽象表达式，定义终结符的解释操作 定义非终结符表达式类：继承/实现抽象表达式，定义非终结符解释操作，一般通过递归处理 2.2 环境类 这里暂时不需要环境类，为了兼容定义一个空类： class Context{} 2.3 抽象表达式 包含抽象解释操作方法： interface AbstractExpression { void interpret(Context context); } 2.4 终结符表达式 解释终结符表达式： class TerminalExpression implements AbstractExpression { @Override public void interpret(Context context) { System.out.println(&quot;终结符解析&quot;); } } 2.5 非终结符表达式 class NonterminalExpression implements AbstractExpression { private AbstractExpression left; private AbstractExpression right; public NonterminalExpression(AbstractExpression left,AbstractExpression right) { this.left = left; this.right = right; } @Override public void interpret(Context context) { System.out.println(&quot;非终结符解析&quot;); if(left != null) left.interpret(context); if(right != null) right.interpret(context); } } 解释非终结符时一般需要递归处理，这里模拟了非终结符左右两边的表达式操作。 2.6 客户端 public static void main(String[] args) { AbstractExpression expression1 = new TerminalExpression(); AbstractExpression expression2 = new TerminalExpression(); AbstractExpression expression3 = new NonterminalExpression(expression1,expression2); expression3.interpret(null); } 定义两个终结符表达式与一个非终结符表达式，最后对非终结符表达式进行解释。 3 实例 对机器人移动指令进行解释，移动的语法表达如下：方向 方式 距离，方向包括上下左右四个方向，方式包括跑以及一般移动，距离为一个整数，一条移动指令可以组合多条子移动指令，使用解释器模式进行设计。 设计如下： 环境类：这里为空 抽象表达式类：AbstractNode 终结符表达式类：DirectionNode+ActionNode+DistanceNode 非终结符表达式类：AndNode+SentenceNode 抽象表达式类如下： interface AbstractNode { String interpret(String str); } 终结符表达式类： class DirectionNode implements AbstractNode { private static final Map&lt;String,String&gt; strs; static { strs = new HashMap&lt;&gt;(); strs.put(&quot;up&quot;, &quot;向上&quot;); strs.put(&quot;down&quot;, &quot;向下&quot;); strs.put(&quot;left&quot;, &quot;向左&quot;); strs.put(&quot;right&quot;, &quot;向右&quot;); } @Override public String interpret(String str) { return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;; } } class ActionNode implements AbstractNode { private static final Map&lt;String,String&gt; strs; static { strs = new HashMap&lt;&gt;(); strs.put(&quot;move&quot;, &quot;移动&quot;); strs.put(&quot;run&quot;, &quot;快速移动&quot;); } @Override public String interpret(String str) { return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;; } } class DistanceNode implements AbstractNode { @Override public String interpret(String str) { return str; } } 根据对应的字符串返回相应的字符串即可。 非终结符表达式类： class SentenceNode implements AbstractNode { private final AbstractNode direction = new DirectionNode(); private final AbstractNode action = new ActionNode(); private final AbstractNode distance = new DistanceNode(); @Override public String interpret(String s) { String [] str = s.split(&quot; &quot;); return direction.interpret(str[0])+action.interpret(str[1])+distance.interpret(str[2]); } } class AndNode implements AbstractNode { @Override public String interpret(String s) { if(s.contains(&quot;and&quot;)) { int index = s.indexOf(&quot;and&quot;); String leftStr = s.substring(0, index-1); String rightStr = s.substring(index+4); AbstractNode left = (leftStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode()); AbstractNode right = (rightStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode()); return left.interpret(leftStr) + &quot; 再 &quot; + right.interpret(rightStr); } return new SentenceNode().interpret(s); } } 其中AndNode采取了递归进行解释操作，如果分割后的字符串还含有and则赋值为AndNode，否则为SentenceNode。 测试： public static void main(String[] args) { AbstractNode node = new AndNode(); System.out.println(node.interpret(&quot;up move 5 and down run 10 and down move 10 and left run -9&quot;)); } 输出如下： 4 扩展 如果项目中需要对数据表达式进行分析与计算，可以直接使用现有的库，比如： Expression4J MESP Jep Fel 等等，下面以Jep为例演示该库的使用方法。Jep是Java expression parser的简称，即Java表达式分析器，它是一个用来转换和计算数学表达式的Java库，用户可以以字符串形式输入一个任意公式，然后快速计算出结果。Jep支持用户自定义变量，常量，函数，包括很多常用的数学函数以及常量。 首先下载JAR包依赖，例子如下： import com.singularsys.jep.*; public class Test { public static void main(String[] args) throws Exception { Jep jep=new Jep(); //定义要计算的数据表达式 String interestOnDeposit=&quot;本金*利率*时间&quot;; //给相关变量赋值 jep.addVariable(&quot;本金&quot;,10000); jep.addVariable(&quot;利率&quot;,0.038); jep.addVariable(&quot;时间&quot;,2); jep.parse(interestOnDeposit); //解析表达式 Object accrual=jep.evaluate(); //计算 System.out.println(&quot;存款利息：&quot;+accrual); } } 5 主要优点 扩展性好：由于解释器中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法 便于实现语言：每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言 实现文法容易：抽象语法树中每一个表达式节点类的实现方式都是类似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码 增加解释表达式方便：如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式，原有表达式类无须修改 6 主要缺点 复杂文法难以维护：在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则会导致类个数急增，导致系统难以管理和维护，可以考虑使用语法分析程序来取代解释器模式 执行效率低：由于解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时速度很慢，而且代码的调试过程也比较麻烦 7 适用场景 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来描述 一个语言的文法较为简单 执行效率不是关键问题 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/"},{"title":"设计模式学习笔记（十七）：命令模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象命令类 2.3 调用者 2.4 接收者 2.5 具体命令类 2.6 客户端 3 实例 4 命令队列 5 撤销与重做 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 日常生活中，可以通过开关控制一些电器的开启和关闭，比如电灯和排气扇。可以将开关理解成一个请求发送者，电灯是请求的最红接收者以及处理者，开关与电灯之间不存在直接的耦合关系，两者通过电线连接在一起，使不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）既可对应不同的接收者（电器）。 软件开发中经常需要向某些对象发送请求，但是并不知道具体的接收者是谁，也不知道被请求的操作是哪个，此时希望以一种松耦合的方式来设计软件，使得请求发送者与请求接收者之间能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作，此时可以使用命令模式进行设计。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 1.2 定义 命令模式：将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，别名为动作模式或者事务模式。 1.3 结构图 1.4 角色 Command（抽象命令类）：抽象命令类一般是一个抽象类或者接口，在其中声明了用于执行请求的execute()方法，通过这些方法可以调用请求接收者的相关操作 ConcreteCommand（具体命令类）：实现了抽象命令类中声明的方法，对应具体的接收者对象，将接收者对象的动作绑定其中，在实现execute()方法时，将调用接收者对象的相关操作 Invoker（调用者）：调用者即请求发送者，通过命令对象来执行请求。一个调用者并不需要设计时确定接收者，因此它只与抽象命令类之间存在关联关系。程序运行时将具体命令对象注入，并调用其中的execute()方法，从而实现间接调用请求接收者的相关操作 Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理 2 典型实现 2.1 步骤 定义抽象命令类：定义执行请求的方法 定义调用者：在调用方法里面包含对具体命令的调用，同时需要包含一个对抽象命令的引用 定义接收者：定义接收请求的业务方法 定义具体命令类：继承/实现抽象命令类，实现其中执行请求方法，转发到接收者的接收方法 2.2 抽象命令类 这里实现为一个接口： interface Command { void execute(); } 2.3 调用者 class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void call() { System.out.println(&quot;调用者操作&quot;); command.execute(); } } 调用者可以通过构造方法或者setter注入具体命令，对外提供一个调用方法call，当调用此方法时调用具体命令的execute。 2.4 接收者 class Receiver { public void action() { System.out.println(&quot;接收者操作&quot;); } } 这里的接收者只有一个action，表示接收方法。 2.5 具体命令类 class ConcreteCommand implements Command { private Receiver receiver = new Receiver(); @Override public void execute() { receiver.action(); } } 具体命令类中需要包含一个对接收者的引用，以便在execute中调用接收者。 2.6 客户端 public static void main(String[] args) { Invoker invoker = new Invoker(new ConcreteCommand()); invoker.call(); } 通过构造方法注入具体命令到调用者中，接着直接调用即可。 输出如下： 3 实例 自定义功能键的设置，对于一个按钮，可以根据需要由用户设置为最小化/最大化/关闭功能，使用命令模式进行设计。 设计如下： 抽象命令类：Command 调用者：Button 接收者：MinimizeHandler+MaximizeHandler+CloseHandler 具体命令类：MinimizeCommand+MaximizeCommand+CloseCommand 首先设计抽象命令类，实现为一个接口，仅包含execute方法： interface Command { void execute(); } 接着是调用者类，包含一个抽象命令的引用： class Button { private Command command; public Button(Command command) { this.command = command; } public void onClick() { System.out.println(&quot;按钮被点击&quot;); command.execute(); } } 然后是接收者类： class MinimizeHandler { public void handle() { System.out.println(&quot;最小化&quot;); } } class MaximizeHandler { public void handle() { System.out.println(&quot;最大化&quot;); } } class CloseHandler { public void handle() { System.out.println(&quot;关闭&quot;); } } 最后是具体命令类，对应包含一个接收者成员即可，实现其中的execute并转发到接收者的方法： class MinimizeCommand implements Command { private MinimizeHandler handler = new MinimizeHandler(); @Override public void execute() { handler.handle(); } } class MaximizeCommand implements Command { private MaximizeHandler handler = new MaximizeHandler(); @Override public void execute() { handler.handle(); } } class CloseCommand implements Command { private CloseHandler handler = new CloseHandler(); @Override public void execute() { handler.handle(); } } 测试类： public static void main(String[] args) { Button button = new Button(new MinimizeCommand()); button.onClick(); button = new Button(new MaximizeCommand()); button.onClick(); button = new Button(new CloseCommand()); button.onClick(); } 输出： 如果需要新增一个命令，只需要命令接收者以及实现了Command的具体命令类，客户端再将具体命令注入请求发送者（Button），无须直接操作请求接收者。 4 命令队列 有时候需要将多个请求排队，当一个请求发送者发送完成一个请求后，不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法完成对请求的处理。这种形式可以通过命令队列实现，实现命令队列很简单，一般是增加一个叫CommandQueue的类，由该类负责存储多个命令对象，不同的命令对象可以对应不同的请求接收者，比如在上面的例子中增加CommandQueue命令队列类： class CommandQueue { private ArrayList&lt;Command&gt; commands = new ArrayList&lt;&gt;(); public void add(Command command) { commands.add(command); } public void remove(Command command) { commands.remove(command); } public void execute() { System.out.println(&quot;批量执行命令&quot;); commands.forEach(Command::execute); } } 接着修改调用者类Button（只需将原来的Command改为CommandQueue）： class Button { private CommandQueue queue; public Button(CommandQueue queue) { this.queue = queue; } public void onClick() { System.out.println(&quot;按钮被点击&quot;); queue.execute(); } } 最后是客户端定义命令队列并作为参数传入调用者的构造方法或者setter中，最后由调用者执行方法： public static void main(String[] args) { CommandQueue queue = new CommandQueue(); queue.add(new MinimizeCommand()); queue.add(new MaximizeCommand()); queue.add(new CloseCommand()); Button button = new Button(queue); button.onClick(); } 输出如下： 5 撤销与重做 设计一个简易计算器，实现加法功能，还能够实现撤销以及重做功能，使用命令模式实现。 设计如下： 抽象命令类：Command 调用者：Calculator 接收者：Adder 具体命令类：AddCommand 首先先不实现撤销以及重做功能： public class Test { public static void main(String[] args) { Calculator calculator = new Calculator(new AddCommand()); calculator.add(3); calculator.add(9); } } interface Command { int execute(int value); } class Calculator { private Command command; public Calculator(Command command) { this.command = command; } public void add(int value) { System.out.println(command.execute(value)); } } class Adder { private int num = 0; public int add(int value) { return num += value; } } class AddCommand implements Command { private Adder adder = new Adder(); @Override public int execute(int value) { return adder.add(value); } } 代码与上面的实例类似，就不解释了。 这里关键的问题是如何实现撤销以及重做功能，撤销能够恢复到进行加法之前的状态，而重做能恢复到进行了加法之后的状态，而且这是有固定顺序的，因此可以联想到数组，使用下标表示当前状态，下标左移表示撤销，下标右移表示重做： 使用一个状态数组存储每次进行加法的状态，用下标表示当前状态，当撤销时，使下标左移，当重做时，使下标右移。 首先需要修改抽象命令类，添加撤销以及重做方法： interface Command { int execute(int value); int undo(); int redo(); } 接着修改调用者类，添加撤销以及重做方法： class Calculator { private Command command; public Calculator(Command command) { this.command = command; } public void add(int value) { System.out.println(command.execute(value)); } public void undo() { System.out.println(command.undo()); } public void redo() { System.out.println(command.redo()); } } 核心的实现位于接收者类Adder，使用了List&lt;Integer&gt;存储了状态，index表示下标，在撤销或重做之前首先判断下标位置是否合法，合法则进行下一步操作： class Adder { private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); private int index = 0; public Adder() { nums.add(0); } public int add(int value) { int result = nums.get(index)+value; nums.add(result); ++index; return result; } public int redo() { if(index + 1 &lt; nums.size()) return nums.get(++index); return nums.get(index); } public int undo() { if(index - 1 &gt;= 0) return nums.get(--index); return nums.get(index); } } 最后具体命令类简单添加撤销以及重做方法即可： class AddCommand implements Command { private Adder adder = new Adder(); @Override public int execute(int value) { return adder.add(value); } @Override public int undo() { return adder.undo(); } @Override public int redo() { return adder.redo(); } } 测试： public static void main(String[] args) { Calculator calculator = new Calculator(new AddCommand()); calculator.add(3); calculator.add(9); calculator.undo(); calculator.undo(); calculator.undo(); calculator.undo(); calculator.redo(); calculator.redo(); calculator.redo(); calculator.redo(); } 6 主要优点 降低耦合度：由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求可以对应不同的接收者，同样相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性 满足OCP：新的命令可以很容易添加到系统中，由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，满足OCP的要求 撤销+中作：为请求的撤销以及重做提供了一种设计和实现方案 7 主要缺点 过多具体命令类：使用命令模式可能会导致系统有过多的具体命令类，因为针对每一个请求接收者的调用操作都需要设计一个具体工具类，因此在某些系统中可能需要提供大量的具体命令类 8 适用场景 系统需要将请求调用者和请求接受者解耦，使得调用者和接收者不直接交互，请求调用者无须知道接收者的存在，也无需知道接收者是谁，接收者也无须关心何时被调用 系统需要在不同时间指定请求，将请求排队和执行请求 系统需要支持撤销以及恢复操作 系统需要将一组操作组合一起形成宏命令，使用命令队列实现 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/"},{"title":"每日分享 第44期","content":" 每日鸡汤 现在的时代不是属于00后，是属于厚脸皮的！ 每日冷知识 据估计，野生动物贩卖每年市值约100亿美元，是仅次于毒品和武器的第三大最有价值的非法贸易。其中鸟类是最为常见的违禁品，每年走私的野生鸟类有200万到500万只。 每日诗词 白发渔樵江渚上，惯看秋月春风。 ——杨慎《临江仙·滚滚长江东逝水》 每日一句 每一个人都应该明确自己的方向和位置。 每日音乐 尽头-赵方婧 觥筹交错 时光如梭 迷失自我 享受折磨 这是你要的 物质生活 一身污浊 自得其乐 谁的命运 谁又能把握 这是种孤独 没有结果 精神虚伪的寄托 不择手段的 迷离恍惚的假想 推翻不假思索 如果换作是我 又是何得的 变作无趣的枷锁 肉体诚实的反驳 不合时宜的 消散太快的热度 假装不食烟火 不由分说的我 换个身份变作 有趣的恶魔 觥筹交错 时光如梭 迷失自我 享受折磨 这是你要的 物质生活 一身污浊 自得其乐 谁的命运 谁又能把握 这是种孤独 没有结果 精神虚伪的寄托 不择手段的 迷离恍惚的假想 推翻不假思索 如果换作是我 又是何得的 变作无趣的枷锁 肉体诚实的反驳 不合时宜的 消散太快的热度 假装不食烟火 不由分说的我 换个身份变作 有趣的恶魔 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/"},{"title":"每日分享 第43期","content":" 每日鸡汤 无毒的身躯抗下有毒的疫苗，你是教育我从小就要坚强！ 每日冷知识 现代手术之父威廉·斯图尔特·霍尔斯特博士通过向自己注射可卡因开创了使用麻醉药的先例。他最终对可卡因成瘾，之后是吗啡，但即便如此，他始终都在促进医学培训现代化。 每日诗词 金陵风景好，豪事集新亭。 ——李白《金陵新亭》 每日一句 即便你忘记了我，我也不回遗忘你。 每日音乐 明知做戏-吴雨霏 等你的汽水喝一半给你加片薄冰 等你的桌面满些我总会打理重整 不想纯情 不够聪明 你未发现我的身影 得我帮你依照编码整理家里电影 只会得我一个帮你选购喜爱铃声 天天如常 估你心情 等一个眼神求证 一闪擦过如流星 怎么我为我做过的感到惊怕 就像爱吗我也不肯定恐怕 我以为存在吗 千变万化 从来不肯开口可相信吗 离谱吗 请你不要阻我喜欢你 明明是爱但你未说话扮作闪避 这个沉默冷静的你毫无办法处理 其实我亦怕是错摸心理 总有天会等到好天气 游行示爱大叫着你在某大片草地 等你无用退避不过仍然害羞的你 还是顾忌太不争气 明知做戏 即使你未在意不感到惊讶 现在要说爱你请准备招架 勇气还存在吗 不要害怕 随时真的胆敢亲手送花 离谱吗 请你不要阻我喜欢你 明明是爱但你未说话扮作闪避 这个沉默冷静的你毫无办法处理 其实我亦怕是错摸心理 总有天会等到好天气 游行示爱大叫着你在某大片草地 等你无用退避不过仍然害羞的你 还是顾忌太不争气 明知做戏 不过不要阻我紧张你 如令你不愉快让我办妥为你准备 喜爱沉默冷静的你还是自信的你 仍愿意为你造一些惊喜 总有天会等到好天气 游行示爱大叫着你在某大片草地 等你无用退避不过途人目光不理 期待贴着你的手臂 无须做戏 等你喜爱等你不爱就凭摘毫验证 想爱不爱偏爱不理亦同样难划清 天天如常 估你心情 不想扑索来求证 争取过趁还年轻 终于你下定决定来答应 太动听 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-43-qi/"},{"title":"设计模式学习笔记（十六）：职责链模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象处理者 2.3 具体处理者 2.4 客户端 3 实例 4 分类 4.1 纯的职责链模式 4.2 不纯的职责链模式 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 很多情况下，一个软件系统中可以处理某个请求的对象不知一个，比如采购单的审批，主任，副董事长，董事长，董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就叫职责链。 职责链可以是一条直线，一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行处理，客户端无须关系请求的处理细节以及具体的传递，只需要将请求发送到链上即可，实现请求发送者以及请求处理者的解耦。 1.2 定义 职责链模式：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 职责链模式是一种行为型模式。 1.3 结构图 1.4 角色 Handler（抽象处理者）：定义一个处理请求的接口，一般为抽象类。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者的对象作为对下一个处理者的引用，通过该引用，处理者可以连成一条链 ConcreteHandler（具体处理者）：抽象处理者的子类，实现具体处理方法，在处理前需要判断是否具有处理权限，如果拥有权限则处理，没有则转发到下一个处理者 2 典型实现 2.1 步骤 定义抽象处理者：定义处理请求接口以及定义一个抽象处理者成员，作为下一个处理者的引用，一般为了让具体处理者方便调用，定义为protected 定义具体处理者：处理/转发请求，处理请求前先判断是否具有权限 ，拥有则处理请求，否则转发请求 客户端创建职责链：职责链模式并不创建职责链，职责链交由客户端创建，根据实际需要定义职责链顺序 2.2 抽象处理者 abstract class Handler { protected Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void handleRequest(int num); } 拥有一个设置下一处理者的对象，可以通过setter注入，同时声明抽象处理方法。 2.3 具体处理者 class ConcreteHandler1 extends Handler { @Override public void handleRequest(int num) { if(num &lt; 10) { System.out.println(&quot;处理小于10的数字:&quot;+num); } else successor.handleRequest(num); } } class ConcreteHandler2 extends Handler { @Override public void handleRequest(int num) { if(num &lt; 20) { System.out.println(&quot;处理大于等于10且小于20的数字:&quot;+num); } else successor.handleRequest(num); } } class ConcreteHandler3 extends Handler { @Override public void handleRequest(int num) { if(num &lt; 30) { System.out.println(&quot;处理大于等于20且小于30的数字:&quot;+num); } else successor.handleRequest(num); } } 继承抽象处理者，首先判断是否拥有权限处理（这里是一个简单的if判断），如果有就处理，没有的话通过protected对象，也就是转发给下一个处理者处理。 2.4 客户端 public static void main(String[] args) { Handler handler = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); handler.setSuccessor(handler2); handler2.setSuccessor(handler3); handler.handleRequest(3); handler.handleRequest(15); handler.handleRequest(22); } 客户端针对抽象处理者编程，需要创建每一个具体处理者对象，并且自定义职责链： handler.setSuccessor(handler2); handler2.setSuccessor(handler3); 接着调用对应的处理者处理即可。 3 实例 设计一个采购单审批系统，分级进行，根据金额不同由不同层次的人员审批，主任可以审批5w以下的采购单，副董事长可以审批5w-10w，董事长可以审批10w-50w，50w以上需要由董事会审批，使用职责链模式设计该系统。 设计如下： 抽象处理者：Approver 具体处理者：Director+VicePresident+President+Congress 采购单请求类：PurchaseRequest 代码如下： //抽象处理者 abstract class Approver { protected Approver successor; public void setSuccessor(Approver successor) { this.successor = successor; } public abstract void processRequest(PurchaseRequest request); } //具体处理者:主任 class Director extends Approver { @Override public void processRequest(PurchaseRequest request) { if(request.getAmount() &lt; 50000) System.out.println(&quot;主任审批一笔\\n金额为&quot;+request.getAmount()+&quot;\\nid为&quot;+request.getId()+&quot;\\n的采购单\\n&quot;); else successor.processRequest(request); } } //具体处理者:副董事长 class VicePresident extends Approver { @Override public void processRequest(PurchaseRequest request) { if(request.getAmount() &lt; 100000) System.out.println(&quot;副董事长审批一笔\\n金额为&quot;+request.getAmount()+&quot;\\nid为&quot;+request.getId()+&quot;\\n的采购单\\n&quot;); else successor.processRequest(request); } } //具体处理者:董事长 class President extends Approver { @Override public void processRequest(PurchaseRequest request) { if(request.getAmount() &lt; 500000) System.out.println(&quot;董事长审批一笔\\n金额为&quot;+request.getAmount()+&quot;\\nid为&quot;+request.getId()+&quot;\\n的采购单\\n&quot;); else successor.processRequest(request); } } //具体处理者:董事会 class Congress extends Approver { @Override public void processRequest(PurchaseRequest request) { System.out.println(&quot;董事会审批一笔\\n金额为&quot;+request.getAmount()+&quot;\\nid为&quot;+request.getId()+&quot;\\n的采购单\\n&quot;); } } //请求类:采购单 class PurchaseRequest { private double amount; private String id; private static final String STR = &quot;xcnvj232cvm&quot;; private static final Random random = new Random(); public PurchaseRequest(double amount) { this.amount = amount; //简易的随机字符串 this.id = STR.substring(0,random.nextInt(STR.length()-1)+1).repeat(random.nextInt(3)+2); } public double getAmount() { return this.amount; } public void setAmount(double amount) { this.amount = amount; } public String getId() { return this.id; } public void setId(String id) { this.id = id; } } 测试： public static void main(String[] args) { Approver director = new Director(); Approver vicePresident = new VicePresident(); Approver president = new President(); Approver congress = new Congress(); director.setSuccessor(vicePresident); vicePresident.setSuccessor(president); president.setSuccessor(congress); director.processRequest(new PurchaseRequest(12345)); director.processRequest(new PurchaseRequest(54321)); director.processRequest(new PurchaseRequest(123456)); director.processRequest(new PurchaseRequest(654321)); } 输出如下： 4 分类 职责链模式可以分为纯的职责链模式与不纯的职责链模式。 4.1 纯的职责链模式 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个，要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。 而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象接收，不能出现某个请求未被任何一个处理者对象处理的情况，比如前面的采购单例子。 4.2 不纯的职责链模式 在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其猴戏处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。 在Java AWT 1.0中的事件处理模型应用就是不纯的职责链模式，基本原理如下：由于窗口组件一般位于容器组件中，当事件发生在窗口组件上时，先通过组件对象的handleEvent()方法传递给相应的事件处理方法，该事件处理方法将处理该事件，然后决定是否将该事件向上一级容器组件传播，上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，直到顶层容器组件为止。如果一直都没有处理方法则不处理该事件。 这种事件处理机制又叫事件浮升机制，JDK1.1后使用观察者模式来代理职责链模式处理事件。 5 主要优点 降低耦合：职责链模式使得一个对象无须知道是其他哪一个对象处理请求，对象仅需知道请求会被处理即可，接收者和发送者都没有对方明确信息，且链中对象不需要知道链的结构，由客户端负责链的创建，降低了系统耦合度 简化对象连接：请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有候选处理者的引用，可简化对象的相互连接 灵活的职责链：可以在运行时对链进行动态增加或者修改 符合OCP：系统增加一个新的具体处理者时无须修改源码，只需要客户端重建职责链，符合OCP 6 主要缺点 请求可能得不到处理：由于一个请求没有明确的接收者，因此请求不一定会被处理，也有可能因为职责链配置错误而得不到处理 性能受到影响：对于较长的职责链，请求的处理可能涉及多个处理对象，系统性能会受到一定影响，而且代码调试时可能不方便 死循环：如果职责链不当，可能会导致死循环调用 7 适用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的 在不明确指定接收者的情况下，向多个对象的一个提交一个请求 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理请求以及处理者之间的先后次序 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-liu-zhi-ze-lian-mo-shi/"},{"title":"设计模式学习笔记（十五）：代理模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 1.5 分类 1.6 与装饰模式的不同 2 典型实现 2.1 步骤 2.2 抽象主题角色 2.3 真实主题角色 2.4 代理主题角色 2.5 客户端 3 实例 4 动态与静态代理 4.1 静态代理 4.2 动态代理 4.2.1 Proxy 4.2.2 InvocationHandler 4.2.3 实例 5 远程代理 5.1 概述 5.2 RMI简例 6 虚拟代理 6.1 概述 6.2 适用情况 6.3 优缺点 6.4 简例 7 缓存代理 7.1 抽象主题角色 7.2 真实主题角色 7.3 代理主题角色 7.4 其他 7.5 测试 8 主要优点 9 主要缺点 10 适用场景 11 总结 1 概述 1.1 引言 所谓代购，就是找人帮忙购买自己需要的商品，代购包括两种类型，一种是在当地买不到商品，或者因为当地该商品价格较高，因此托人在其他地区或者国外购买，另一种类型是消费者对想要购买的商品消息缺乏，只能委托中介或者中间商购买。 在软件开发中，有时也需要提供与代购类似的功能，由于某些原因，客户端不想或不能直接访问对象，此时可通过一种叫代理的第三者来实现间接访问，这种方案对应的设计模式称为代理模式。 代理模式是一种应用很广泛的结构型设计模式，而且变化很多。在代理模式中引入了一个新的代理对象，代理对象可以在客户端对象和目标对象之间起到中介的作用，去掉客户不能看到的内容或者增添客户需要的额外服务。 1.2 定义 代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式是一种对象结构型模式。 1.3 结构图 1.4 角色 Subject（抽象主题角色）：声明了真实主题和代理主题的共同接口，客户端通常需要针对抽象主题角色编程 Proxy（代理主题角色）：内部包含了对真实主题的引用，从而可以操作真实主题对象。代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理角色还可以控制对真实主题的使用，在需要的时候创建或删除真实主题对象，并对真实主题的使用加以约束。通常在代理主题角色中，客户端调用之前或之后都需要执行特定操作，比如图中的preRequest以及postRequest RealSubject（真实主题角色）：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理角色间接调用真实主题角色中的操作 1.5 分类 代理模式根据目的以及实现方式可以分成很多类，常见的几种如下： 远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以不在同一台主机中。远程代理又叫“大使”（Ambassador） 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建 保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓存代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理：当一个对象被引用时，提供一些额外的操作，比如将对象被调用的次数记录下来等 1.6 与装饰模式的不同 代理模式和装饰模式在实现时类似，主要区别如下： 增加的职责范围问题域不同：代理模式以及装饰模式都能动态地增加职责，但是代理模式增加的是一些全新的职责，比如权限控制，缓存处理，智能引用，远程访问等，这些职责与原有职责不属于同一个问题域。对于装饰模式，为具体构件类增加一些相关的职责，是原有职责的扩展，这些职责属于同一个问题域 目的不同：代理模式的目的是控制对对象的访问，而装饰模式是为对象动态增加功能 2 典型实现 2.1 步骤 定义抽象主题角色：定义为抽象类/接口，声明抽象业务方法 定义真实主题角色：继承/实现抽象主题角色，实现真实业务操作 定义代理主题角色：继承/实现抽象主题角色，将客户端的请求转发到真实主题角色进行调用，同时根据需要进行调用前/后的一些相关操作 2.2 抽象主题角色 这里简单实现为一个接口： interface Subject { void request(); } 2.3 真实主题角色 实现抽象主题接口，执行真正的业务操作： class RealSubject implements Subject { public void request() { System.out.println(&quot;真实主题角色方法&quot;); } } 2.4 代理主题角色 同样实现抽象主题接口，一般来说在调用真正的业务方法之前或之后会有相关操作： class Proxy implements Subject { private RealSubject subject = new RealSubject(); public void pre() { System.out.println(&quot;代理前操作&quot;); } public void request() { pre(); subject.request(); post(); } public void post() { System.out.println(&quot;代理后操作&quot;); } } 2.5 客户端 客户端针对抽象主题角色进行编程即可，如果不需要代理，则实例化真实主题角色，如果需要代理则实例化代理主题角色： public static void main(String[] args) { Subject subject = new RealSubject(); subject.request(); System.out.println(&quot;\\n使用代理:\\n&quot;); subject = new Proxy(); subject.request(); } 3 实例 一个已具有搜索功能的系统，需要为搜索添加身份认证以及日志记录功能，使用代理模式设计该系统。 设计如下： 抽象主题角色：Searcher 真实主题角色：RealSearcher 代理主题角色：ProxySearcher 代码如下： public class Test { public static void main(String[] args) { Searcher subject = new ProxySearcher(); subject.search(); } } interface Searcher { void search(); } class RealSearcher implements Searcher { public void search() { System.out.println(&quot;搜索&quot;); } } class ProxySearcher implements Searcher { private RealSearcher subject = new RealSearcher(); public void validate() { System.out.println(&quot;身份验证&quot;); } public void search() { validate(); subject.search(); log(); } public void log() { System.out.println(&quot;日志记录,查询次数+1&quot;); } } 进行搜索之前，先验证用户，接着进行搜索，搜索完成后进行日志记录，这是保护代理以及智能引用代理的例子。 4 动态与静态代理 4.1 静态代理 通常情况下，每一个代理类编译之后都会生成一个字节码文件，代理所实现的接口和所代理的方法都固定，这种代理称为静态代理。 静态代理中，客户端通过Proxy调用RealSubject的request方法，同时封装其他方法（代理前/代理后操作），比如上面的查询验证以及日志记录功能。 静态代理的优点是实现简单，但是，代理类以及真实主题类都需要事先存在，代理类的接口以及代理方法都明确指定，但是如果需要： 代理不同的真实主题类 代理一个真实主题类的不同方法 需要增加新的代理类，这会导致系统中类的个数大大增加。 这是静态代理最大的缺点，为了减少系统中类的个数，可以采用动态代理。 4.2 动态代理 动态代理可以让系统根据实际需要动态创建代理类，同一个代理类可以代理多个不同的真实主题类，而且可以代理不同方法，在Java中实现动态代理需要Proxy类以及InvocationHandler接口。 4.2.1 Proxy Proxy类提供了用于创建动态代理类和实例对象的方法，最常用的方法包括： public static Class&lt;?&gt; getProxy(ClassLoader loader,Class&lt;?&gt; ... interfaces)：该方法返回一个Class类型的代理类，在参数中需要提供类加载器并指定代理的接口数组，这个数组应该与真实主题类的接口列表一致 public staitc Object newProxyInstance(ClassLoader loader,Class&lt;?&gt; [] interfaces,InvocationHandler h)：返回一个动态创建的代理类实例，第一个参数是类加载器，第二个参数表示代理类实现的接口列表，同理与真实主题的接口列表一致，第三个参数表示h所指派的调用处理程序类 4.2.2 InvocationHandler InvocationHandler接口是代理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用者（也就是实现了InvocationHandler的类），该接口中声明以下方法： public Object invoke(Object proxy,Method method,Object [] args)：该方法用于处理对代理类实例的方法调用并返回相应结果，当一个代理实例中的业务方法被调用时自动调用该方法。第一个参数表示代理类的实例，第二个参数表示需要代理的方法，第三个参数表示方法的参数数组 动态代理类需要在运行时指定所代理的真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会自动转发到InvocationHandler的invoke方法，由invoke实现对请求的统一处理。 4.2.3 实例 为一个数据访问Dao层增加方法调用日志，记录每一个方法被调用的时间和结果，使用动态代理模式进行设计。 设计如下： 抽象主题角色：AbstractUserDao 真实主题角色：UserDao1+UserDao2 请求处理角色：DAOLogHandler 代理主题角色：无需手动定义，由Proxy.newInstance()生成 首先设计抽象主题角色： interface AbstarctUserDao { void findUserById(String id); } 接着创建两个具体类实现该接口： class UserDao1 implements AbstarctUserDao { public void findUserById(String id) { System.out.println(&quot;1号数据库中查找id&quot; + (&quot;1&quot;.equals(id) ? &quot;成功&quot; : &quot;失败&quot;)); } } class UserDao2 implements AbstarctUserDao { public void findUserById(String id) { System.out.println(&quot;2号数据库中查找id&quot; + (&quot;2&quot;.equals(id) ? &quot;成功&quot; : &quot;失败&quot;)); } } 接着定义请求处理角色： class DAOLogHandler implements InvocationHandler { private Object object; public DAOLogHandler(Object object) { this.object = object; } @Override public Object invoke(Object proxy,Method method,Object [] args) throws Throwable { beforeInvoke(); Object result = method.invoke(object, args); postInvoke(); return result; } private void beforeInvoke() { System.out.println(&quot;记录时间&quot;); } private void postInvoke() { System.out.println(&quot;记录结果&quot;); } } 核心是实现了InvocationHandler的invoke方法，该方法在调用抽象主题角色中的方法时自动转发到该方法处理。 也就是说，假设抽象主题角色有A(),B(),C()三个方法，当调用A()时，将调用A()替换掉里面的Object result = method.invoke(object.args)，也就是实际上相当调用如下函数： @Override public Object invoke(Object proxy,Method method,Object [] args) throws Throwable { beforeInvoke(); Object result = A(args); postInvoke(); return result; } 当调用B()时，相当于调用以下函数： @Override public Object invoke(Object proxy,Method method,Object [] args) throws Throwable { beforeInvoke(); Object result = B(args); postInvoke(); return result; } 下面是测试客户端的代码： public static void main(String[] args) { AbstarctUserDao userDao1 = new UserDao1(); AbstarctUserDao proxy = null; InvocationHandler handler = new DAOLogHandler(userDao1); proxy = AbstarctUserDao.class.cast( Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(), new Class[]{AbstarctUserDao.class}, handler) ); proxy.findUserById(&quot;2&quot;); AbstarctUserDao userDao2 = new UserDao2(); handler = new DAOLogHandler(userDao2); proxy = AbstarctUserDao.class.cast( Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(),new Class[]{AbstarctUserDao.class},handler) ); proxy.findUserById(&quot;2&quot;); } 输出如下： 在测试代码中，代理主题角色由以下语句生成： proxy = AbstarctUserDao.class.cast( Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(), new Class[]{AbstarctUserDao.class}, handler) ); 其中cast()方法相当于是对强制类型转换进行了包装，转换前进行了安全检查。 在Proxy.newInstance()中，第一个参数是抽象主题角色的类加载器，第二个参数表示抽象主题角色的所有方法都转发请求到第三个参数中的invoke方法处理。第三个参数是自定义的InvocationHandler，通过构造方法注入抽象主题角色，目的是提供一个抽象主题角色的引用，调用代理方法时自动调用抽象主题角色的方法。 5 远程代理 5.1 概述 远程代理是一种常见的代理模式，使得客户端程序可以访问在远程主机（或另一个JVM）上的对象，远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是本地的而不是远程的，远程代理对象承担了大部分的网络通信工作，并负责对远程业务的方法调用。 远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端而言是透明的。客户端无须关心实现的具体业务是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。 在Java中可以通过RMI(Remote Method Invocation,远程方法调用)机制来实现远程代理，它能够实现一个JVM中的对象调用另一个JVM中的对象，下面看一个简单的例子。 5.2 RMI简例 这个简单的例子有以下四个类： 接口：Hello 接口实现类：HelloImpl 服务端：HelloServer 客户端：HelloClient 代码如下： interface Hello extends Remote { String sayHello(String name) throws RemoteException; } 一个简单的sayHello方法，注意里面的方法需要声明为抛出RemoteException。 接着是接口实现类： public class HelloImpl extends UnicastRemoteObject implements Hello{ public HelloImpl() throws RemoteException { super(); } public String sayHello(String name) throws RemoteException { System.out.println(&quot;Hello&quot;); return &quot;Hello&quot;+name; } } 实现sayHello方法。 接下来是服务端： public class HelloServer { public static void main(String[] args) { try { Hello hello = new HelloImpl(); LocateRegistry.createRegistry(8888); System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;127.0.0.1&quot;); Naming.bind(&quot;rmi://localhost:8888/hello&quot;, hello); System.out.println(&quot;远程绑定对象成功&quot;); } catch (Exception e) { e.printStackTrace(); } } } 服务端中首先注册了一个本地端口8888，接着设置系统属性rmi服务的主机名为本地地址，也就是127.0.0.1，如果是部署在服务器上修改对应ip即可。下一步是通过Naming的静态方法bind绑定该URL到RMI服务器上，并命名为hello。其中rmi:（RMI协议）可以省略。 最后是客户端： public class HelloClient { public static void main(String[] args) { try { Hello hello = Hello.class.cast( Naming.lookup(&quot;rmi://127.0.0.1:8888/hello&quot;) ); System.out.println(hello.sayHello(&quot;111&quot;)); } catch(Exception e) { e.printStackTrace(); } } } 客户端通过Naming的lookup查找参数URL中对应的远程服务对象hello，找到后返回并强制转换为Hello，接着即可调用远程对象的方法sayHello。 首先运行服务端： 接着启动客户端： 可以看到来自服务端的结果。 再查看服务端： 可以看到这是调用了sayHello的结果。 6 虚拟代理 6.1 概述 对于一直占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮 演真实对象的替身，当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 6.2 适用情况 以下两种情况可以考虑使用虚拟代理： 由于对象本身复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象 当一个对象的加载十分消耗系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用到它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象 6.3 优缺点 优点：由于应用程序启动时由于不需要创建和装载所有的对象，因此加速了应用程序的启动 缺点：不能保证特定的应用程序对象被创建，在访问这个对象的任何地方都需要提前进行判空操作 6.4 简例 有一批人找老板谈事情，谈事情之前需要先通过老板的助手进行预约，预约这件事只需要助手完成，真正执行预约列表里面的任务时才需要老板出现，使用虚拟代理模式进行设计。 设计如下： 抽象主题角色：Approvable 真实主题角色：Boss 代理主题角色：Assistant 代码如下： //抽象主题角色 interface Approvable { void approve(); } 下一步定义真实主题角色Boss： class Boss implements Approvable { private List&lt;String&gt; orders = new LinkedList&lt;&gt;(); static { System.out.println(&quot;\\n老板来处理了\\n&quot;); } public Boss(List&lt;String&gt; orders) { this.orders = orders; } public void addOrder(String order) { orders.add(order); } @Override public void approve() { while(orders.size() &gt; 0) { System.out.println(&quot;老板处理了&lt;&quot;+orders.remove(0)+&quot;&gt;&quot;); } } } 使用List存储待处理的事件，approve表示处理所有的事件。 代理主题角色如下： class Assistant implements Approvable { private List&lt;String&gt; orders = new LinkedList&lt;&gt;(); private volatile Boss boss; public void addOrder(String order) { if(boss != null) { System.out.println(&quot;老板将&lt;&quot;+order+&quot;&gt;添加到预约列表&quot;); boss.addOrder(order); } else { System.out.println(&quot;助手将&lt;&quot;+order+&quot;&gt;添加到预约列表&quot;); orders.add(order); } } @Override public void approve() { if(boss == null) { synchronized(this) { if(boss == null) { boss = new Boss(orders); } } } boss.approve(); } } 在添加事件（addOrder）函数中，首先判断boss是否为null，如果为null表示还没创建老板对象，这时让助手添加到预约列表中去，如果不为null表示已经存在老板对象，直接交由老板加入预约列表。 对于approve方法，首先判断boss是否为null，不为null表示老板能直接处理所有事件。为null表示老板对象还没有创建，新建一个Boss并将待处理的事件作为参数注入boss中。 测试类： public static void main(String[] args) { Assistant assistant = new Assistant(); assistant.addOrder(&quot;找老板面试&quot;); assistant.addOrder(&quot;找老板借钱&quot;); assistant.addOrder(&quot;找老板聊天&quot;); assistant.approve(); assistant.addOrder(&quot;找老板吃饭&quot;); assistant.addOrder(&quot;找老板喝酒&quot;); assistant.approve(); } 输出如下： 7 缓存代理 缓存代理为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果，在这里使用缓存代理模式模拟YouTube对使用集成的第三方库下载进行缓存。 设计如下： 模拟第三方库：ThirdPartyYouTubeLib+ThirdPartyYouTubeClass 模拟视频文件：Video 模拟缓存代理：YouTubeCacheProxy 模拟下载器：YouTubeDownloader 首先是第三方类库，通常情况下是没有源码实现的，其中ThirdPartyYouTubeLib是一个接口，并且ThirdPartyYouTubeClass以及YouTubeCacheProxy实现了它，也就是说： ThirdPartyYouTubeLib是抽象主题角色 ThirdPartyYouTubeClass是真实主题角色 YouTubeCacheProxy是代理主题角色 7.1 抽象主题角色 首先定义抽象主题角色： interface ThirdPartyYouTubeLib { HashMap&lt;String,Video&gt; popularVideos(); Video getVideo(String videoId); } 一个是获取热门视频的方法，一个是根据id获取具体视频的方法。 7.2 真实主题角色 class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib { private static final String URL = &quot;https://www.youtube.com&quot;; @Override public HashMap&lt;String,Video&gt; popularVideos() { connectToServer(URL); return getRandomVideos(); } @Override public Video getVideo(String id) { connectToServer(URL+id); return getSomeVideo(id); } private int random(int min,int max) { return min+(int)(Math.random()*((max-min)+1)); } private void experienceNetworkLatency() { int randomLatency = random(5, 10); for(int i=0;i&lt;randomLatency;++i) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } } } private void connectToServer(String url) { System.out.println(&quot;连接到 &quot; + url + &quot; ...&quot;); experienceNetworkLatency(); System.out.println(&quot;连接成功!\\n&quot;); } private HashMap&lt;String,Video&gt; getRandomVideos() { System.out.println(&quot;正在下载热门视频&quot;); experienceNetworkLatency(); HashMap&lt;String,Video&gt; map = new HashMap&lt;&gt;(); map.put(&quot;1111111&quot;,new Video(&quot;1111&quot;,&quot;1111.mp4&quot;)); map.put(&quot;2222222&quot;,new Video(&quot;2222&quot;,&quot;2222.avi&quot;)); map.put(&quot;3333333&quot;,new Video(&quot;3333&quot;,&quot;3333.mov&quot;)); map.put(&quot;4444444&quot;,new Video(&quot;4444&quot;,&quot;4444.mkv&quot;)); System.out.println(&quot;下载完成!\\n&quot;); return map; } private Video getSomeVideo(String id) { System.out.println(&quot;正在下载id为&quot;+id+&quot;的视频&quot;); experienceNetworkLatency(); System.out.println(&quot;下载完成!\\n&quot;); return new Video(id,&quot;title&quot;); } } 获取热门视频或者某一个视频时，进行了一个模拟连接到服务器的操作，首先输出提示连接到xxx，接着模拟了网络延迟，最后提示下载完成并返回相应的视频。 7.3 代理主题角色 class YouTubeCacheProxy implements ThirdPartyYouTubeLib { private ThirdPartyYouTubeLib youtubeService = new ThirdPartyYouTubeClass(); private HashMap&lt;String,Video&gt; cachePopular = new HashMap&lt;&gt;(); private HashMap&lt;String,Video&gt; cacheAll = new HashMap&lt;&gt;(); @Override public HashMap&lt;String,Video&gt; popularVideos() { if(cachePopular.isEmpty()) { cachePopular = youtubeService.popularVideos(); } else { System.out.println(&quot;从缓存检索中热门视频&quot;); } return cachePopular; } @Override public Video getVideo(String id) { Video video = cacheAll.get(id); if(video == null) { video = youtubeService.getVideo(id); cacheAll.put(id,video); } else { System.out.println(&quot;从缓存中检索id为&quot;+id+&quot;的视频&quot;); } return video; } public void reset() { cachePopular.clear(); cacheAll.clear(); } } 这里的缓存代理角色其实就是在调用真实主题角色的获取视频方法之前，首先判断是否存在缓存，存在的话直接从缓存中获取，不存在的话首先调用获取视频方法并存储在缓存中，下次获取时从缓存中获取。 7.4 其他 class Video { private String id; private String title; private String data; public Video(String id,String title) { this.id = id; this.title = title; } //getter+setter... } class YouTubeDownloader { private ThirdPartyYouTubeLib api; public YouTubeDownloader(ThirdPartyYouTubeLib api) { this.api = api; } public boolean useCacheProxy() { return api instanceof YouTubeCacheProxy; } public void renderVideoPage(String id) { Video video = api.getVideo(id); System.out.println(&quot;\\n-------------------------------------------&quot;); System.out.println(&quot;ID:&quot;+video.getId()); System.out.println(&quot;标题:&quot;+video.getTitle()); System.out.println(&quot;数据:&quot;+video.getData()); System.out.println(&quot;\\n-------------------------------------------&quot;); } public void renderPopularVideos() { HashMap&lt;String,Video&gt; list = api.popularVideos(); System.out.println(&quot;\\n-------------------------------------------&quot;); System.out.println(&quot;热门视频&quot;); list.forEach((k,v)-&gt;System.out.println(&quot;ID:&quot;+v.getId()+&quot;\\t标题:&quot;+v.getTitle())); System.out.println(&quot;\\n-------------------------------------------&quot;); } } 7.5 测试 public class Test { public static void main(String[] args) { YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass()); YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy()); long navie = test(naiveDownloader); long smart = test(smartDownloader); System.out.println(&quot;缓存代理节约的时间:&quot;+(navie-smart)+&quot;ms&quot;); } private static long test(YouTubeDownloader downloader) { long startTime = System.currentTimeMillis(); downloader.renderPopularVideos(); downloader.renderVideoPage(&quot;1111&quot;); downloader.renderPopularVideos(); downloader.renderVideoPage(&quot;2222&quot;); downloader.renderVideoPage(&quot;3333&quot;); downloader.renderVideoPage(&quot;4444&quot;); long estimatedTime = System.currentTimeMillis() - startTime; System.out.println(downloader.useCacheProxy() ? &quot;使用缓存运行时间:&quot; : &quot;不使用缓存运行时间:&quot;); System.out.println(estimatedTime+&quot;ms\\n&quot;); return estimatedTime; } } 模拟了两个下载器，一个使用原生下载，一个使用缓存代理下载，输出如下： 连接到 https://www.youtube.com ... 连接成功! 正在下载热门视频 下载完成! ------------------------------------------- 热门视频 ID:4444 标题:4444.mkv ID:2222 标题:2222.avi ID:3333 标题:3333.mov ID:1111 标题:1111.mp4 ------------------------------------------- 连接到 https://www.youtube.com1111 ... 连接成功! 正在下载id为1111的视频 下载完成! ------------------------------------------- ID:1111 标题:title 数据:null ------------------------------------------- 连接到 https://www.youtube.com ... 连接成功! 正在下载热门视频 下载完成! ------------------------------------------- 热门视频 ID:4444 标题:4444.mkv ID:2222 标题:2222.avi ID:3333 标题:3333.mov ID:1111 标题:1111.mp4 ------------------------------------------- 连接到 https://www.youtube.com2222 ... 连接成功! 正在下载id为2222的视频 下载完成! ------------------------------------------- ID:2222 标题:title 数据:null ------------------------------------------- 连接到 https://www.youtube.com3333 ... 连接成功! 正在下载id为3333的视频 下载完成! ------------------------------------------- ID:3333 标题:title 数据:null ------------------------------------------- 连接到 https://www.youtube.com4444 ... 连接成功! 正在下载id为4444的视频 下载完成! ------------------------------------------- ID:4444 标题:title 数据:null ------------------------------------------- 不使用缓存运行时间: 9312ms 连接到 https://www.youtube.com ... 连接成功! 正在下载热门视频 下载完成! ------------------------------------------- 热门视频 ID:4444 标题:4444.mkv ID:2222 标题:2222.avi ID:3333 标题:3333.mov ID:1111 标题:1111.mp4 ------------------------------------------- 连接到 https://www.youtube.com1111 ... 连接成功! 正在下载id为1111的视频 下载完成! ------------------------------------------- ID:1111 标题:title 数据:null ------------------------------------------- 从缓存检索中热门视频 ------------------------------------------- 热门视频 ID:4444 标题:4444.mkv ID:2222 标题:2222.avi ID:3333 标题:3333.mov ID:1111 标题:1111.mp4 ------------------------------------------- 连接到 https://www.youtube.com2222 ... 连接成功! 正在下载id为2222的视频 下载完成! ------------------------------------------- ID:2222 标题:title 数据:null ------------------------------------------- 连接到 https://www.youtube.com3333 ... 连接成功! 正在下载id为3333的视频 下载完成! ------------------------------------------- ID:3333 标题:title 数据:null ------------------------------------------- 连接到 https://www.youtube.com4444 ... 连接成功! 正在下载id为4444的视频 下载完成! ------------------------------------------- ID:4444 标题:title 数据:null ------------------------------------------- 使用缓存运行时间: 7611ms 缓存代理节约的时间:1701ms 可以看到缓存代理是能节省时间的，除了第一次获取视频外，随后的获取视频都是从缓存中直接提取。 8 主要优点 降低耦合度：代理模式能够协调调用者以及被调用者，一定程度上降低了系统的耦合度 灵活可扩展：客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源码，符合OCP，系统具有较好的灵活性和可扩展性 提高整体效率（远程代理）：远程代理为位于两个不同的地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统整体运行效率 节约开销（虚拟代理）：虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 控制权限（保护代理）：保护代理可以控制一个对象的访问权限，为不同用户提供不同级别的使用权限 9 主要缺点 速度变慢：由于在客户端以及真实主题之间增加了代理对象，因此可能会造成处理速度变慢，比如保护代理 实现复杂：实现代理模式需要额外的操作，有些代理模式其实很复杂，比如远程代理 10 适用场景 客户端需要访问远程主机中的对象，使用远程代理 需要一个消耗资源较少的对象来代表资源较多的对象时，使用虚拟代理 需要控制访问权限，使用保护代理 需要为一个频繁访问的操作结果提供临时存储空间，使用缓存代理 需要为一个对象的访问（引用）提供额外的操作时，使用智能引用代理 11 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-wu-dai-li-mo-shi/"},{"title":"每日分享 第42期","content":" 每日鸡汤 我是一条酸菜鱼，又酸又菜，还多余。 每日冷知识 《吉尼斯世界纪录》这本书持有在公共图书馆内最经常被盗的书这一记录。 每日诗词 一番荷芰生池沼，槛前风送馨香。 ——尹鹗《临江仙·一番荷芰生池沼》 每日一句 世间本无公平可言，除非公平掌握在自己手中。 每日音乐 坏女孩-徐良/小凌 I miss you Now don't you love me Sorry I'm so sorry 那时我放开了你的手 转过身只剩了保重 你话都没说却哭了很久很久 我喜欢坏坏的女友 我喜欢刺激的感受 你单纯太过多余了那些温柔 你消失在无名大街 从此就没有再见面 好长的时间再没有你的来电 在后来酒吧的房间 舞池里跳动着音乐 熟悉的侧脸喂 迷人的笑脸吸引视线 慵懒的靠在陌生的肩 黑色的眼线你的指间 有一点轻蔑 在谁的怀中会有感觉 被爱的深夜我在想念 明明是为你才会改变 却回不到从前 那时我放开了你的手 转过身只剩了保重 你话都没说却哭了很久很久 我喜欢坏坏的女友 我喜欢刺激的感受 你单纯太过多余了那些温柔 你消失在无名大街 从此就没有再见面 好长的时间再没有你的来电 在后来酒吧的房间 舞池里跳动着音乐 熟悉的侧脸喂 迷人的笑脸吸引视线 慵懒的靠在陌生的肩 黑色的眼线你的指间 有一点轻蔑 在谁的怀中会有感觉 被爱的深夜我在想念 明明是为你才会改变 却回不到从前 然后我安静的发现 两个人已经没有任何语言 曾经你纯真的永远 让我不顾一切开始怀念 迷人的笑脸吸引视线 慵懒的靠在陌生的肩 黑色的眼线你的指间 有一点轻蔑 在谁的怀中会有感觉 被爱的深夜我在想念 明明是为你才会改变 却回不到从前 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-42-qi/"},{"title":"每日分享 第41期","content":" 每日鸡汤 为什么你能智障一样活着，而我却不可以。 每日冷知识 螳螂虾（皮皮虾）挥动爪子的速度极好，甚至可以令周围的水沸腾并制造一道闪光。 每日诗词 休言女子非英物，夜夜龙泉壁上鸣。 ——秋瑾《鹧鸪天·祖国沉沦感不禁》 每日一句 我今天就要带她走，我看谁敢拦我！ 每日音乐 不分手的恋爱-汪苏泷 不知不觉不问 不痛不痒 多少的时光 不确定的某个 夜晚小巷 泪悄悄流淌 街边天气微凉 淡淡月光 我沿路哼唱 找寻我们一直 找不到的 缘分被捆绑 感觉不到你为我坚强 感觉得到你对我说谎 我安静听着肖邦 用维也纳忧伤 你的爱被埋葬 恨被收藏 痛应该原谅 我的爱不用讲 恨不用想 思念在发烫 看着你的脸庞 背着行囊 说要去远方 谁还记得那年我拉着你说 爱永远一样 我也搞不懂为什么那么多人真心相爱 到最后都会变成两个人分开的无奈 当初我们说过要谈一场永远不分手的恋爱 是否今天这句话竟变成我们之间的阻碍 不想太多 不想太多 也许会明白的更多 不想再说 不想再说 就让我们彼此沉默 现在我们终于明白 结局却也无法更改 这场不分手的恋爱 我想结局注定失败 不知不觉不问 不痛不痒 多少的时光 不确定的某个 夜晚小巷 泪悄悄流淌 街边天气微凉 淡淡月光 我沿路哼唱 找寻我们一直 找不到的 缘分被捆绑 感觉不到你为我坚强 感觉得到你多我说谎 我安静听着肖邦 用维也纳忧伤 你的爱被埋葬 恨被收藏 痛应该原谅 我的爱不用讲 恨不用想 思念在发烫 看着你的脸庞 背着行囊 说要去远方 谁还记得那年我拉着你说 爱永远一样 你的爱被埋葬 恨被收藏 痛应该原谅 我的爱不用讲 恨不用想 思念在发烫 看着你的脸庞 背着行囊 说要去远方 谁还记得那年我拉着你说 爱永远一样 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-41-qi/"},{"title":"设计模式学习笔记（六）：抽象工厂模式","content":" 1 概述 1.1 引言 1.1.1 产品等级结构 1.1.2 产品族 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象产品 2.3 具体产品 2.4 抽象工厂 2.5 具体工厂 2.6 客户端 3 实例 4 有关OCP 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 在了解抽象工厂模式之前，首先来了解一下两个术语： 产品等级结构 产品族 1.1.1 产品等级结构 产品等级结构也就是产品的继承结构，例如一个抽象类是电视机，子类有不同品牌的电视机，比如海尔电视机，海信电视机，TCL电视机，而抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是子类。 1.1.2 产品族 产品族是指由一个同一个工厂产生的位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机，海尔电冰箱。海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机与海尔电冰箱共同构成了一个产品族。 两者示意图如下： 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式是针对一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。 每一个具体工厂可以生产属于一个产品族的所有产品，所生产的产品又位于不同的产品等级结构中，在上图的例子中，如果使用工厂方法模式需要12个具体工厂类，而使用抽象工厂模式只需要4个工厂类，大大减少了系统中类的个数。 1.2 定义 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 抽象工厂模式又叫Kit模式，是一种对象创建型模式。 1.3 结构图 1.4 角色 AbstractFactory（抽象工厂）：声明了一组用于创建一族产品的方法，每一个方法对应一种产品 ConcreteFactory（具体工厂）：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品的等级结构中 AbstractProduct（抽象产品）：为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法 ConcreteProduct（具体产品）：定义具体工厂生产的具体对象，实现在抽象层产品接口中声明的业务方法 2 典型实现 2.1 步骤 确定产品等级结构：也就是定义抽象产品，抽象产品的数量就是产品等级结构的数量，为抽象产品声明产品所具有的业务方法 确定产品族：也就是定义具体产品，对于每个抽象产品，有多少个子类就有多少个产品族，具体产品类实现或继承抽象产品，实现其中的业务方法 定义抽象工厂：定义为接口/抽象类，声明创建一族产品的方法，根据产品等级结构数量确定方法数量 定义具体工厂：实现/继承抽象工厂，实现其中的业务方法 2.2 抽象产品 这里简单定义两个抽象产品接口，也就是假设有两个产品等级结构（A与B）： interface ProductA { void methodA(); } interface ProductB { void methodB(); } 2.3 具体产品 声明四个具体产品，假设每种产品由分别两个工厂生产，也就是假设有两个产品族： class ProductA1 implements ProductA { public void methodA() { System.out.println(&quot;Product A1&quot;); } } class ProductA2 implements ProductA { public void methodA() { System.out.println(&quot;Product A2&quot;); } } class ProductB1 implements ProductB { public void methodB() { System.out.println(&quot;Product B1&quot;); } } class ProductB2 implements ProductB { public void methodB() { System.out.println(&quot;Product B2&quot;); } } 2.4 抽象工厂 由于只有两个产品等级结构（A与B），这里的抽象工厂只需要两个方法，分别表示生产这两种产品： interface Factory { ProductA getProductA(); ProductB getProductB(); } 2.5 具体工厂 由于上面已经假设为两个产品族，因此这里需要两个具体工厂： //产品族Factory1 class Factory1 implements Factory { public ProductA getProductA() { return new ProductA1(); } public ProductB getProductB() { return new ProductB1(); } } //产品族Factory2 class Factory2 implements Factory { public ProductA getProductA() { return new ProductA2(); } public ProductB getProductB() { return new ProductB2(); } } 2.6 客户端 public static void main(String[] args) { Factory factory = new Factory1(); ProductA productA = factory.getProductA(); ProductB productB = factory.getProductB(); productA.methodA(); productB.methodB(); factory = new Factory2(); productA = factory.getProductA(); productB = factory.getProductB(); productA.methodA(); productB.methodB(); } 客户端针对抽象工厂以及抽象产品编程，只需要知道工厂类名即可获取同一工厂（同一产品族）不同产品等级结构的产品。 3 实例 界面皮肤库设计：开发一套皮肤库，用户可以通过菜单选择皮肤，不同的皮肤提供视觉不同的按钮，文本框等UI元素，使用抽象工厂模式进行设计。 这里简单起见假设开发两套皮肤： 春季皮肤（SpringSkin） 夏季皮肤（SummerSkin） 每套皮肤具有以下UI元素： 按钮（Button） 文本框（TextField） 组合框（ComboBox） 具体设计如下： 抽象产品：Button+TextField+ComboBox 具体产品：SpringButton+SummerButton+SpringTextField+SummerTextField+SpringComboBox+SummerComboBox 抽象工厂：SkinFactory 具体工厂：SpringSkinFactory+SummerSkinFactory 先设计产品类： //抽象产品 interface Button { void display(); } //具体产品 class SpringButton implements Button { public void display() { System.out.println(&quot;春季皮肤按钮&quot;); } } //具体产品 class SummerButton implements Button { public void display() { System.out.println(&quot;夏季皮肤按钮&quot;); } } //抽象产品 interface TextField { void display(); } //具体产品 class SpringTextField implements TextField { public void display() { System.out.println(&quot;春季皮肤文本框&quot;); } } //具体产品 class SummerTextField implements TextField { public void display() { System.out.println(&quot;夏季皮肤文本框&quot;); } } //抽象产品 interface ComboBox { void display(); } //具体产品 class SpringComboBox implements ComboBox { public void display() { System.out.println(&quot;春季皮肤组合框&quot;); } } //具体产品 class SummerComboBox implements ComboBox { public void display() { System.out.println(&quot;夏季皮肤组合框&quot;); } } 接着是工厂类： //抽象工厂 interface SkinFactory { Button createButton(); TextField createTextField(); ComboBox createComboBox(); } //具体工厂 class SpringSkinFactory implements SkinFactory { public Button createButton() { return new SpringButton(); } public TextField createTextField() { return new SpringTextField(); } public ComboBox createComboBox() { return new SpringComboBox(); } } //具体工厂 class SummerSkinFactory implements SkinFactory { public Button createButton() { return new SummerButton(); } public TextField createTextField() { return new SummerTextField(); } public ComboBox createComboBox() { return new SummerComboBox(); } } 测试： public class Test { public static void main(String[] args) { SkinFactory factory = new SpringSkinFactory(); factory.createButton().display(); factory.createTextField().display(); factory.createComboBox().display(); factory = new SummerSkinFactory(); factory.createButton().display(); factory.createTextField().display(); factory.createComboBox().display(); } } 4 有关OCP 虽然使用抽象工厂模式增加新的皮肤界面非常方便，但是如果增加一个UI元素，会修改大量的代码，需要修改抽象工厂以及每一个具体工厂类，也就是说，不能够在符合OCP（开放闭合原则）的前提下增加新的组件。 这是抽象工厂模式的最大缺点，尽管增加新的产品族（这里是皮肤）非常方便，但是增加新的产品等级结构（这里是UI元素）很麻烦。抽象工厂模式的这种性质叫做开闭原则的倾斜性。因此设计人员在设计之初需要全面考虑，否则新增产品结构会导致大量的代码修改。 5 主要优点 隔离：抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离更换一个具体工厂类变得很相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为 同一产品族对象：当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加产品族容易：增加新的产品族容易，无须修改已有系统，符合OCP 6 主要缺点 主要缺点是增加新的产品等级结构麻烦，需要对系统进行大量的修改，违背了OCP。 7 适用场景 一个系统不当应依赖与产品类实例如何被创建，组合和表达细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建以及使用解耦 系统中有多于一个的产品族，而每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一皮肤下的按钮以及文本框，按钮与文本框没有直接联系，但是都属于同一皮肤 产品等级结构稳定，设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-liu-chou-xiang-gong-han-mo-shi/"},{"title":"设计模式学习笔记（五）：工厂方法模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象产品 2.3 具体产品 2.4 抽象工厂 2.5 具体工厂 2.6 客户端 3 实例 4 隐藏 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 尽管简单工厂模式实现了对象的创建和使用分离，但是仍然存在以下两个问题： 工厂类过于庞大，包含了大量的判断代码，导致维护和测试难度增大 系统扩展不灵活，如果增加了新的产品类型，必须修改静态工厂方法的业务逻辑，违反了开闭原则 具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性 一个更好的办法是使用工厂方法模式。 1.2 定义 工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 工厂方法又简称工厂模式或虚拟构造器模式或多态工厂模式，让一个类的实例化延迟到其子类，是一种类创建型模式。 1.3 结构图 1.4 角色 Product（抽象产品）：定义产品的接口，是工厂方法模式所创建的超类型，也就是产品对象的公共父类 ConcreteProduct（具体产品）：实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂与具体产品一一对应 Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例 2 典型实现 2.1 步骤 定义抽象产品：定义为接口/抽象类，是所有具体产品的父类 定义具体产品：实现/继承抽象产品，一个类对应与一个具体产品 定义抽象工厂：定义为接口/抽象类，声明工厂方法，但不需要实现，在运行时确定具体工厂 定义具体工厂：实现/继承抽象工厂，实现其中的工厂方法 2.2 抽象产品 这里定义为接口： interface Product { void method(); } 2.3 具体产品 两个示例具体产品： class ConcreteProductA implements Product { public void method() { System.out.println(&quot;Concrete Product A&quot;); } } class ConcreteProductB implements Product { public void method() { System.out.println(&quot;Concrete Product B&quot;); } } 2.4 抽象工厂 这里定义为接口： interface Factory { Product get(); } 抽象工厂中声明了工厂方法但没有实现，交由子类具体工厂负责。 2.5 具体工厂 class ConcreteFactoryA implements Factory { public Product get() { return new ConcreteProductA(); } } class ConcreteFactoryB implements Factory { public Product get() { return new ConcreteProductB(); } } 一个具体产品对应一个具体工厂，每一个具体工厂返回不同的具体产品。 2.6 客户端 客户端针对抽象产品以及抽象工厂进行编程，无需知道具体产品的类名，只需要知道具体产品对应的工厂，即可获取具体产品： Factory factory = new ConcreteFactoryA(); Product product = factory.get(); product.method(); factory = new ConcreteFactoryB(); product = factory.get(); product.method(); 3 实例 日志记录器的设计：该记录器可以通过多种途径保存系统的运行日志，例如文件记录或者数据库记录，使用工厂方法模式进行设计。 设计如下： 抽象产品：Logger 具体产品：DatabaseLogger+FileLogger 抽象工厂：LoggerFactory 具体工厂：DatabaseLoggerFactory+FileLoggerFactory 代码如下： public class Test { public static void main(String[] args) { LoggerFactory factory = new FileLoggerFactory(); Logger logger = factory.createLogger(); logger.log(); } } //抽象产品 interface Logger { void log(); } //具体产品:DatabaseLogger class DatabaseLogger implements Logger { public void log() { System.out.println(&quot;数据库日志记录&quot;); } } //具体产品:FileLogger class FileLogger implements Logger { public void log() { System.out.println(&quot;文件日志记录&quot;); } } //抽象工厂 interface LoggerFactory { Logger createLogger(); } //具体工厂:DatabaseLoggerFactory class DatabaseLoggerFactory implements LoggerFactory { public Logger createLogger() { return new DatabaseLogger(); } } //具体工厂:FileLoggerFactory class FileLoggerFactory implements LoggerFactory { public Logger createLogger() { return new FileLogger(); } } 4 隐藏 可以把抽象工厂设置为抽象类，工厂方法直接可以对客户端隐藏，也就是说可以直接通过抽象工厂调用具体产品类的业务方法，客户端无需创建具体产品，直接通过工厂类调用即可，代码修改如下（抽象产品以及具体产品类不用修改）： //抽象工厂 abstract class LoggerFactory { public void log() { this.createLogger().log(); } public abstract Logger createLogger(); } //具体工厂:DatabaseLoggerFactory class DatabaseLoggerFactory extends LoggerFactory { public Logger createLogger() { return new DatabaseLogger(); } } //具体工厂:FileLoggerFactory class FileLoggerFactory extends LoggerFactory { public Logger createLogger() { return new FileLogger(); } } public class Test { public static void main(String[] args) { LoggerFactory factory = new FileLoggerFactory(); factory.log(); } } 5 主要优点 封装细节：工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名 多态：工厂方法的多态性能够让工厂可以自主确定创建何种产品对象，而如何创建对象的细节则完全封装在具体工厂内部 扩展性好：加入新产品时无须修改抽象工厂，抽象产品的接口，也无须修改客户端与其他的具体产品和具体工厂，只需要增加一个具体工厂以及具体产品，系统扩展性很好，完全符合开闭原则 6 主要缺点 类数量多：在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度，有更多的类需要编译和运行，给系统带来额外开销 增加理解难度：基于系统的扩展性需要引入抽象层，在客户端中均使用了抽象层的定义，增加了系统的抽象性以及理解难度 7 适用场景 客户端不知道其所需要的对象的类：在工厂方法模式中，客户端不需要知道具体的产品类名，只需要知道所对应的工厂即可 抽象工厂类通过子类来指定创建哪个对象：工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而有其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更加容易扩展 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi/"},{"title":"每日分享 第40期","content":" 每日鸡汤 成长就是将你哭声调成静音的过程。 每日冷知识 希腊火厮守拜占庭人在7世纪研发出的一种燃烧武器，并且不透水。这种武器被用于船舰之间的战斗以及手持式发射管，其操作类似于火焰喷射器。其精确的化学成分是一个只有极少数人知道的秘密，并且已经被淹没在了历史长河中。 每日诗词 残月出门时，美人和泪醉。 ——韦庄《菩萨蛮·红楼别夜惆怅》 每日一句 问君能有几多愁？恰似一部新番没看头。 每日音乐 恋人心-魏新雨 化作风 化作雨 化作春 走向你 梦如声 梦如影 梦是遥远的掌印 化作烟 化作泥 化作云 飘向你 思如海 恋如城 思念最遥不可及 你问西湖水 偷走她的几分美 时光一去不再 信誓旦旦留给谁 你问长江水 淘尽心酸的滋味 剩半颗恋人心唤不回 化作诗 化作笔 化作灯 写着你 默念着 轻叹着 那些深沉的字句 化作路 化作怪 化作情 找寻你 爱一次 梦一场 思念最遥遥无期 你问西湖水 偷走她的几分美 时光一去不再 信誓旦旦留给谁 你问长江水 淘尽心酸的滋味 剩半颗 恋人心 唤不回 你问西湖水 偷走她的几分美 时光一去不再 信誓旦旦留给谁 你问长江水 淘尽心酸的滋味 剩半颗恋人心唤不回 剩半颗恋人心唤不回 剩半颗恋人心唤不回 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-40-qi/"},{"title":"设计模式学习笔记（十四）：享元模式","content":" 1 概述 1.1 引言 1.2 内部状态与外部状态 1.3 定义 1.4 结构图 1.5 角色 2 典型实现 2.1 步骤 2.2 抽象享元类 2.3 具体享元类 2.4 非共享具体享元类 2.5 享元工厂类 2.6 客户端 2.7 反射简化 3 实例 4 加入外部状态 5 单纯享元模式与复合享元模式 5.1 单纯享元模式 5.2 复合享元模式 6 补充说明 7 主要优点 8 主要缺点 9 适用场景 10 总结 1 概述 1.1 引言 当一个系统中运行时的产生的对象太多，会带来性能下降等问题，比如一个文本字符串存在大量重复字符，如果每一个字符都用一个单独的对象表示，将会占用较多内存空间。 那么该如何避免出现大量相同或相似的对象，同时又不影响客户端以面向对象的方式操作呢？ 享元模式正为解决这一问题而生，通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对 应，但是物理上却共享一个享元对象。 在享元模式中，存储共享实例的地方称为享元池，可以针对每一个不同的字符创建一个享元对象，放置于享元池中，需要时取 出，示意图如下： 1.2 内部状态与外部状态 享元模式以共享的方式高效地支持大量细粒度对象的重用，能做到共享的关键是区分了内部状态以及外部状态。 内部状态：存储在享元对象内部并且不会随环境改变而改变，内部状态可以共享，例如字符的内容，字符a永远是字符a，不会变为字符b 外部状态：能够随环境改变而改变，不可以共享的状态，通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。外部状态之间通常是相互独立的，比如字符的颜色，字号，字体等，可以独立变化，没有影响，客户端在使用时将外部状态注入到享元对象中 正因为区分了内部状态以及外部状态，可以将具有相同内部状态的对象存储在享元池中，享元池的对象是可以实现共享的，需要的时候从中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象实际上只存储一份。 1.3 定义 享元模式：运用共享技术有效地支持大量细粒度对象的复用。 系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此又叫轻量级模式，是一种对象结构型模式。 1.4 结构图 享元模式一般结合工厂模式一起使用，结构图如下： 1.5 角色 Flyweights（抽象享元类）：通常是一个接口或者抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态） ConcreteFlyweight（具体享元类）：实现/继承抽象共享类，实例称为共享对象，在具体享元类中为内部状态提供了存储空间，通常可以结合单例模式来设计具体享元类 UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非具体享元对象时可以直接实例化创建 FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，针对抽象享元类编程，将具体享元对象存储于享元池中。一般使用键值对集合（比如Java中的HashMap）作为享元池，当客户端获取享元对象时，首先判断是否存在，存在则从集合中取出并返回，不存在则创建新具体享元的实例，存储于享元池中并返回新实例 2 典型实现 2.1 步骤 定义抽象享元类：将抽象享元类定义为接口或者抽象类，声明业务方法 定义具体享元类：继承或实现抽象享元，实现其中的业务方法，同时使用单例模式设计，确保每个具体享元类提供唯一的享元对象 （可选）定义非共享具体享元类：继承或实现抽象享元类，不使用单例模式设计，每次客户端获取都会返回一个新实例 定义享元工厂类：通常使用一个键值对集合作为享元池，根据键值返回对应的具体享元对象或非共享具体享元对象 2.2 抽象享元类 这里使用接口实现，包含一个opeartion业务方法： interface Flyweight { void operation(String extrinsicState); } 2.3 具体享元类 简单设计两个枚举单例的具体享元类： enum ConcreteFlyweight1 implements Flyweight { INSTANCE(&quot;INTRINSIC STATE 1&quot;); private String intrinsicState; private ConcreteFlyweight1(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void operation(String extrinsicState) { System.out.println(&quot;具体享元操作&quot;); System.out.println(&quot;内部状态:&quot;+intrinsicState); System.out.println(&quot;外部状态:&quot;+extrinsicState); } } enum ConcreteFlyweight2 implements Flyweight { INSTANCE(&quot;INTRINSIC STATE 2&quot;); private String intrinsicState; private ConcreteFlyweight2(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void operation(String extrinsicState) { System.out.println(&quot;具体享元操作&quot;); System.out.println(&quot;内部状态:&quot;+intrinsicState); System.out.println(&quot;外部状态:&quot;+extrinsicState); } } 2.4 非共享具体享元类 两个简单的非共享具体享元类，不是枚举单例类： class UnsharedConcreteFlyweight1 implements Flyweight { @Override public void operation(String extrinsicState) { System.out.println(&quot;非共享具体享元操作&quot;); System.out.println(&quot;外部状态:&quot;+extrinsicState); } } class UnsharedConcreteFlyweight2 implements Flyweight { @Override public void operation(String extrinsicState) { System.out.println(&quot;非共享具体享元操作&quot;); System.out.println(&quot;外部状态:&quot;+extrinsicState); } } 2.5 享元工厂类 为了方便客户端以及工厂管理具体享元以及非共享具体享元，首先建立两个枚举类作为享元池的键： enum Key { KEY1,KEY2 } enum UnsharedKey { KEY1,KEY2 } 这里的工厂类使用了枚举单例： enum Factory { INSTANCE; private Map&lt;Key,Flyweight&gt; map = new HashMap&lt;&gt;(); public Flyweight get(Key key) { if(map.containsKey(key)) return map.get(key); switch(key) { case KEY1: map.put(key, ConcreteFlyweight1.INSTANCE); return ConcreteFlyweight1.INSTANCE; case KEY2: map.put(key, ConcreteFlyweight2.INSTANCE); return ConcreteFlyweight2.INSTANCE; default: return null; } } public Flyweight get(UnsharedKey key) { switch(key) { case KEY1: return new UnsharedConcreteFlyweight1(); case KEY2: return new UnsharedConcreteFlyweight2(); default: return null; } } } 使用HashMap&lt;String,Flyweight&gt;作为享元池： 对于具体享元类，根据键值判断享元池中是否存在具体享元对象，如果存在直接返回，如果不存在把具体享元的单例存入享元池，并返回该单例 对于非共享具体享元类，由于是“非共享”，不需要把实例对象存储于享元池中，每次调用直接返回新实例 2.6 客户端 客户端针对抽象享元进行编程，首先获取享元工厂单例，接着利用工厂方法，传入对应的枚举参数获取对应的具体享元或者非共享具体享元： public static void main(String[] args) { Factory factory = Factory.INSTANCE; Flyweight flyweight1 = factory.get(Key.KEY1); Flyweight flyweight2 = factory.get(Key.KEY1); System.out.println(flyweight1 == flyweight2); flyweight1 = factory.get(UnsharedKey.KEY1); flyweight2 = factory.get(UnsharedKey.KEY1); System.out.println(flyweight1 == flyweight2); } 2.7 反射简化 如果具体享元对象变多，工厂类的get()中的switch会变得很长，这时候可以将键值类以及工厂类的get()改进以简化代码，例如在上面的基础上又增加了两个具体享元类： enum ConcreteFlyweight3 implements Flyweight {...} enum ConcreteFlyweight4 implements Flyweight {...} 这样工厂类的switch需要增加两个Key： switch(key) { case KEY1: map.put(key, ConcreteFlyweight1.INSTANCE); return ConcreteFlyweight1.INSTANCE; case KEY2: map.put(key, ConcreteFlyweight2.INSTANCE); return ConcreteFlyweight2.INSTANCE; case KEY3: map.put(key, ConcreteFlyweight3.INSTANCE); return ConcreteFlyweight3.INSTANCE; case KEY4: map.put(key, ConcreteFlyweight4.INSTANCE); return ConcreteFlyweight4.INSTANCE; default: return null; } 可以利用具体享元类的命名方式进行简化，这里使用了顺序编号1,2,3,4...的方式，因此，利用反射获取对应的类后直接获取其中的单例对象： public Flyweight get(Key key) { if(map.containsKey(key)) return map.get(key); try { Class&lt;?&gt; cls = Class.forName(&quot;ConcreteFlyweight&quot;+key.code()); Flyweight flyweight = (Flyweight)(cls.getField(&quot;INSTANCE&quot;).get(null)); map.put(key,flyweight); return flyweight; } catch(Exception e) { e.printStackTrace(); return null; } } 在此之前需要修改一下Key类： enum Key { KEY1(1),KEY2(2),KEY3(3),KEY4(4); private int code; private Key(int code) { this.code = code; } public int code() { return code; } } 增加一个code字段，作为区分每一个具体享元的标志。 对于非共享具体享元类似，首先修改UnsharedKey，同理添加code字段： enum UnsharedKey { KEY1(1),KEY2(2),KEY3(3),KEY4(4); private int code; private UnsharedKey(int code) { this.code = code; } public int code() { return code; } } 接着修改get方法： public Flyweight get(UnsharedKey key) { try { Class&lt;?&gt; cls = Class.forName(&quot;UnsharedConcreteFlyweight&quot;+key.code()); return (Flyweight)(cls.newInstance()); } catch(Exception e) { e.printStackTrace(); return null; } } 由于笔者使用的是OpenJDK11，其中newInstance被标记为过时了： 因此使用如下方式代替直接使用newInstance()： return (Flyweight)(cls.getDeclaredConstructor().newInstance()); 区别如下： newInstance：直接调用无参构造方法 getDeclaredConstructor().newInstance()：getDeclaredConstructor()会根据传入的参数搜索该类的构造方法并返回，没有参数就返回该类的无参构造方法，接着调用newInstance进行实例化 3 实例 围棋棋子的设计：一个棋盘中含有大量相同的黑白棋子，只是出现的位置不一样，使用享元模式对棋子进行设计。 设计如下： 抽象享元类：IgoChessman接口（如果想要具体享元类为枚举单例的话必须是接口，使用其他方式实现单例可以为抽象类），包含getColor以及display方法 具体享元类：BlackChessman+WhiteChessman，枚举单例类 非共享具体享元类：无 享元工厂类：Factory，枚举单例类，包含简单的get作为获取具体享元的方法，加上了white以及balck简单封装，在构造方法中初始化享元池 代码如下： //抽象享元接口 interface IgoChessman { Color getColor(); void display(); } //具体享元枚举单例类 enum BlackChessman implements IgoChessman { INSTANCE; @Override public Color getColor() { return Color.BLACK; } @Override public void display() { System.out.println(&quot;棋子颜色&quot;+getColor().color()); } } //具体享元枚举单例类 enum WhiteChessman implements IgoChessman { INSTANCE; @Override public Color getColor() { return Color.WHITE; } @Override public void display() { System.out.println(&quot;棋子颜色&quot;+getColor().color()); } } //享元工厂枚举单例类 enum Factory { INSTANCE; //HashMap&lt;Color,IgoChessman&gt;作为享元池 private Map&lt;Color,IgoChessman&gt; map = new HashMap&lt;&gt;(); private Factory() { //构造方法中直接初始化享元池 map.put(Color.WHITE, WhiteChessman.INSTANCE); map.put(Color.BLACK, BlackChessman.INSTANCE); } public IgoChessman get(Color color) { //由于在构造方法中已经初始化，如果不存在可以返回null或者添加新实例到享元池并返回，这里选择了返回null if(!map.containsKey(color)) return null; return (IgoChessman)map.get(color); } //简单封装 public IgoChessman white() { return get(Color.WHITE); } public IgoChessman black() { return get(Color.BLACK); } } enum Color { WHITE(&quot;白色&quot;),BLACK(&quot;黑色&quot;); private String color; private Color(String color) { this.color = color; } public String color() { return color; } } 在初始化享元池时，如果具体享元类过多可以使用反射简化，不需要手动逐个put： private Factory() { map.put(Color.WHITE, WhiteChessman.INSTANCE); map.put(Color.BLACK, BlackChessman.INSTANCE); } 根据枚举值数组，结合List与forEach，逐个利用数组中的值获取对应的类，进而获取实例： private Factory() { List.of(Color.values()).forEach(t-&gt; { String className = t.name().substring(0,1)+t.name().substring(1).toLowerCase()+&quot;Chessman&quot;; try { map.put(t,(IgoChessman)(Class.forName(className).getField(&quot;INSTANCE&quot;).get(null))); } catch(Exception e) { e.printStackTrace(); map.put(t,null); } }); } 测试： public static void main(String[] args) { Factory factory = Factory.INSTANCE; IgoChessman white1 = factory.white(); IgoChessman white2 = factory.white(); white1.display(); white2.display(); System.out.println(white1 == white2); IgoChessman black1 = factory.black(); IgoChessman black2 = factory.black(); black1.display(); black2.display(); System.out.println(black1 == black2); } 4 加入外部状态 通过上面的方式已经能够实现黑白棋子的共享了，但是还有一个问题没有解决，就是如何将相同的黑白棋子放置于不同的棋盘位置上？ 解决办法也不难，增加一个坐标类Coordinates，调用display时作为要放置的坐标参数传入函数。 首先增加一个坐标类： class Coordinates { private int x; private int y; public Coordinates(int x,int y) { this.x = x; this.y = y; } //setter+getter... } 接着需要修改抽象享元接口，在display中加入Coordinates参数： interface IgoChessman { Color getColor(); void display(Coordinates coordinates); } 然后修改具体享元类即可： enum BlackChessman implements IgoChessman { INSTANCE; @Override public Color getColor() { return Color.BLACK; } @Override public void display(Coordinates coordinates) { System.out.println(&quot;棋子颜色&quot;+getColor().color()); System.out.println(&quot;显示坐标:&quot;); System.out.println(&quot;横坐标&quot;+coordinates.getX()); System.out.println(&quot;纵坐标&quot;+coordinates.getY()); } } 对于客户端，创建享元对象的代码无须修改，只需修改调用了display的地方，传入Coordinates参数即可： IgoChessman white1 = factory.white(); IgoChessman white2 = factory.white(); white1.display(new Coordinates(1, 2)); white2.display(new Coordinates(2, 3)); 5 单纯享元模式与复合享元模式 5.1 单纯享元模式 标准的享元模式既可以包含具体享元类，也包含非共享具体享元类。 但是在单纯享元模式中，所有的具体享元类都是共享的，也就是不存在非共享具体享元类。 比如上面棋子的例子，黑白棋子作为具体享元类都是共享的，不存在非共享具体享元类。 5.2 复合享元模式 将一些单纯享元对象进行使用组合模式加以组合还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解为单纯享元对象，而后者可以共享。 通过复合享元模式可以确保复合享元类所包含的每个单纯享元类都具有相同的外部状态，而这些单纯享元的内部状态可以不一样，比如，上面棋子的例子中： 黑棋子是单纯享元 白棋子也是单纯享元 这两个单纯享元的内部状态不同（颜色不同） 但是可以设置相同的外部状态（比如设置为棋盘上同一位置，但是这样没有什么实际意义，或者设置显示为同一大小） 例子如下，首先在抽象享元中添加一个以int为参数的display： interface IgoChessman { Color getColor(); void display(int size); } 在具体享元实现即可： enum BlackChessman implements IgoChessman { INSTANCE; @Override public Color getColor() { return Color.BLACK; } @Override public void display(int size) { System.out.println(&quot;棋子颜色&quot;+getColor().color()); System.out.println(&quot;棋子大小&quot;+size); } } 接着添加复合享元类，里面包含一个HashMap存储所有具体享元： enum Chessmans implements IgoChessman { INSTANCE; private Map&lt;Color,IgoChessman&gt; map = new HashMap&lt;&gt;(); public void add(IgoChessman chessman) { map.put(chessman.getColor(),chessman); } @Override public Color getColor() { return null; } @Override public void display(int size) { map.forEach((k,v)-&gt;v.display(size)); } } 在display中，实际上是遍历了HashMap，给每一个具体享元的display传入相同的参数。 测试： public static void main(String[] args) { Factory factory = Factory.INSTANCE; IgoChessman white = factory.white(); IgoChessman black = factory.black(); Chessmans chessmans = Chessmans.INSTANCE; chessmans.add(white); chessmans.add(black); chessmans.display(30); } 输出： 这样内部状态不同（颜色不同）的两个具体享元类（黑白棋）就被复合享元类（Chessmans）设置为具有相同的外部状态（显示大小30）。 6 补充说明 与其他模式联用：享元模式通常需要与其他模式联用，比如工厂模式（享元工厂），单例模式（具体享元枚举单例），组合模式（复合享元模式） JDK中的享元模式：JDK中的String使用了享元模式。大家都知道String是不可变类，对于类似String a = &quot;123&quot;这种声明方式，会创建一个值为&quot;123&quot;的享元对象，下次使用&quot;123&quot;时从享元池获取，在修改享元对象时，比如a += &quot;1&quot;，先将原有对象复制一份，然后在新对象上进行修改，这种机制叫做&quot;Copy On Write&quot;。基本思路是，一开始大家都在共享内容，当某人需要修改时，把内容复制出去形成一个新内容并修改 7 主要优点 降低内存消耗：享元模式可以极大地减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而节约系统资源，提供系统性能 外部状态独立：享元模式外部状态相对独立，不会影响到内部状态，从而使得享元对象可以在不同环境中被共享 8 主要缺点 增加复杂度：享元模式使得系统变复杂，需要分离出内部状态以及外部状态，使得程序逻辑复杂化 运行时间变长：为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态使得运行时间变长 9 适用场景 一个系统有大量相似或相同对象，造成大量内存浪费 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中 由于需要维护享元池，造成一定的资源开销，因此在需要真正多次重复使用享元对象时才值得使用享元模式 10 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-si-xiang-yuan-mo-shi/"},{"title":"设计模式学习笔记（十三）：外观模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 外观角色 2.3 客户端 3 实例 4 引入抽象外观类 4.1 为什么需要引入抽象外观类？ 4.2 如何引入？ 5 注意事项 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 根据单一权责原则，软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，使客户类与子系统之间的通信和相互依赖关系达到最小，方法之一就是引入一个外观角色，为子系统的访问提供一个简单而单一的入口。外观模式通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 （这里的子系统是广义的概念，可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统） 如果没有外观角色，每个客户端可能需要和多个子系统之间进行复杂的交互，系统的耦合度很大，简化示意图如下： 而引入外观角色后，客户端只需直接与外观角色交互，客户端与子系统之间的原有复杂度由外观角色实现，从而降低系统耦合度，简化示意图如下： 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观角色进行，外观角色将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。 1.2 定义 外观模式：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口。 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式又叫门面模式，是一种对象结构型模式。 1.3 结构图 1.4 角色 Facade（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的一个或多个子系统的功能和责任，正常情况下将来自客户端的请求委派到对应的子系统中去，传递给相应的子系统对象处理 SubSystem（子系统角色）：每一个子系统是一个单独的类，也可以是一个类的集合，实现子系统的功能。每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求，子系统并不知道外观类的存在，对于子系统而已，外观角色仅仅是另一个客户端 2 典型实现 2.1 步骤 定义子系统：首先定义子系统，实现一个单一的功能，处理由客户端传来的请求 定义外观角色：外观角色可以知道一个或多个子系统的功能和责任，将来自客户端的请求委派到对应的子系统去，外观角色对于子系统而言是另一个客户端 2.2 外观角色 通常实现如下： class Facade { private SubSystemA subSystemA = new SubSystemA(); private SubSystemB subSystemB = new SubSystemB(); private SubSystemC subSystemC = new SubSystemC(); public void method() { subSystemA.method(); subSystemB.method(); subSystemC.method(); } } class SubSystemA { public void method() { System.out.println(&quot;子系统A&quot;); } } class SubSystemB { public void method() { System.out.println(&quot;子系统B&quot;); } } class SubSystemC { public void method() { System.out.println(&quot;子系统C&quot;); } } 2.3 客户端 使用外观模式的原因就是简化客户端的调用，在这里只需定义外观对象并调用业务方法即可： Facade facade = new Facade(); facade.method(); 3 实例 设计一个文件加密系统，加密流程包括三部分：读取文件，加密文件，保存文件。这三个操作相对独立，并且封装在三个不同的类中，使用外观模式设计该系统。 设计如下： 子系统类：FileReader+Encrypt+FileWriter 外观角色类：Facade FileReader：文件读取类 Encrypt：文件加密类 FileWriter：文件保存类 代码如下： public class Test { public static void main(String[] args) { Facade facade = new Facade(); facade.fileEncrypt(&quot;111&quot;); } } class FileReader { public void read(String name) { System.out.println(&quot;读取文件&quot;+name); } } class Encrypt { public void encrypt(String name) { System.out.println(&quot;加密文件&quot;+name); } } class FileWriter { public void write(String name) { System.out.println(&quot;保存文件&quot;+name); } } class Facade { private FileReader reader = new FileReader(); private Encrypt encrypt = new Encrypt(); private FileWriter writer = new FileWriter(); public void fileEncrypt(String name) { reader.read(name); encrypt.encrypt(name); writer.write(name); } } 这里的例子比较简单，其实就是将读取，加密以及保存操作用外观角色包装起来，方便客户端调用。 4 引入抽象外观类 4.1 为什么需要引入抽象外观类？ 在标准的外观模式结构中，如果需要增加，删除或修改外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，比如上面的例子中需要更换一种加密方法，也就是换一个加密类，这样需要直接修改外观类。 可以通过引入抽象外观类来解决该问题，引入后，客户端可以针对抽象外观类进行编程，对于新的业务需求不需要修改原有的外 观类，只需要新增一个对应的具体外观类即可。 4.2 如何引入？ 首先定义抽象外观类，接着具体外观类继承或者实线抽象外观类即可。客户端针对抽象外观类进行编程，在运行时再确定具体的外观类，比如在上面例子的基础上修改加密方法，首先定义抽象外观类（这里是接口，只有一个加密方法）： interface AbstractFacade { void encrypt(String name); } 接着定义具体外观类： class Facade1 implements AbstractFacade { private FileReader reader = new FileReader(); private Encrypt1 encrypt1 = new Encrypt1(); private FileWriter writer = new FileWriter(); @Override public void encrypt(String name) { reader.read(name); encrypt1.encrypt(name); writer.write(name); } } class Facade2 implements AbstractFacade { private FileReader reader = new FileReader(); private Encrypt2 encrypt2 = new Encrypt2(); private FileWriter writer = new FileWriter(); @Override public void encrypt(String name) { reader.read(name); encrypt2.encrypt(name); writer.write(name); } } 这两个类除了加密方法不一样其他都一样，测试： AbstractFacade facade = new Facade1(); facade.encrypt(&quot;111&quot;); facade = new Facade2(); facade.encrypt(&quot;222&quot;); 引入抽象外观类后，客户端针对抽象外观类进行编程，运行时确定具体外观类，输出如下： 5 注意事项 外观单例：很多情况下为了节约系统资源，系统只需要一个外观类的实例，也就是外观类可以是一个单例类，这样可以降低系统资源的消耗 多个外观类：在一个系统中可以设计多个外观类，每个外观类负责和一些特定子对象交互，向客户端提供相应业务功能 不要通过外观类增加新行为：外观模式的意图是为子系统提供一个集中简化的沟通渠道，而不是向子系统中增加新行为，新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现而不是通过外观类实现 6 主要优点 简化处理：对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易，引入外观模式后客户端代码将简化 松耦合：实现了子系统于客户端之间松耦合关系，使得子系统的变化不会影响到客户端，只需修改外观类 子系统修改灵活：一个子系统的修改对其他子系统没有影响，而且子系统内部变化也不会影响外观对象 唯一入口：只提供了一个访问子系统的唯一入口，但不会影响客户端直接使用子系统类 7 主要缺点 不能限制客户端使用子系统：外观模式不能很好地限制客户端直接使用子系统，如果客户端对访问子系统做太多的限制就会减少可变性与灵活性 可能需要修改外观类：如果设计不当，增加新的子系统可能需要外观类，违背OCP 8 适用场景 当要为访问一系列复杂的子系统提供一个简单的入口时 客户端与多个子系统存在很大依赖性 层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-san-wai-guan-mo-shi/"},{"title":"设计模式学习笔记（十二）：装饰模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象构件类 2.3 具体构件类 2.4 抽象装饰类 2.5 具体装饰类 2.6 客户端 3 实例 4 透明装饰与半透明装饰 4.1 透明装饰模式 4.2 半透明装饰模式 5 注意事项 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。比如，一张照片，不改变照片本身，增加一个相框。 装饰模式是一种用于替代继承的技术，无须定义子类即可给对象动态增加职责，使用对象之间的关联关系来代替继承关系，在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类方法，还可以增加新的方法，以扩充原有的类功能。 1.2 定义 装饰模式：动态地给对象增加一些额外的职责。 就增加对象功能来说，装饰模式比生成子类实现更为灵活，装饰模式是一种对象结构型模式。 1.3 结构图 1.4 角色 Component（抽象构件类）：是具体构件以及抽象装饰类的父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰之后的对象，以实现客户端的透明操作 ConcreteComponent（具体构件类）：是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责 Decorator（抽象装饰类）：用于给具体构件类增加职责，但是具体职责在子类实现。抽象装饰类维护一个指向抽象构件的引用，通过该引用可以调用装饰之前构件对象的方法，并通过子类扩展该方法以达到装饰的目的 ConcreteDecorator（具体装饰类）：负责向构件中添加新的职责，每一个具体装饰类都定义了一些新的行为，可以调用抽象装饰类中定义的方法，并可以增加新的职责用以扩充对象的行为 2 典型实现 2.1 步骤 定义抽象构件类：可以是抽象类或者接口，声明业务方法 定义具体构件类：继承或实现抽象构件，实现具体业务方法 定义抽象装饰类：继承或实现抽象构件，增加一个抽象构件私有成员，通过该成员可以调用装饰之前具体构件的方法 定义具体装饰类：继承抽象装饰类，并且增加装饰行为，在装饰之前调用具体构件方法，接着调用装饰方法 2.2 抽象构件类 简化只有一个业务方法： abstract class Component { abstract void operation(); } 2.3 具体构件类 继承抽象构件： class ConcreteComponent extends Component { public void operation() { System.out.println(&quot;具体构件方法&quot;); } } 2.4 抽象装饰类 class Decorator extends Component { private Component component; public Decorator(Component component) { this.component = component; } public void operation() { component.operation(); } } 抽象装饰类需要包含一个抽象构件的私有成员，以便可以通过setter或构造方法注入不同的具体构件，同时在业务方法中方便调用具体构件未装饰之前的方法。 2.5 具体装饰类 class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } public void operation() { super.operation(); newBehavior(); } public void newBehavior() { System.out.println(&quot;装饰方法&quot;); } } 继承抽象装饰类，在业务方法中首先调用父类（抽象装饰类）的方法再调用新的装饰方法。 2.6 客户端 public static void main(String[] args) { Component component = new ConcreteComponent(); Component decorator = new ConcreteDecorator(component); decorator.operation(); } 客户端针对抽象构件编程即可，无需指定具体装饰类或者具体构件类的类型，使用装饰器时，通过构造方法注入具体构件，直接调用业务方法即可。 3 实例 设计一个图形界面构件库，具体构件有窗体，文本框以及列表框，装饰方法包括添加滚动条与添加黑边框，使用装饰模式对系统进行设计。 设计如下： 抽象构件类：Component 具体构件类：Window+TextBox+ListBox 抽象装饰类：Decorator 具体装饰类：ScrollBarDecorator+BlackBorderDecorator 代码如下： public class Test { public static void main(String[] args) { Component component = new Window(); Component decorator = new ScrollBarDecorator(component); decorator.display(); } } abstract class Component { abstract void display(); } class Window extends Component { public void display() { System.out.println(&quot;显示窗口&quot;); } } class TextBox extends Component { public void display() { System.out.println(&quot;显示文本框&quot;); } } class ListBox extends Component { public void display() { System.out.println(&quot;显示列表框&quot;); } } class Decorator extends Component { private Component component; public Decorator(Component component) { this.component = component; } public void display() { component.display(); } } class ScrollBarDecorator extends Decorator { public ScrollBarDecorator(Component component) { super(component); } public void display() { addScrollBar(); super.display(); } public void addScrollBar() { System.out.println(&quot;添加滚动条&quot;); } } class BlackBorderDecorator extends Decorator { public BlackBorderDecorator(Component component) { super(component); } public void display() { addBlackBorder(); super.display(); } public void addBlackBorder() { System.out.println(&quot;添加黑边框&quot;); } } 输出如下： 核心部分就是客户端的代码： Component component = new Window(); Component decorator = new ScrollBarDecorator(component); decorator.display(); 创建具体构件后，再创建具体装饰器，把具体构件传入具体装饰器的构造方法中，这样具体装饰器就能在装饰之后（在添加滚动条之后）调用具体构件的方法（调用显示窗口）。 另外，如果向增加新的装饰方法，比如增加了滚动条后，再增加黑边框，只需要将”滚动条装饰器“本身再装饰一次： Component component = new Window(); Component decorator = new ScrollBarDecorator(component); decorator = new BlackBorderDecorator(decorator); decorator.display(); 也就是把已经对具体构件进行装饰之后的具体装饰器，注入到另一个具体装饰器的构造方法再一次装饰。 4 透明装饰与半透明装饰 4.1 透明装饰模式 标准的装饰模式就是透明装饰，比如上述例子。在透明装饰模式中，要求客户端完全针对抽象构件编程，也就是将对象全部声明为抽象构件类型，而不是具体构件类型或具体装饰器类型。 透明装饰模式的优点如下： 客户端透明地使用装饰前以及装饰后的对象，无须关心两者区别 能对已装饰过的对象进行多次装饰 在实现透明装饰模式时，要求具体装饰类的业务方法覆盖抽象装饰类的业务方法，需要调用原有具体构件对象的业务方法以及新增装饰方法。 4.2 半透明装饰模式 对于有时用户需要单独调用装饰方法，这时候需要使用具体装饰类型定义装饰后的对象，而具体构件对象还是可以使用抽象构件定义，这种装饰模式就叫半透明装饰模式。对于客户端来说： 具体构件类型无需关心，是透明的 具体装饰类型必须指定，是不透明的 例子如下，修改上面的滚动条具体装饰类： class ScrollBarDecorator extends Decorator { public ScrollBarDecorator(Component component) { super(component); } public void display() { super.display(); } public void addScrollBar() { System.out.println(&quot;添加滚动条&quot;); } } 其中addScrollBar由客户端单独调用： Component component = new Window(); ScrollBarDecorator decorator = new ScrollBarDecorator(component); decorator.display(); decorator.addScrollBar(); 半透明装饰可以带来更大的灵活性，使用起来更加方便，客户端可以单独调用装饰方法来进行装饰，但是缺点就是不能对同一个对象进行多次装饰。 5 注意事项 保持接口相同：尽量保持装饰类的接口与被装饰类的接口相同，这样对客户端而言装饰前/后的对象可以一致对待，也就是尽量使用透明装饰模式 减少具体构件行为：过多的行为不需要放在具体构件类中，通过具体装饰类进行扩展 去除抽象构件：如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类，也就是说将原来的抽象构件用具体构件代替 6 主要优点 动态扩展灵活：对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。通过选择不同的具体装饰类，可以动态扩展对象的行为 多次装饰：可以对一个对象进行多次装饰，使用不同的具体装饰类以及这些装饰类的排列组合，可以创造很多不同行为的组合 构件与装饰类独立变化：具体构件类以及具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类或者具体装饰类，无须修改原有代码，符合开闭原则 7 主要缺点 对象较多：使用装饰模式会产生很多小对象，这些对象的区别在于相互连接方式的不同，小对象过多会一定程度上影响性能 排查繁琐：尽管装饰模式比继承更加灵活，但也意味着比继承更加容易出错，排错也很困难，对于多次装饰后的对象可能需要逐级排查 8 适用场景 在不影响其他对象的情况下，以动态和透明的方式给单个对象增加职责 在不能采用继承扩展系统或者采用继承不利于对系统扩展和维护时可以使用装饰模式 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi/"},{"title":"设计模式学习笔记（十一）：组合模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象构件 2.3 叶子构件 2.4 容器构件 2.5 客户端 3 实例 4 透明组合模式与安全组合模式 4.1 如何简化代码 4.2 默认实现 4.3 删除方法 4.4 透明组合模式 4.5 安全组合模式 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 对于树形结构，比如文件目录，一个文件夹中可以包含多个文件夹和文件，而一个文件中不能在包含子文件或者子文件夹，在这里可以称文件夹为容器，称文件为叶子。 在树形结构中，当容器对象（比如文件夹）的某个方法被调用时，将遍历整个文件夹，寻找也包含这个方法的成员对象（容器对象或叶子对象）并调用执行。由于容器对象以及叶子对象在功能上的区别，使用这些对象的代码中必须有区别对待容器对象以及叶子对象，但大多数情况下需要一致性处理它们。 组合模式为解决此类问题而生，它可以让叶子对象以及容器对象的使用具有一致性。 1.2 定义 组合模式：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。 组合模式又叫“部分-整体”模式，它是一种对象结构型模式。 1.3 结构图 1.4 角色 Component（抽象构件）：可以是接口或者抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问以及管理它的子构件的方法，例如增加/删除/获取子构件 Leaf（叶子构件）：表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为，对于访问以及管理子构件的方法，通常会抛出异常 Composite（容器构件）：表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括访问以及管理子构件的方法 2 典型实现 2.1 步骤 组合模式的关键是定义了一个抽象构件类，它既可以表示叶子也可以表示容器，客户端针对该抽象构件进行编程，无须知道到底是叶子还是容器，同时容器对象与抽象构件之间需要建立一个聚合关联关系，在容器对象中既可以包含叶子也可以包含容器，以此实现递归组合，形成树形结构。 因此首先需要定义抽象构件类，通用步骤如下： 定义抽象构件：定义抽象构件类，添加四个基本方法：增加/删除/获取成员+业务方法，可以将抽象构件类定义为抽象类或者接口 定义叶子构件：继承或实现抽象构件类，覆盖或实现具体业务方法，同时对于管理或访问子构件的方法提供异常处理或错误提示 定义容器构件：继承或实现抽象构件类，覆盖或实现抽象构件中的所有方法，一般来说容器构件会包含一个集合私有成员用于保存抽象构件，在业务方法中对这个集合进行遍历从而实现递归调用 2.2 抽象构件 抽象构件一般定义如下： abstract class Component { abstract void add(Component c); abstract void remove(Component c); abstract Component getChild(int i); abstract void operation(); } 2.3 叶子构件 class Leaf extends Component { public void add(Component c) { //叶子构件不能访问该方法 System.out.println(&quot;错误,不能访问添加构件方法!&quot;); } public void remove(Component c) { //叶子构件不能访问该方法 System.out.println(&quot;错误,不能访问删除构件方法!&quot;); } public Component getChild(int i) { //叶子构件不能访问该方法 System.out.println(&quot;错误,不能访问获取构件方法!&quot;); return null; } public void operation() { System.out.println(&quot;叶子业务方法&quot;); } } 叶子构件只需要覆盖具体业务方法opeartion，对于管理子构件的方法可以提示错误或者抛出异常来处理。 2.4 容器构件 class Composite extends Component { private ArrayList&lt;Component&gt; list = new ArrayList&lt;&gt;(); public void add(Component c) { list.add(c); } public void remove(Component c) { list.remove(c); } public Component getChild(int i) { return list.get(i); } public void operation() { list.forEach(Component::operation); } } 容器构件只需要简单实现管理子构件的方法，对于业务方法一般需要对抽象构件集合进行遍历来实现递归调用。 2.5 客户端 客户端针对抽象构件进行编程，根据需要添加叶子或者容器： public static void main(String[] args) { Component leaf1 = new Leaf(); Component leaf2 = new Leaf(); Component composite1 = new Composite(); Component composite2 = new Composite(); composite1.add(leaf1); composite2.add(leaf2); composite1.add(composite2); composite1.operation(); } 3 实例 开发一个杀毒软件系统，可以对某个文件夹或单个文件进行杀毒，还能根据文件类型的不同提供不同的杀毒方式，比如文本文件和图像文件的杀毒方式有所差异，使用组合模式对该系统进行设计。 设计如下： 抽象构件类：AbstractFile 容器构件类：Folder 叶子构件类：ImageFile+TextFile+VideoFile 代码如下： public class Test { public static void main(String[] args) { AbstractFile file1,file2,file3,file4,folder1,folder2; file1 = new ImageFile(&quot;图像文件1号&quot;); file2 = new VideoFile(&quot;视频文件1号&quot;); file3 = new TextFile(&quot;文本文件1号&quot;); file4 = new ImageFile(&quot;图像文件2号&quot;); folder1 = new Folder(&quot;文件夹1&quot;); folder2 = new Folder(&quot;文件夹2&quot;); try { folder2.add(file1); folder2.add(file2); folder2.add(file3); folder1.add(file4); folder1.add(folder2); } catch(IllegalAccessException e) { e.printStackTrace(); } folder1.killVirus(); System.out.println(); folder2.killVirus(); } } //抽象构件类 abstract class AbstractFile { protected String name; abstract void add(AbstractFile file) throws IllegalAccessException; abstract void remove(AbstractFile file) throws IllegalAccessException; abstract AbstractFile getChild(int i) throws IllegalAccessException; public void killVirus() { System.out.println(name+&quot; 杀毒&quot;); } } //叶子构件类 class ImageFile extends AbstractFile { public ImageFile(String name) { this.name = name; } public void add(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;); } public void remove(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;); } public AbstractFile getChild(int i) { throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;); } } //叶子构件类 class TextFile extends AbstractFile { public TextFile(String name) { this.name = name; } public void add(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;); } public void remove(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;); } public AbstractFile getChild(int i) { throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;); } } //叶子构件类 class VideoFile extends AbstractFile { public VideoFile(String name) { this.name = name; } public void add(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;); } public void remove(AbstractFile c) { throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;); } public AbstractFile getChild(int i) { throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;); } } //容器构件类 class Folder extends AbstractFile { private ArrayList&lt;AbstractFile&gt; list = new ArrayList&lt;&gt;(); public Folder(String name) { this.name = name; } public void add(AbstractFile c) { list.add(c); } public void remove(AbstractFile c) { list.remove(c); } public AbstractFile getChild(int i) { return list.get(i); } public void killVirus() { System.out.println(&quot;对 &quot;+name+&quot; 进行杀毒&quot;); list.forEach(AbstractFile::killVirus); } } 输出如下： 4 透明组合模式与安全组合模式 4.1 如何简化代码 尽管组合模式的扩展性好，在上面的例子中增加新的文件类型无须修改原有代码，但是，由于抽象构件类AbstractFile声明了与叶子构件无关的构件管理方法，因此 需要实现这些方法，这样就会带来很多重复性的工作。 解决方案有两个： 抽象构件提供默认实现：叶子构件中的构件管理方法转移到抽象构件中提供默认实现 抽象构件删除方法：在抽象构件中不提供管理构件的方法 4.2 默认实现 如果使用抽象构件提供默认实现的方法，则上述例子代码简化如下： abstract class AbstractFile { protected String name; public AbstractFile(String name) { this.name = name; } public void add(AbstractFile file) throws IllegalAccessException { throw new IllegalAccessException(&quot;错误,不能访问添加文件方法!&quot;); } public void remove(AbstractFile file) throws IllegalAccessException { throw new IllegalAccessException(&quot;错误,不能访问删除文件方法!&quot;); } public AbstractFile getChild(int i) throws IllegalAccessException { throw new IllegalAccessException(&quot;错误,不能访问获取文件方法!&quot;); } public void killVirus() { System.out.println(name+&quot; 杀毒&quot;); } } class ImageFile extends AbstractFile { public ImageFile(String name) { super(name); } } class TextFile extends AbstractFile { public TextFile(String name) { super(name); } } class VideoFile extends AbstractFile { public VideoFile(String name) { super(name); } } 在叶子构件中只有构造方法（实际上业务方法应该是抽象的，在叶子构件中实现业务方法，这里的业务方法是killVirus()，这里是进行了简化），这样修改虽然简化了代码，但是总的来说为叶子构件提供这些方法是没有意义的，因为叶子不会再下一个层次的对象，这在编译阶段不会出错 ，但是在运行阶段可能会出错。 4.3 删除方法 如果使用抽象构件删除方法的方式进行简化代码，则上述例子简化如下： abstract class AbstractFile { protected String name; public AbstractFile(String name) { this.name = name; } abstract void killVirus(); } class ImageFile extends AbstractFile { public ImageFile(String name) { super(name); } public void killVirus() { System.out.println(&quot;图像文件&quot;+name+&quot;杀毒&quot;); } } class TextFile extends AbstractFile { public TextFile(String name) { super(name); } public void killVirus() { System.out.println(&quot;文本文件&quot;+name+&quot;杀毒&quot;); } } class VideoFile extends AbstractFile { public VideoFile(String name) { super(name); } public void killVirus() { System.out.println(&quot;视频文件&quot;+name+&quot;杀毒&quot;); } } 这样做叶子构件就无法访问管理构件的方法了，但是带来的坏处是客户端无法统一针对抽象构件类AbstractFile进行编程，修改之前代码如下： AbstractFile file1,file2,file3,file4,folder1,folder2; 由于AbstractFile中删除了管理构件方法，因此客户端需要修改代码如下： AbstractFile file1,file2,file3,file4; Folder folder1,folder2; 4.4 透明组合模式 透明组合模式就是第一种解决方案中的方法，在抽象构件中声明所有用于管理构件的方法，这样做的好处是确保所有的构件类都具有相同的接口，客户端可以针对抽象构件进行统一编程，结构图如下： 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一层次的对象，提供管理构件的方法是没有意义的，在编译阶段不会报错，但是在运行阶段可能会出错。 4.5 安全组合模式 安全组合模式就是第二种方法的办法，安全组合模式中，抽象构件没有声明管理构件的方法，而是在容器构件中添加管理构件的方法，这种做法是安全的因为叶子对象不可能调用到这些方法。结构图如下： 安全组合模式的缺点是不够透明，因为叶子构件与容器构件具有不同的方法，管理构件的方法在容器构件中定义，客户端不能完全针对抽象构件进行编程，必须有区别地对待叶子构件与容器构件。 5 主要优点 层次控制：组合模式可以清楚定义分层次的复杂对象，表示对象的全部或者部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制 一致使用构件：客户端可以一致地使用容器构件或者叶子构件，也就是能针对构件抽象层一致性编程 扩展性好：增加新的容器构件或者叶子构件都很方便，符合开闭原则 有效针对树形结构：组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子构件与容器构件的递归组合，可以形成复杂的树形结构，但控制树形结构却很简单 6 主要缺点 难以限制构件类型：增加新构件时难以限制构件类型，比如希望容器构件中只有某一特定类型的叶子构件，例如一个只能包含图片的文件夹，使用组合模式时不能依赖类型系统来施加这些约束，需要再运行时进行类型检查来实现，过程较为复杂 7 适用场景 具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性对待它们 处理树形结构 系统中能够分离出叶子构件以及容器构件，而且类型不固定，需要增加新的叶子构件或者容器构件 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-yi-zu-he-mo-shi/"},{"title":"每日分享 第39期","content":" 每日鸡汤 你打起精神，3分钟就能做完事情，打起精神就要花上3小时。 每日冷知识 有研究发现，红发女性的疼痛阀值比我们其他人高出25%。此外得益于“红发基因”MC1R，红发者可以自己补充维生素D，对于温度变化的感觉也更为强烈。 每日诗词 杏馆花阴恨浅，画堂银烛嫌明。 ——陆游《朝中措·代谭德称作》 每日一句 破解版的“爱情”APP，有吗？ 每日音乐 一万个舍不得-庄心妍 不要追问对与错 毕竟我们深爱过 有你陪的日子里 我真的好快乐 你总是小心翼翼的 因为你怕我难过 而我却不能给你 给你想要的结果 一万个舍不得 不能回到从前了 爱你没有后悔过 只是应该结束了 一万个舍不得 我是永远爱你的 爱你我觉得值得 只是不能再爱了 不要追问谁对谁错 毕竟我们深爱过 有你陪的日子里 我真的好快乐 你总是小心翼翼的 因为你怕我难过 而我却不能给你 给你想要的结果 你永远都是最好的 不要追问对与错 毕竟我们深爱过 有你陪的日子里 我真的好快乐 你总是小心翼翼的 而我却不能给你 给你想要的结果 一万个舍不得 不能回到从前了 爱你没有后悔过 只是应该结束了 一万个舍不得 我是永远爱你的 爱你我觉得值得 只是不能再爱了 一万个舍不得 不能回到从前了 爱你没有后悔过 只是应该结束了 一万个舍不得 我是永远爱你的 爱你我觉得值得 只是不能再爱了 分开了 不代表不爱你了 我心里 你永远都是最好的 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-39-qi/"},{"title":"每日分享 第38期","content":" 每日鸡汤 以后要对女朋友好一点，毕竟她已经瞎了，不能再受伤害了。 每日冷知识 莫桑比克的蜂蜜狩猎人会用特殊的呼唤招募被称为“蜂蜜向导”的鸟类，这些鸟类会将人类带去蜂蜜的巢穴，并得到剩下的蜂蜡作为回报。 每日诗词 来是空言去绝踪，月斜楼上五更钟。 ——李商隐《无题·来是空言去绝踪》 每日一句 为错误停驻是件可悲的事。 每日音乐 嚣张-en 太多的 太重的 太残忍的话 没纠缠 是你的 理由太假 我觉得 你大可不必说的天花乱坠 是天使 是魔鬼 都没有绝对 没想的 没说的 都请收起吧 你扮演 的角色 更可悲吗 放弃的 就大可不必再争辩是非 放下的 就请你 烧得干脆 你的一字一句犹如刀疤划心上 我的一举一动随你改变多荒唐 任你肆意玩弄 从没去想 你是有多嚣张 我的心脏脉搏为你跳动为你狂 你说我真的多余不如离开流浪 都怪我 没治愈我的伤 没想的 没说的 都请收起吧 放弃的 就大可不必再争辩是非 放下的 就请你 烧的干脆 你的一字一句犹如刀疤划心上 我的一举一动随你改变多荒唐 任你肆意玩弄 从没去想 你是有多嚣张 我的心脏脉搏为你跳动为你狂 你说我真的多余不如离开流浪 都怪我 没治愈我的伤 你的一字一句犹如刀疤划心上 我的一举一动随你改变多荒唐 任你肆意玩弄 从没去想 你是有多嚣张 我的心脏脉搏为你跳动为你狂 你说我真的多余不如离开流浪 都怪我没治愈我的伤 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-38-qi/"},{"title":"设计模式学习笔记（十）：桥接模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象类与实现类接口 2.3 扩充抽象类以及具体类实现 2.4 客户端 3 实例 4 主要优点 5 主要缺点 6 适用场景 7 总结 1 概述 1.1 引言 桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统变得更加符合SRP。 比如，设计一个跨平台的图像浏览系统，支持的图片格式包括： PNG BMP JPG GIF 等等，而支持的系统包括： Windows Unix Linux 等等，这样，系统与图片格式就是两个不同的维度，可以利用桥接模式将这两个维度分离，使得它们可以独立变化，增加新的图片格式或者新的系统时，都不会对另一个维度造成任何影响。 1.2 定义 桥接模式：将抽象部分与其实现部分分离，使它们都可以独立地变化。 它是一种对象结构型模式，又称为柄体模式或者接口模式。 1.3 结构图 1.4 角色 Abstraction（抽象类）：用于定义抽象类的接口，一般是抽象类而不是接口，具有一个Implementor的成员，与Implementor为关联关系，既可以包含抽象的业务方法，也可以包含具体业务方法 RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常为具体类，实现了在Abstraction中的抽象业务方法，同时可以调用Implementor中的业务方法 Implementor（实现类接口）：实现类的接口，相比起Abstractoin提供的更多更复杂的操作，Implementor一般只提供基本操作，具体实现交由子类处理 ConcreteImplementor（具体实现类）：具体实现Implementor接口，不同的ConcreteImplementor提供不同实现的基本操作 2 典型实现 2.1 步骤 识别维度：首先识别出系统中两个独立变化的维度，设计出抽象类以及实现类接口 建立抽象耦合：在抽象层建立一个抽象关联，也就是在抽象类以及实现类接口之间建立抽象关联 继承：识别出维度后，将它们设计为两个独立的继承等级结构，设计出扩充抽象类以及具体类实现，比如上面的图片格式以及系统，将图片格式与系统设为抽象层，而BMP，GIF等继承图片格式抽象层，Windows等具体系统集成系统抽象层 扩展：建立抽象耦合后，根据需要对两个维度进行独立扩展，比如增加新的图片格式WBEP，增加新的操作系统Mac等 2.2 抽象类与实现类接口 首先对系统中独立变化的维度进行识别，比如有两个维度（A与B），其中A设计为抽象类，B设计为接口： abstract class DimensionA{} interface DimensionB{} 接着是建立抽象耦合，A维度包含一个B维度成员，将B维度作为setter参数传入A维度，同时定义两个普通方法： abstract class DimensionA { protected DimensionB dimensionB; public abstract void methodA(); public void setDimensionB(DimensionB dimensionB) { this.dimensionB = dimensionB; } } interface DimensionB { void methodB(String str); } 2.3 扩充抽象类以及具体类实现 接着是扩充抽象类以及具体类实现，维度A有三个具体类，维度B有两个具体类： class A1 extends DimensionA { @Override public void methodA() { dimensionB.methodB(&quot;A1&quot;); } } class A2 extends DimensionA { @Override public void methodA() { dimensionB.methodB(&quot;A2&quot;); } } class A3 extends DimensionA { @Override public void methodA() { dimensionB.methodB(&quot;A3&quot;); } } class B1 implements DimensionB { @Override public void methodB(String str) { System.out.println(&quot;B1---&quot;+str); } } class B2 implements DimensionB { @Override public void methodB(String str) { System.out.println(&quot;B2---&quot;+str); } } 2.4 客户端 针对抽象层（两个维度）进行编程，将B维度作为setter参数传入A维度，接着调用A维度的方法： public static void main(String[] args) { DimensionA dimensionA = new A1(); dimensionA.setDimensionB(new B1()); dimensionA.methodA(); } 3 实例 跨平台的图片浏览系统，支持的图片格式包括PNG，JPG，BMP，GIF等，支持的系统包括Linux，Unix，Windows等，使用桥接模式设计。 设计如下： 两个维度：图片维度+系统维度 抽象类：Image，Image具有一个ImageShow的成员变量 扩充抽象类：BMP，GIF等继承Image 实现类接口：ImageShow 具体实现类：Linux，Unix，Windows实现图片显示接口ImageShow 代码如下： public class Test { public static void main(String[] args) { Image image = new GIF(); image.setImageShow(new Linux()); image.show(); } } //Image抽象类 abstract class Image { protected ImageShow imageShow; public void setImageShow(ImageShow imageShow) { this.imageShow = imageShow; } public abstract show(); } class BMP extends Image { @Override public void show() { imageShow.show(&quot;BMP&quot;); } } class GIF extends Image { @Override public void show() { imageShow.show(&quot;GIF&quot;); } } class PNG extends Image { @Override public void show() { imageShow.show(&quot;PNG&quot;); } } class JPG extends Image { @Override public void show() { imageShow.show(&quot;JPG&quot;); } } //图片显示接口 interface ImageShow { void show(String name); } class Windows implements ImageShow { @Override public void show(String name) { System.out.println(&quot;Windows show &quot;+name); } } class Linux implements ImageShow { @Override public void show(String name) { System.out.println(&quot;Linux show &quot;+name); } } class Unix implements ImageShow { @Override public void show(String name) { System.out.println(&quot;Unix show &quot;+name); } } 更换图片格式只需要修改Image的父类： Image image = new GIF(); Image image = new BMP(); Image image = new JPG(); Image image = new PNG(); 而更换操作系统只需要修改传入setter的参数： image.setImageShow(new Linux()); image.setImageShow(new Windows()); image.setImageShow(new Unix()); 这样就可以把图片以及系统两个维度分离，并能够独立扩展，增加新的图片格式，只需要增加一个新的继承Image的类即可，增加新的系统只需实现ImageShow接口即可。 由于例子简单使用反射进行简化代码并增加了新的系统以及图片格式，代码如下： public class Test { public static void main(String[] args) { Image image = new WBEP(); image.setImageShow(new Mac()); image.show(); } } abstract class Image { protected ImageShow imageShow; public void setImageShow(ImageShow imageShow) { this.imageShow = imageShow; } public void show() { imageShow.show(getClass().getName()); } } class BMP extends Image{} class GIF extends Image{} class PNG extends Image{} class JPG extends Image{} class WBEP extends Image{} interface ImageShow { void show(String name); } abstract class ImageSystem implements ImageShow { public void show(String name) { System.out.println(getClass().getName()+&quot; show &quot;+name); } } class Windows extends ImageSystem{} class Linux extends ImageSystem{} class Unix extends ImageSystem{} class Mac extends ImageSystem{} 4 主要优点 低耦合：分离抽象接口及其实现部分，桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以按照各自的维度变化。也就是说，抽象和实现不再同一个继承层次中，而是让抽象作为父类，实现作为子类，这样就可以任意组合子类，从而获得多维度的组合对象 取代多重继承：很多情况下桥接模式可以取代多重继承，多重继承违反了SRP（单一权责原则），复用性差，而且类的个数多，桥接模式可以有效减少子类个数 提高扩展性：桥接模式提高了系统的扩展性，在两个维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则 5 主要缺点 增加理解难度：桥接模式会增加系统的理解以及设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计以及编程 需要正确识别抽象层：桥接模式要求正确识别系统中两个独立变化的维度，因此适用范围有一定局限，正确识别独立维度需要一定经验积累 6 适用场景 如果一个系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象类子类的对象和一个实现类子类的对象进行动态组合 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展 对于不希望使用继承或因为多重继承导致系统类的个数急剧增加的系统 7 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qiao-jie-mo-shi/"},{"title":"每日分享 第37期","content":" 每日鸡汤 诗和远方越远越脏，以梦为马越骑越傻。 每日冷知识 1996年，英格兰德文郡的一名男子花了一年时间向猫头鹰鸣叫，并记录下了他们的回应声，结果发现回应声是他的邻居所发出，而他邻居一直以为有猫头鹰对自己鸣叫。 每日诗词 子规啼彻四更时，起时蚕稠怕叶稀。 ——谢枋得《蚕妇吟》 每日一句 我为自己而死，并且，在最后的最后，为自己而活。 每日音乐 水星记-郭顶 着迷于你眼睛 银河有迹可循 穿过时间的缝隙 它依然真实地 吸引我轨迹 这瞬眼的光景 最亲密的距离 沿着你皮肤纹理 走过曲折手臂 做个梦给你 做个梦给你 等到看你银色满际 等到分不清季节更替 才敢说沉溺 还有多远才能进入你的新 还要多久才能和你接近 咫尺远近却无法靠近的那个人 也等着和你相遇 环游的行星 怎么可以 拥有你 这瞬眼的光景 最亲密的距离 沿着你皮肤纹理 走过曲折手臂 做个梦给你 做个梦给你 等到看你银色满际 等到分不清季节更替 才敢说沉溺 还有多久才能进入你的心 还要多久才能和你接近 咫尺远近却无法靠近的那个人 也等着和你相遇 环游的行星 怎么可以 拥有你 还要多远才能进入你的心 还要多久才能和你接近 咫尺远近却无法靠近的那个人 要怎么探寻 要多么幸运 才敢让你发觉你并不孤寂 当我还可以再跟你飞行 环游是无趣 至少可以 陪着你 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-37-qi/"},{"title":"设计模式学习笔记（九）：适配器模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 分类 1.3.1 对象适配器模式 1.3.2 类适配器模式 1.4 角色 2 典型实现 2.1 步骤 2.2 目标抽象类 2.3 适配者类 2.4 适配器类 2.4.1 对象适配器 2.4.2 类适配器 2.5 客户端 3 实例 4 双向适配器 5 缺省适配器 5.1 定义 5.2 结构图 5.3 角色 5.4 实例 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 有的笔记本电脑工作电压为20V，而我国家庭用电为220V，如何让20V的笔记本在220V的电压下工作？答案就是引入一个电源适配器，有了这个电源适配器笔记本就能在220V的电压下工作。 在软件开发中，有时也会存在这类不兼容的状况，需要引入一个像电源适配器这样的称之为适配器的角色来协调这些不兼容的结构，这种设计方案就是适配器模式。 1.2 定义 将一个接口转换为客户希望的另一个接口，使接口不兼容的那些类可以一起工作，别名为包装器。 适配器中的接口是广义的接口，可以表示一个方法或者方法的集合。 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 1.3 分类 根据适配器与适配者类的关系不同，可以分为对象适配器模式以及类适配器模式。 1.3.1 对象适配器模式 对象适配器模式就是适配器与适配者之间是关联关系。 结构图如下： 1.3.2 类适配器模式 类适配器模式就是适配器与适配者之间是继承或实现关系。 结构图如下： 由于语言特性的限制，比如Java，C#不支持多重继承，类适配器模式受到很多限制，例如Target如果不是接口而是一个类，就无法使用类适配器模式。此外如果适配者为final类也无法使用适配器模式，在Java等语言中大部分情况下使用对象适配器模式。 1.4 角色 Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是一个具体类 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器类是适配器模式的核心，在对象适配器模式中，它通过继承Target并关联一个Adaptee对象使两者产生联系，在类适配器模式，通过继承Adaptee并实现Target使两者产生联系 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码 2 典型实现 2.1 步骤 定义目标抽象类：接口/抽象类/具体类，客户端需要的接口，比如上面电源的例子，目标类就是给笔记本充电 （可选）定义适配者类：定义适配者类，但是一般来说适配者已经存在，比如上面电源的例子，适配者类就是220V的电压，而且对于某些库来说可能没有适配者的源码 定义适配器类：继承/实现目标抽象类，并通过转发请求到适配者来完成操作 2.2 目标抽象类 这里实现为具体类： class Target { public void request() { System.out.println(&quot;Target方法&quot;); } } 2.3 适配者类 适配者一般为具体类，但是很多情况下已经存在并且没有源码实现： class Adaptee { public void specificRequest() { System.out.println(&quot;Adaptee方法&quot;); } } 2.4 适配器类 2.4.1 对象适配器 对象适配器种适配器与适配者是关联关系，适配器中包含一个适配者成员，代码如下： class Adapter extends Target { private Adaptee adaptee = new Adaptee(); @Override public void request() { adaptee.specificRequest(); } } 适配器覆盖目标抽象类的request，并将请求转发，交由适配者完成。 2.4.2 类适配器 类适配器中适配器与适配者是继承关系，其中适配者为父类，适配器为子类。但是在Java中由于不支持多重继承，因此想要在Java中实现类适配器模式，并且如果适配者是具体类的话，那么必须将目标抽象类指定为接口： interface Target { void request(); } class Adaptee { public void specificRequest() { System.out.println(&quot;Adaptee方法&quot;); } } class Adapter extends Adaptee implements Target { @Override public void request() { super.specificRequest(); } } 在上述对象适配器的基础上，将目标抽象类修改为接口，同时适配器继承了适配者并实现了Target，并取消了适配者作为成员变量，在方法内直接调用super.xxx，也就是适配者的方法。 2.5 客户端 客户端的代码很简单，针对目标抽象类进行编程： public static void main(String[] args) { Target adapter = new Adapter(); adapter.request(); } 3 实例 假设目前只有一条Micro USB线以及一台只有Type-C接口的手机，需要对其进行充电，这时候就需要一个转接头把Micro USB转为Type-C接口，才能给手机充电，使用适配器模式对其进行设计。 设计如下： 目标抽象类：TypeC 适配者类：MicroUSB 适配器：MicroUSBToTypeC 简化实现代码如下： public class Test { public static void main(String[] args) { TypeC typeC = new MicroUSBToTypeC(); typeC.chargeWithTypeC(); } } //Target:给TypeC接口的手机充电 interface TypeC { void chargeWithTypeC(); } //Adaptee:适配者,MicroUSB线 class MicroUSB { public void chargeWithMicroUSB() { System.out.println(&quot;MicroUSB充电&quot;); } } //Adapter:适配器,MicroUSB到TypeC的转接头 class MicroUSBToTypeC implements TypeC { private MicroUSB microUSB = new MicroUSB(); @Override public void chargeWithTypeC() { microUSB.chargeWithMicroUSB(); } } 4 双向适配器 在对象适配器的使用过程中，如果在适配器中同时包含对Target类和Adaptee类的引用，Adaptee类可以通过适配器调用Target类中的方法，Target类也可以通过适配器调用Adaptee类的方法，那么该适配器就是一个双向适配器。例子如下： public class Test { public static void main(String[] args) { Adapter adapter = new Adapter(); adapter.request(); adapter.specificRequest(); } } //适配者 interface Adaptee { void specificRequest(); } //Target类 interface Target { void request(); } //Target实现 class TargetImpl implements Target { @Override public void request() { System.out.println(&quot;Target方法&quot;); } } //适配者实现 class AdapteeImpl implements Adaptee { @Override public void specificRequest() { System.out.println(&quot;Adaptee方法&quot;); } } //适配器 class Adapter implements Adaptee,Target { private Target target = new TargetImpl(); private Adaptee adaptee = new AdapteeImpl(); @Override public void request() { //Target的方法调用适配者方法 adaptee.specificRequest(); } @Override public void specificRequest() { //适配者方法调用Target的方法 target.request(); } } 5 缺省适配器 5.1 定义 缺省适配器：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法都提供一个默认实现（空实现），那么该抽象类子类可以选择性覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中所有方法的情况，又叫单接口适配器模式。 5.2 结构图 5.3 角色 ServiceInterface（适配者接口）：通常是一个声明了大量方法的接口 AbstractServiceClass（缺省适配器类）：缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法，通常定义为抽象类 ConcreteServiceClass（具体业务类）：是缺省适配器类的子类，只需要有选择性地覆盖适配器者中定义的方法，其他的方法在缺省适配器类中提供了空实现 5.4 实例 Java AWT中一般可以通过两种方式来处理窗口事件： 实现WindowListener 继承WindowAdapter 其中WindowAdapter实现了WindowListener接口，但是都是提供了空实现，也就是说实现WindowsListener的话需要实现里面所有的方法，而继承WindowAdapter只需要选择性地覆盖方法即可，结构图： 6 主要优点 类适配器以及对象适配器的共同优点如下： 解耦：将Target与Adaptee解耦，引入适配器来重用现有的适配者类，无须修改原有结构 提高复用性：将具体的业务实现过程封装在适配者类中，对于客户端而言是透明的，而且提高了适配者类的复用性，同一个适配者类可以在多个不同的系统复用 扩展性好：可以很方便地更换适配器，也可以在不修改代码的基础上增加了新的适配器类，完全符合开闭原则，扩展灵活 类适配器的独有优点如下： 由于适配器类是适配者的子类，因此在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器的独有优点如下： 一个对象适配器可以把多个不同的适配者适配到同一个Target 可以适配一个适配者的子类，由于适配器与适配者之间是关联关系，根据LSP（里氏代换原则），适配者的子类也可以通过该适配器进行适配 7 主要缺点 类适配器缺点： 对于Java，C#等不支持多重继承的语言，一次最多只能适配一个适配者类 适配者不能是“不能继承的类”，比如Java的final类，C#的sealed类 在Java，C#等Target只能是接口不能是类 对象适配器缺点： 置换麻烦：相比起类适配器，在适配器中置换适配者的某些方法比较麻烦，需要先创建一个适配者类的子类，在子类将适配者类的方法置换掉，再把适配者的子类作为真正的适配者类进行适配，实现较为复杂 8 适用场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需求，甚至没有这些类的源代码 想创建一个可以重复使用的类，用于与彼此之间没有太大关联的类，包括可能在将来引进的类一起工作 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-jiu-gua-pei-qi-mo-shi/"},{"title":"Vue学习笔记（四）","content":"1 表单绑定 可以利用v-model在表单控件元素上创建双向的数据绑定，v-model会根据控件类型自动选取正确的方法来更新元素。 2 文本框 文本框的绑定例子如下： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;input&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;p&gt;textarea&lt;/p&gt; &lt;textarea v-model=&quot;message2&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; new Vue({ el:'#app', data:{ message:'', message2:'' } }) 3 按钮 3.1 单选 data中的值为&lt;input&gt;的value，如： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; value=&quot;Value1&quot; v-model=&quot;picked&quot;&gt; &lt;input type=&quot;radio&quot; value=&quot;Value2&quot; v-model=&quot;picked&quot;&gt; &lt;span&gt;选中的值为：{{picked}}&lt;/span&gt; &lt;/div&gt; new Vue({ el: '#app', data: { picked:'Value1' } }) 3.2 多选 单个多选绑定的数据是一个布尔值，多个多选绑定的是一个数组： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;span&gt;是否选中：{{checked ? &quot;选中&quot; : &quot;不选中&quot;}}&lt;/span&gt; &lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Value1&quot; id=&quot;box1&quot; v-model=&quot;checked2&quot;&gt; &lt;label for=&quot;box1&quot;&gt;Value1&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Value2&quot; id=&quot;box2&quot; v-model=&quot;checked2&quot;&gt; &lt;label for=&quot;box2&quot;&gt;Value2&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Value3&quot; id=&quot;box3&quot; v-model=&quot;checked2&quot;&gt; &lt;label for=&quot;box3&quot;&gt;Value3&lt;/label&gt; &lt;br&gt; &lt;span&gt;选中的值为：{{checked2}}&lt;/span&gt; &lt;/div&gt; new Vue({ el: '#app', data: { checked:'Value1', checked2:[] } }) 4 列表 &lt;div id=&quot;app&quot;&gt; &lt;select name=&quot;fruit&quot; v-model=&quot;selected&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择一个&lt;/option&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;div&gt; 选择的水果是：{{selected}} &lt;/div&gt; &lt;/div&gt; new Vue({ el: '#app', data: { selected:'' } }) 5 修饰符 .lazy：默认情况下，v-model在input事件中同步输入框的值与数据，但可以添加一个修饰符.lazy，从而转变为在change事件中同步数据，比如&lt;input v-model.lazy=&quot;meesage&quot;&gt; .number：自动将用户的输入值转化为Number类型，如果原值的转换结果是NaN会返回原值，比如&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; .trim：自动过滤用户输入的首尾空格，比如&lt;input v-model.trim=&quot;message&quot;&gt; 修饰符可以混合使用，例子： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;test&quot;&gt; &lt;br&gt; &lt;p&gt;{{test}}&lt;/p&gt; &lt;input type=&quot;text&quot; v-model.number.lazy=&quot;test2&quot;&gt; &lt;br&gt; &lt;p&gt;{{test2}}&lt;/p&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;test3&quot;&gt; &lt;br&gt; &lt;p&gt;{{test3}}&lt;/p&gt; &lt;/div&gt; 6 组件 组件可以扩展HTML元素，封装可重用的代码，组件系统可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树。 注册一个全局组件语法如下： Vue.component(tagName,options) 其中tagName为组件名，options为配置选项。注册后，按如下方式调用组件： &lt;tagName&gt;&lt;/tagName&gt; 7 全局组件 全局组件就是所有实例都能使用的组件，例如： &lt;div id=&quot;app&quot;&gt; &lt;test-title&gt;&lt;/test-title&gt; &lt;/div&gt; Vue.component('test-title',{ template:'&lt;h1&gt;Test Title&lt;/h1&gt;' }) new Vue({el:'#app'}) 注意标签名不能大写，比如写成： &lt;div id=&quot;app&quot;&gt; &lt;testTitle&gt;&lt;/testTitle&gt; &lt;/div&gt; Vue.component('testTitle',{ template:'&lt;h1&gt;Test Title&lt;/h1&gt;' }) 页面不会显示标题。 8 局部组件 局部组件就是在本实例内使用的组件，比如： &lt;div id=&quot;app&quot;&gt; &lt;test-title&gt;&lt;/test-title&gt; &lt;/div&gt; new Vue({ el: '#app', components: { 'test-title': { template:'&lt;h1&gt;Test Title&lt;/h1&gt;' } } }) 也可以把模板的内容分离出来成为一个变量： var myTemplate = { template:'&lt;h1&gt;Test Title&lt;/h1&gt;' } new Vue({ el: '#app', components: { 'test-title': myTemplate } }) 9 prop prop是子组件来接受父组件传递过来的数据的一个自定义属性，父组件的数据需要通过props把数据传递给子组件，子组件需要显示地使用props选项声明prop： &lt;div id=&quot;app&quot;&gt; &lt;test-title title=&quot;Test Title&quot;&gt;&lt;/test-title&gt; &lt;/div&gt; Vue.component('test-title',{ props:['title'], template:'&lt;h1&gt;{{title}}&lt;/h1&gt;' //template:'&lt;h1&gt;{{this.title}}&lt;/h1&gt;' }) new Vue({el: '#app'}) 9.1 动态prop 类似于v-bind绑定HTML特性到一个表达式，也可以利用v-bind动态绑定props值到父组件的数据中，每当父组件的数据变化时，该变化会传递给子组件： &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;br&gt; &lt;test-title v-bind:title=&quot;message&quot;&gt;&lt;/test-title&gt; &lt;/div&gt; Vue.component('test-title',{ props:['title'], template:'&lt;h1&gt;{{title}}&lt;/h1&gt;' }) new Vue({ el: '#app', data: { message:'' } }) 首先当输入框内容发生变化时，更新父组件的message，再传递给子组件的title，最后更新&lt;test-title&gt;的内容。 下面是一个绑定无序列表的例子： &lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;test-item v-for=&quot;i in items&quot; v-bind:val=&quot;i&quot;&gt;&lt;/test-item&gt; &lt;/ol&gt; &lt;/div&gt; Vue.component('test-item',{ props:['val'], template:'&lt;h1&gt;{{val.text}}&lt;/h1&gt;' }) var vm = new Vue({ el: '#app', data: { items:[ {text:'111'}, {text:'222'} ] } }) 注意prop是单向绑定的，当父组件属性变化时传导到子组件，但是不会反过来。 9.2 子组件回传 父组件使用props传递数据给子组件，如果子组件把数据传递回去需要使用自定义事件，可以在v-on绑定自定义事件，每个Vue实例都实现了事件接口，也就是： 使用$on(eventName)监听事件 使用$emit(eventName)触发事件 另外父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件，例子： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;总计：{{total}}&lt;/p&gt; &lt;test v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/test&gt; &lt;br&gt;&lt;br&gt; &lt;test v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/test&gt; &lt;/div&gt; Vue.component('test',{ template:'&lt;button v-on:click=&quot;incrementHandler&quot;&gt;点击增加，目前为{{counter}}&lt;/p&gt;', data:function(){ return { counter:0 } }, methods:{ incrementHandler:function(){ this.counter += 1 this.$emit('increment') } } }) new Vue({ el: '#app', data: { total:0 }, methods:{ incrementTotal:function(){ this.total += 1 } } }) 效果： 当点击任意一个按钮增加时，更新子组件内的counter，同时使用this.$emit向父组件传值，这里没有参数，如果有参数的话在后面加上即可：this.$emit(&quot;func&quot;,parm)。 父组件中引用子组件的地方需要添加v-on:func，其中v-on:func中的func需要与this.$emit(&quot;func&quot;)中的func同名，接着在v-on:func=&quot;func2&quot;中修改func2为父组件的函数即可。简写方式为： @func=&quot;func2&quot; 在某个组件的根元素上监听一个原生事件可以使用.native修饰v-on，比如： &lt;test-title v-on:click.native=&quot;func&quot;&gt;&lt;/test-title&gt; 9.3 关于子组件的data 上面的例子中data不是一个对象而是一个函数，如果data直接返回一个已有对象会影响其他实例，比如修改上面的data为： var counter = { counter:0 } //... data:function(){ return counter } 效果如下： 也就是子组件共享了数据，而修改为： data:function(){ return { counter:0 } } 效果如下： 这是因为返回给每个实例一份独立的拷贝。 ","link":"https://2293736867.github.io/post/vue-xue-xi-bi-ji-si/"},{"title":"每日分享 第36期","content":" 每日鸡汤 早起的鸟儿有虫吃，可惜你是那条虫。 每日冷知识 虽然自1941年以来，烟花在美国佛罗里达州就已经完全违法，但该州数百家商店仍在将烟花卖给所有签署弃权书表示将烟花用于农业，目的是驱除鸟类以令其远离农作物的人。 每日诗词 此花此叶常相映，翠减红衰愁杀人。 ——李商隐《赠荷花》 每日一句 少年，别想你，那个人不是你。 每日音乐 选择失忆-季彦琳 一杯烈酒倒入喉 是你给的温柔 想念翻滚如浪腾 最后更痛 最后的最后 不过是一场梦 心越来越痛 如果回到最初 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 一杯烈酒倒入喉 是你 给的温柔 想念翻滚如浪腾 最后更痛 最后的最后 不过是一场梦 心越来越痛 如果回到最初 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi-36/"},{"title":"JetBrains系列IDE无法输入中文","content":"1 问题描述 环境Linux+fcitx，JetBrains的IDE无法输入中文，包括IDEA，PyCharm，WebStorm，CLion等等。 2 解决方案 Linux下一般使用fcitx进入中文输入，安装的时候教程一般都会提到以下三个环境变量： export XMODIFIERS=&quot;@im=fcitx&quot; export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx 安装的时候一般在~/.bashrc或~/.bash_profile或~/.xprofile中输入以上三个环境变量，这样fcitx就能输入中文了。 但是对于JetBrains的IDE，需要进行全局环境变量的设置，也就是说需要在/etc/profile输入以上三个环境变量，这样就能输入中文了。 ","link":"https://2293736867.github.io/post/jetbrains-xi-lie-ide-wu-fa-shu-ru-zhong-wen/"},{"title":"每日分享 第35期","content":" 每日鸡汤 黑夜从来不会亏待晚睡的人，它会赐予你黑眼圈，和即将猝死的身体。 每日冷知识 土耳其婴儿出生后，被大人拎着腌火腿一样在盐堆里滚几圈，直到浑身满盐才结束。当地人相信，这样可以赋予新生儿抵御疾病的力量。 每日音乐 38度6-黑龙 逃不出你的左右 像鱼在沙里游 明知道没尽头 却不怕头破血流 爱你是海市蜃楼 像泡沫般游走 虚幻和无所求 第一次我见你情难开口心跳在发抖 拥抱这片绿洲 那热烈的温柔 我放弃整个森丽留下眷恋和哀愁 像初见你眼眸 时间停止倒流 我燃烧了宇宙像温度充满了电流 在38度6 逃不出你的左右 像鱼在沙里游 明知道没尽头 却不怕头破血流 爱你是海市蜃楼 像泡沫般游走 虚幻和无所求 第一次我见你情难开口 心跳在发抖 拥抱这片绿洲 那热烈的温柔 我放弃整个森林留下眷恋和哀愁 像初见你眼眸 时间停止倒流 我燃烧了宇宙温度像充满了电流 在38度6 拥抱这片绿洲 那热烈的温柔 我放弃整个森林留下眷恋和哀愁 像初见你眼眸 时间停止倒流 我燃烧了宇宙温度像充满了电流 拥抱到白了头 不放开你的手 我卸下了等候和全部爱你的理由 全世界跟我走 从黑夜到白昼 我唯一的要求我们的爱永远停留 在38度6 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi/"},{"title":"每日分享 第34期","content":" 每日鸡汤 年轻人不要老想着走捷径，父母强才是硬道理。 每日冷知识 土耳其的十二生肖，将龙换成了鳄鱼，其他相同。 每日音乐 黄昏-周传雄 过完整个夏天 忧伤并没有好一些 开车行驶在公路无际无边 有离开自己的感觉 唱不完一首歌 疲倦还剩下黑眼圈 感情的世界伤害在所难免 黄昏再美终要黑夜 依然记得从你口中说出再见坚决如铁 昏暗中有种烈日灼身的错觉 黄昏的地平线 划出一句离别 爱情进入永夜 依然记得从你眼中滑落的泪伤心欲绝 混乱中有种热泪烧伤的错觉 黄昏的地平线 割断幸福喜悦 相爱已经幻灭 唱不完一首歌 疲倦还剩下黑眼圈 感情的世界伤害在所难免 黄昏再美终要黑夜 依然记得从你口中说出再见坚决如铁 昏暗中有种烈日灼身的错觉 黄昏的地平线 划出一句离别 爱情进入永夜 依然记得从你眼中滑落的泪伤心欲绝 混乱中有种热泪烧伤的错觉 黄昏的地平线 割断幸福喜悦 相爱已经幻灭 依然记得从你口中说出再见坚决如铁 昏暗中有种烈日灼身的错觉 黄昏的地平线 划出一句离别 爱情进入永夜 依然记得从你眼中滑落的泪伤心欲绝 混乱中有种热泪烧伤的错觉 黄昏的地平线 割断幸福喜悦 相爱已经幻灭 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-35-qi/"},{"title":"每日分享 第33期","content":" 每日鸡汤 明日复明日，明日何其多！既然这么多，不妨再拖拖。 每日冷知识 土耳其的英文Turkey，另一个意思是火鸡。 每日音乐 有些爱情放不下-唐伯虎 你说着那些美丽的谎话 在我的心上定格成伤疤 你说的那些承诺未抵达 热情就慢慢融化 走不进你描述的那个家 却迷失我幻想的那幅画 深夜里想着你心乱如麻 我的爱旧伤复发 有些爱情真的想放放不下 有些人真的可恨却牵挂 谁的爱对了谁的爱错了 爱本就真真假假 有些爱情真的想放放不下 有些梦真的做的太浮夸 眼泪虽渺小但爱却伟大 告诉我还爱我吗 你说着那些美丽的谎话 在我的心上定格成伤疤 你说的那些承诺未抵达 热情就慢慢融化 走不进你描述的那个家 却迷失我幻想的那幅画 深夜里想着你心乱如麻 我的爱旧伤复发 有些爱情真的想放放不下 有些人真的可恨却牵挂 谁的爱对了谁的爱错了 爱本就真真假假 有些爱情真的想放放不下 有些梦真的做得太浮夸 眼泪虽渺小但爱却伟大 告诉我还爱我吗 有些爱情真的想放放不下 有些人真的可恨却牵挂 谁的爱对了谁的爱错了 爱本就真真假假 有些爱情真的想放放不下 有些梦真的做得太浮夸 眼泪虽渺小但爱却伟大 告诉我还爱我吗 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-34-qi/"},{"title":"每日分享 第32期","content":" 每日鸡汤 加我回来吧，我给你发我的婚礼请柬。 每日冷知识 一项新研究发现，蟒蛇实际上并非通过令猎物窒息而将其杀死，而是通过切断血液循环导致猎物心脏病发作而死。 每日诗词 尽虽设柴门，长是闭斜晖。 ——杨万里《归去来兮引》 每日一句 我们终将在没有黑暗的地方相见。 每日音乐 残雪-蒋蒋 时光它荏苒了所有 它蹉跎了回眸 它和我撒了泼 它揭开我的伤 浑然不知的痛 眼泪滑过所有的梦 绕过你眼神的汹涌 你内心的躁动 你为谁发了疯 我百般的包容 你什么都不懂 却把承诺千穿百孔 你曾说过陪我去看一场雪 我在漫漫黑夜静候你的约 可谁又知道 寒冬守不住枯叶 被风分裂留下一个缺 你说爱情就像缠绵的蝴蝶 注定躲不过昙花残谢的夜 你赌的誓约还可以改写 绕来绕去的结败给了诀别 时光它荏苒了所有 它蹉跎了回眸 它和我撒了泼 它揭开我的伤 浑然不知的痛 眼泪滑过所有的梦 绕过你眼神的汹涌 你内心的躁动 你为谁发了疯 我百般的包容 你什么都不懂 却把承诺千穿百孔 你曾说过陪我去看一场雪 我在漫漫黑夜静候你的约 可谁又知道寒冬守不住枯叶 被风分裂留下一个缺 你说爱情就像缠绵的蝴蝶 注定躲不过昙花残谢的夜 你赌的誓约还可以改写 绕来绕去的结败给了诀别 你曾说过陪我去看一场雪 我在漫漫黑夜静候你的约 可谁又知道 寒冬守不住枯叶 被风分裂留下一个缺 你说爱情就像缠绵的蝴蝶 注定躲不过昙花残谢的夜 你赌的誓约还可以改写 绕来绕去的结败给了诀别 你曾说过陪我去看去看一场雪 我在漫漫黑夜静候静候你的誓约 可谁又知道呢 这寒冬守不住枯叶 我被风分裂留下一个缺缺缺缺缺 你说爱情就像缠缠缠缠绵的蝴蝶 注定躲不过谢了又谢的黑夜 你赌的誓约呢 还怎么能改写 绕来绕去的结败给了诀别 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-33-qi/"},{"title":"每日分享 第31期","content":" 每日鸡汤 爱情是把双刃剑，一边把你割得很疼，另一边也把你割得很疼。 每日冷知识 美洲虎的下颚力量惊人，甚至可以直接从猎物头骨咬其大脑，以此杀死猎物。 每日诗词 更无柳絮因风起，惟有葵花向日倾。 ——司马光《客中初夏》 每日一句 不管风吹浪打，胜似闲庭信步。 每日音乐 玫瑰花的葬礼-许嵩 离开你一百个星期 我回到了这里 寻找我们爱过的证据 没有人愿意提起 玫瑰花它的过去 今天这里的主题 我把它叫作回忆 我知道 爱情这东西 他没什么道理 过去我和你在一起 是我太叛逆 现在只剩我自己 偷偷的想你 玫瑰花的葬礼 埋葬关于你的回忆 感觉双手麻痹 不能自已 已拉不住你 真的好美丽 那天的烟花雨 我说要娶穿碎花洋裙的你 玫瑰花的葬礼 埋葬深深爱着的你 残朵停止呼吸 深入大地 没人会注意 一片小雨滴 陪着我等天明 我用这最后一分钟怀念你 我在夜幕笼罩的天桥上潜行 每一级阶梯 都留着你我昔日印迹 温存迷醉 吵闹清醒 都还在我的脚畔兜兜兜兜兜转转不清 没来得及把红色玫瑰递给你 爱就像是一场雨 已经离我而去 你说过 太过鲜艳的爱情 终将凋零 玫瑰花的葬礼 埋葬关于你的回忆 感觉双手麻痹 不能自已 已拉不住你 真的好美丽 那天的烟花雨 我说要娶穿碎花洋裙的你 玫瑰花的葬礼 埋葬深深爱着的你 残朵停止呼吸 深入大地 没人会注意 一片小雨滴 陪着我等天明 我用这最后一分钟怀念你 总是回想过去埋怨我自己 总是不经意间想起了你 现在的你已经太遥不可及 只能留在我记忆 玫瑰花的葬礼 埋葬关于你的回忆 感觉双手麻痹 不能自已 已拉不住你 真的好美丽 那天的烟花雨 我说要娶穿碎花洋裙的你 玫瑰花的葬礼 埋葬深深爱着的你 残朵停止呼吸 渗入大地 没人会注意 一片小雨滴 陪着我等天明 我用这最后一分钟怀念你 我用这最后一分钟 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-31-qi/"},{"title":"Vue学习笔记（三）","content":"1 监听 在Vue.js中可以通过watch来监听数据的变化，比如通过watch实现的简单计数器： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;计数器：{{count}}&lt;/p&gt; &lt;button @click=&quot;count++&quot;&gt;点我增加&lt;/button&gt; &lt;p id=&quot;info&quot;&gt;&lt;/p&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { count:0 } }) vm.$watch('count',function(newValue,oldValue) { document.getElementById(&quot;info&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue; }) 效果如下： watch有两个参数，一个是要监听的变量，另一个是回调函数，回调函数接受两个参数，第一个参数是新值，第二个参数是旧值。 下面再来看一下有关单位换算的例子： &lt;div id=&quot;app&quot;&gt; 吨：&lt;input type=&quot;text&quot; v-model=&quot;ton&quot;&gt; 千克：&lt;input type=&quot;text&quot; v-model=&quot;kilograms&quot;&gt;&lt;br&gt; 吨：&lt;p id=&quot;tonInfo&quot;&gt;&lt;/p&gt; 千克：&lt;p id=&quot;kilogramsInfo&quot;&gt;&lt;/p&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { ton:0, kilograms:0 }, watch: { ton:function(val) { this.kilograms = (this.ton = val) * 1000; }, kilograms:function(val) { this.ton = (this.kilograms = val) / 1000; } } }) vm.$watch('ton',function(newValue,oldValue) { document.getElementById(&quot;tonInfo&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue; }) vm.$watch('kilograms',function(newValue,oldValue) { document.getElementById(&quot;kilogramsInfo&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue; }) 2 样式绑定 class与style是HTML元素的属性，用于设置元素的样式，可以利用v-bind来设置样式属性。v-bind在处理class以及style时专门增强了，表达式的结果类型除了是字符串外，还能是对象或者数组。 2.1 class绑定 可以为v-bind:class设置一个对象，从而动态切换class： &lt;style&gt; .active { width:100px; height: 100px; background: green; } &lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;{'active':isActive}&quot;&gt;&lt;/div&gt; &lt;/div&gt; vm = new Vue({ el: '#app', data: { isActive:true } }) 也可以传入多个属性来动态切换多个class： .class0 { width:100px; height: 100px; } .class1 { background: green; } .class2 { background: red; } &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;class0&quot; v-bind:class=&quot;{'class1':active1,'class2':active2}&quot;&gt;&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { active1:true, active2:true } }) 效果： 也可以利用对象进行简化： &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;class0&quot; v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { classObject: { class1:true, class2:true } } }) 2.2 计算属性 在v-bind:class中除了是一个对象还能绑定返回对象的计算属性，比如： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { active1:true, error:{ value:true, type:'fatal' } }, computed:{ classObject:function() { return { class0:true, class1: this.active1 &amp;&amp; !this.error.value, class2: this.error.value &amp;&amp; this.error.type === 'fatal' } } } }) 效果如下： 2.3 数组 也可以传递给v-bind:class一个数组，数组的元素为变量，变量的内容为对应的CSS类名： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;[active1,active2]&quot;&gt;&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { active1:'class0', active2:'class1' } }) 也可以利用三元表达式来切换： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;[active1,active2 ? 'class1' : 'class2']&quot;&gt;&lt;/div&gt; &lt;/div&gt; 3 内联样式 可以在v-bind:style中直接设置样式（注意前后带{}）： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;{color:color,fontSize:fontSize+'px'}&quot;&gt;测试&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { color:'#FF0000', fontSize:30 } }) 当然也可以像绑定class一样直接绑定到一个对象上： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;styleObject&quot;&gt;测试&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { styleObject: { color:'#FF0000', fontSize:'30px' } } }) 也可以使用数组进行绑定多个样式： &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;[styleObject1,styleObject2]&quot;&gt;测试&lt;/div&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { styleObject1: { color:'#FF0000', }, styleObject2:{ fontSize:'30px' } }# 5 }) 另外当v-bind:style需要特殊前缀的CSS时，比如transform，Vue会自动侦测并添加相应前缀。 4 事件处理 4.1 v-on 事件监听可以使用v-on： &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;count += 1&quot;&gt;点击增加1&lt;/button&gt; &lt;p&gt;这个按钮被点击了{{count}}次&lt;/p&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', data: { count:0 } }) 通常来说单击按钮会触发一个方法调用，在methods中指定即可： &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;test&quot;&gt;点击触发事件&lt;/button&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', methods:{ test:function(){ alert('Hello') //event表示是原生DOM事件 if(event) { alert(event.target.tagName) } } } }) 当然也可以使用内联的JS语句： &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;say('hi')&quot;&gt;Say hi&lt;/button&gt; &lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', methods:{ say:function(val){ alert(val) } } }) 4.2 事件修饰符 Vue为v-on提供了事件修饰符来处理DOM事件细节，如event.preventDefault()或event.stopPropagation()，通过.表示的指令调用修饰符： .stop：阻止事件冒泡 .prevent：提交事件不再重载页面，如&lt;form v-on.submit.prevent=&quot;onSumbit&quot;&gt;&lt;/form&gt; .capture：事件捕获模式 .self：只当事件在该元素本身（而不是子元素）触发时回调 .once：事件只能点击一次 4.3 按键修饰符 Vue允许在v-on在监听键盘事件时添加按键修饰提示符： &lt;!--只有keyCode为13时调用submit()--&gt; &lt;input v-on:keyup.13=&quot;submit&quot;&gt; keyCode值对应ASCII表，为了方便，Vue为常用的按键提供了别名： .esc .delete（删除+退格） .enter/.space/.tab .up/.down/.left/.right .ctrl/.alt/.shift/.meta 当然也可以进行按键的组合，使用.连接即可。 例子如下： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请按下空格&quot; v-on:keyup.space=&quot;spacePressed&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请按下Ctrl+C&quot; v-on:keyup.ctrl.67=&quot;ctrlCPressed&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; placeholder=&quot;请按下Ctrl+C&quot; @keyup.ctrl.67=&quot;ctrlCPressed&quot;&gt; --&gt; &lt;p id=&quot;info&quot;&gt;&lt;/p&gt; &lt;/div&gt; var vm = new Vue({ el: '#app', methods:{ spacePressed:function(){ document.getElementById(&quot;info&quot;).innerHTML = &quot;您按下了空格&quot;; }, ctrlCPressed:function(){ document.getElementById(&quot;info&quot;).innerHTML = &quot;您按下了Ctrl+C&quot;; } } }) ","link":"https://2293736867.github.io/post/vue-xue-xi-bi-ji-san/"},{"title":"设计模式学习笔记（八）：建造者模式","content":" 1 概述 1.1 引言 1.2 复杂对象 1.3 定义 1.4 结构图 1.5 角色 2 典型实现 2.1 步骤 2.2 产品角色 2.3 抽象建造者 2.4 具体建造者 2.5 导演类 2.6 客户端 3 实例 4 优化 4.1 省略Director 4.2 钩子方法 4.3 返回Builder 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需的建造者类型即可。建造者模式关注一步一步地创建一个复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。 1.2 复杂对象 建造者模式中用到了复杂对象这个概念。 复杂对象就是指那些包含多个成员变量的对象，这些成员变量也叫部件或者零件，例如汽车包括方向盘，发动机，轮胎等 ， 汽车就是复杂对象，方向盘，发动机以及轮胎就是汽车的部件。 1.3 定义 建造者模式：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一种对象创建型模式。 1.4 结构图 1.5 角色 建造者模式包含以下四个角色： Builder（抽象建造者）：为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类是buildXXX()方法，用于创建复杂对象的各个部分（部件），另一类是是getResult()，用于返回复杂对象。Builder既可以是抽象类，也可以是接口 ConcreteBuilder（具体建造者）：实现了Builder接口或者继承了Builder类，实现各个部件的具体构造和装配方法，定义并明确其所创建的复杂对象，也可以提供一个方法返回创建好的复杂对象 Product（产品角色）：是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义其装配过程 Director（指挥者）：指挥者又叫导演类，复杂安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造以及装配方法，完成复杂对象的建造。客户端一般只需要与导演类进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象，然后通过导演类的构造函数或者setter将该对象传入导演类中 2 典型实现 2.1 步骤 定义产品角色：一般为复杂对象 定义抽象建造者：根据产品角色确定bulidXXX的数量，同时声明类似getResult返回产品角色对象的方法 定义具体建造者：实现抽象建造者中的buildXXX方法 定义导演类：通过构造方法或者setter注入抽象建造者，提供类似construct的方法给外界，调用具体建造者的方法并返回产品角色对象 2.2 产品角色 一般来说Product是一个复杂对象，典型的实现如下： class Product { private type1 part1; private type2 part2; private type3 part3; //getter + setter ... } 其中type1，type2等指各种不同的类型，一般来说会有嵌套类。 2.3 抽象建造者 抽象建造者的典型实现如下： abstract class Builder { protected Product product = new Product(); public abstract void buildPart1(); public abstract void buildPart2(); public abstract void buildPart3(); public Product getResult() { return product; } } 抽象建造者中声明了一系列buildXXX方法，用于创建Product的各个部件，具体创建过程在ConcreteBuilder中实现，getResult()返回已创建完成的Product。 2.4 具体建造者 ConcreteBuilder实现了Builder中的buildXXX方法，通过调用Product的setter来实现给产品对象的各部分赋值。 不同的ConcreteBuilder在实现buildXXX时将有所区别，比如传入Product的setter参数的不同。 另外在有些ConcreteBuilder中某些buildXXX无须实现（提供一个空实现），这些对客户端来说无须关心，客户端只需要知道具体建造者的类型即可。 典型实现如下： class ConcreteBuilder extends Builder { public void buildPart1() { product.setPart1(&quot;part1&quot;); } public void buildPart2() { product.setPart2(&quot;part2&quot;); } public void buildPart3() { product.setPart3(&quot;part3&quot;); } } 2.5 导演类 Director类主要有两个作用： 隔离了客户与创建过程 控制产品的创建过程，包括某个buildXXX方法是否被调用，以及调用时的先后次序等等 指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者调用建造者的相关方法，返回一个完整的产品对象。典型实现如下： class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void setBuilder(Builder builder) { this.builder = builder; } public Product construct() { builder.buildPart1(); builder.buildPart2(); builder.buildPart3(); return builder.getResult(); } } 2.6 客户端 创建具体建造者并传入导演类作为构造方法参数，然后调用construct即可获取产品对象： public static void main(String[] args) { Director director = new Director(new ConcreteBuilder()); Product product = director.construct(); System.out.println(product.getPart1()); } 3 实例 游戏角色的创建：不同的角色具有差别极大的外部特征，而且要求随着游戏的进行会不断出现新的角色，也就是说扩展性要好。这里例子简化就创建三个角色：英雄，天使与恶魔，使用建造者模式进行设计。 设计如下： 产品对象：Actor 抽象建造者：ActorBuilder 具体建造者：HeroBuilder+AngelBuilder+DevilBuilder 指挥者：ActorController 代码如下： // 复杂产品 class Actor { private String type; private String face; private String costume; private String hairstyle; //getter and setter ... } //抽象建造者 abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor createActor() { return actor; } } //具体建造者 class HeroBuilder extends ActorBuilder { public void buildType(){ actor.setType(&quot;英雄&quot;); } public void buildFace(){ actor.setFace(&quot;英俊&quot;); } public void buildCostume(){ actor.setCostume(&quot;盔甲&quot;); } public void buildHairstyle(){ actor.setHairstyle(&quot;飘逸&quot;); } } class AngleBuilder extends ActorBuilder { public void buildType(){ actor.setType(&quot;天使&quot;); } public void buildFace(){ actor.setFace(&quot;漂亮&quot;); } public void buildCostume(){ actor.setCostume(&quot;白裙&quot;); } public void buildHairstyle(){ actor.setHairstyle(&quot;披肩长发&quot;); } } class DevilBuilder extends ActorBuilder { public void buildType(){ actor.setType(&quot;恶魔&quot;); } public void buildFace(){ actor.setFace(&quot;帅气&quot;); } public void buildCostume(){ actor.setCostume(&quot;黑衣&quot;); } public void buildHairstyle(){ actor.setHairstyle(&quot;红色&quot;); } } // 指挥者类 class ActorController { public Actor construct(ActorBuilder builder) { builder.buildType(); builder.buildFace(); builder.buildHairstyle(); builder.buildCostume(); return builder.createActor(); } } 测试类： public class Test { public static void main(String[] args) { ActorBuilder builder = new AngleBuilder(); ActorController controller = new ActorController(); Actor actor = controller.construct(builder); System.out.println(actor.getType()); System.out.println(actor.getCostume()); System.out.println(actor.getHairstyle()); System.out.println(actor.getFace()); } } 4 优化 4.1 省略Director 其实Director是可以省略的，直接与Builder合并，在Builder中提供类似Direcotr中的construct()方法，并定义为静态方法，如： abstract class ActorBuilder { protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public static Actor build(ActorBuilder builder) { builder.buildType(); builder.buildFace(); builder.buildHairstyle(); builder.buildCostume(); return actor; } } 同时客户端代码修改如下： Actor actor = ActorBuilder.build(new AngleBuilder()); //Actor actor = ActorBuilder.build(new HeroBuilder()); //Actor actor = ActorBuilder.build(new DevilBuilder()); 再简单一点的可以省略createActor中的参数： abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor build() { buildType(); buildFace(); buildHairstyle(); buildCostume(); return actor; } } 同时客户端简化如下： Actor actor = new AngleBuilder().build(); 这两种方式简化了系统结构的同时又不影响灵活性以及可扩展性，但是加重了抽象建造者的职责，如果build方法较为复杂，待构建的产品组成部分较多，建议还是将其单独封装在Director中，这样更加符合SRP（单一权责原则）。 4.2 钩子方法 钩子方法是一种可以控制是否调用某个buildXXX的方法，特征如下： 返回类型为boolean 方法名一般为isXXX 例如修改ActorBuilder如下： abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public boolean isBareheaded() { return false; } public Actor createActor() { return actor; } } 并修改DevilBuilder，覆盖默认方法： class DevilBuilder extends ActorBuilder { public void buildType(){ actor.setType(&quot;恶魔&quot;); } public void buildFace(){ actor.setFace(&quot;帅气&quot;); } public void buildCostume(){ actor.setCostume(&quot;黑衣&quot;); } public void buildHairstyle(){ actor.setHairstyle(&quot;红色&quot;); } public boolean isBareheaded(){ return true; } } 最后修改ActorController： class ActorController { public Actor construct(ActorBuilder builder) { builder.buildType(); builder.buildFace(); builder.buildCostume(); if(builder.isBareheaded()) builder.buildHairstyle(); return builder.createActor(); } } 相比起之前的ActorController多了一次判断，测试如下： public static void main(String[] args) { ActorController controller = new ActorController(); Actor actor = controller.construct(new AngleBuilder()); System.out.println(actor.getType()); System.out.println(actor.getCostume()); System.out.println(actor.getHairstyle()); System.out.println(actor.getFace()); System.out.println(); actor = controller.construct(new DevilBuilder()); System.out.println(actor.getType()); System.out.println(actor.getCostume()); System.out.println(actor.getHairstyle()); System.out.println(actor.getFace()); } 输出如下： 4.3 返回Builder 在实际应用中Director较少出现，通常只有Builder以及Product，而且Builder是作为Product的内部类，提供一系列set方法，这些set方法返回一个Builder方便后续调用，最后以一个build()结尾，比如OkHttp中的Request/OkHttpClient： OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(5000,TimeUnit.MILLISECONDS) .readTimeout(10,TimeUnit.SECONDS) .build(); Request request = new Request.Builder() .url(&quot;https://xxx&quot;) .post(requestBody) .build(); 5 主要优点 封装细节：建造者模式中客户端不需要知道产品内部组成细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 扩展性好：每一个具体建造者都相对独立，而与其他建造者无关，伊尼茨可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，扩展方便，符合开闭原则 控制创建过程：将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，更加精细地控制创建过程 6 主要缺点 范围受限：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分不相同，就不适合使用建造者模式，因此使用范围收到一定限制 建造者多：如果产品内部结构复杂多变，可能会需要定义很多具体建造者类来实现这种变化，增大系统的理解难度与运行成本 7 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量 需要生成的产品对象的属性相互依赖，需要指定其生成顺序 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不再建造者类或者客户类中 隔离复杂对象的创建与使用，并使得相同的创建过程可以创建不同的产品 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-ba-jian-zao-zhe-mo-shi/"},{"title":"每日分享 第30期","content":" 每日鸡汤 知道为何自古红颜多薄命吗？因为没人在意丑的人活多久。 每日冷知识 为了便于将石料运到现场，建造北京紫禁城的工人修建了一条冰路。这条冰路通过雪橇运输石料，以水进行润滑，从而减少摩擦，并使雪橇在水重新冷冻之前更容易滑动。 每日诗词 白发渔樵江渚上，惯看秋月春风。 ——杨慎《临江仙·滚滚长江东逝水》 每日一句 末将于禁，愿为曹家世代赴汤蹈火。 每日音乐 我热情如火，你冰冻成河-黄静美 我该如何去厮守 你才觉得不将就 互相折磨到白头 渐渐消逝的温柔 难道非你不可 是有多难得 这样的感情对我来说 或许不知道 自己到底要的是什么 遇见你就像飞蛾扑火 不管值不值得 最美的承诺 只是一时快乐惹的祸 而如今只剩孤独的我 注定没有结果 我懂你要的自由 别再惯性找借口 你从未被我拥有 随时都可能放开手 而我热情如火 你冰冻成河 被爱的权利你都占有 我该如何去厮守 你才觉得不将就 互相折磨到白头 渐渐消逝的温柔 难道非你不可 是有多难得 这样的感情对我来说 不值得 或许不知道 自己到底要的是什么 遇见你就像飞蛾扑火 不管值不值得 最美的承诺 只是一时快乐惹的祸 而如今只剩孤独的我 注定没有结果 我懂你要的自由 别再惯性找借口 你从未被我拥有 随时都能放开手 而我热情如火 你冰冻成河 被爱的权利你都占有 我该如何厮守 你才觉得不将就 互相折磨到白头 渐渐消逝的温柔 难道非你不可 是有多难得 这样的感情对我来说 我懂你要的自由 别再惯性找借口 你从未被我拥有 随时都能放开手 而我热情如火 你冰冻成河 被爱的权利你都占有 我该如何去厮守 你才觉得不将就 互相折磨到白头 渐渐消逝的温柔 难道非你不可 是有多难得 这样的感情对我来说 不值得 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-30-qi/"},{"title":"设计模式学习笔记（七）：原型模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象原型类 2.3 具体原型类 2.3.1 通用实现方法 2.3.2 clone 2.4 客户类 3 实例 4 浅克隆与深克隆 4.1 浅克隆 4.2 深克隆 5 原型管理器 5.1 定义 5.2 实例 6 主要优点 7 主要缺点 8 适用场景 9 总结 1 概述 1.1 引言 对于某些岗位来说，工作周报的内容会大同小异，如果用户每次都需要从空白的周报进行输入无疑会浪费用户很多的时间，如果周报能够按照用户的自定义来生成模板，或者从已有模板修改小部分得到新模板，这样用户的输入效率会大大提高。原型模式正是为解决这类问题而生。 1.2 定义 原型模式：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。 原型模式是一种对象创建型模式。 原型模式的工作原理很简单，将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。原型模式是一种另类的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法实现。 通过克隆方法创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆多产生的对象进行的修改不会对原型对象造成任何的影响，每一个克隆的对象都是相互独立的，通过不同的方式对克隆对象进行修改之后，可以得到一系列相似但不完全相同的对象。 1.3 结构图 1.4 角色 Prototype（抽象原型类）：声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，还能是具体实现类 ConcretePrototypr（具体原型类）：实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象 Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。 2 典型实现 2.1 步骤 定义抽象原型类：定义为接口/抽象类，至少需要定义一个类似clone的方法 定义具体原型类：实现/继承抽象原型类，核心是实现其中的clone 定义客户类：针对抽象原型类编程，首先需要通过实例化或工厂方法等创建一个原型对象，接着通过其中的clone方法获取多个对象 2.2 抽象原型类 这里定义为接口： interface Prototype { Prototype clone(); String getAttr(); void setAttr(String attr); } 2.3 具体原型类 实现抽象原型接口，核心在于如何实现clone，在Java中clone通常有两种实现方式： 通用实现方法 clone()方法 2.3.1 通用实现方法 通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证成员变量相同。 代码如下： class ConcretePrototype implements Prototype { private String attr; @Override public String getAttr() { return this.attr; } @Override public void setAttr(String attr) { this.attr = attr; } @Override public Prototype clone() { Prototype = new ConcretePrototype(); prototype.setAttr(attr); return prototype; } } 2.3.2 clone java.lang.Object提供了一个clone()，可以将一个Java对象克隆一份，利用clone()可以直接将对象克隆一份，但是必须实现Cloneable接口，否则clone()时会抛出CloneNotSupportedException。 代码如下： class ConcretePrototype implements Prototype,Cloneable { private String attr; public String getAttr() { return this.attr; } public void setAttr(String attr) { this.attr = attr; } public Prototype clone() { Object object = null; try { object = super.clone(); } catch (Exception e) { e.printStacktrace(); } return (Prototype)object; } } 一般而言，Java中的clone()满足： 对任何对象x都有x.clone() != x，也就是克隆的对象与原型对象不是同一个对象 对任何对象x都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样 如果x的equals()定义恰当，那么x.clone().equals(x)应该成立 具体实现步骤如下： 覆盖clone()，并声明为public clone()中调用super.clone() 派生类需要实现Cloneable接口 2.4 客户类 客户类针对抽象原型类编程，通过实例化获取具体原型后，调用其中的clone进行克隆： public class Test { public static void main(String[] args) { Prototype prototype1 = new ConcretePrototype(); prototype1.setAttr(&quot;test&quot;); Prototype prototype2 = prototype1.clone(); System.out.println(prototype1.getAttr() == prototype2.getAttr()); System.out.println(prototype1 == prototype2); } } 3 实例 开发一个工作周报系统，工作周报的内容都大同小异，只有一些小地方存在差异，但是系统每次默认创建的都是空白报表，用户不断复制粘贴来填写重复内容。使用原型模式对其进行优化，快速创建相同或类似的工作周报。 设计如下： 抽象原型类：无（也可以认为是Object） 具体原型类：WeeklyLog 代码如下： public class Test { public static void main(String[] args) { WeeklyLog weeklyLog1 = new WeeklyLog(); weeklyLog1.setContent(&quot;content&quot;); weeklyLog1.setName(&quot;Weekly log 1&quot;); weeklyLog1.setDateTime(LocalDateTime.now()); System.out.println(weeklyLog1.getName()); System.out.println(weeklyLog1.getContent()); System.out.println(weeklyLog1.getDateTime()); WeeklyLog weeklyLog2 = weeklyLog1.clone(); weeklyLog2.setName(&quot;Weekly log 2&quot;); System.out.println(weeklyLog2.getName()); System.out.println(weeklyLog2.getContent()); System.out.println(weeklyLog2.getDateTime()); } } class WeeklyLog implements Cloneable { private String name; private LocalDateTime dateTime; private String content; //getter and setter //... public WeeklyLog clone() { Object obj = null; try { obj = super.clone(); } catch(Exception e) { e.printStackTrace(); } return (WeeklyLog)obj; } } 4 浅克隆与深克隆 一般来说，工作周报可能会携带附件，使用上面的原型模式来进行工作周报的复制没有问题，但是附件（一般是另一个类）不会进行复制。这是因为浅克隆与深克隆的原因，下面具体来看一下。 4.1 浅克隆 在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象。（在Java中）值类型包括： int double byte boolean char float long short 也就是这些类型的值都会完整复制一份给克隆对象，对于引用类型，则将引用对象的地址复制一份给克隆对象。（在Java中）引用类型就是除了基本类型之外的所有类型，常见的有： 类 接口 数组 对于引用类型，原型对象与克隆对象指向相同的内存地址，也就是其实并没有被复制，而是共享一份地址相同的值。 在Java中可以通过Object的clone()实现浅克隆，也就是上面例子的做法。 4.2 深克隆 在深克隆中，无论变量是值类型还是引用类型都会完整复制一份给克隆对象。 在Java中实现深克隆可以通过序列化等方式实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制品，而原对象仍然存在于内存中。想要进行序列化必须实现Serializable接口。 代码如下： public class Test { public static void main(String[] args) { WeeklyLog weeklyLog1 = new WeeklyLog(); WeeklyLog weeklyLog2 = null; Attachement attachement = new Attachement(); weeklyLog1.setAttachement(attachement); try { weeklyLog2 = weeklyLog1.deepClone(); } catch(Exception e) { e.printStackTrace(); } System.out.println(weeklyLog1 == weeklyLog2); System.out.println(weeklyLog1.getAttachement() == weeklyLog2.getAttachement()); } } class Attachement implements Serializable { private String name; //getter and setter //... } class WeeklyLog implements Serializable { private String name; private LocalDateTime dateTime; private String content; private Attachement attachement; //getter and setter //... public WeeklyLog deepClone() throws IOException , ClassNotFoundException , OptionalDataException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); return (WeeklyLog)objectInputStream.readObject(); } } 当然除了使用ByteArrayOutput/InputStream以及ObjectInput/OutputStream外，还可以利用以下工具类进行深克隆： org.apache.commons.lang3.SerializationUtils.clone()：需要实现Serializable接口 Gson：无需实现Serializable接口，toJson()+fromJson() Jackson：也是无需实现Serializable接口，readValue()+writeValueAsString()等 5 原型管理器 5.1 定义 原型管理器是将多个原型对象存储在一个集合中供客户端使用的专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的克隆，可以通过复制集合中对应的原型对象来获取。在原型管理器中针对抽象原型类进行编程。 结构图如下： 5.2 实例 日常办公中会有许多公文需要创建，例如《可行性分析报告》，《立项建议书》，《软件需求规格说明书》，《项目进展报告》等，为了提高工作效率需要为各类公文创建模板，用户可以通过这些模板快速创建新的公文，这些公文模板进行统一的管理，系统根据用户的请求的不同生成不同的新公文。 首先是抽象原型以及具体原型的代码： interface OfficialDocument extends Cloneable { OfficialDocument clone(); void display(); } //可行性分析报告 class FAR implements OfficialDocument { public OfficialDocument clone() { OfficialDocument far = null; try { far = (OfficialDocument)super.clone(); } catch(Exception e) { e.printStackTrace(); } return far; } public void display() { System.out.println(&quot;可行性分析报告&quot;); } } //软件需求规格说明书 class SRS implements OfficialDocument { public OfficialDocument clone() { OfficialDocument srs = null; try { srs = (OfficialDocument)super.clone(); } catch(Exception e) { e.printStackTrace(); } return srs; } public void display() { System.out.println(&quot;软件需求规格说明书&quot;); } } 接着是原型管理器的代码，使用枚举单例实现： enum PrototypeManager { INSTANCE; private Hashtable&lt;String,OfficialDocument&gt; hashtable = new Hashtable&lt;&gt;(); private PrototypeManager() { add(&quot;far&quot;,new FAR()); add(&quot;srs&quot;,new SRS()); } public void add(String key,OfficialDocument document) { hashtable.put(key, document); } public OfficialDocument get(String key) { return ((OfficialDocument)hashtable.get(key)).clone(); } } 测试代码： public class Test { public static void main(String[] args) { PrototypeManager manager = PrototypeManager.INSTANCE; OfficialDocument document1,document2,document3,document4; document1 = manager.get(&quot;far&quot;); document1.display(); document2 = manager.get(&quot;far&quot;); document2.display(); System.out.println(document1 == document2); document3 = manager.get(&quot;srs&quot;); document3.display(); document4 = manager.get(&quot;srs&quot;); document4.display(); System.out.println(document3 == document4); } } 6 主要优点 简化创建过程：当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好：由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对系统都没有任何影响 简化创建结构：原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无需专门的工厂类来创建产品 保存状态：可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作 7 主要缺点 修改不方便：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造的时候，需要修改源代码，违背了OCP（开放闭合原则） 深克隆需要嵌套类支持：在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象都必须支持深克隆，实现起来可能比较麻烦 8 适用场景 创建新对象成本较大，比如初始化需要较长时间，占用太多的CPU资源或网络资源，新的对象可以通过原型模式对已有对象进行复制获取，如果是相似对象可以对成员变量稍作修改 如果系统要保存对象的状态，而对象的变化状态很小，或者对象本身占用内存较少，可以使用原型模式配合备忘录模式 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个实例方便 9 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-qi-yuan-xing-mo-shi/"},{"title":"每日分享 第29期","content":" 每日鸡汤 又一天过去了，怎么样，是不是梦想更遥远了？ 每日冷知识 为阻止俄罗斯潜艇入境，瑞典和平雨仲裁协会创造了一种名为“唱歌水手”打指示牌，指示牌显示着一个身穿紧身内裤打水手扭动臀部打动画，同时以莫尔斯电码播报：“是同性恋就往这边开”。 每日诗词 端午临中夏，时清日复长。 ——李隆基《端午》 每日一句 我听到水流进入我打身体，我听到阳光穿透海面。 每日音乐 ブルーバード（青鸟）-いきものがかり 飛翔いたら戻らないと言って 目指したのは 蒼い 蒼い あの空 “悲しみ”はまだ覚えられず “切なさ”は今つかみはじめた あなたへと抱く この感情も 今“言葉”に変わっていく 未知なる世界の 遊迷(ゆめ)から目覚めて この羽根を広げ 飛び立つ 飛翔(はばた)いたら 戻らないと言って 目指したのは 白い 白い あの雲 突き抜けたら みつかると知って 振り切るほど 蒼い 蒼い あの空 蒼い 蒼い あの空 蒼い 蒼い あの空 愛想尽きたような音で 錆びれた古い窓は壊れた 見飽きたカゴは ほら捨てていく 振り返ることはもうない 高鳴る鼓動に 呼吸を共鳴(あず)けて この窓を蹴って 飛び立つ 駆け出したら 手にできると言って いざなうのは 遠い 遠い あの声 眩しすぎた あなたの手も握って 求めるほど 蒼い 蒼い あの空 墜ちていくと わかっていた それでも 光を追い続けていくよ 飛翔(はばた)いたら 戻らないと言って 探したのは 白い 白い あの雲 突き抜けたら みつかると知って 振り切るほど 蒼い 蒼い あの空 蒼い 蒼い あの空 蒼い 蒼い あの空 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-29-qi/"},{"title":"每日分享 第28期","content":" 每日鸡汤 如果你变成了备胎，请忘记你也是千斤顶。 每日冷知识 在秘密战争（1959-1975）或称“老挝内战”期间，美国对这个小小打东南亚国家进行了超过50万次飞行任务，投下的炸弹数量超过了第二次世界大战对德国和日本的总和。 每日诗词 空床卧听南窗雨，谁复挑灯夜补衣。 ——贺铸《半死桐·重过阊门万事非》 每日一句 相恨不如潮有信，相思始觉海非深。 每日音乐 Don't let me know-iKON 난 모르게 해줘요 너무 사랑해서 자랑하고 싶은 그런 사람 만나도 난 모르겠어요 너만큼 애틋한 사람을 만날 수 있을까 걱정돼 알아요 우리가 했던 그 모든 순간 이제는 그와 나누겠죠 그래도 제발 처량한 내가 모르게 해줘요 아직 가슴속에 아직 가슴속에 네가 가득해서 네가 가득해서 다른 누군가를 다른 누군가를 채울 수가 없어 난 모르게 해줘요 너무 사랑해서 자랑하고 싶은 그런 사람 만나도 난 모르겠어요 너만큼 애틋한 사람을 만날 수 있을까 걱정돼 내가 모르게 아직은 괜찮지가 않아요 나도 모르게 마음이 저릴까 봐 겁나요 난 모르게 해줘요 Yeah 당신의 아름다움을 혼자 담아내기에 나의 그릇이 너무 작아서 놓치다 못해 엎질러지고 야속하게 물처럼 흩어져 너는 괜찮은 사람 만나 내가 행복할 거라 생각하면 기쁘기는 하다만 왠지 맘 한켠이 아파 아직 가슴속에 아직 가슴속에 네가 가득해서 네가 가득해서 다른 누군가를 다른 누군가를 채울 수가 없어 난 모르게 해줘요 너무 사랑해서 자랑하고 싶은 그런 사람 만나도 난 모르겠어요 너만큼 애틋한 사람을 만날 수 있을까 걱정돼 내가 모르게 아직은 괜찮지가 않아요 나도 모르게 마음이 저릴까 봐 겁나요 난 모르게 해줘요 좋아요 그대가 웃어서 아파요 난 그러지 못해서 함께 했었던 그 시절에서 벗어나질 못해요 내가 모르게 아직은 괜찮지가 않아요 나도 모르게 마음이 저릴까 봐 겁나요 Oh oh oh oh oh oh oh Oh oh oh oh oh oh oh Oh oh oh oh oh oh oh Oh oh oh oh oh oh oh 난 모르게 해줘요 너무 사랑해서 자랑하고 싶은 그런 사람 만나도 난 모르겠어요 너만큼 애틋한 사람을 만날 수 있을까 걱정돼 난 모르게 해줘요 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-28-qi/"},{"title":"每日分享 第27期","content":" 每日鸡汤 瘦的人能把衣服穿出故事，胖的人只能穿成事故。 每日冷知识 海马没有胃，只有肠子可以从食物中吸收营养。因此食物会迅速通过其消化系统，导致它们必须几乎不断进食。 每日诗词 纷纷红紫已成尘，布谷声中夏令新。 ——陆游《初夏绝句》 每日一句 爱欲于人，犹如执炬，逆风而行，必有烧手之患。 每日音乐 独留世上-小甜（你的酒馆对我打了烊粤语） 是那天 多恩爱的一双 但这刻 竟通话都牵强 明白爱情死了 不必开口讲原谅 情像酒馆打烊门关上 留下此生不必还的账 能自欺不松开谁手掌 紧抱残像 来独留世上 情是苦酒一杯像砒霜 尝尽刻骨穿心和冷枪 然后撕开伤口来欣赏 无关我那样 说过那些天老地长 日后换作凄凉 如同无恙 我半醉半醒 挤笑扮欢畅 梦里断肠 未够伤 小小擦损轻伤 愉快些 请关掉供的氧 明白爱情死了 不必开口说原谅 情像酒馆打烊门关上 留下此生不必还的账 能自欺不松开谁手掌 紧抱残像 来独留世上 情是苦酒一杯像砒霜 尝尽刻骨穿心和冷枪 然后撕开伤口来欣赏 无关我那样 请你请你补上那一枪 你我方算美好绝唱 想你想你不过渐变凉 气数早已结出寒霜 情像酒馆打烊门关上 留下此生不必还的账 谁亦不必捉紧谁手掌 应要拍掌 能独留世上 情是苦酒一杯像砒霜 吸取寂寞做绝望营养 当作喜剧落幕便散场 无关我那样 然后安息于心房中央 无关我那样 印度神油 起源 印度神油真的来自印度吗？ 就像阿拉伯数字不是阿拉伯人发明一样，印度神油其实并不来自印度，产自中国香港。 1958年，何敏森，何敏祯两兄弟在香港九龙办了一个叫“华仁行”的化工厂： 主要产品包括杀虫剂，脚气喷雾，药膏等，当时有一个著名的黑旋风广告： 月黑风高夜，黑旋风忍者为民除害，唔使用剑嘎，用黑旋风就得嘞 ——黑旋风够晒威，黑旋风的确好使 至于印度神油，则是何敏森的灵感之作。第一代印度神油如下： 多年后的华仁行老员工透露：所有的成为都是自己配出来的，主要是一些有麻醉作用的药物，跟真正的印度半毛钱关系也没有。 至于为什么安上印度的名号，大概是因为印度宗教与性文化。 印度几乎所有的宗教，文化和艺术都起源于《吠陀经》，在吠陀教传统中，性是永无终结的。人们对将对性的信奉和拒绝当作决定灵魂存亡的措施，无论是印度教教徒还是佛教教徒都信仰“投胎转世”的人生轮回说，认为人死后灵魂可变成人或动物继续存在。而性就是人类这种人生轮回的一个重要部分，尤其在印度教是继承了印度土著居民达罗毗茶人的生殖文化和雅利安人的自然崇拜传统而产生的一种宗教，他们都认为生殖与性欲就是人生最关键的连接点。 尽管印度教和佛教都有禁欲主义传统，但是在大量的典籍中却发现这些宗教与性文化有千丝万缕的联系，而这些典籍中的记载也令人寻味，也就知道这些宗教禁欲却不禁性。他们只是认为人应该放弃对性自由，婚姻和家庭三种乐欲的追求，这样才能去往极乐世界，而性本身确实天堂必经之路。由此可以看出禁欲与禁性是完全不同的两个概念，而佛教在传入中国时却对于性是完全禁止，这是因为佛教为了在中国生存和更好的传播并发展延续而不得不与中国文化传统习俗相融合，逐渐改变修缮佛教中的教义，向中国根深蒂固的儒家文化让步，以求妥协和彼此融合。中国的佛教更多的是带有中国儒家文化色彩，而这也是为什么佛教能在中国发扬光大而在印度本土逐渐衰落的原因之一。而与印度接壤的西藏却更接近于原来的印度佛教，并有了藏传佛教中的密宗一支。 印度人虽然撰写了第一本集“爱”与“性”为一体的《爱经》，但他们却总是将“爱”与“性”完全分开，认为真正的爱应该是无师自通的人类本能，无需任何指导，相反“性”却需要强调技巧。因而，印度关于性问题的书籍中常常用最主要的篇幅来介绍“无爱的性技巧”，即使《爱经》一书也明显反映出这一倾向。 大多的宗教尽管互不相干，却也在长期的历史沿革中不断吸收和相互的影响着。如佛教中的密宗，其中就有一个欢喜佛。在笈多王朝（320年-600年）以后，佛教在印度本土日益衰微，几乎没有立足之地，印度教日趋强盛，几乎控制了印度大部分地区，尤其在南印度，基本都是印度教的势力范围。尽管在古印度帕拉王朝（750-1150年）的庇护统治下，佛教又保存了一段较长的时期，但是为了发展和延续，不得不吸收了大量的印度教的内容，衍变为密宗。 密教也称坦罗多教，坦罗多的词根tan的原义就是生殖，繁衍。在密宗中，彼岸的超验智慧“般若”代表女性的创造活力，另一种修炼的方式“方便”代表男性的创造活力，分别以女阴的变形莲花和男根的变形金刚杵为象征，通过想象的阴阳交媾和真实的男女欢交的瑜伽方式，亲证“般若”与“方便”融为一体的极乐涅磐境界。这就是欢喜佛的宗教寓意。佛教密宗里男女双修就是印度教性力派影响下的产物。 在欢喜佛图象中凶神恶煞的明王和明王妃合抱交媾，明妃搂其头，一足围绕其腰，就是“大乐”形式。与明王合为一体的妩媚多姿的明妃，是明王修行时必不可少的伙伴。在佛经上叫做“先以欲勾之，后令入佛智”，她以爱欲供奉那些残暴的神魔，使之受到感化，然后再把他们引到佛的境界中来。这就是供奉欢喜佛所谓的“调心工具”和培植佛性的“机缘”。对着欢喜佛的“观形鉴视”，时日久了则习以为常，欲念之心顿消，利用“空乐双运”产生了悟空性，达到“以欲制欲”的目的。 密宗认为他们对女性的崇拜是一种无私的行为，是一种真正意义上的爱：无爱，也就是《爱经》所诠释的性爱的最高境界。因此，密宗仪式中的性事并不表现为激情，而是一种非个性化的行为，一种无状态的心灵状态和浑然一体的自我，沉浸于其中的是彻底的自我和自我的解脱。正是在这种解脱的意义上，禁欲与纵性，苦行与性力奇特地化为一体，成为同归的殊途。这也就是为什么在许多的寺庙中你都可以看见精美绝伦的性爱雕像的原由，在今天，漫步在印度诸多神庙中，你感受到的不是性的羞涩隐晦而是一种自然的原生态的美，那种源于生命本质的，是最持久的，也是永恒的。 好了扯远了，回归正题，为了让印度神油为更多人”造福“，华仁行找来一辆厢式卡车，上面印着： 印度神油，妙不可言，佛国之宝，的确够劲 在加上电影的宣传： 印度神油变得非常火爆，一位印度的中文导游表示： 每一个中国游客都会问哪里能买到正宗的印度神油，自己不厌其烦地被追问了几十年。 另外据阿里巴巴，京东等电商平台数据统计显示，2019年3月-2020年2月，男士精油近一年线上交易总额达1.04亿，销售同比上涨86.17%。 究竟有没有用？ 用“鼻祖”华仁行出品的印度神油来说，主要原材料为蟾蜍，即从中华大蟾蜍或黑眶蟾蜍皮肤身上的有毒分泌物制取而成。现代医学认为，产出对于跌打损伤有消肿止痛之效，适量喷涂皮肤可有麻痹之感，使得敏感度下降，从而起到延时作用。 但是对于真正存在生殖障碍的患者来说，无异于饮鸠止渴。此外频繁使用外用药极易导致受伤或者发炎，操作手法也需谨慎，否则麻到对方等于互相伤害。 浙江大学医学院揭露，西医用于治疗男性障碍一般多为口服用药，这种外用药无法直接作用于内部海绵体，并不能起到实际作用，反而会延误病情的治疗良机。说到底印度神油只是一款有着局麻作用的普通男性外用保健品，充其量只能起到辅助作用，健康本体才是关键所在。 再看看后来的“正统”印度本土精油，可以分为六大种类： 皇帝油 延时喷剂 男士红油 阿育吠陀玉女油 阿育吠陀霸油 男优膏 但其实即使商品种类混杂，能证明真实有效的并不多，换句话说，说无效也不奇怪。 鱼龙混杂的神油市场 印度神油并非商标，谁都可以使用以及生产，久而久之市场混乱程度可想而知。 在电商平台上随意搜索即能找到各种各样的印度神油，虽然价格参差不齐，但是都会突出“本产品由印度XXX集团出品”，“本品选用印度秘方XXX”等宣传词，月销量过万者比比皆是。但实际上国家药监局从未批准过从印度进口任何延时喷剂，这类山寨精油大多是私人作坊炮制出的三无产品，即便国内最正宗的印度神油，最多也不过是香港华仁行生产的罢了。 每年国家处理的神油造假类案件达数万起，一方面利益熏心的商家们为增加销量，不惜铤而走险，不仅私自添加明令禁止的化学成分，很多配比更是经不起考量，轻则过敏反应，重则对肝，肾等产生不可逆转的副作用。另一方面，因为涉及隐私，多数人宁可吞下哑巴亏，也不愿公开报案，使得造假制假事件屡禁不止，愈演愈烈。 说明 摘自这里与这里 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-27-qi/"},{"title":"每日分享 第26期","content":" 每日鸡汤 穷不可怕，可怕的是，最穷的人是我。 每日冷知识 凭借2013年的电影《达拉斯买家俱乐部》，化妆师罗宾·马修斯赢得了第86届奥斯卡最佳化妆与发型设计奖，在整部影片28天的制作周期中，化妆预算仅为250美元。 每日诗词 最爱湖东行不足，绿杨阴里白沙堤。 ——白居易《钱塘湖春行》 每日一句 吾心吾行澄如明镜，所作所为皆为正义。 每日音乐 生而为人-尚士达 曾经说过不会抽的烟 都已经吸进肺里好几年 曾经的梦想天真无邪 后来满脑子都是为了钱 每年生日闭眼许的愿 能有几个可以灵验 人总会变 抱歉 都说生命可以不分贵贱 可有人生来就被叫做少爷 有人只能看着地面 抬头都是些肮脏的嘴脸 励志要走社会的前列 可总是败在势力的面前 肺腑之言 抱歉 我想忘了从前的一切 做一个凡事不问的俗人 从今天起远离人群 做一只狡猾的狐狸 那天我双手合十 看着镜子里狼狈的自己 我用了一半的青春 来思考做人的道理 对不起年少的自己 行千万里 再别忘了初心 都说生命可以不分贵贱 可有人生来就被叫做少爷 有人只能看着地面 抬头都是些肮脏的嘴脸 励志要走在社会的前列 可总是败在势力的面前 肺腑之言 抱歉 我想忘了从前的一切 做一个凡事不问的俗人 从今天起远离人群 做一只狡猾的狐狸 那天我双手合十 看着镜子里狼狈的自己 我用了一半的青春 来思考做人的道理 对不起年少的自己 行千万里 再别忘了初心 我想忘了从前的一切 做一个凡事不问的俗人 从今天起远离人群 做一只狡猾的狐狸 那天我双手合十 看着镜子里狼狈的自己 我用了一半的青春 来思考做人的道理 对不起年少的自己 行千万里 再别忘了初心 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-26-qi/"},{"title":"每日分享 第25期","content":" 每日鸡汤 把女孩子弄哭是很没种的事，把男孩子弄哭是一件叼爆的事啊。 每日冷知识 骆驼仅需13分钟就可喝下13加仑（约114升的水）。这些水储存在骆驼的血液中，而不是存在能量丰富而且富含脂肪的驼峰中。 每日诗词 又莫是东风逐君来，便吹散眉间一点春皱。 ——苏轼《洞仙歌·咏柳》 每日一句 不合理的事物，未必都是显而易见的。 每日音乐 童话幻灭-蒋蒋 你开始悲伤哽咽 像诗里写的决别 陪你看过那场雪 一转眼却要分别 这故事就要完结 落笔时满天枫叶 陪你走过那条街 霎那间童话幻灭 我没搞懂也没种 我陷在黑黑无底洞 爬不出来 不知好歹 板着脸孔话很冲 说我不是你的英雄 算哪盘菜 只好认栽 我努力释怀回忆的挚爱 却刻进脑海不让人去猜 目送着离开注定回不来 就算是伤害也瞒天过海 你开始悲伤哽咽 像诗里写的决别 陪你看过那场雪 一转眼却要分别 这故事就要完结 落笔时满天枫叶 陪你走过那条街 霎那间童话幻灭 我没搞懂也没种 我陷在黑黑无底洞 爬不出来 不知好歹 板着脸孔话很冲 说我不是你的英雄 算哪盘菜 只好认栽 我努力释怀回忆的挚爱 却刻进脑海不让人去猜 目送着离开注定回不来 就算是伤害也瞒天过海 你开始悲伤哽咽 像诗里写的决别 陪你看过那场雪 一转眼就要分别 落笔时满天枫叶 陪你走过那条街 霎那间童话幻灭 你开始悲伤哽咽 像诗里写的决别 陪你看过那场雪 一转眼就要分别 这故事就要完结 落笔时满天枫叶 陪你走过那条街 霎那间通话幻灭 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-qi/"},{"title":"设计模式学习笔记（四）：简单工厂模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 抽象产品角色 2.3 具体产品角色 2.4 工厂角色 2.5 客户端 3 实例 4 简化 5 主要优点 6 主要缺点 7 适用场景 8 总结 1 概述 1.1 引言 简单工厂模式不属于GoF23种设计模式之一，但是实际中用途广泛，并且可以作为学习“工厂方法模式”以及“抽象工厂模式”的基础。在简单工厂模式中，工厂类提供一个创建产品的工厂方法，用于创建各种产品。客户端只需传入对应的参数，利用该方法即可根据传入参数的不同返回不同的具体产品对象。 1.2 定义 简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 因为在简单工厂模式用于创建实例的方法是静态的方法，因此简单工厂模式又被称为静态工厂方法模式，它属于类创建型模式。 1.3 结构图 1.4 角色 Factory（工厂角色）：即工厂类，负责实现创建所有产品实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象，在工厂类中提供了一个静态工厂方法用于获取产品 Product（抽象产品角色）：是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法。Product会提高系统的灵活性，使得在工厂类只需要定义一个通用的工厂产品方法，因为所有创建的具体产品都是其子类对象 ConcreteProduct（具体产品角色）：所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法 2 典型实现 2.1 步骤 定义抽象产品角色：定义为抽象类/接口，封装各种产品对象的公有方法 定义具体产品角色：实现/继承抽象产品角色，实现其中声明的方法 定义工厂角色：提供静态获取具体产品方法，根据传入参数的不同返回不同的产品 2.2 抽象产品角色 简单定义如下： interface Product { void method(); } 2.3 具体产品角色 实现抽象产品角色接口： class ConcreteProductA implements Product { public void method() { System.out.println(&quot;具体产品A方法&quot;); } } class ConcreteProductB implements Product { public void method() { System.out.println(&quot;具体产品B方法&quot;); } } 2.4 工厂角色 由于工厂角色需要根据传入参数不同返回不同的具体产品，因此通常使用枚举作为传入参数，先定义具体产品的枚举类： enum ConcreteProduct { A,B; } 接着定义静态工厂方法： class Factory { public static Product get(ConcreteProduct type) { switch (type) { case A: return new ConcreteProductA(); case B: return new ConcreteProductB(); default: return null; } } } 根据参数的不同创建不同的具体产品实例并返回。 2.5 客户端 传入不同参数即可获取不同的具体产品： Product product = Factory.get(ConcreteProduct.A); product.method(); product = Factory.get(ConcreteProduct.B); product.method(); 3 实例 某公司需要开发一个图表库，该图表库可以提供各种不同外观的图表，例如柱状图，折线图等等，使用简单工厂模式对其进行设计。 设计如下： 抽象产品类：Chart，这里是一个接口，只有一个display方法 具体产品类：HistogramChart+PieChart+LineChart 工厂类：Factory 代码如下： //抽象产品类 interface Chart { void display(); } //具体产品类,柱状图 class HistogramChart implements Chart { public HistogramChart() { System.out.println(&quot;创建柱状图&quot;); } public void display() { System.out.println(&quot;显示柱状图&quot;); } } //具体产品类,饼状图 class PieChart implements Chart { public PieChart() { System.out.println(&quot;创建饼状图&quot;); } public void display() { System.out.println(&quot;显示饼状图&quot;); } } //具体产品类,折线图 class LineChart implements Chart { public LineChart() { System.out.println(&quot;创建折线图&quot;); } public void display() { System.out.println(&quot;显示折线图&quot;); } } //工厂类 class Factory { public static Chart getChart(Charts charts) { switch(charts) { case PIE_CHART: return new PieChart(); case LINE_CHART: return new LineChart(); case HISTOGRAM_CHART: return new HistogramChart(); default: return null; } } } enum Charts { PIE_CHART,LINE_CHART,HISTOGRAM_CHART; } 测试： public static void main(String[] args) { Chart chart = Factory.getChart(Charts.LINE_CHART); chart.display(); } 4 简化 为了简化设计，可以将抽象产品类与工厂类合并，将静态方法移至抽象产品类中： 这样可以通过抽象产品类的静态方法获取子类对象，优化代码如下： interface Chart { void display(); static Chart getChart(Charts charts) { switch(charts) { case PIE_CHART: return new PieChart(); case LINE_CHART: return new LineChart(); case HISTOGRAM_CHART: return new HistogramChart(); default: return null; } } } 5 主要优点 分离职责：简单工厂模式实现了对象创建以及使用的分离，工厂类包含必要的判断逻辑，可以决定在什么时候创建什么哪一个产品的实例，客户端可以免除直接创建产品对象的职责，仅仅是“消费”产品 简化记忆：客户端无须知道具体产品类的名字，只需要知道对应的参数即可，一般使用常量字符串或者枚举 提高灵活性：可以引入配置文件（xml等）在不修改客户端代码情况下增加新的具体产品类，提高灵活性 6 主要缺点 工厂职责过重：工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统都要受影响 复杂度增加：由于引入了工厂类会增加系统中类的个数，会增加系统的复杂度和理解难度 扩展困难：系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型过多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护 无法继承：简单工厂模式使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构 7 适用场景 工厂类负责创建的对象比较少，由于创建对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只需要知道传入工厂类的参数，对如何创建对象不关心 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-si-jian-dan-gong-han-mo-shi/"},{"title":"Vue学习笔记（二）","content":"1 条件判断 1.1 普通if 条件判断使用v-if指令： &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;看到了&lt;/p&gt;; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ seen:true } }) &lt;/script&gt; v-if指令根据表达式的值（在这里是seen）决定是否插入&lt;p&gt; 1.2 if-else 可以使用v-else添加一个else块： &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;Math.random()&gt;0.5&quot;&gt;1&lt;/div&gt; &lt;div v-else&gt;2&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app' }) &lt;/sctipt&gt; 也可以增加v-else-if： &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;value === 'A'&quot;&gt;A&lt;/div&gt; &lt;div v-else-if=&quot;value === 'B'&quot;&gt;B&lt;/div&gt; &lt;div v-else-if=&quot;value === 'C'&quot;&gt;C&lt;/div&gt; &lt;div v-else&gt;D&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ value:'A' } }) &lt;/script&gt; v-else以及v-else-if必须跟在v-if或者v-else-if之后。 1.3 v-show 也可以根据v-show展示元素： &lt;div id=&quot;app&quot;&gt; &lt;h1 v-show=&quot;ok&quot;&gt;Test&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data: { ok:true } }) &lt;/script&gt; 2 循环 循环使用v-for，格式为：A in B，其中A是B中的每一个值，若B为数组，则A表示其中的没一个元素，若B为对象，则A可以表示B中的没一个值，通常配合&lt;li&gt;使用： &lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;i in arr&quot;&gt;{{i.value}}&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data: { arr: [ {value:'value1'}, {value:'value2'}, {value:'value3'} ] } }) &lt;/script&gt; 另外也可以通过一个对象的属性来迭代数据： &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;value in obj&quot;&gt;{{value}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data: { obj: { value1:'value1', value2:'value2', value3:'value3' } } }) &lt;/script&gt; 也可以提供第二个参数作为键名： &lt;li v-for=&quot;(value,key) in obj&quot;&gt; {{key}} -&gt; {{value}} &lt;/li&gt; 第三个参数作为索引： &lt;li v-for=&quot;(value,key,index) in obj&quot;&gt; {{index}} : {{key}} -&gt; {{value}} &lt;/li&gt; 另外也可以迭代整数： &lt;li v-for=&quot;n in 10&quot;&gt;{{n}}&lt;/li&gt; 范围是从0到10，包含0与10。 3 计算属性 3.1 computed 计算属性类似与方法调用，比如之前的反转字符串的例子： {{message.split('').reverse().join('')}} 这样看起来很长，可以使用计算属性进行简化： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{reverse}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data: { message:'Test' }, computed: { reverse:function() { return this.message.split.reverse().join('') } } }) &lt;/script&gt; 这里声明了一个计算属性reverse，提供的函数作为属性reverse的getter，reverse依赖于message，当message更新时，reverse也会更新。 3.2 computed与methods 可以使用methods来代替computed： methods: { reverse:function() { return this.message.split.reverse().join('') } } 对应只需要增加一对()： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{reverse()}}&lt;/p&gt; &lt;/div&gt; computed基于它的依赖缓存，只有相关依赖修改时才会重新取值，而使用methods，在重新渲染时函数总会重新调用执行。 3.3 setter computed默认只有 getter，不过也可以自行提供setter： var vm = new Vue({ el:'#app', data: { name:'test', url:'https://www.test.com' }, computed: { site: { get:function() { return this.name + ' ' + this.url; }, set:function(value) { var values = value.split(' ') this.name = values[0] this.url = values[1] } } } }) vm.site = 'test2 https://www.test2.com' document.write('name:'+vm.name) document.write('&lt;br&gt;') document.write('url:'+vm.url) 输入如下： ","link":"https://2293736867.github.io/post/vue-xue-xi-bi-ji-er/"},{"title":"每日分享 第24期","content":" 每日鸡汤 你不能因为你胖，就忽略了你的丑。 每日冷知识 男性制造的精子比女性制造的卵子多1000000000000000000000000倍（25个0）。 每日诗词 休说鲈鱼堪脍，尽西风，季鹰归未？ ——辛弃疾《水龙吟·登建康赏心亭》 每日一句 异地恋是，尝过欣喜若狂，也知道失魂落魄。 每日音乐 风恋歌-恋恋故人难 / 芝麻Mochi (吹梦到西洲的日文版) いつかの街角で 君とすれ違った時 気付かぬふりをした 理由さえもわからずに 木枯らし吹く道を俯きながら呟く ぽつりと漏れた言葉は 届くことなく消えてった 街路樹 落ち葉が溢れる でも私の季節は変わらないままで 教えてよ この風の行方 あなたの想いは誰に向け吹くの 頬を伝い流れる涙が乾かないのは そんな全て包む 愛を待っているから 道行く足並みが忙しなくなるこの頃 あなたは今頃何処で 誰の手を取り歩いてるの 景色は色を変えるけど 今も私の想いは変わらないままで 教えてよ この恋の行方 あなたを探して どこまでも往くの 胸の奥に灯った炎が揺らがないのは 今日も吹き止まない 風を待っているから あと何回この季節を 乗り越えられたのなら あなたに伝えられるだろう 愛しさと切なさのその全てを 教えてよ この恋の行方 あなたにまた会えたのなら いつか夢に見た形じゃなくても どうか近くにいさせて 教えてよ この風の行方 あなたの想いは誰に向け吹くの 頬を伝い流れる涙が乾かないのは そんな全て包む 愛を待っているから ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-24-qi/"},{"title":"设计模式学习笔记（三）：单例模式","content":" 1 概述 1.1 引言 1.2 定义 1.3 结构图 1.4 角色 2 典型实现 2.1 步骤 2.2 单例角色 2.3 客户端 3 实例 4 饿汉式单例 5 懒汉式单例 6 饿汉式与懒汉式的比较 7 IoDH 8 枚举实现单例（推荐） 9 主要优点 10 主要缺点 11 适用场景 12 总结 1 概述 1.1 引言 很多时候为了节约系统资源，需要确保系统中某个类只有一个唯一的实例，当这个唯一实例创建了之后，无法再创建一个同类型的其他对象，所有的操作只能基于这一个唯一实例。这是单例模式的动机所在。 比如Windows的任务管理器，可以按Ctrl+Shift+Esc启动，而且启动一个，不能启动多个。 1.2 定义 单例模式（Singleton Pattern）：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式是一种对象创建型模式。 1.3 结构图 1.4 角色 单例模式只有一个角色： Singleton（单例角色）：在单例类的内部只生成一个实例，同时它提供一个类似名叫getInstance的静态方法获取实例，同时为了防止外部生成新的实例化对象，构造方法可见性为private，在单例类内部定义了一个Singleton的静态对象，作为供外部访问的唯一实例 2 典型实现 2.1 步骤 构造函数私有化：也就是禁止外部直接使用new等方式创建对象 定义静态成员：定义一个私有静态成员保存实例 增加公有静态方法：增加一个类似getInstance()的公有静态方法来获取实例 2.2 单例角色 单例角色通常实现如下： class Singleton { //饿汉式实现 private static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance() { return instance; } } 2.3 客户端 客户端直接通过该类获取实例即可： Singleton singleton = Singleton.getInstance(); 3 实例 某个软件需要使用一个全局唯一的负载均衡器，使用单例模式对其进行设计。 代码如下： public class LoadBalancer { private static LoadBalancer instance = null; private LoadBalancer(){} public static LoadBalancer getInstance() { return instance == null ? instance = new LoadBalancer() : instance; } public static void main(String[] args) { LoadBalancer balancer1 = LoadBalancer.getInstance(); LoadBalancer balancer2 = LoadBalancer.getInstance(); System.out.println(balancer1 == balancer2); } } 这是最简单的单例类的设计，获取实例时仅仅判断是否为null，没有考虑到线程问题。也就是说，多个线程同时获取实例时，还是有可能会产生多个实例，一般来说，常见的解决方式如下： 饿汉式单例 懒汉式单例 IoDH 4 饿汉式单例 饿汉式单例就是在普通的单例类基础上，在定义静态变量时就直接实例化，因此在类加载的时候就已经创建了单例对象，而且在获取实例时不需要进行判空操作直接返回实例即可： public class LoadBalancer { private static LoadBalancer instance = new LoadBalancer(); private LoadBalancer(){} public static LoadBalancer getInstance() { return instance; } } 当类被加载时，静态变量instance被初始化，类的私有构造方法将被调用，单例类的唯一实例将被创建。 5 懒汉式单例 懒汉式单例在类加载时不进行初始化，在需要的时候再初始化，加载实例，同时为了避免多个线程同时调用getInstance()，可以加上synchronized： public class LoadBalancer { private static LoadBalancer instance = null; private LoadBalancer(){} synchronized public static LoadBalancer getInstance() { return instance == null ? instance = new LoadBalancer() : instance; } } 这种技术又叫延迟加载技术，尽管解决了多个线程同时访问的问题，但是每次调用时都需要进行线程锁定判断，这样会降低效率。 事实上，单例的核心在于instance = new LoadBalancer()，因此只需要锁定这行代码，优化如下： public static LoadBalancer getInstance() { if(instance == null) { synchronized (LoadBalancer.class) { instance = new LoadBalancer(); } } return instance; } 但是实际情况中还是有可能出现多个实例，因为如果A和B两个线程同时调用getInstance()，都通过了if(instance == null)的判断，假设线程A先获得锁，创建实例后，A释放锁，接着B获取锁，再次创建了一个实例，这样还是导致产生多个单例对象。 因此，通常采用一种叫“双重检查锁定”的方式来确保不会产生多个实例，一个线程获取锁后再进行一次判空操作： private volatile static LoadBalancer instance = null; public static LoadBalancer getInstance() { if(instance == null) { synchronized (LoadBalancer.class) { if(instance == null) { instance = new LoadBalancer(); } } } return instance; } 需要注意的是要使用volatile修饰变量，volatile可以保证可见性以及有序性。 6 饿汉式与懒汉式的比较 饿汉式在类加载时就已经初始化，优点在于无需考虑多线程访问问题，可以确保实例的唯一性 从调用速度方面来说饿汉式会优于懒汉式，因为在类加载时就已经被创建 从资源利用效率来说饿汉式会劣于懒汉式，因为无论是否需要使用都会加载单例对象，而且由于加载时需要创建实例会导致类加载时间变长 懒汉式实现了延迟加载，无须一直占用系统资源 懒汉式需要处理多线程并发访问问题，需要双重检查锁定，且通常来说初始化过程需要较长时间，会增大多个线程同时首次调用的几率，这会导致系统性能受一定影响 7 IoDH 为了克服饿汉式不能延迟加载以及懒汉式的线程安全控制繁琐问题，可以使用一种叫Initialization on Demand Holder（IoDH）的技术。实现IoDH时，需在单例类增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，代码如下： public class LoadBalancer { private LoadBalancer(){} private static class HolderClass { private static final LoadBalancer instance = new LoadBalancer(); } public static LoadBalancer getInstance() { return HolderClass.instance; } } 由于单例对象没有作为LoadBalancer的成员变量直接实例化，因此类加载时不会实例化instance。首次调用getInstance()时，会初始化instance，由JVM保证线程安全性，确保只能被初始化一次。另外相比起懒汉式单例，getInstance()没有线程锁定，因此性能不会有任何影响。 通过IoDH既可以实现延迟加载，又可以保证线程安全，不影响系统性能，但是缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH。另外，还可能引发NoClassDefFoundError（当初始化失败时），例子可以戳这里。 8 枚举实现单例（推荐） 其中，无论是饿汉式，还是懒汉式，还是IoDH，都有或多或少的问题，并且还可以通过反射以及序列化/反序列化方式去“强制”生成多个单例，有没有更优雅的解决方案呢？ 有！答案就是枚举。 代码如下： public class Test { public static void main(String[] args) { LoadBalancer balancer1 = LoadBalancer.INSTANCE; LoadBalancer balancer2 = LoadBalancer.INSTANCE; System.out.println(balancer1 == balancer2); } } enum LoadBalancer{ INSTANCE; } 使用枚举实现单例优点如下： 代码简洁不易出错 无须像饿汉式一样直接在类加载时初始化 也无须像懒汉式一样需要双重检查锁定 也无须像IoDH一样添加一个静态内部类增加系统中类的数量 由JVM保证线程安全 不会因为序列化生成新实例 也不会因为反射生产新实例 9 主要优点 唯一实例：单例模式提供了对唯一实例的受控访问，可以严格控制客户怎样以及何时访问它 节约资源：由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式可以提高系统性能 10 主要缺点 扩展困难：没有抽象层，扩展困难 职责过重：单例类职责过重，一定程度上违反了SRP，因为既提供了业务方法，也提供了创建对象方法，将对象创建以及对象本身的功能耦合在一起 GC导致重新实例化：很多语言提供了GC机制，实例化的对象长时间不使用将被回收，下次使用需要重新实例化，这回导致共享的单例对象状态丢失 11 适用场景 系统需要一个实例对象 客户调用类的单个实例只允许使用一个公共访问点 12 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-san-dan-li-mo-shi/"},{"title":"每日分享 第23期","content":" 每日鸡汤 我从不去想何时能成功，既然选择了远方，那就还远着呢。 每日冷知识 自1922年以来，已有30项（最高100万美元）现金悬赏令向所有人征集能够证明超自然现象的证据，可至今为止，仍未收集到任何相关证据。 每日诗词 江月去人只数尺子，风灯照夜欲三更。 ——杜甫《漫成一绝》 每日一句 所有的梦境都是另一个现实，永远不要忘记。 每日音乐 温泉-许嵩/刘美麟 你用温柔手臂弯住迟钝的我 蓝色披风鼓裹着半立方悸动 骑行在泉水小镇下坡有点陡 正好紧贴我背后 和你在一起就会莫名的放松 所有阴翳的回忆都一扫而空 在深巷小馆品尝当年的果酒 像你清新而醇厚 喜欢看你的笑容 绽放在夏日雨后 你融化了多少的忧愁或许只有我能懂 你轻轻的问我 我有没有点重 可抱住你就不想松手 喜欢看你的笑容 环绕着香甜的风 你戳中了我的审美点准确得好像针灸 我微微的颤抖 那紧张的喉咙 认真讲述了没做的梦 很生动 你用温柔手臂弯住迟钝的我 蓝色披风鼓裹着半立方悸动 骑行在泉水小镇下坡有点陡 正好紧贴我身后 和你在一起就会莫名的放松 所有阴翳的会议都一扫而空 在深巷小馆品尝当地的果酒 像你清新而醇厚 喜欢看你的笑容 绽放在夏日雨后 你融化了多少的忧愁或许只有我能懂 你轻轻的问我 我有没有点重 可抱住你就不想松手 喜欢看你的笑容 环绕着香甜的风 你戳中了我的审美点准确得好像针灸 我微微的颤抖 那紧张的喉咙 认真讲述了没做的梦 很生动 说实话我可不确定我能够陪你多久 没关系能博红颜一笑是我的温柔 等我们绕过几轮冬夏和春秋 还能不能和你遨游 喜欢看你的笑容 绽放在夏日雨后 你融化了多少的忧愁或许只有我能懂 你轻轻的问我 我有没有点重 可抱住你就不想松手 喜欢看你的笑容 环绕着香甜的风 有泡在丛林里的温泉神器疗愈的作用 我微微的颤抖 那紧张的喉咙 认真讲述了没做的梦 很生动 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-23-qi/"},{"title":"设计模式学习笔记（二）：UML与面向对象设计原则","content":" 1 UML 1.1 UML 1.2 UML特性 1.3 UML结构 1.3.1 视图 1.3.2 图 1.3.3 模型元素 1.3.4 通用机制 2 UML类图 2.1 类图 2.1.1 类名 2.1.2 属性 2.1.3 操作 2.2 类之间的关系 3 关联关系 3.1 双向关联 3.2 单向关联 3.3 自关联 3.4 多重性关联 3.5 聚合关系 3.6 组合关系 4 依赖关系 5 泛化关系 6 接口与实现关系 7 面向对象设计原则 7.1 概述 7.2 单一职责原则SRP 7.3 开闭原则OCP 7.4 里氏代换原则LSP 7.5 依赖倒转原则DIP 7.6 接口隔离原则ISP 7.7 合成复用原则CRP 7.7.1 继承 7.7.2 组合/聚合 7.8 迪米特法则LoD 8 总结 1 UML 1.1 UML UML（Unified Modeling Language）是统一建模语言，1997年11月UML1.1版本提交给OMG并正式通过，成为建模语言的个那个也标准。2003年6月UML2.0获得正式通过。 1.2 UML特性 U（Unified）：统一，UML融合了多种优秀的面向对象建模方法以及多种得到认可的软件工程方法，消除了因方法林立且相互独立而带来的种种不便，集众家之长，故名“统一”。通过统一的表示方法可以让不同知识背景的领域专家，系统分析设计人员以及开发人员可以方便地交流 M（Modeling）：UML是一种通用的可视化建模语言，不同与编程语言，UML通过一些标准的图形符号和文字来对系统进行建模，用于对软件进行描述，可视化处理，构造系统制品的文档。UML适用于各种软件开发方法，软件生命周期的各个阶段，各种应用领域以及各种开发工具 L（Language）：UML是一种语言，也就意味着它有属于自己的标准表达规则，不是一种类似Java，C++的编程语言，而是一种分析设计语言，一种建模语言 1.3 UML结构 UML结构通常包括以下4个部分：视图，图，模型元素以及通用机制。 1.3.1 视图 UML视图用于从不同的角度来表示待建模的系统。视图是由许多图形组成的一个抽象集合，在建立一个系统模型时，只有通过定义多个视图，每个视图显示该系统的一个特定方面，才能构造出该系统的完整蓝图。 UML视图包括： 用户视图：以用户的观点表示系统的目标，是所有视图的核心，用于描述系统的需求 结构视图：系统的静态行为，描述系统的静态元素，比如包，类，对象以及它们之间的关系 行为视图：系统的动态行为，描述系统的组成元素在系统运行时的交互关系 实现视图：系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系 环境视图：系统中物理元素的分布，描述系统中硬件设备以及他们之间的关系 1.3.2 图 UML图是描述UML视图内容的图形，UML2.0提供了13种图，分别是用例图，类图，对象图，包图，组合结构图，状态图，活动图，顺序图，通信图，定时图，交互概览图，组件图和部署图。其中： 用例图对应用户视图 类图，对象图，包图和组合结构图对应结构视图 状态图，活动图，顺序图，通信图，定时图和交互概览图对应行为视图 组件图对应实现视图 部署图对应环境视图 1.3.3 模型元素 模型元素是指UML图中所使用的一些概念，对应于普通的面向对象概念，如类，对象，消息以及这些概念之间的关系，如关联关系，泛化关系等。 1.3.4 通用机制 UML提供的通用机制为模型元素提供额外的注释，信息和语义，这些通用机制也提供了扩展机制，允许用户对UML进行扩展，如定义新的建模元素，扩展原有的语义，添加新的特殊信息来扩展模型元素的规则说明等，以便适用于特定的方法或过程，组织和用户。 2 UML类图 2.1 类图 类封装了数据和行为，是具有相同属性，操作，关系的对象集合的总称。类图是用出现在系统中不同类来描述系统的静态结构，主要描述不同的类以及它们之间的关系。 在UML中，类图包含类名，属性以及操作。如下面的Employee类： 类一般由三部分组成： 类名 属性 操作 2.1.1 类名 类名就是类的名字，一个字符串。 2.1.2 属性 类的成员变量，一般的格式为 可见性 名称 : 类型 [ = 默认值] 可见性表示该属性对于类外的元素是否可见，包括： 公有：+ 私有：- 受保护：# 包：~ 2.1.3 操作 UML规定操作的定义方式为： 可见性 名称(参数列表)[ : 返回类型] 可见性与属性可见性的定义一致 参数列表表示方法的参数，语法与属性定义类似，用,分隔 2.2 类之间的关系 UML提供了四种不同的方式表示类与类之间的关系： 关联关系 依赖关系 泛化关系 接口与实现关系 下面逐个看一下。 3 关联关系 关联关系是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML中用实线连接有关联关系的类。可以在关联线上标注角色名，关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的，但可以使类之间的关系更加明确。 例如在一个登录界面类LoginForm包含一个JButton： UML中关联通常包括以下六种形式： 双向关联 单向关联 自关联 多重性关联 聚合关系 组合关系 3.1 双向关联 默认情况下关联是双向的，例如顾客购买商品并拥有商品，反之卖出的商品总是某个顾客与之相关联： 3.2 单向关联 关联也可以是单向的，在UML中关联用带箭头的实线表示，比如顾客拥有地址： 3.3 自关联 系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系为自关联，常见于链表： 3.4 多重性关联 多重性关联又称为多重性关联联系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或者一个数字范围来表示。常见的表示方式如下： 例如一个界面可以具有0个或多个按钮，但是一个按钮只能从属于一个界面： 3.5 聚合关系 聚合关系表示整体与部分的关系，使用空心菱形表示。聚合关系中部分是整体的一部分，但是部分可以脱离整体独立存在，比如引擎是汽车的一部分，但是引擎可以独立于汽车存在： 3.6 组合关系 组合关系也表示整体与部分之间的关系，但是部分不能脱离整体存在。组合关系使用实心菱形表示。比如人的头和嘴巴是组合关系： 4 依赖关系 依赖关系是一种使用关系，在需要表示“一个事物使用另一个事物”时使用依赖关系。UML中依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如驾驶员开车，开车需要车，也就是驾驶员依赖于车： 5 泛化关系 泛化关系也就是继承关系，用于描述父类与子类之间的关系，父类又叫基类或者超类，子类又称作派生类。UML中泛化关系用带空心三角形的直线表示，箭头指向基类： 6 接口与实现关系 很多语言比如Java，C#都有接口的概念，接口通常没有属性，所有是操作都是抽象的，只有操作的声明没有操作的实现。UML中使用&lt;&lt;Interface&gt;&gt;表示接口： 类与接口之间的实现关系使用空心三角形+虚线表示： 7 面向对象设计原则 7.1 概述 面向对象设计的目标之一是支持可维护性复用，一方面需要实现设计方案或者源代码的重用，一方面要确保系统能够易于扩展和修改，具有较好的灵活性。面向对象设计原则由此诞生，它们蕴含于很多设计模式中，是从许多方案总结出来的指导性原则。常见的7种面向对象设计原则如下： 单一权责原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 合成复用原则 迪米特法则 7.2 单一职责原则SRP 单一权责原则（Single Responsibility Principal）：一个类只负责一个功能领域中的相应职责。 或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 单一权责原则的核心思想是：一个类不能太“累”。一个类（大到模块，小到方法）承担的职责越多，被复用的可能性越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此需要将职责分离，封装在不同的类中，即将不同的变化原因封装在不同的类中。单一权责原则是实现高内聚，低耦合的指导方针。 7.3 开闭原则OCP 开闭原则（Open-Closed Principle）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量不修改原有代码的情况下进行扩展。 其中软件实体可以是一个软件模块，一个由多个类组成的局部结构或者一个独立的类。 一个软件设计符合开闭原则，则可以非常方便地对其进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以通过接口，抽象类等定义抽象层，通过具体类进行扩展，修改系统的行为时无需修改抽象层，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 7.4 里氏代换原则LSP 里氏代换原则（Liskov Substitution Principle）：所有引用基类/父类的地方必须能透明地使用其子类的对象。 简单地说就是父类出现的地方可以用子类代替，程序不会产生任何的错误和异常。使用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现父类中声明的方法，运行时，子类实例代替父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 7.5 依赖倒转原则DIP 依赖倒转原则（Dependency Inversion Principal）：抽象不应该依赖具体细节，细节应当依赖于抽象，换言之要针对接口编程，而不是针对实现编程。 依赖倒转原则要求程序在源代码中传递参数时或者在关联关系中，尽量引用高层次的抽象层类，即使有接口和抽象类进行变量类型声明，参数类型声明，方法返回类型声明以及数据类型的转换等，而不是用具体类来做。一个具体类应该只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用在子类中新增的方法。 在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式包括： 构造注入：通过构造函数来传入具体类的对象 设值注入（setter注入）：通过setter来传入具体类对象 接口注入：通过实现在接口中声明的方法来传入具体类对象 上面的方法在定义时使用抽象类型，在运行时传入具体类型的对象，由子类对象来覆盖父类对象 。 7.6 接口隔离原则ISP 接口隔离原则（Interface Segregation Principal）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖于那些它不需要的接口。 也就是说，当一个接口太大时需要划分为更小的接口，使用该接口的客户端仅需知道与之相关的方法。每一个接口应该承担一种相对独立的角色，这里的接口有两层意思： 一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象 另一种是指某个语言具体接口的定义，有严格的定义和结构，比如Java中的interface ISP对两种不同含义的表达方式有所不同： 当接口理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分，可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫“角色隔离原则” 把接口理解成狭义的特定语言的接口，ISP表达的意思是接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不提供大的总接口。接口应尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或者业务逻辑类）所需的方法即可，这种机制也叫“定制服务” 使用接口隔离原则时，注意控制接口的粒度： 接口太小导致接口泛滥，不利于维护 接口太大将违背ISP，灵活性差，使用不方便 一般而言接口中仅包含为某一类用户定制的方法即可。 7.7 合成复用原则CRP 合成复用原则（Composite Reuse Principal）：尽量使用对象组合而不是继承来达成复用目的。 合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principal），就是在一个新对象中通过关联关系（组合/聚合）对对象进行重用而不是使用继承。 面向对象设计中，可以通过两种方法在不同环境中复用已有的设计和实现： 继承 组合/聚合 7.7.1 继承 继承需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。继承主要带来的问题是会破坏系统的封装性，因为继承会将基类实现细节暴露给子类，由于基类内部细节对子类可见，因此叫“白箱复用”。 一般而言两个类之间的关系是“Is-A”关系就可以使用继承。 7.7.2 组合/聚合 尽管可以通过继承来对代码进行复用，一般来说优先考虑组合/聚合。组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。由于新对象可以直接调用已有对象的功能，这样做可以使成员对象的内部实现细节对新对象不可见，所以这种复用叫“黑箱复用”。 一般而言两个类之间的关系是“Has-A”关系就可以使用组合/聚合。 7.8 迪米特法则LoD 迪米特法则（Law of Demeter）：一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则又叫最少知识原则（Least Knowledge Principal，LKP），迪米特法则会对软件实体之间通信的宽度与深度进行限制，可以降低系统的耦合度，使类与类之间保持松耦合。 迪米特法则还有几种定义形式：不要和“陌生人”说话，只与直接朋友通信。对于一个对象“朋友”可以是以下几类： 对象本身（this） 以参数形式传入的对象 成员对象 如果成员对象是一个集合，那么集合中的元素也是“朋友” 当前对象所创建的对象 满足上述条件之一即是“朋友”，否则就是“陌生人”，不能和“陌生人”发生直接交互。 迪米特法则要求设计系统时尽量减少对象之间的交互，通过引入一个合理的中间类来降低现有对象之间的耦合度。应用迪米特法则时需要注意几点： 优先将类设计为不变类 类划分上尽量创建松耦合的类 类结构设计上尽量降低成员变量和成员函数的访问权限 在对其他类的引用上，一个对象对其他对象的引用应当降到最低 8 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-uml-yu-mian-xiang-dui-xiang-she-ji-yuan-ze/"},{"title":"Vue学习笔记（一）","content":" 1 Vue目录结构 2 Vue对象 3 Vue模板语法 3.1 插值 3.2 属性 3.3 表达式 3.4 指令 3.5 参数 3.6 修饰符 3.7 v-model 3.8 按钮事件 3.9 过滤器 3.10 缩写 1 Vue目录结构 build：项目构建webpack的相关代码 config：配置目录，包括端口号等 node_modules：npm加载的项目依赖模块 src：开发的目录模块，包含assets（资源文件），components（组件文件），App.vue项目入口文件，main.js项目核心文件 static：静态资源文件，如图片，字体等 test：初始测试目录 .xxx：配置文件，比如语法配置，git配置等等 index.html：首页入口文件 package.json：项目配置文件 README.md：项目说明文件 2 Vue对象 Vue对象的基本参数有： el：DOM元素的id data：用于定义属性 methods：用于定义函数 {{}}输出对象属性和函数返回值 一个Vue实例被创建时，会向Vue的响应式系统加入了data中能找到的所有属性，当这些属性的值改变时HTML视图也会发生相应变化。 3 Vue模板语法 Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层Vue实例数据。 Vue.js的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进DOM的系统，结合响应系统，在应用状态改变时，Vue能够智能地计算出重新渲染组建的最小代价并应用到DOM操作上。 3.1 插值 插值分为两种方式： 纯文本 HTML 纯文本可以使用{{}}插值，比如： &lt;div id=&quot;app&quot;&gt;{{message}}&lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'text' } }) &lt;/script&gt; HTML使用v-html指令： &lt;div id=&quot;app&quot; v-html=&quot;message&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'&lt;h1&gt;h1标题&lt;/h1&gt;' } }) &lt;/script&gt; 3.2 属性 属性绑定使用v-bind指令，比如： &lt;div v-bind:class=&quot;{'class1':use}&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ use:false } }) &lt;/script&gt; 3.3 表达式 可以在{{}}直接嵌入JS表达式，包括计算以及函数调用等等，比如： &lt;div id=&quot;app&quot;&gt; {{5.222-1.2345}} &lt;br&gt; {{ok ? 'YES' : 'NO'}} &lt;br&gt; {{message.reverse()}} &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ ok:true, message:'Reverse', } }) &lt;/scirpt&gt; 3.4 指令 指令是带有v-前缀的特殊属性，指令用于在表达式的值改变时，将某些行为应用到DOM上，比如： &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;看到了&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ seen:true } }) &lt;/script&gt; 3.5 参数 参数在指令后面以冒号表明，比如v-bind指令用于响应地更新HTML： &lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;某个网站&lt;/a&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ url:'https://www.xxx.com' } }) &lt;/script&gt; href是参数，告知v-bind指令将该元素的href属性与表达式url的值绑定。 3.6 修饰符 修饰符是以.指明的特殊后缀，用于指出一个指令应该以特殊的方式绑定，例如.prevent修饰符告知v-on指令对于出发事件调用event.preventDefault()： &lt;form v-on:sbumit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 3.7 v-model v-model用来在input，select，textarea，chekcbox，radio等表单控件元素上创建双向的数据绑定，根据表单上的值更新绑定元素的值。比如： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'text' } }) &lt;/script&gt; 3.8 按钮事件 可以使用v-on:click监听按钮事件，比如： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;button v-on:click=&quot;reverse&quot;&gt;反转字符串&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'reverseeeeee' }, methods:{ reverse:function(){ this.message=this.messaage.split('').reverse().join('') } } }) &lt;/script&gt; 3.9 过滤器 允许定义过滤器用作一些常见文本的格式化，比如： &lt;div id=&quot;app&quot;&gt;{{message | f}}&lt;/div&gt; &lt;script&gt; new Vue({ el:'#app', data:{ message:'text' }, filters:{ f:function(value){ if(!value) return '' value = value.toString return value.charAt(0).toUpperCase()+value.slice(1) } } }) &lt;/script&gt; 另外，过滤器可以串联以及接受参数： {{message | filterA | filterB}} {{message | filterA('arg1','arg2')}} // message作为filterA的第一个参数，'arg1','arg2'分别为第二个，第三个参数 将上面的过滤器改动一下： &lt;div id=&quot;app&quot;&gt;{{message | f(10)}}&lt;/di&gt; &lt;script&gt; new Vue({ el:'#app', data:{ }, filter:{ f:function(value,times){ if(!value) return '' value = value.toString() value = value.charAt(0).toUpperCase()+value.slice(1) return value.repeat(times) } } }) &lt;/script&gt; 3.10 缩写 v-bind:href可以缩写为:href v-on:click可以缩写为@click ","link":"https://2293736867.github.io/post/vue-xue-xi-bi-ji-yi/"},{"title":"设计模式学习笔记（一）：设计模式","content":" 1 前言 2 设计模式 2.1 来源 2.2 定义 3 常用设计模式 3.1 创建型模式 3.2 结构型模式 3.3 行为型模式 4 设计模式用途 5 总结 1 前言 软件开发技术包含“招式”与“内功”，其中，编程语言，开发技术，著名框架可以认为是“招式”，而数据结构，算法，设计模式，重构，软件工程等则为“内功”。“招式”可以很快学会，但是“内功”的修炼需要更长的时间。对设计模式的学习会令“内功”大增，配合日益纯熟的“招式”，软件开发“功力”想必会达到一个新境界。下面来正式踏入修炼设计模式之旅。 2 设计模式 2.1 来源 模式是在特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。 GoF（Gang of Four，简称GoF，分别是Erich Gamma，Richard Helm，Ralph Johnson，John Vlissides）将模式的概念引入软件工程领域，标志着软件模式的诞生。软件模式是将模式的一般概念应用与软件开发领域，即软件开发的总体指导思想或参照样板。软件模式并非仅限于设计模式，还包括架构模式，分析模式和过程模式等。 在软件模式中，设计模式是研究最为深入的分支。设计模式用于在特定条件下为一些重复出现的问题提供合理的，有效的解决方案。 2.2 定义 设计模式：是一套被反复使用的，多数人知晓的，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码， 让代码更容易被他人理解并且提高代码的可靠性。 设计模式一般包含的要素： 模式名称 问题 目的 解决方案 效果 其中关键要素为模式名称，问题，解决方案以及效果： 模式名称：模式的命名 问题：描述了应该在何时使用模式，包括了设计中存在的问题以及问题存在的原因 解决方案：描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述 效果：描述了模式的优缺点以及使用模式时应权衡的问题 GoF设计模式有23个，模式分类可以按照用途或者处理方式进行分类，按照用途分类的话，可以分为： 创建型模式：主要用于描述如何创建对象 结构型模式：主要用于描述如何实现类或对象的组合 行为型模式：主要用于描述类或对象怎么交互以及怎样分配职责 根据处理方式分类，可以分为： 类模式 对象模式 两种分类模式通常结合使用，比如单例模式是对象创建型模式。 3 常用设计模式 3.1 创建型模式 单例模式 简单工厂模式 工厂方法模式 抽象工厂模式 原型模式 建造者模式 3.2 结构型模式 适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式 3.3 行为型模式 职责链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式 4 设计模式用途 能够实现可维护性复用的设计方案，提高设计与开发效率 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间的沟通以及交流，使得设计方案更加通俗易懂。因为设计模式跨语言，跨平台，跨应用，跨国界 大部分设计模式都兼顾了系统的可重用性以及可扩展性，使得可以更好地重用一些已有的设计方案、功能模块以及一个完整的软件系统 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统 5 总结 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-yi-she-ji-mo-shi/"},{"title":"每日分享 第22期","content":"每日鸡汤 二十年前吃小浣熊，集不齐卡的傻孩子们，依然集不齐五福。 每日冷知识 太空的宇航员需要在风扇附近睡觉，以便他们呼吸时面前不会形成二氧化碳云，从而避免因此窒息而死。 每日诗词 霜落荆门江树空，布帆无恙挂秋风。 ——李白《秋下荆门》 每日一句 如果必须要失去，那么不如一开始就不曾拥有。 每日音乐 季彦霖-选择失忆 一杯烈酒倒入喉 是你 给的温柔 想念翻滚如浪腾 最后 更痛 最后的最后 不过 是一场梦 心越来越痛 如果 回到最初 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 一杯烈酒倒入喉 是你 给的温柔 想念翻滚如浪腾 最后 更痛 最后的最后 不过 是一场梦 心越来越痛 如果 回到最初 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 如何能选择忘记 忘记每一段过去 你的话语太伤心 一点也没有余地 可我还是会想你 去想你 没忘记 你刺痛我心 或许一切都归零 归零到最初记忆 我一定选择 不会继续爱你 我的爱已经选择暂停 选择了失忆 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-22-qi/"},{"title":"强大的工具（一）：Capslock+ 3.x版本","content":" 1 概述 2 基础功能 2.1 光标移动 2.2 光标选择 2.3 删除操作 2.4 换行 2.5 剪贴板 3 F1-F6 3.1 F1 3.2 F2 3.3 F3 3.4 F4 3.5 F5 3.6 F6 4 高级功能 4.1 全局设置 4.2 Tab 4.2.1 补全 4.2.2 计算 4.3 窗口绑定 4.4 Qbar 4.4.1 设置文件以及版本信息 4.4.2 打开网址 4.4.3 浏览文件 4.4.4 搜索 4.4.5 使用特定程序打开特定文件 4.4.6 细节补充 4.5 Qbar自定义 4.6 自定义按键 5 其他 1 概述 作者终于把Capslock+更新到了3.x版本了，所以就更了这篇博客。 2.x版本的可以戳这里。 Linux版本的可以戳这里。 3.x版本与2.x版本的主要不同是更新了新的键盘布局，更加顺手，下面让我们一起来看一下吧。 2 基础功能 下面的按键都以Capslock+开头，也就是说需要先按着Capslock键，而Alt键无特殊说明指的是左边的Alt键。 2.1 光标移动 按键 效果 E 光标向上移动一次 Alt+E 光标向上移动三次 D 光标向下移动一次 Alt+D 光标向下移动三次 S 光标向左移动一次 Alt+S 光标向左移动五次 F 光标向右移动一次 Alt+F 光标向右移动五次 按键 效果 T 光标向上移动十次 Alt+T 光标向上移动三十次 B 光标向下移动十次 Alt+B 光标向下移动三十次 按键 效果 A 光标向左移动一个单词 Alt+A 光标向左移动三个单词 G 光标向右移动一个单词 Alt+G 光标向左移动三个单词 P 光标移动到行首 Alt+P 光标移动到页首 ; 光标移动到行尾 Alt+; 光标移动到页尾 注意中文不好界定单词的界限，一般会整句跳过。 2.2 光标选择 按键 效果 I 光标向上选中一次 Alt+I 光标向上选中三次 K 光标向下选中一次 Alt+K 光标向下选中三次 J 光标向左选中一次 Alt+J 光标向左选中五次 L 光标向右选中一次 Alt+L 光标向右选中五次 按键 效果 , 光标选中当前单词 Alt+, 光标选中当前行 U 光标选中至行首 Alt+U 光标选中至页首 O 光标选中至行尾 Alt+O 光标选中至页尾 2.3 删除操作 按键 效果 W 光标向后删除（=Backspace） Alt+W 光标向后删除单词 R 光标向前删除（=Delete） Alt+R 光标向前删除单词 [ 光标删除至行首 Alt+[ 光标删除至页首 / 光标删除至行尾 Alt+/ 光标删除至页尾 Backspace 删除当前行 Alt+Backspace 删除全部内容 2.4 换行 按键 效果 Space 等价于Enter Enter 向下插入一行，相当于先按End再按Enter 2.5 剪贴板 按键 效果 X/C/V 剪切/复制/粘贴，独立于Ctrl+X/C/V，如果有选中则剪切/复制选中的内容，如果没有选中会剪切/复制当前行的内容 Alt+X/C/V 另一套独立的剪贴板 3 F1-F6 3.1 F1 打开官网。 3.2 F2 F2是计算面板。可以按Enter或者Shift+Enter获取计算结果，加上Shift计算结果会出现下一行。 也可以按Capslock+Tab获取结果，这样会把原来的表达式给替换掉。 3.3 F3 F3是翻译功能，使用的是有道API，注意事项如下： 英语单次可以不用选中，只需要光标靠着单词 中文最好选中再翻译，不好界定“单词”界限 翻译框的文本可以使用Capslock+Alt+Backspace清空再次输入进行下一次翻译 网络差的话使用翻译可能会导致Capslock+假死，稍等即可 API接口请求为每小时1000次，如果有特殊需求可以前往有道智云申请一个独立Key，并修改Capslock+settings.int 3.4 F4 F4可以将窗口变修改窗口透明度： 短按：修改为半透明/不透明 长按：配合鼠标滚轮修改透明度 3.5 F5 F5重新加载Cpaslock+，会有一个reload提示框。 3.6 F6 F6可以置顶或者解除置顶一个窗口。 4 高级功能 4.1 全局设置 全局设置在Capslock+settings.ini的[Global]中，其中： autostart：是否开机自启，可选1或0，默认为0，不自启 default_hotkey_scheme：热键布局，可选capslox或capslock_plus，默认前者，后者为2.x版本的热键 loadScript：加载的JS脚本，必须位于loadScript文件夹下，用逗号分隔要加载的JS，比如locaScript=1.js,2.js mouseSpeed：按下Capslock+Alt时的鼠标速度，默认为3，可以按住Capslock+Alt配合滚轮修改临时的鼠标速度 allowClipboard：是否开启默认剪贴板，可选1或0，默认为1，开启 loadingAnimation：是否开启加载动画，可选1或0，默认为1，开启 4.2 Tab Tab可以实现字符串的补全还有计算。 4.2.1 补全 补全就是利用设置文件中的值对特定的字符串进行补全，比如设置有 qq = 123456 tel = 11111111111 输入qq或者tel后按Capslock+Tab就可以补全： 可以输入Capslock+Q再输入cl set打开设置文件，在Capslock+settings.ini的[TabHotString]中进行设置： 格式为： 键名 = 字符串 可以加上空格。 这个可以填上一些常见的个人信息，邮箱，电话什么的。对程序员可以自定义某些代码段，比如可以设置 so = System.out.println(&quot;&quot;); 修改完txt直接保存即可生效，无需使用Capslock+F5进行重载。 4.2.2 计算 计算可以对普通的表达式进行计算，或者调用JS函数进行计算，默认内置了以下函数（在loadScript下的scriptDemo.js中）： pow：次幂，比如pow(3,2.1) variance：方差，比如variance(1,2,3,4,5) spVariance：样本方差，比如spVariance(1,2,3,4,5) stdResidual：标准化残差，比如stdResidual(1,2,3,4,5,6) average：平均值，比如average(1,2,3) stepNum：输出一组步进数字，比如stepNum(1,3,3)会输出1,4,7，参数是起始值，个数，步长 roll：随机数，比如roll(100)会输出一个0-99的随机数 date：当前日期 time：当前时间 dateTime：当前日期+时间 String.alignment：字符串对齐格式，参数为对齐参考符号，是否按名称长短排序，参数类型为字符串类型，布尔类型，默认值为'=',false String.repeat：字符串重复函数，比如&quot;123&quot;.repeat(3)会输出123123123 细节补充： 使用时需要把光标移动到表达式或者函数的右边 表达式含有=时保留原来表达式，不含有=时直接将结果替换掉原来表达式 表达式带有空格需要选中表达式或者在表达式头部加上反引号 若表达式跨越多行需要选中 如果需要自定义函数，请编写.js文件，并放置于loadScript文件夹下，并修改Capslock+settings.int中的[Gloabl]下的loadScript，在默认的scriptDemo.js后面逗号分隔加上自己的.js文件即可。 4.3 窗口绑定 有三种窗口绑定模式： 单击：绑定当前激活的窗口 双击：追加绑定当前激活的窗口 三击：绑定当前窗口所属程序的所有窗口 什么意思呢？窗口绑定的键位为Capslock+Win+0-9，比如当前打开了浏览器，再按下了Capslock+Win+1，就会绑定浏览器到1这个按键，这时候按一次Capslock+1就会把浏览器最小化，再按一次Cpaslock+1就会把浏览器还原。 这时候如果切换到了一个记事本窗口，按下了Capslock+Win+1+1（按两次1），就会把这个记事本也绑定到1这个按键，这时候按Capslock+1就会在浏览器以及记事本之间切换。 如果打开了多个记事本，同时窗口切换到其中一个记事本，按下Capslock+Win+1+1+1（按三次1），就会把所有的记事本窗口绑定到1这个按键，这时候按下Capslock+1就会在这些记事本窗口之间进行切换。 这个功能笔者觉得不错，起码比Alt+Tab或者Win+Tab好用，切换速度很快。 4.4 Qbar Qbar是Capslock+提供的一个功能输入框，按下Capslock+Q显示。 功能包括： 查看相关设置文件以及版本信息：输入cl about或者cl set 打开网址 文件浏览 使用自定义搜索引擎进行搜索 使用特定应用程序打开特定文件 4.4.1 设置文件以及版本信息 输入cl about可以查看版本信息 输入cl set可以查看配置文件的demo以及进行配置文件的修改，包括全局配置，热字串配置等 4.4.2 打开网址 可以输入baidu.com或者加上前缀web baidu.com 网址以http://或者https://或者www.开头可以省略 Ctrl+Enter而不是直接Enter可以加上前缀www.以及后缀.com，就像图中一样，如果不是Ctrl+Enter而是直接Enter会搜索baidu 4.4.3 浏览文件 可以进行本地文件的浏览： 输入/或者\\可以进入下一层目录 输入Capslock+-可以回到上一层目录 文件过多时为了保证速度会放弃加载部分图标 4.4.4 搜索 可以使用自定义的搜索引擎搜索，默认为谷歌搜索，可以输入cl set查看。默认内置了： 谷歌 百度 淘宝 维基百科 MDN 使用很简单，可以直接输入搜索关键字然后Enter即可，选择相应引擎可以加上特定前缀： 自带搜索引擎前缀关键字如下： s或者bd：百度 g或者gg：谷歌 m ：MDN wk：维基百科 tb：淘宝 自定义搜索引擎时，将搜索词用{q}代替，并添加到[QSearch]字段即可，再加上关键字即可。 Chrome自带了搜索引擎的管理功能，如果使用过知乎搜索，打开设置中的管理搜索引擎： 并找到知乎： 接着把整个字符串复制到[QSearch]，并修改%s为{q}，同时加上关键字zh： 接着就可以使用zh搜索了： 4.4.5 使用特定程序打开特定文件 需要再设置文件中设置[QRun]字段，比如设置了： [QRun] code = &quot;D:\\xxxx\\xxx\\xxx\\Code.exe&quot; txt = &quot;C:\\xxx\\xxx\\xxx\\1.txt&quot; 则可以输入code txt使用VSCode打开这个txt。 4.4.6 细节补充 选中文件再键入Capslock+Q会填上选中文件的路径 设置热字串时可以使用Capslock+Q设置，格式为xxx -&gt; xxx，比如aa -&gt; 11这样会提示是否将aa设为热字串，也可以加入xxx -&gt; run xxx或者xxx -&gt; web xxx，在对应的[QWeb]或者[QRun]下设置 4.5 Qbar自定义 Qbar可以按照设置文件里面的配置自定义样式，支持的样式如下表： 属性 取值 borderBackgroundColor 背景颜色，默认red borderRadius 边框四角圆角程度，默认9 textBackgroundColor 文字输入框的背景颜色，默认green textColor 输入文字的颜色，默认ffffff，白色 editFontName 输入文字的字体，默认Hiragino Sans GB W6 editFontSize 输入文字大小，默认12 listFontName 提示列表字体，默认consoals listFontSize 提示列表字体大小，默认10 listBackgroundColor 提示列表背景颜色，默认blue listColor 提示列表文字颜色，默认0x000000 listCount 提示列表行数，默认5 lineHeight 提示列表每行高度，默认19 progressColor 进度条颜色，默认0x00cc99 颜色可以是指定的16种HTML的基础颜色之一或者6位RGB颜色值（可以省略0x前缀），例如red，ffffaa，FFFFAA，0xFFFFAA。 4.6 自定义按键 Capslock+支持的按键有： Capslock + (LALt + ) F1~F12 Capslock + (LALt + ) 0~9 Capslock + (LALt + ) a~z Capslock + (LALt + ) -=[]\\;',./ Capslock + (LALt + ) Backspace, Tab, Enter, Space, RAlt Capslock+Win+0~9 实际上按下某个键相当于执行特定的函数，比如按下了Capslock+B，在配置文件中可以找到如下映射： caps_b=keyFunc_moveDown(10) 由于是AutoHotKey写的，代码开源在Github上，需要的话可以自行修改对应的函数，另外还有如下四个没有按键映射的函数： keyFunc_mediaPlayPause：停止播放 keyFunc_volumeUp：增大音量 keyFunc_volumeDown：降低音量 keyFunc_volumeMute：静音 可以直接修改对应键位后面的映射函数，比如caps_lalt_1=keyFunc_doNothing修改为caps_lalt_1=keyFunc_volumeMute，这样按下Capslock+Alt+1就可以静音了。 5 其他 启动过Capslock+后，可以通过快捷键Ctrl+Alt+Capslock启动 使用窗口绑定的功能时，如果同时开启了PowerToys会绑定不了，请先关闭PowerToys再进行窗口绑定（2.x的版本使用Alt不会有此问题，希望作者修复） F12可以关闭/打开独立的剪贴板 Capslock+E/D/S/F并不能完全代替上/下/左/右键，比如很多时候Alt+←是后退，但是Alt+Capslock+S被实现为了光标向左移动五次 其他更多请按Capslock+F1打开官网或者打开Qbar后输入cl set查看配置文件的更多信息 ","link":"https://2293736867.github.io/post/qiang-da-de-gong-ju-yi-capslock-3x-ban-ben/"},{"title":"每日分享 第21期","content":" 每日鸡汤 混到现在，拿得起，放得下的，只有筷子。 每日冷知识 尽管千禧一代经常被视为“滥交”一代，但他们的性伴侣比前几代人都少，而且性行为也比父母同龄时间更少。 每日诗词 等闲识得东风面，万紫千红总是春。 ——朱熹《春日》 每日一句 无法拒绝的礼物，决定了我的轮廓什么样，却不能把我的心也捆绑。 每日音乐 倒带-蔡依林 我受够了等待 你所谓的安排 说的未来到底多久才来 总是要来不及 才知道我可爱 我想依赖 而你却都不在 应该开心的地带 你给的全是空白 一个人假日发呆 找不到人陪我看海 我在幸福的门外 却一直都进不来 你累积给的伤害我是真的很难释怀 终于看开爱回不来 而你总是太晚明白 最后才把话说开 哭着求我留下来 终于看开爱回不来 我们面前太多阻碍 你的手却放不开 宁愿没出息求我别离开 你总是要我乖 慢慢计划将来 我的眼泪却一直掉下来 过去怎么交代 你该给的信赖 被你亲手缓缓推入悬崖 从我脸上的苍白 看到记忆慢下来 过去甜蜜在倒带 只是感觉已经不在 而我对你的期待 被你一次次摔坏 已经碎成太多块 要怎么拼凑跟重来 终于看开爱回不来 而你总是太晚明白 最后才把话说开 哭着求我留下来 终于看开爱回不来 我们面前太多阻碍 你的手却放不开 宁愿没出息求我别离开 终于看开爱回不来 而你总是太晚明白 最后才把话说开 哭着求我留下来 终于看开爱回不来 我们面前太多阻碍 你的手却放不开 宁愿没出息求我别离开 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-21-qi/"},{"title":"每日分享 第20期","content":" 每日鸡汤 听说你的城市下雨了，不知道你带伞了没有，如果带了这雨就白下了。 每日冷知识 虽然美国威斯康星州的饮酒年龄为21岁，但根据法律规定，任何未成年人都可以在酒吧和餐馆喝酒，只要与达到法定饮酒年龄的父母或者监护人在一起即可。 每日诗词 嫩阴里，烟滋露染，翠娇红溜。 ——吴文英《花心动·柳》 每日一句 这么好的一位少年，那么他喜欢着的少女，得是多好的姑娘啊？ 每日音乐 开心的马骝-刘德华 紫色夹杂 灰色衬衫 T恤橙雨楼 思想放任 衣衫更是 不须多扣钮 衫松裤大 胶表带着 拉绳的布袋 街边跳动 开心快活 七彩的马骝 夜 不再等候 别放手 不再要走 夜街 穿插左右 令我热热烈烈痛痛快快似喝醉了酒 大雨落在七彩雨楼 两点似菊豆 十只着上七彩雨楼的湿水马骝 夜里荡在尖东去追 刺激快感受 站在路上一起再多饮光几罐酒 紫色夹杂 灰色衬衫 T恤橙雨楼 思想放任 衣衫更是 不须多扣钮 衫松裤大 胶表带着 拉绳的布袋 街边跳动 开心快活 七彩的马骝 夜 不再等候 别放手 不再要走 夜街 穿插左右 令我热热烈烈痛痛快快似喝醉了酒 大雨落在七彩雨楼两点似菊豆 十只着上七彩雨楼的湿水马骝 夜里荡在尖东去追刺激快感受 站在路上一起再多饮光几罐酒 夜 不再等候 别放手 不再要走 夜街 穿插左右 令我热热烈烈痛痛快快似喝醉了酒 大雨落在七彩雨楼两点似菊豆 十只着上七彩雨楼的湿水马骝 夜里荡在尖东去追刺激快感受 站在路上一起再多饮光几罐酒 大雨落在七彩雨楼两点似菊豆 十只着上七彩雨楼的湿水马骝 夜里荡在尖东去追刺激快感受 站在路上一起再多饮光几罐酒 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-20-qi/"},{"title":"每日分享 第19期","content":" 每日鸡汤 生活不止眼前的苟且，还有前任的喜贴，所以拉黑很重要。 每日冷知识 人类已经通过旅行者1号从地球向外探测了近140亿英里，但仅向地球内部钻了7.5英里。 每日诗词 有三秋桂子，十里荷花。 ——柳永《望海潮·东南形胜》 每日一句 奇怪的是，当他死去，所有人才开始爱他。 每日音乐 外愈-任然 有人等在那家咖啡馆 熟悉音乐播放不间断 只为了纪念他们的走散 有一些习惯确实伤感 假装隐藏却莫名心酸 想表现坦然明明两难 没有谁能比谁更加好过 掩饰伤口不代表谁软弱 不要解释反而弄巧成拙 想洒脱就别执着 没了谁谁都一样的好过 伤口随时间都会愈合 终于明白过往会吞没所有 有一些习惯确实伤感 假装隐藏却莫名心酸 想表现坦然明明两难 没有谁谁比谁更加好过 掩饰伤口不代表谁软弱 不要解释反而弄巧成拙 想洒脱就别执着 没了谁谁都一样好过 伤口随时间都会愈合 终于明白过往会吞没所有 没有谁谁比谁更加好过 掩饰伤口不代表谁软弱 不要解释反而弄巧成拙 想洒脱就别执着 没了谁谁都一样好过 伤口随时间都会愈合 终于明白过往会吞没所有 高考 各位高三学子高考加油啊！ 疫情下的高考真是困难重重，有人说，这届考生真是“生于非典，考于新冠”，好像也有那么一点道理。 安徽 就在今天（2020.07.07）凌晨，安徽省黄山市歙（she）县遭遇了50年一遇的洪涝灾害，截至9点，歙县中学，歙县二中2个高考考点大部分考生均未进入考点，近十点正式通知语文考试取消。 真是惨，真的变了“乘风破浪”的学生。 贵州 今天贵州安顺一大巴冲进水库，车内有高考考生，截止7日下午17时30分，共搜救出36人，其中21人死亡，15人受伤。 真惨。 阅读 今年的语文阅读有新梗了，尼克乔治滑雪。 全国一卷的阅读理解是海明威的一篇文章，叫《越野滑雪》，是这样的： “也许咱们再也没机会滑雪了，尼克，”乔治说。 “咱们一定得滑，”尼克说，“要是不能滑就没有意义了。” “咱们要去滑，没错儿，”乔治说。 “咱们一定得滑，”尼克附和说。 “希望咱们能就此说定了，”乔治说。 然后就出了一个题目问： 两人的对话表达了什么？ 原文（看不到图片的可以去搜索原文“《越野滑雪》 海明威”）： 这个题目笔者也不会做，目前因为刚刚高考答案也没公开，网上也没多少文章，就不说什么了。 作文 今年的高考语文试卷作文题一共11道，5道教育部命制，天津、上海、江苏、浙江等各1道，北京命制2道，下面看看全国一卷作文： 春秋时期，齐国的公子纠与公子小白争夺君位，管仲和鲍叔分别辅佐他们。管仲带兵阻击小白，用箭射中他的衣带钩，小白装死逃脱。后来小白即位为君，史称齐桓公。鲍叔对桓公说，要想成就霸王之业，非管仲不可。于是桓公重用管仲，鲍叔甘居其下，终成一代霸业。后来人称颂齐桓公九合诸侯，一匡天下，为“春秋五霸”之首。孔子说：“桓公九合诸侯，不以兵车，管仲之力也。”司马迁说：“天下不多（称赞）管仲之贤而多鲍叔能知人也。” 班级计划举行读书会，围绕上述材料展开讨论。齐桓公、管仲、鲍叔三人，你对哪个感触最深？请结合你的感受和思考写一篇发言稿。 于是就有了这样的图片： 笔者讨厌写作文，就不说什么了，立意可以看一下这里。 其他作文题目可以看一下这里。 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-19-qi/"},{"title":"每日分享 第18期","content":" 每日鸡汤 赚钱就像便秘——老难了，花钱就像拉稀——憋不住。 每日冷知识 如果你在菲律宾的每座岛屿都待上一天，那么访问完这些岛屿将花上你将近21年的时间。这些岛屿的最新计数为7641座。 每日诗词 去年五月黄梅雨，曾典袈裟籴米归。 ——与恭《思母》 每日一句 落叶的一生，只是为了归根吧。 每日音乐 丁香花-唐磊 你说你最爱丁香花 因为你的名字就是她 多么忧郁的话 多愁善感的人啊 当花儿枯萎的时候 当画面定格的时候 多么娇嫩的花 却躲不过风吹雨打 飘啊摇啊的一生 多少美丽编织的梦啊 就这样匆匆你走了 留给我一生牵挂 那坟前开满鲜花 是你多么渴望的美啊 你看啊漫山遍野 你还觉得孤单吗 你听啊有人在唱 那首你最爱的歌谣啊 尘世间多少繁芜 从此不必再牵挂 你说你最爱丁香花 因为你的名字就是它 多么忧郁的话 多愁善感的人啊 当花儿枯萎的时候 当画面定格的时候 多么娇嫩的花 却躲不过风吹雨打 飘啊摇啊的一生 多少美丽编织的梦啊 就这样匆匆你走了 留给我一生牵挂 那坟前开满鲜花 是你多么渴望的美啊 你看啊漫山遍野 你还觉得孤单吗 你听啊有人在唱 那首你最爱的歌谣啊 尘世间多少繁芜 从此不必再牵挂 那坟前开满鲜花 是你多么渴望的美啊 你看啊漫山遍野 你还觉得孤单吗 你听啊有人在唱 那首你最爱的歌谣啊 尘世间多少繁芜 从此不必再牵挂 院子里栽满丁香花 开满紫色美丽的鲜花 我在这里陪着她 一生一世守护她 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-18-qi/"},{"title":"Vim 常用操作","content":"1 退出 :qa 关闭所有文件 :qa! 关闭所有文件，放弃更改 :w 保存 :wq或:x 保存和关闭文件 :q关闭文件 :q! 关闭文件，放弃更改 ZZ 保存退出 ZQ 退出，放弃更改 2 编辑 a 追加 A 行尾追加 i 插入 I 行首插入 o 插入行 O 上方插入行 s 删除插入当前字符 S 删除行同时插入 C 删除到行尾同时插入 r 替换单个字符 R 替换模式 u 撤销 Ctrl+R 重做 3 退出插入模式 Esc Ctrl+[ Ctrl+C 退出插入模式同时终止当前命令 4 剪贴板 x 剪切字符 dd 剪切行 yy 复制行 p 粘贴，对于复制行在下方粘贴，对于字符后方粘贴 P 粘贴，对于复制行在上方粘贴，对于字符前方粘贴 &quot;*p或&quot;*P 从系统剪贴板粘贴，*与+是与系统剪贴板交互的寄存器，若&quot;*p不行可以尝试&quot;+p，需要确保vim支持剪贴板，可以使用vim --version | grep clipboard查看，出现+clipboard即为支持 ”*y或+y 复制到系统剪贴板 5 导航 h/j/k/l 左/下/上/右 Ctrl+E/Y 滚动上/下一行 Ctrl+U/D 滚动上/下半页 Ctrl+F/B 滚动上/下一页 b/w 前/后一个单词首字母 ge/e 前/后一个单词尾字母 0 绝对行首（忽略空白） ^ 相对行首 $ 行尾 fc或Fc 向前/后跳转到字符c gg 首行 G 末行 :n或nG 第n行 Ctlr+O/I 上一次位置/撤回 [(/[{ 前一个(/{ ])/]} 后一个)/} [m 方法前一个开始/结束处 ]m 方法后一个开始/结束处 zz 滚动窗口让当前行居中 zt 滚动窗口让当前行置顶 H/M/L 移动到屏幕顶部/中部/底部 :tabedit file 打开一个新tab编辑文件file :tabclose 关闭当前tab :tabs 列出所有tab :tabfirst/:tablast 跳转到第一个/最后一个tab :tabn/:tabp 下一个/上一个tab 6 可视化模式 v 可视化模式 V 行可视化模式 Ctrl+V 块可视化模式 7 操作符+动作 形式如下： 操作符 动作 例子： dw d是操作符代表删除，w是移动到下一个单词首 ，所以就是删除到下一个单词首 db 删除到上一个单词首 2dd 删除两行 dip 删除一个文本对象（下面有说） 操作符列表： d 删除 y 复制（也叫yank） c 修改 &gt; 右缩进 &lt; 左缩进 g~ 变换大小写 gU 大写 gu 小写 8 文本对象 形式如下： 操作符 i/a 文本对象 其中操作符是上面提到的，i/a表示： i inside，仅选择文本，比如文本对象是一个字符串，仅选择字符串内容，不包括包围的单/双引号 a around，选择包括文本，包围的字符与周围的空白，比如文本对象是一个[]块，会选择[]里面的内容，同时选中包围的[]，如果[]周围有空白也会进行选中 文本对象： p 段落 w 单词 s 句子 [/(/{/&lt; 一个[]/()/{}/&lt;&gt;块 '/&quot;/反引号 单/双/反引号字符串 t 一个xml标签块 例子： vip 选择段落 vipipip 选择更多段落 yit 复制一个xml标签块 ya&quot; 复制一个&quot;字符串以及包围的&quot; di[ 删除一个[]块的内容 ca{ 修改一个{}块以及周围空白 9 杂项 9.1 数字增减 Ctrl+A 数字加1 Ctrl+X 数字减1 默认识别十进制，使用:set nrformats=bin,octal,hex后，能识别2/8/16进制。 二进制：0b或0B开头 八进制：0开头 十六进制：0x或0X开头 9.2 大小写 g~ 切换大小写 gU 大写 gu 小写 g~~ 整行切换大小写 gUU 整行大写 guu 整行小写 9.3 计算器 插入模式下，输入Ctrl+R，接着输入=，再输入式子即可计算。Enter获取计算结果，会将计算结果插入到当前光标所在位置。 9.4 标记 反引号^ 插入模式的上一次位置 反引号. 上一次修改位置 反引号反引号 上一次跳转的位置 ma 标记当前位置为标记a 反引号a 跳转到标记a的位置 'a 跳转到标记a的位置的行首 ","link":"https://2293736867.github.io/post/vim-chang-yong-cao-zuo/"},{"title":"MySQL 常用操作","content":"1 创建/打开/删除数据库 create database db; create database db character set utf8mb4; use db; drop database db; alter database db character set utf8mb4; 2 修复表 mysqlcheck --all-databases mysqlcheck --all-databases --fast 3 查询 select * from table1; select * from table1,table2; select field1,field2,... from table1,table2; select ... from ... where condition; select ... from ... where condition group by field; select ... from ... where condition1 group by field having condition2; select ... from ... where condition order by field; select ... from ... where condition order by field1,field2 desc; select ... from ... where condition limit 10; select distinct field1,field2 from ... select distinct table1.field1,table2.field2 from table1,table2 where condition1 group by field4 having condition2 order by field3 desc limit 20; 4 插入/删除/更新数据 # 插入 insert into table1(field1,field2,...) values(value1,value2,...); # 删除 delete from table1; truncate from table1; delete from table1 where condition; delete table1,table2 from table1,table2 where condition; # 更新 update table1 set field=new_value where condition; update table1,table2 set field1=new_value1,field2=new_value2,... where table1.id=table2.id and condition; 5 创建/删除/修改表 # 创建 create table table1(field1 type,field2 type,...); create table table1(field type,...,index(field)); create table table1(field type,...,primary key(field)); create table table1(field1 type,field2 type,...,primary key(field1,field2)); create table table1(field type,...,foreign key(field) references table2(field)); create table table1(field1 type,field2 type,...foreign key(field1,field2) references table2(field1,field2)); create table if not exists table1(field type,...); create temporary table table1(field type,...); # 删除 drop table table1; drop table if exists table1; drop table table1,table2; # 修改 alter table table1 modify old_name new_type; alter table table1 modify old_name new_type not null; alter table table1 change old_name new_name new_type; alter table table1 change old_name new_name new_type not null; alter table table1 alter field set default ...; alter table table1 alter field drop default; alter table table1 add new_name new_type; alter table table1 add new_name new_type first; alter table table1 add new_name new_type after field; alter table table1 drop field; alter table table1 add index(field); # 改变字段顺序 alter table table1 modify field type first; alter table table1 modify field1 type after field2; alter table table1 change old_name new_name new_type first; alter table table1 change old_name new_name new_type after field; 6 重置root密码 # 停止服务，各个机器具体不一样，可以使用图形界面停止 systemctl stop mysqld mysqld_safe --skip-grant-tables # 若失败可以尝试 # mysqld_sage --shared-memory --skip-grant-tables # 另一个终端 mysql # 进入之后 # MySQL 8+ flush privileges; alter user 'root'@'localhost' identified by 'new_pass'; # MySQL 旧版 update mysql.user set password=password('new_password') where user='root'; 7 备份与恢复 # 备份 mysqldump -u username -p dbname &gt; backup.sql # 恢复 mysql -u username -p dbname &lt; backup.sql 8 浏览 show databases; show tables; show fields from table1; describe table1; show create table table1; show processlist; 9 连接查询 select ... from t1 join t2 on t1.id = t2.id where condition; select ... from t1 left/right join t2 on t1.id = t2.id where condition; select ... from t1 join (t2 join t3 on ...) on ...; 10 条件 field = value field &lt;&gt; value field like 'value%' filed is null field is not null field in (value1,value2,...) field not in (value1,value2,...) condition1 and conditoin2 condition1 or condition2 11 用户与权限 grant all privileges on database.table to 'user'@'localhost' identified by 'password'; grant select,insert,delete on database.* to 'user'@'xxx.xxx.xxx.xxx' identified by 'password'; revoke select on database.table from 'user'@'host'; revoke all privileges,grant option from 'user'@'host'; alter user 'user'@'host' identified with mysql_native_password by 'new_password'; drop user 'user'@'host'; ","link":"https://2293736867.github.io/post/mysql-chang-yong-cao-zuo/"},{"title":"每日分享 第17期","content":" 每日鸡汤 当你觉得生活对你不公时，秤秤体重，照照镜子，你会觉得一切又合乎情理。 每日冷知识 科学家估计地球上约有40万种植物，其中一半以上可以食用。不过作为人类，我们只在吃大约200种植物。 每日诗词 竹深树密虫鸣处，时有微凉不是风。 ——杨万里《夏夜追凉》 每日一句 没人生来杰出。 每日音乐 最幸福的人-曾春年 遇上一个人 要多少缘分 茫茫人海擦肩而过多少陌生人 但你的眼神 触动我的心 我愿意用所有 换你一个转身 爱上一个人 要多少缘分 心甘情愿为你付出不觉得愚蠢 爱你那么深 爱得那么真 真的好想这样 让这份爱永恒 你知不知道你就是我最爱的人 为你赴汤蹈火也不是不可能 从来都没有爱过这么深 遇上你我感觉我是最幸福的人 你知不知道你就是我最爱的人 为你放弃一切也不是不可能 从来都没有 爱过这么深 爱上你我感觉我是最幸福的人 遇上一个人 要多少缘分 茫茫人海擦肩而过多少陌生人 但你的眼神 触动我的心 我愿意用所有 换你一个转身 爱上一个人 要多少缘分 心甘情愿为你付出不觉得愚蠢 爱你那么深 爱得那么真 真的好想这样 让这份爱永恒 你知不知道你就是我最爱的人 为你赴汤蹈火也不是不可能 从来都没有 爱过这么深 遇上你我感觉我是最幸福的人 你知不知道你就是我最爱的人 为你放弃一切也不是不可能 从来都没有爱过这么深 爱上你我感觉我是最幸福的人 你知不知道你就是我最爱的人 为你赴汤蹈火也不是不可能 从来都没有 爱过这么深 遇上你我感觉我是最幸运的人 你知不知道你就是我最爱的人 为你放弃一切也不是不可能 从来都没有 爱过这么深 爱上你我感觉我是最幸福的人 爱上你我感觉我是最幸福的人 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-17-qi/"},{"title":"Linux 递归修改后缀名","content":"1 修改命令 需要用到： find awk xargs 递归修改命令如下： find . -name '*.XXX' | awk -F &quot;.&quot; '{print $2}' | xargs -i -t mv ./{}.XXX ./{}.XXXX 把XXX后缀修改为XXXX。 2 find find用来在指定目录下查找文件，位于参数之前的字符串都被视为需要查找的目录。 find . -name '*.XXX'中： .表示当前文件夹 -name表示文件名符合name的文件，有一个类似的-iname会忽略大小写 *.XXX表示寻找所有的XXX后缀的文件 其他常用例子： find . -type f：递归列出一般文件 find . -ctime -20：递归列出最近20天内更新过的文件 find /var/log -type f -mtime +7 -ok rm {} \\;：查找/var/log下更新时间在7日以前的普通文件，并在删除之前询问 find . -type f -perm 644 -exec ls -l {} \\;：查找当前目录下权限为644的文件 find / -type f -size 0 -exec ls -l {} \\;：查找/下文件大小为0的普通文件并列出完整路径 3 awk awk是一种处理文本文件的语言，是一个强大的分析工具。 awk -F &quot;.&quot; '{print $2}'中： -F指定输入文件拆分分隔符，因为需要修改后缀名，后缀名与主文件名由.分隔，因此后面加上&quot;.&quot;参数 '{print $2}'：print表示打印，$在awk中表示字段引用，这里$2表示引用第二个字段，字段根据前面的-F参数进行分隔。 因为find打印出来的是./a/b/c.XXX，因此print $2会打印其中第二个字段，就是路径/a/b/c，而print $1为空（因为第一个.之前没有其他内容），print $3为后缀名 4 xargs xargs是给命令传递参数的一个过滤器，可以将管道或者标准输入数据转换为命令行参数，默认的命令为echo。使用xargs可以对不支持管道的命令添加类似管道的功能，比如： find . -name '*.jpg' | ls -l # 错误，但是能执行，执行的结果仅仅是ls -l的结果 find . -name '*.jpg' | xargs ls -l # 正确 xargs -i -t mv ./{}.XXX ./{}.XXXX中： -i表示将xargs的每项名称，一般是一行一行赋值给后面的{} -t可选，表示先打印需要执行的命令（这里是先打印mv）再执行 mv：重命名 {}：配合-i使用，这里的{}表示前一步awk中的路径名，对每一个路径都执行一次mv，也就是修改后缀名 ","link":"https://2293736867.github.io/post/linux-di-gui-xiu-gai-hou-zhui-ming/"},{"title":"每日分享 第16期","content":" 每日鸡汤 你若帮了一急需用钱的朋友，他一定会记得你，在他下次急需用钱的时候。 每日冷知识 为了向医学界证明溃疡并非胃酸所引发，巴里·马歇尔博士主动服用了幽门螺杆菌。他在随后几天内患上了胃溃疡，并用抗生素进行了治疗，并在此后获得了诺贝尔生理学或医学奖。 每日诗词 竹色溪下绿，荷花镜里香。 ——李白《别储邕之剡中》 每日一句 松树千年终是朽，槿花一日自为荣。 每日音乐 一首，嗯，比较“老”的歌，徐良的，虽然是挺悲伤的，但是。。。好听啊！！！（话说徐良陪伴了笔者的整个青春啊！！！） 徐良/孙羽幽-虐心 落叶飘过一个曾经 曾经许下一个约定 两个人的手深深握紧 同样的街景 熟悉的声音 你说了 对不起 坚强从来都是故意 故意假装着不在意 亲爱的请你不要哭泣 只有你幸福 我愿意忘记 记忆中全部的你 下一次我们会在某个路口相遇 请告诉我你过得很开心 想念你的眼睛 你的表情 你的身影 泪湿在一个人的夜里 下一次我们会在某个路口相遇 请告诉我怎么能不想你 忘掉你的真心 你的用心 你的伤心 忘掉牵挂着你的自己 和尘封的记忆 落叶飘过一个曾经 曾经许下一个约定 两个人的手深深握紧 同样的街景 熟悉的声音 你说了 对不起 坚强从来都是故意 故意假装着不在意 亲爱的请你不要哭泣 只要你幸福 我愿意忘记 记忆中全部的你 下一次我们会在某个路口相遇 请告诉我你过得很开心 想念你的眼睛 你的表情 你的身影 泪湿在一个人的夜里 下一次我们会在某个路口相遇 请告诉我怎么能不想你 忘掉你的真心 你的用心 你的伤心 忘掉牵挂着你的自己 下一次我们会在某个路口相遇 请告诉我怎么能不想你 忘掉你的真心 你的用心 你的伤心 忘掉牵挂着你的自己 和尘封的记忆 有关凶宅 北京有近3000套凶宅，香港则超过3000套，广州和上海也分别有数千套凶宅。呃。。。 凶宅一般指屋中发生过他杀、自杀或者其他非自然死亡事件的住宅。许多买家和租客在不知情的状态下就住进去了。 一般来说，出租房屋时，中介不会透露是“凶宅”（废话），另外一些大型的房地产中介平台，已经建立有”凶宅数据库“，比如这里上海的一个网站： 一些凶宅会被中介从房主那里收走，接着进行一些烈的刷白，装修处理再出租。 还有这个香港的网站： 避免买到凶宅可以从几方面入手： 查“数据库”（不过这个一般比较难查） 房价：一般来说会比同地段的便宜20%-30% 买房之前多了解房屋信息 亲自走访房屋所在的楼层，小区，和周边的邻居多聊天 如果实在无法确定，可以在购房合同中增加对“凶宅”的约定条款 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-16-qi/"},{"title":"Java 获取资源文件路径","content":"1 问题描述 通过源码运行时，一般使用如下方式读取资源文件： String str = &quot;1.jpg&quot;; 资源文件与源码文件放在同一目录下，或者拥有同一父级目录： String str = &quot;a/b/1.jpg&quot;; 这样直接编译运行没有问题，但是打成JAR包后会读取不了，直接抛空指针异常。 2 解决办法 使用URL或者InputStream进行读取： URL url = getClass().getClassLoader().getResource(&quot;a/b/1.jpg&quot;); InputStream inputStream = getClass().getClassLoader().getResourceAsStream(&quot;a/b/1.png&quot;); 注意不能在路径前加/： URL url = getClass().getClassLoader().getResource(&quot;/a/b/1.jpg&quot;); InputStream inputStream = getClass().getClassLoader().getResourceAsStream(&quot;/a/b/1.png&quot;); 这样读取出来是null。 getClass().getClassLoader().getResource()从源码运行的URL如下： 从JAR包运行的URL如下： 测试系统Win10，从源码运行的话有一个file:前缀，而从JAR包运行有一个jar:file:前缀。 前缀一般没有影响，一般都能直接通过URL获取文件，比如在Swing的JFrame中设置图标： mainFrame.setIconImage(new ImageIcon(getClass().getClassLoader().getResource(&quot;image/icon.png&quot;)).getImage()); 如果只能通过String处理路径，需要把前缀file:或者jar:file:去掉，JAR的话可以结合JarFile类读取文件。 ","link":"https://2293736867.github.io/post/java-huo-qu-zi-yuan-wen-jian-lu-jing/"},{"title":"每日分享 第15期","content":" 每日鸡汤 减肥，你想要坚持，但是坚持不想要你。 每日冷知识 气候变化正在将世界上最古老的木乃伊变成黑色粘稠物质。尽管这些木乃伊已经在智力的阿塔卡马沙漠保存了7000年，但是该地区的湿度如今已经上升到足以令木乃伊迅速腐烂的地步。 每日诗词 阴阴溪曲绿交加，小雨翻萍上浅沙。 ——晁冲之《春日》 每日一句 如果你仲记得我，就返转头啦。 每日音乐 井胧-想死却又不敢 把黑夜当作是我最爱的颜色 一个人独自忍受着夜的折磨 只有对着孤独沉默 慢慢地怀恋 想要爱你却又不敢 把幸福当作幻想都沉醉入眠 把誓言当作谎言却都是欺骗 回忆曾经那些诺言 浮现在眼前 想要放弃却心又不甘 把黑夜当作是我最爱的颜色 一个人独自忍受着夜的折磨 只有对着孤独沉默 慢慢地怀恋 想要爱你却又不敢 把爱情当作拥有却难以忘怀 把深情当作伤害却难以放开 只有喝着孤独的酒 慢慢地怀恋 想要爱你却又不敢 把幸福当作幻想都沉醉入眠 把誓言当作谎言却全都欺骗 回忆曾经那些诺言 浮现在眼前 想要放弃我却又不敢 把爱情当作拥有却难以忘怀 把深情当作伤害却难以放开 只有喝着孤独烈酒 慢慢地怀恋 想要爱你却又不敢 有关民间骗术 清朝末年，江湖骗子这一职业被细分为“蜂、麻、燕、雀”（也叫“风、马、颜、缺”）四个门派。 蜂 蜂字门，靠的是多人配合，行动如蜂群，分工明确演绎一场骗局。 例子： 近几年中国乡村流行的“煤气罐诈骗” 电信诈骗（会追随社会热点和一些热门新闻，包括政治、经济、文化、体育、娱乐等） 2005年“木匠假扮港商欲建西北第一楼” &quot;西北第一爆&quot; 麻 麻字门，走技术流。骗子大多号称自己是神医、高僧、大仙，靠戏法，靠三寸不烂之舌混迹江湖。 例子： “筷子刮眼抓虫” 北宋郭京，“六甲神兵” 高科技：48亿的立体快巴“巴铁”项目 燕 燕字门，靠美色。比如 靠女色行骗，这种很常见 靠男色行骗，跟就是现在说的PUA差不多 例子： “最美通缉犯” 仙人跳，这个太多了，随便举几个：戳这里，这里，或这里 PUA 杀猪盘，顾名思义受害人是猪，把猪养肥了再杀，男女的例子都有 雀 雀字门，当属最硬核操作，杀官夺印冒名上任。 例子： 《西游记》中的强盗刘洪 2010年&quot;爱新觉罗三公主&quot; 2017年詹承华 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-15-qi/"},{"title":"每日分享 第14期","content":" 每日鸡汤 小时候我常想，长大了是上北大还是清华，现在想想原来是我想多了。 每日冷知识 老鼠无法呕吐，这就是为什么老鼠药会如此有效。除此之外，老鼠既无法打嗝，也不会感到胃灼热。 每日诗词 胡蝶梦中家万里，子规枝上月三更。 ——崔涂《春夕》 每日一句 爱与友情以及勇气改变不了一个人，只有受伤才能让人成长。 每日音乐 可惜我是水瓶座-杨千嬅 原来你这样珍惜我 从前在热恋中都未听讲过 别说这种行货 哪里留得住我 到底是为什么分手你很清楚 如何笨到底 但到底还是我 谁人待我好 待我差 太清楚 想继续装傻 却又无力受折磨 心里羡慕那些人 盲目到不计后果 我 就回去 别引出我泪水 尤其明知水瓶座最爱是流泪 若然道别是下一句 可以闭上了你的嘴 无谓再会要是再会更加心碎 要是回去 没有止痛药水 拿来长岛冰茶换我半晚安睡 十年后或现在失去 反正到最尾也唏嘘 够绝情 我都赶我自己出去 犹如最结实的堡垒 原来在逐点崩溃逐点粉碎 极固执的如我 也会捱不下去 每天扮着幸福始终有些心虚 如何笨到底 但到底 还是我 谁人待我好 待我差 太清楚 想继续装傻 却又无力受折磨 心里羡慕那些人 盲目到不计后果 我就回去 别引出我泪水 尤其明知水瓶座最爱是流泪 若然道别是下一句 可以闭上了你的嘴 无谓再会要是再会更加心碎 要是回去 没有止痛药水 拿来长岛冰茶换我半晚安睡 十年后或现在失去 反正到最尾也唏嘘 够绝情 我都赶我自己出去 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-qi-mei-ri-fen-xiang-mo-ban/"},{"title":"每日分享 第13期","content":" 每日鸡汤 为什么你能像智障一样活着，而我却不可以。 每日冷知识 鸣枪礼这怡传统最初起源于和平意图的示意。由于每次射击后都需要重新装填枪支和大炮，因此向天空射击实际上会使你“解除武装”。 每日诗词 夜来南风起，小麦覆陇黄。 ——白居易《观刈麦》 每日一句 你总是这样轻易放弃的话，无论多久都只会原地踏步。 每日音乐 一阵风吹过-刘阳阳/萝莉大大 看着你远去的背影 忧伤瞬间就被扬起 情花一片片的凋零 心里投下斑驳的痕迹 那伤感悠扬的曲调 在蓝色天空下飘摇 那麦浪就如同波涛 拍打在落日色的吊桥 一阵风吹过 把你带走了 花儿在颤抖 蝴蝶流泪了 记忆在拼凑 心儿破碎了 甜蜜的哀愁 童话停止了 天空的尽头 有人伤心了 失色的云朵 画面更改了 挥一挥衣袖 故事结束了 作别你温柔世界突然都变了 看着你远去的背影 忧伤瞬间就被扬起 情花一片片的凋零 心里投下斑驳的痕迹 那伤感悠扬的曲调 在蓝色天空下飘摇 那麦浪就如同波涛 拍打在落日色的吊桥 一阵风吹过 把你带走了 花儿在颤抖 蝴蝶流泪了 记忆在拼凑 心儿破碎了 甜蜜的哀愁 童话停止了 天空的尽头 有人伤心了 失色的云朵 画面更改了 挥一挥衣袖 故事结束了 作别你温柔世界突然就变了 一阵风吹过 把你带走了 花儿在颤抖 蝴蝶流泪了 记忆在拼凑 心儿破碎了 甜蜜的哀愁 童话停止了 天空的尽头 有人伤心了 失色的云朵 画面更改了 挥一挥衣袖 故事结束了 作别你温柔世界突然都变了 7.1 今天是7月1日，是建党99周年日。 99岁了啊，加油！！ ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-13-qi/"},{"title":"每日分享 第12期","content":" 每日鸡汤 如果不能一夜暴富，两夜也可以，三晚我也不嫌多。 每日冷知识 水稻是最耗水的农作物之一，种植每公斤需要耗费约2500升水，但这些水主要是为了防止杂草生长。SRI（水稻强化栽培体系）是一项新秀技术，可以减少50%以上的用水量。 每日诗词 月明船笛参差起，风定池莲自在香。 ——秦观《纳凉》 每日一句 我不承认需要有人牺牲的魔法，而且人与人的思念，可以超越魔法。 每日音乐 Despacito-Luis Fonsi / Daddy Yankee / Justin Bieber Come on over in my direction So thankful for that, it's such a blessin', yeah Turn every situation into Heaven, yeah Oh, you are My sunrise on the darkest day Got me feelin' some kind of way Make me wanna savor every moment slowly, slowly You fit me, tailor-made love, how you put it on Got the only key, know how to turn it on The way you nibble on my ear, the only words I wanna hear Baby take it slow so we can last long Oh, tú, tú eres el imn y yo soy el metal Me voy acercando y voy armando el plan Sólo con pensarlo se acelera el pulso Oh, yeah Ya, ya me está gustando más de lo normal Todos mis sentidos van pidiendo más Esto hay que tomarlo sin ningún apuro Despacito Quiero respirar tu cuello despacito Deja que te diga cosas al oído Para que te acuerdes si no estás conmigo Despacito Quiero desnudarte a besos despacito Firmo en las paredes de tu laberinto Y hacer de tu cuerpo todo un manuscrito (Sube, sube, sube, sube, sube) Quiero ver bailar tu pelo Quiero ser tu ritmo Que le enseñes a mi boca Tus lugares favoritos (Favorito, favorito, baby) Déjame sobrepasar tus zonas de peligro Hasta provocar tus gritos Y que olvides tu apellido Si te pido un beso, ven, dámelo Yo sé que estás pensándolo Llevo tiempo intentándolo Mami, esto es dando y dándolo Sabes que tu corazón conmigo te hace bang-bang Sabes que esa beba está buscando de mi bang-bang Ven, prueba de mi boca para ver cómo te sabe Quiero, quiero, quiero ver cuánto amor a ti te cabe Yo no tengo prisa, yo me quiero dar el viaje Empecemos lento, después salvaje Pasito a pasito, suave suavecito Nos vamos pegando, poquito a poquito Cuando tú me besas con esa destreza Veo que eres malicia con delicadeza Pasito a pasito, suave suavecito Nos vamos pegando, poquito a poquito Y es que esa belleza es un rompecabezas Pero pa' montarlo aquí tengo la pieza ¡Oye! Despacito Quiero respirar tu cuello despacito Deja que te diga cosas al oído Para que te acuerdes si no estás conmigo Despacito Quiero desnudarte a besos despacito Firmo en las paredes de tu laberinto Y hacer de tu cuerpo todo un manuscrito (Sube, sube, sube, sube, sube) Quiero ver bailar tu pelo Quiero ser tu ritmo Que le enseñes a mi boca Tus lugares favoritos (Favorito, favorito, baby) Déjame sobrepasar tus zonas de peligro Hasta provocar tus gritos Y que olvides tu apellido Despacito This is how we do it down in Puerto Rico I just wanna hear you screaming, &quot;¡Ay, Bendito!&quot; I can move foreverm se quede contigo ¡Bailalo! Pasito a pasito, suave suavecito Nos vamos pegando, poquito a poquito Que le enseñes a mi boca Tus lugares favoritos (Favorito, favorito, baby) Pasito a pasito, suave suavecito Nos vamos pegando, poquito a poquito Hasta provocar tus gritos (Fonsi) Y que olvides tu apellido (D.Y.) Despacito ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-12-qi/"},{"title":"每日分享 第11期","content":" 每日鸡汤 做一天的好人并不难，难的是做一辈子有钱人。 每日冷知识 女人更擅长辨别颜色的深浅，而男人更擅长追踪快速移动的物体并从远处识别细节。这些都是与人类狩猎采集历史相关的进化细节。 每日诗词 莫辞盏酒十分劝，只恐风花一片飞。 ——程颢《郊行即事》 每日一句 所以我松开拳头用手握紧笔，作为自己作为人类也作为你。 ——贰拾 每日音乐 自己-黄伊汶 人若活一次 多少苦都要试 流泪或失意 有尽时 恨他多少次 以后才懂确定 变幻无常 人生必经 多珍惜都会走 无奈人善变 多舍不得放手 也只有接受 自尊心伤过太多次 眼泪流下了 何必勉强自己 不甘心都要走 无奈留住你 到最后换来是 白费心机 伤心伤过这一次 会努力面对 人总要靠自己 理想是坚守到白头 她很奋斗 但最终是一切 背道而驰 为他哭得呼天抢地 流干眼泪 自怨又自艾 谁撑到你 多珍惜都会走 无奈人善变 多舍不得放手 也只有接受 自尊心伤过太多次 眼泪流下了 何必勉强自己 不甘心都要走 无奈留住你 到最后换来是 白费心机 伤心伤过这一次 会努力面对 人总要靠自己 很可惜他要走 无奈人善变 多舍不得放手 也只有接受 自尊心伤过太多次 眼泪流下了 何必放弃自己 经得起这结果 其实跌低过 到最后 任何事也会经过 冷静下来便清楚 前路得一个 得你爱自己 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-11-qi/"},{"title":"CLion 2020.1.2 激活","content":"1 下载 官网。 2 运行 解压安装并运行，选择Evaluate。 3 激活 来这里下载jar补丁，拖进去即可。 ","link":"https://2293736867.github.io/post/clion-202012-ji-huo/"},{"title":"每日分享 第10期","content":" 每日鸡汤 你得好好努力，才能配得上，被人利用。 每日冷知识 有一些植物（如拟南芥）在感应到毛毛虫咀嚼的振动时能以释放毒素作为防御机制，哪怕咀嚼声是播放的录音。 每日诗词 忧喜相寻，风雨过，一江春绿。 ——苏轼《满江红·忧喜相寻》 每日一句 值得获取的东西，就在风险的彼岸。 每日音乐 野孩子-杨千嬅 就算只谈一场感情 除外都是一时虚荣 不等于在蜜月套房游玩过 就可自入自出仙境 情愿获得你的尊敬 承受太高傲的罪名 挤得进你臂弯 如情怀渐冷 未算孤苦也伶仃 明知爱这种男孩子 也许只能如此 但我会成为你最牵挂的一个女子 朝朝暮暮让你猜想如何驯服我 若果亲手抱住 或者不必如此 许多旁人说我不太明了男孩子 不受命令就是一种最坏名字 笑我这个毫无办法管束的野孩子 连没有幸福都不介意 若我依然坚持忠诚 难道你又适合安定 真可惜 说要吻我的还未吻 自己就自梦中苏醒 离场是否有点失敬 还是更轰烈的剧情 必需有这结果 才能怀念我 让我于荒野中驰骋 明知爱这种男孩子 也许只能如此 但我会成为你最牵挂的一个女子 朝朝暮暮让你猜想如何驯服我 若果亲手抱住 或者不必如此 许多旁人说我不太明了男孩子 不受命令就是一种最坏名字 笑我这个毫无办法管束的野孩子 连没有幸福都不介意 明知爱这种男孩子 也许只能如此 但我会成为你最牵挂的一个女子 朝朝暮暮让你猜想如何驯服我 若果亲手抱住 或者不必如此 许多旁人说我不太明了男孩子 不受命令就是一种最坏名字 我也笑我原来是个天生的野孩子 连没有幸福都不介意 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-10-qi/"},{"title":"每日分享 第9期","content":" 每日鸡汤 虽然你长的丑，但是你想得美啊。 每日冷知识 老式的&quot;高轮车&quot;也被称为&quot;便士法新&quot;,因为人们认为其车轮看上去像是最大（便士）和最小（法新）的英国硬币。 每日诗词 杜鹃啼初，泪洒胭脂雨。 —— 陈子龙《点绛唇·春日风雨有感》 每日一句 无论乌云有多厚，星星也一定还在，只是暂时看不到了而已。 —— 电波女与青春男 每日音乐 萤火虫之光-ホタルノヒカリ SHA LA LA いつかきっと 僕は手にするんだ はかなき 胸に そっと ひかり 燃えていけ 逢いたくなるの「衝動」 哭きたくなるの「純情」 夏の火に飛び込んだ ホタルはかえらない あなたは何も言わず接吻(くちづけ)を残して 火傷(きず)つくまま うなづいたね 哀しいほど命 揺らめいていた SHA LA LA いつかきっと 僕は手にするんだ はかなき 胸に そっと ひかり 燃えていけ SHA LA LA 愛しきひと あなたもみえているの まばゆい 月が そっと 明日を照らして 強く 強く 輝いて 風に吹かれるほど 烈しくなる心に はぐれそうな想い出が また優しく灯る 夢中で駆けだしたら 触れられる気がした 意志(おもむ)くまま 手を伸ばすよ 切ないほど命 揺らめいていく SHA LA LA 僕はずっと 唄いつづけていくよ ふるえる 胸に そっと ひかり 燃えていけ SHA LA LA 愛しきひと あなたに届くように はてない 空に そっと 想い つのらせて 強く 強く 響かせて SHA LA LA いつかきっと ホタルは燃え尽き散って きえゆく 胸に そっと 夢よ 輝いて SHA LA LA 愛しきひと あなたも忘れないで きらめく 夏に そっと 願いを重ねて SHA LA LA いつかきっと 僕は手にするんだ はかなき 胸に そっと ひかり 燃えていけ SHA LA LA 愛しきひと あなたもみえているの まばゆい 月が そっと 明日を照らして 強く 強く 輝いて ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-9-qi/"},{"title":"Kotlin学习笔记","content":"1 概述 这篇文章首先会介绍Kotlin的特点，接着介绍Kotlin与Java的语法比较。 2 Kotlin特点 一门现代化的编程语言 可开发跨平台应用，web，Socket，安卓，js，NativeApp等 静态编程语言，性能基本与原声Java相当 100%兼容Java（说是兼容但实际上有些坑，可以戳这里看看） 简洁：跟Java相比真的是简洁很多，语法糖特别舒服 安全：彻底解决写Java基本上都会遇到的著名的NullPointerException问题，结合编译器可以在编译截断发现几乎所有可能存在NPE问题的代码 互操作性：基于JVM，可以直接拿现有的Java库用 工具友好：和JetBrains的IDE结合简直舒服得不要不要的 支持函数式编程：比如Lambda表达式 支持协程：协程像是非常轻量级的县城，协程将复杂性放入库来简化异步编程，逻辑可以在协程中顺序表达，底层库负责解决异步性，很重要的一点是协程挂起不会阻塞其他线程。官方一个demo是开启10w个协程： 支持扩展函数：类似C#，能够扩展一个类的新功能而无需继承类或者使用装饰者这样的设计模式，Kotlin支持扩展函数和扩展属性 泛型：当然Java也支持泛型，但是Kotlin比Java支持得更好 不依赖XML 下面进入Kotlin的语法部分。 3 基本语法 无;结尾 println()代替System.out.println(); 输出语句中使用$变量名代替Java中的+变量名，比如println(&quot;age:$age&quot;)而不是System.out.println(&quot;age:&quot;+age) 三引号（三个双引号连在一起）中的字符串不会进行转义 4 变量与常量 var声明变量 val声明常量 可以在var/val后面加上类型，比如val a:Int 如上图提示val不能被赋值，提示改为var。val类似与Java中的final，虽然val引用自身不可变，但是指向的对象是可以改变的。 val只能进行唯一一次初始化，如果编译器能确保只有唯一一条初始化语句被执行，可以根据条件进行不同的初始化操作： val a:Int if (4&gt;3) { a = 9 } else { a = 10 } 5 表达式和语句 Java中所有的控制结构都是语句，在Kotlin中除了三大循环（while，for，do while）外，大多数控制结构都是表达式。比如if是表达式而不是语句。也就是说，if有值而不像Java里面一样没有值（语句）。 例子： var a = if (3&gt;2) 3 else 2 fun main() { var a = max(4,9) } fun max(a:Int,b:Int): Int = if(a&gt;b) a else b 6 枚举 使用enum class而不是Java中的enum： fun main() { val months = Months.May println(months.days) } enum class Months(val days:Int) { May(31), Jun(30) } 7 when when相当于Java中的switch： fun main() { val months = Months.May when(months) { Months.May -&gt; print(&quot;May&quot;) Months.Jun -&gt; print(&quot;June&quot;) } } enum class Months(val days:Int) { May(31), Jun(30),; } 使用-&gt;进行了简化。 8 循环 8.1 while与do while 与Java一样。 8.2 for 使用..表示区间，在i前面没有类型： for (i in 1..100) print(i) 注意区间是两边都包含的，也就是1..100表示i从1循环到100。 使用下标迭代： val arr = arrayListOf(&quot;1111&quot;,&quot;2222&quot;,&quot;333&quot;) for ((i,e) in arr.withIndex()) println(&quot;$i = $e&quot;) 输出： 0 = 1111 1 = 2222 2 = 333 9 类 9.1 构造方法 class Person(val name:String) 不需要像Java一样this.xxx=xxx。 9.2 getter/setter 因为val代表常量，而var代表变量，setter是用于改变值的，因此，使用var声明的属性具有getter与setter，使用val声明的属性只有getter。 Kotlin没有提供直接操纵getter与setter的方式，通过使用.属性名进行修改属性或者获取属性： class Person { var name = &quot;&quot; val id = &quot;&quot; } var person = Person() person.name=&quot;111&quot; person.id=&quot;222&quot; //编译不通过，id为val不可变 9.3 自定义getter/setter 在相应的属性后面加上get/set即可自定义getter/setter： class Person { var name=&quot;&quot; get() { return &quot;name&quot;+field } var id=&quot;&quot; set(id) { field = id } } 在get/set中使用field表示字段，比如在上面例子中的get中，field表示name，而在下面的set中，field表示自己的id，=后面是参数的id。 10 异常 10.1 抛出异常 直接throw，无需new： val age = 300 if(age !in 1..100) throw IllegalArgumentException(&quot;Out of range:$age&quot;) 10.2 try/catch try { throw Exception(&quot;exception&quot;) } catch (e:Exception) { e.printStackTrace() } 10.3 受检异常与不受检异常 Java中的异常有两类： Unchecked Exception：不受检异常，可以不进行try/catch处理，包括Runtime Exception及其子类 Checked Exception：受检异常，必须进行try/catch处理或者声明需要抛出，不属于不受检异常的异常都属于受检异常 Kotlin不区分两者，也就是对于Java的受检异常可以不处理，比如： fun main() { throw IllegalArgumentException(&quot;333&quot;) } 可通过编译，而Java中的 public class Test { public static void main(String []args) { throw new Exception(&quot;111&quot;); } } 则无法通过编译。 11 集合类 val arrayList = ArrayList&lt;Int&gt;() arrayList.add(3) arrayList.add(9) arrayList.forEach { t-&gt; println(t) } val hashSet = hashSetOf&lt;String&gt;() hashSet.add(&quot;2222&quot;) hashSet.add(&quot;99999&quot;) hashSet.forEach{t-&gt; println(t)} val list = listOf(3,5,5) list.forEach{t-&gt; println(t)} val map = mapOf(&quot;a&quot; to 1,&quot;b&quot; to 2) map.forEach{(k,v)-&gt; println(&quot;$k to $v&quot;)} 可以直接使用集合类或者xxxOf创建，遍历使用forEach与Lambda，Kotlin风格的Lambda使用{}。 12 函数 12.1 基本语法 fun printStr(str:String) { println(str) } fun add(a:Int):Int { return a+3 } fun声明函数 形参类型在形参名称后 返回类型放在最后，前面需要带： 函数不强制放在类中 12.2 默认参数 Java里面没有默认参数，实现类似功能需要重载去解决，而Kotlin的函数可以具有默认参数： fun main() { println(add()) println(add(1)) println(add(1,2)) } fun add(a:Int = 3,b:Int = 4):Int = a+b 可以省略的只有在末尾的参数，也就是默认参数从末尾开始确定默认值。 12.3 命名参数 类似Python，调用函数时使用形参名称与值的方式调用而不是仅仅通过值调用，同时可以结合默认参数省略部分值。 fun main() { println(add(b=1)) println(add(b=5,a=9)) } fun add(a:Int = 3,b:Int = 4):Int = a+b 12.4 可变参数 使用vararg： fun main() { println(add(1,2,3,4)) } fun add(vararg a:Int):Int = a.sum() 13 顶层函数与顶层属性 13.1 顶层函数 Kotlin中可以将函数放在代码文件的顶层，不用附属于任何类，但仍然是包内作用域，包外需要import，作用类似Java中的静态函数。 fun add(vararg a:Int):Int = a.sum() fun main() { println(add(1,2,3,4)) } Java中调用顶层函数时可以使用默认的Kotlin文件名作为默认包去调用，也可以使用@file:JvmName修改调用的包名，比如上面的文件名为Test.kt，则Java中调用的代码如下： TestKt.add() 使用注解后： @file:JvmName(&quot;Test&quot;) fun add(vararg a:Int):Int = a.sum fun main() { println(add(1,2,3,4)) } Java调用方式改变如下： Test.add() 13.2 顶层属性 与Java中的静态属性类似，有点像全局变量或全局常量，可以使用var，val，const val修饰： var a = 0 val b = 0 const val c = 0 fun main() { println(++a) println(&quot;$b\\n$c&quot;) test() } fun test() { println(&quot;$a\\n$b\\n$c&quot;) } val与const val的主要区别是： val实质上相当与Java中的private final static const val实质上相当于Java中的public final static const相当于@JvmField，也就是说const val a = 0与@JvmField val a = 0等价： 14 参考 1、Kotlin语言的特点和优劣势 2、Java受检异常与不受检异常 3、Kotlin中的getter与setter 4、Kotlin与Java的异同 5、Kotlin之const val与val ","link":"https://2293736867.github.io/post/kotlin-xue-xi-bi-ji/"},{"title":"Kotlin Hello World","content":"1 Kotlin Kotlin是一种在JVM上运行的静态类型编程语言，被称为Android界的Wsift，由JetBrains设计。Kotline可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。Google宣布在Google I/O 2017上宣布Kotlin成为Android官方语言。 笔者不是专攻Android的，是做服务端的，尽管目前大部分都是使用Java做后端，但是也有一些Kotlin做后端的资料，比如Kotlin结合Spring Boot的也有不少文章，因此笔者决定使用Kotlin进行后端开发。 那么，先从Hello world开始。 2 新建工程 IDE用的是IDEA，新建工程并选择Kotlin： 项目名： 结构应该长这样（居然连个Main都没有。。。）： 3 Main 在src下新建一个Main.kt： 代码在图中就不再贴一次了。 当然可能有人会问Stirng [] args去哪里了，那就把它加上： IDEA提示从Kotlin1.3开始main参数不是必要的，因此把它去掉了。不过老实说Kotlin比起Java还真的简洁。 4 添加运行配置 选择Add Configuration，接着选择Kotlin： 在Main class:处输入默认包MainKt： 5 运行 Shift+F10或者点击绿色小箭头运行即可。 ","link":"https://2293736867.github.io/post/kotlin-hello-world/"},{"title":"每日分享 第8期 樱花树下特辑","content":" 每日鸡汤 老一辈的人常告诉我们，年轻的时候多吃点苦，这样老了才能习惯啊！ 每日冷知识 一项研究发现，帽贝齿由自然界中最强韧的生物材料制成。组成这种软体动物牙齿材料强度大约是蜘蛛丝的五倍（前最强韧生物材料头衔持有者）。 每日诗词 空白处，寄幽怀。怕人猜。 执轻罗扇，捕影追风，斜过香腮。 —— 张维芬《诉衷情令 约茶樱花树下》 每日一句 窗外 那绛红色的茎叶上 长串的樱花 伸展着淡粉色的花瓣 ——《樱花树下》（外两首） 每日音乐 樱花树下 树荫有一只蝉 跌落你身边 惊慌到失足向前 然后扑入我一双肩 令你腼腆一脸 像樱花万千 怀念美好高中两年 期望你的青春不变 去到今天 还记得樱花正开 还未懂跟你示爱 初春来时 彼此约定过 继续期待 人置身这大时代 投入几番竞技赛 曾分开 曾相爱 等待 花蕊又跌下来 才洞悉这是恋爱 未有过的爱情 但有种温馨 归家那单车小径 沿路细听你的歌声 没法再三倾听 你的感动昵称 维系错的一番友情 无奈已经不可纠正 太过坚贞 还记得樱花正开 还未懂跟你示爱 初春来时 彼此闭着眼 渴望未来 人置身这大时代 投入几番竞技赛 曾分开 曾相爱 等待 跟你未爱的爱 你说悲不悲哀 秒速之间变改 小小世界 眷恋 也许走不过 拆卸的街 少女亦随年渐长 走得多么快 如有天樱花再开 期望可跟你示爱 当天园林 今天已换上 满地青苔 如有天置地门外 乘电车跨过大海 匆匆 跟你 相望一眼 没理睬 明日花 昨日已开 《樱花树下》 这里说的是渡边淳一的小说《樱花树下》，笔者看过这本书，最近有回想了起来，记录一下感悟。 首先介绍一下渡边淳一吧，1933-2014，出生于北海道上砂川町，日本当代作家，1963年获得医学博士学位。1969年35岁的渡边淳一弃医从文，1989年发表《樱花树下》，获得过的奖项包括同人杂志奖，芥川奖，直木文学奖，吉川英治文学奖，文艺春秋读者奖。 《樱花树下》与渡边淳一的其他情爱作品类似，下面是摘自知乎的原话： 《失乐园》“清纯而又冶艳的少妇”爱上了已婚的中老年编辑 《泡沫》“清纯而又冶艳的少妇”爱上了中老年作家 《雁来红》“清纯而又冶艳的少女”爱上了已婚的中老年医生 《为何不分手》“清纯而又冶艳的年轻医生”爱上了已婚的中老年医生 《樱花树下》“清纯而又冶艳的母女俩”同时爱上了已婚的中老年出版社社长 《一片雪》“清纯而又冶艳的富婆、少女、少妇”同时爱上了已婚的中老年设计师 。。。 小说有写到： “樱花这么美，你知道是为什么吗？” “因为，樱花树下埋着尸体。” “真的吗？埋了尸体，樱花就能开得更盛吗？” “也许是把人的血肉当养分吸收了。” 樱花贯穿始终，无论是作为环境的描写还是场景的过渡，给人的感觉就是有一种神秘的色彩。小说里面介绍了两种樱花： 一种是开得鲜艳、娇滴滴的垂枝樱 一种是开得妩媚又有些悲哀的染井吉野 下面是染井吉野的图： 染井吉野是一种花期只有一周的花，谢幕的时候花瓣会坠落成“樱花雨”： 染井吉野给人一种美得妖艳的感觉，这种谢幕的场景给笔者的感觉是确实很美但是会感到一丝凉意。在作品中，樱花仿佛是一个具有灵气的妖孽，从开幕的赏樱花到最后的菊乃躺在樱花树下，始终充满了迷幻的色彩。尽管作者没有大段大段的描写过樱花，但是寥寥几笔就能让读者“想入非非”，感受到了樱花的美。 垂枝樱和染井吉野代指了凉子与菊乃，暗示着凉子就是开得诱人鲜艳的垂枝樱，而菊乃就是妩媚但悲哀的染井吉野。或许正是由于染井吉野的妖艳，菊乃迎来的最后结局注定是悲惨的。尽管小说没有写到菊乃是自杀还是不小心坠落致死，不过给笔者的感觉就是自杀死亡的。试想，女儿怀孕了，但是造成这结果的人确实自己心爱的男人，这样的事实又能有多少正常女性可以接受？ 菊乃死后埋在樱花树下，与“樱花树下埋着尸体”对应了起来： 去年赏樱的时候，你说过，樱花树下埋着尸体。凉子和游佐并肩而立，抬头看着樱花说道。 “妈妈现在真的在这棵樱花树下长眠了。” “听到那句话的时候我就有不详的预感。” “我说的时候，并不是有心的。” “但是，确实就像真的一样，很可怕。” “虽然觉得可怕，还是被你深深吸引。” 最后凉子离开游佐，宣告了故事的结束，就这样两种不同的“樱花”，仿佛就是游佐生命的过客，来得安静，也走得安静。 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-8-qi-ying-hua-shu-xia-te-ji/"},{"title":"每日分享 第7期","content":" 每日鸡汤 吃货一般都比较善良，因为每天都只想着吃，没有时间去算计别人。 每日冷知识 在1937年之前的美国，男性裸露上半身（即使在海滩上）是非法的。如果在纽约市或其市政海滩被当场抓获，则将被罚款1美元。 每日诗词 荷风送香气，竹露滴清响。 ——孟浩然《夏日南亭怀辛大》 每日一句 希望你可以记住我，记住我这样活过，这样在你身边呆过 ——《挪威的森林》 每日音乐 广寒宫-丸子呦 午夜时分月上枝头谁为谁心疼 一杯浊酒浇在心头谁让谁心冷 置身囫囵唯唯诺诺还诚惶诚恐 阴错阳差天地分别谁成了英雄 广寒宫阙之中 锁着她的寂寞 桂树花印霓虹 管他雕梁画栋 只愿晨鼓暮钟 化作一丝温柔 云涛翻涌苍穹 是她遗恨相思愁 云母屏风花烛映影深 幻影成茧奈何奴身不由己几分 长河渐落破晓韵星沉 玉兔金蟾助我药成再伴吾君身 午夜时分月上枝头谁为谁心疼 一杯浊酒浇在心头谁让谁心冷 置身混沌唯唯诺诺还诚惶诚恐 阴差阳错天地分别谁成了英雄 广寒宫阙之中 锁着她的寂寞 桂树花印霓虹 管他雕梁画栋 只愿晨鼓暮钟 化作一丝温柔 云涛翻涌苍穹 是她遗恨相思愁 云母屏风花烛映影深 幻影成茧奈何奴身不由己几分 长河渐落破晓陨星沉 玉兔金蟾在伴吾君身 云母屏风花烛映影深 幻影成茧奈何奴身不由己几分 长河渐落破晓陨星沉 玉兔金蟾在伴吾君身 有关OCIQ 打开了OICQ，聊天记录停步去年的深秋 ——许嵩《灰色头像》 这首歌应该很多人听过吧，那么里面的OICQ到底是什么呢？ 今天笔者有空去查了一下，资料整理如下： 腾讯开始搞即时聊天工具的时候，就是模仿国外的聊天软件ICQ，ICQ是I seek you的缩写，O是opening的缩写，OICQ就是开放的ICQ，之后为了避免与ICQ发生法律冲突，就改成了QQ。 想当年，最火的互联网沟通方式还是聊天室，当时使用聊天工具的人并不是主流用户，大多数用户仍在使用网易聊天室等网页版的同城聊天室。但是这种公共聊天室无法建立点对点的个人联系，而腾讯公司推出的OICQ是第一款点对点，一对多的聊天软件，又叫网络寻呼机。集合了聊天、公共聊天室、单点传输文件的功能。 下面是OICQ的一些头像： ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-7-qi/"},{"title":"IDEA 2020.1 激活","content":"1 下载安装 平台windows,官网这里. 选位置之后: 选项分别是创建32/64位的快捷方式,把运行目录添加到PATH环境变量,添加右键菜单&quot;打开文件夹作为工程&quot;,添加java/groovy/kt/kts的文件关联,下载安装32位JetBrains运行库.按需要勾选即可. 2 启动 当然是黑色的主题: 这里根据需要选择插件. 选好插件后,选择Evaluate: 3 创建工程进入 默认即可. 如果没有JDK可以利用新版本自带的下载JDK的功能: 4 修改VM options 末尾加上: -javaagent:\\xxx\\xxx\\xxx\\xxx\\xxx.jar 其中jetbrains-agent.jar和激活码可以从这里下载. 这里把jetbrains-agent.jar放到IDEA的lib下面. 5 重启输入注册码激活 成功! 6 声明:仅个人开发学习使用,请不要用作商业用途. ","link":"https://2293736867.github.io/post/20201-idea-ji-huo/"},{"title":"PyCharm 2020.1.1 激活","content":"1 下载安装 平台windows,官网: 选路径后, 选项分别是64位的快捷方式,添加运行目录到环境变量PATH,添加右键菜单&quot;打开文件夹作为一个工程&quot;,python文件关联,按需要勾选即可. 2 启动 选UI,肯定黑色的. 插件,建议IdeaVim. 3 安装补丁 进入启动界面,把jar补丁(下载链接这里)拖到界面去,提示重启: 默认即可. 选择是: 然后重启之后,激活成功. 4 声明:仅个人开发学习使用,请不要用作商业用途. ","link":"https://2293736867.github.io/post/pycharm-202011-ji-huo/"},{"title":"每日分享 第6期","content":" 每日鸡汤 不是吃燕窝的人皮肤好，是吃得起燕窝的人皮肤好。 每日冷知识 仅回收一吨纸张，即可节省3.3立方码的垃圾填埋场、17棵成熟树木、682.5加仑油和7000加仑水。 每日诗词 芳歇去何须根，夏木阴阴正可人。 ——秦观《三月晦日偶题》 每日一句 不管你说再多的慌，只有自己的内心，是无法欺骗的啊。 每日音乐 爱在记忆中找你-林峯 我对你 这一生 哪个可比 我与你 差一些 永远一起 邂逅时间场地 似连场好戏 要 自何页说起 Wow Ho 爱太重 深呼吸 欠缺空气 爱太美 轻轻的 却载不起 爱情来到时候 似明媚天气 它走了 突然骤变雪落雨飞 如果可以恨你 全力痛恨你 连遇上也要躲避 无非想放下你 还是挂念你 谁又会及我伤悲 前事最怕有人提起 就算怎么伸进手臂 我们亦有一些距离 你太远 该怎么 说对不起 你太近 一转身 却已高飞 快乐也许太短 似长流星雨 一眨眼 就如幻觉怕又记起 如果可以恨你 全力痛恨你 连遇上亦要躲避 无非想放下你 还是挂念你 谁又会及我伤悲 前事最怕有人提起 就算怎么伸进手臂 我们亦有一些距离 如果可以恨你 全力痛恨你 连遇上亦要躲避 无非想放下你 还是挂念你 谁又会及我伤悲 前事最怕有人提起 就算怎么伸尽手臂 我们亦有一些距离 我情愿我狠心憎你 我还在记忆中找你 有关太宰治 最近在微博上看到一篇太宰治的文章。 说实话笔者看过他的《人间失格》，确实是丧，有一种很压抑的感觉。建议在心情平和的时候去看，千万千万不要在情绪波动的时候去看，搞不好会“黑化”。 下面是太宰治的一些语录： 只要被人批评，我就觉得对方说得一点都没错，是我自想法有误。 因此我总是黯然接受外界的攻击，内心却承受这疯狂的恐惧。 “我想，一辈子做个钓鱼人，像个白痴一样生活。” “你做不到的，你太容易理解鱼的心情。” 日日重复同样的事，遵循着与昨日相同的惯例，若能避开猛烈的狂喜，自然也不会有悲痛的来袭。 见一个爱一个的人，其实谁都不爱。 我仍然认为向人诉苦不过是徒劳，与其如此，不如默默承受。 有人问我想要什么时，我总是突然就什么都不想要了。 我的不幸，恰恰在于我缺乏拒绝的能力。我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。 悲伤的人总是在笑。 正因是不经意说出的话，才带有真实的味道。 太敏感的人会体谅到他人的痛苦，自然急救无法轻易做到坦率。所谓的坦率，其实就是暴力。 爱好这东西啊，可真够复杂的。一千种厌恶才能生出一个爱好。没有爱好的人，一般也没什么厌恶。 当然，我并不相信世上的人都有能力去爱别人。 诉诸于人——对这一手段我不怀有任何期待。 不管诉诸给谁，恐怕终归不过是被精于世故之人口中那世间常理所反复劝说而已。 家里的事不可说，身上的痛苦不可说，对明日的畏惧不可说，对世人的敏感不可说，昨日之耻不可说。 生而为人，我很抱歉。（这句话只是在《人间失格》中被引用了，原出处为寺内寿太郎的《遗书》） ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-6-qi/"},{"title":"WebStorm 2020.1.2 激活","content":"1 下载 没下载的先去官网下载。 2 安装 系统Linux，解压后直接运行bin下的webstorm.sh。 首先提示是否导入设置，如果以前安装过的话会默认选择第一项。 选UI主题： 是否创建Desktop Entry，类似于Windows上的桌面快捷方式。 是否创建启动脚本，创建后可以通过命令行启动。 选择插件： 先进入： 3 激活 戳这里下载jar补丁，提取里面的jetbrains-agent.jar： 接着拖拽并重启： 提示安装： 重启即可看到激活： ","link":"https://2293736867.github.io/post/webstorm-202012-ji-huo/"},{"title":"Vue Hello World","content":"1 Vue介绍 伟大的项目是从Hello World而来的，Hello World尽管没有什么实际性的作用，但是在于意义重大。（哈哈哈哈） 好了不废话了入正题。 Vue是一套用于构建用户界面的渐进式JS框架，与其他大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完成能够为复杂的单网页应用提供驱动。 2 Hello World 最简单的Hello World是通过&lt;script&gt;引入vue.js： &lt;!-- 开发环境版本 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 生产环境版本 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 开发环境包含了有帮助的命令行警告，而生产环境版本进行了压缩，优化了尺寸以及速度。 下一步直接创建一个html： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue Hello World&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:'#app', data:{ message:'Hello world' } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器直接打开后会看到Hello world： 这样Hello world就完成了。 3 更进一步 由于数据和DOM已经被建立了关联，所有的东西都是响应式的，因此，打开控制台直接修改app.message的值，就会看到相应的更新： 接着将div修改如下： &lt;div id=&quot;app&quot;&gt; {{message}} &lt;br&gt;&lt;br&gt; &lt;span v-bind:title=&quot;message&quot; style=&quot;border: 1px solid orange;&quot;&gt; 悬停这里会显示信息 &lt;/span&gt; &lt;/div&gt; 效果： v-bind属性称为指令。带有v-前缀的是Vue提供的特殊属性，会在渲染DOM上应用特殊的响应式行为。在这里v-bind:title的意思是将这个元素节点的title属性和Vue示例的message属性保持一致。 当然此时也可以使用控制台修改message的值，同时也会更新HTML： 4 使用vue-cli搭建Hello world npm install --global vue-cli vue init webpack helloworld cd helloworld 首先安装全局vue-cli命令，接着基于webpack模板初始化项目，创建过程中会提示输入相关信息： 输入项目名，项目描述以及作者后，会提示选择Vue运行时还是运行时+编译器，默认（运行时+编译器）即可， 接着提示安装vue-router，是否使用ESLint（y与n影响不大，其实不需要使用这两项功能）： 测试的话可以暂时不需要，接着提示创建工程会是否运行npm install，默认即可。 等待创建完成后，按提示运行即可： cd helloworld npm run dev 浏览器上打开即可： ","link":"https://2293736867.github.io/post/vue-hello-world/"},{"title":"每日分享 第5期","content":" 每日鸡汤 想好了的是假象，认真的做了也没前途。 每日冷知识 据估计，有5%的人类从未经历过头痛。 每日诗词 潜力黄云白日曛，北风吹雁雪纷纷。 ——高适《别董大二首》 每日一句 隔着屏幕轻易产生感情的你，肯定很孤独吧。 每日音乐 千本桜-黒うさP / 初音ミク 大胆不敵にハイカラ革命 磊々落々(らいらいらくらく) 反戦国 日の丸印の二輪車転が 悪霊退散 ICBM 環状線を走り抜けて 東奔西走なんのその 少年少女戦国無双 浮世の随(まにま)に 千本桜 夜ニ紛レ 君ノ声モ届カナイヨ 此処は宴 鋼の檻 その断頭台で見下ろし 三千世界 常世之闇(とこよのやみ) 嘆ク唄モ聞コエナイヨ 青藍(せいらん)の空 遥か彼方 その光線銃で打ち抜いて 百戦錬磨の見た目は将校 いったりきたりの 花魁(おいらん)道中 アイツもコイツも皆で集まれ 聖者の行進 わんっ つー さん しっ 禅定門(ぜんじょうもん)を 潜り抜けて 安楽浄土厄払い きっと終幕(さいご)は大団円 拍手の合間に 千本桜 夜ニ紛レ 君ノ声モ届カナイヨ 此処は宴 鋼の檻 その断頭台で見下ろして 三千世界 常世之闇(とこよのやみ) 嘆ク唄モ聞コエナイヨ 希望の丘 遥か彼方 その閃光弾を打ち上げろ 環状線を走り抜けて 東奔西走なんのその 少年少女戦国無双 浮世の随(まにま)に 千本桜 夜ニ紛レ 君ノ声モ届カナイヨ 此処は宴 鋼の檻 その断頭台を飛び降りて 千本桜 夜ニ紛レ 君が歌い僕は踊る 此処は宴 鋼の檻 さあ光線銃を撃ちまくれ 有关十二生肖 最近看了一篇十二生肖的文章，我们知道中国传统的十二生肖分别是： 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪 但是十二生肖并不是中国所特有，在中国周边国家甚至中国不同民族也有不同的十二生肖，有的国家是直接引进，比如日本，有的国家是变形重组，比如越南。 与中国十二生肖相同的有：日本、韩国、朝鲜、台湾和新加坡。 在国内的一些少数民族，十二生肖会有部分不一样，比如： 桂西彝族：龙 凤 马 蚁 人 鸡 狗 猪 雀 牛 虎 蛇 哀牢山彝族：虎 兔 穿山甲 蛇 马 羊 猴 鸡 狗 猪 鼠 牛 川滇黔彝族：鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪 海南黎族：鸡 狗 猪 鼠 牛 虫 兔 龙 蛇 马 羊 猴 而在越南中，兔改成了猫（以后可以说十二生肖中有猫了哈哈），由兔子变成猫有三种说法： 一是越南当时没有兔子，用猫代替。 二是比起兔子越南人更喜欢猫，并且猫在越南有“小虎”之称。 三是当初十二生肖传入越南时，当地人把原本的“卯兔年”误读成“猫”，于是沿用至今。 泰国，生肖从蛇开始，而龙变成了“那伽”。 古埃及则是：牝（pin）牛 山羊 狮子 驴 蟹 蛇 犬 猫 鳄 红鹤 猿 秃鹰 美国原住民则是：狼 隼（sun） 海狸 鹿 啄木鸟 鲑鱼 熊 乌鸦 蛇 猫头鹰 鹅 水獭 （ta） 但是对于古代欧洲的凯尔特人，他们依照月亮的周期将一年分为13月，每一个月都有代表的动物和守护树，代表的13种动物为：鹿 猫 牛 马 蝴蝶 蛇 海马 鱼 狼 狐狸 鹪鹩（jiao liao） 天鹅 隼 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-5-qi/"},{"title":"每日分享 第4期","content":" 每日鸡汤 长得好看的才叫吃货，长得不好看的那叫饭桶。 每日冷知识 欧洲最矮的国家是马耳他。马耳他人的平均身高为164.9cm（约65英寸），而欧盟的平均身高为169.6cm（约67英寸）。 每日诗词 凉风吹夜雨，萧瑟动寒林。 ——张说《幽州夜饮》 每日一句 如果温柔是罪，那就只能用拳头来洗清我们犯下的罪孽。 ——镇魂街 每日音乐 Dancin-Aaron Smith/Luvli/Krono Get up on the floor Dancin' all night long Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' All the time My baby you on my mind And I don't know why Yeah but the feeling is find Can't you see Yo' honey you are for me oh It were meant to be Dancin' in the moonlight Gazing at the stars so bright Holding you until the sunrise Sleeping unti the midnight Get up on the floor Dancin's all night floor Get up on the floor Dancin till the break of dawn Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' Dancin' is what to do Dancin' is what I think of you Dancin' is what makes me whole Dancin' is what to do Dancin' when I think of you Dancin' is what clears my soul Dancin' is what makes me whole Everytime when I look in your eyes That smile was crying that you were mine Do you know, your love is true I know You are the best thing that has happened to me Get up on the floor Dancin' all night long Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' Dancin' is what to do Dancin' when I thik of you Dancin' is what clears my soul Dancin' is what to do Dancin' when I think of you Dancin' is what clears my soul Dancin' is what makes me whole Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin'(oh) Get up on the floor Dancin' all night long Get up on the floor Dancin' till the break of dawn Get up on the floor Dancin'(oh) Dancin' is what to do Dancin' when I think of you Dancin' is what clears my soul Dancin' what to do Dancin' when I think of yo Dancin' is what clears my soul Dancin' is what to do Dancin' when I think of you Dancin' is what clears my soul Dancin' is what makes me whole Dancin' what to do Dancin' when I think of you Dancin' is what clears my soul Dancin' is what makes me whole ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-4-qi/"},{"title":"每日分享 第3期","content":" 每日鸡汤 我的脑袋不是空的。我是要大有作为的人，只是混沌初开。 每日冷知识 在日本直到2015年时，人们在过了零点以后跳舞还是非法行为。这条法律是在1948年开始实施的，为的是打击一些为非法活动作掩护的餐厅，到了2015年这条法律才废除。 每日诗词 接天莲叶无穷碧，映日荷花别样红。 ——杨万里《晓出净慈寺送林子方》 每日音乐 我配不上你-夏天Alex 你完全可以找个更好的知己 不一定和我这样子如此亲密 害怕有一天自己 真的就离不开你 距离让我们怎么靠近 我知道自己和你有很大差距 爱情却让我再一次身不由己 受过伤的人怀疑 尽管这来之不易 拼命的争取不如放弃 我配不上你 纵然很努力 我喜欢你 心里却没底 我没有歇斯底里 我只是望尘莫及 就像买不起心爱的衬衣 我还在原地 你飞上天际 我喜欢你 想一想而已 总是说后会有期 有天会在一起 只是在一起的两个人 不是我和你 你完全可以找个更好的知己 不一定和我这样子如此亲密 害怕有一天自己真的就离不开你 距离让我们怎么靠近 我知道自己和你有很大差距 爱情却让我再一次身不由己 受过伤的人怀疑 尽管尽管这来之不易 拼命的争取不如放弃 我配不上你 纵然很努力 我喜欢你 心里却没底 我没有歇斯底里 我只是望尘莫及 就像买不起心爱的衬衣 我还在原地 你飞上天际 我喜欢你 想一想而已 总是说后会有期 有天会在一起 只是在一起的两个人 不是我和你 我配不上你 纵然很努力 我喜欢你 心里却没底 我没有歇斯底里 我只是望尘莫及 就像买不起心爱的衬衣 我还在原地 你飞上天际 我喜欢你 想一想而已 总是说后会有期 有天会在一起 只是在一起的两个人 不是我和你 每日一句 温柔正确的人总是难以生存，因为这个世界既不温柔，也不正确 ——我的青春恋爱物语果然有问题 有关重温火影 最近重温了火影的一些经典，包括白与再不斩，佐助VS鼬，佐助VS卡卡西，当然还有最后的鸣左封印辉夜，要不是疫情的原因估计我也不会去看。 不过说真的感觉自己的青春就这么过去了还是有点不甘啊，720集也就是最后一集无数人留名以及表白，感觉自己的青春也就这么没了啊。。。。 来说说鼬神吧，背负整个村子的骂名，杀光一整族的人，只是为了弟弟。真的是宠弟狂魔，临死前也有给佐助上个天照就是为了不与带土见面。个人觉得鼬是真的厉害，智商爆棚，可惜到了358集就死了，唉，真是可惜了，虽然后面秽土转生给复活了。 不过打佐助的时候还是放了点水的，虽然很多弹幕说“放了海”“鬼鲛的大坝都要塌了不要放海了”，一开始的月读虽然动漫里面说是佐助解的，但是感觉是鼬自己解开的，也需要做点戏给观战的绝看看，到后面豪火球对决的时候，加上了天照，吞噬佐助的火球的同时还把翅膀给烧了，但是主动熄灭了。。。这确实是放水了。佐助放麒麟被鼬的须佐抵挡后，用十拳剑封印了佐助体内的大蛇丸，为什么当时就不一刀下去把佐助给杀了？（当然这样的话可能就全剧终了岸本也不会这样做的不过也可以劈一下啊，确实放水了） 最后虽然是鼬死了但是感觉是鼬自己用万花筒过度加上自身的病死的，说真的要不是鼬放水佐助应该打不过，即使鼬死后场地旁边还留有天照，还把封印大蛇丸时逃出来的那一条小白蛇给烧了，确实是保护佐助到家了。 鼬应该给个火影做啊，这人设确实有点惨。 就这样吧，反正我的青春也完结了2333333。。。。 虽然还有博人传，但是怎么也看不惯，毕竟画风不一样，当然这也不奇怪，毕竟不是岸本画的，是池本画的。感觉里面的鸣人还有佐助被削了很多，鸣人动不动就暴仙人九尾，螺旋手里剑都看不见了，不是一般先搞一下体术，然后分身，再仙人之类的吗？？？？ 还有佐助虽然单手了，豪火球都不怎么用，轮回眼说闪就闪，须佐一用就最厉害的那个，不是要仇恨吗？？？还记得以前是怎么打迪达拉，打团藏的吗？ 不过也无可厚非了，毕竟博人的丸子会隐身，而且觉得65集，也就是国人黄成希导演的那一集，是做的不错的。虽然博人出场扔了两个丸子，一个是基本没什么伤害的但是救了众人的，一个是父子合力的。。。大的夸张的丸子，直接把桃式给秒了，还留下什么狠化“一个打败神的人是注定做不回凡人的”。不过这集确实看的过瘾，佐助和鸣人的配合着实高燃。 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-3-qi/"},{"title":"每日分享 第2期","content":" 每日鸡汤 不明白你们遇到好事，为什么要掐腿揉眼睛，真醒了怎么办？ 每日冷知识 尽管可可豆已经被食用了数千年之久，但知道19世纪40年代人类才产生出第一块固体巧克力棒。以前可可豆都以粉末或饮料形式被食用。 每日诗词 荷叶罗裙一色裁，芙蓉向脸两边开。 ——王昌龄《采莲曲》 每日音乐 分手假期-钟洁/Hojo 原来分手也有假期 想要回去 才发现我无法面对你 曾经对爱的憧憬 拼了命去爱你 而最后 只剩下回忆 删掉你短信 怪我不争气 失落的情绪 就让你离去 别犹豫 你还在我回忆 别伤心 没什么了不起 也许是我还不懂爱情 还是我不够年龄 太多的心事说给谁听 你听我后悔的声音 你听 我爱上你的原因 Oh Baby 还记得第一次邂逅的场景 我被你的眼睛吸引 我动心 不想在犹豫 慢慢向你靠近 风吹散你香气 深深的为你着迷 爱上你 我难以抽离 怪我的坏脾气 你才会狠下心 眼看着我陷入谷底 我该怎么才能挽回你 原来分手也有假期 想要回去 才发现我无法面对你 曾经对爱的憧憬 拼了命去爱你 而最后 只剩下回忆 原来分手还会想你 保持清醒 只是我再也不会爱你 喜欢孤单的旅行 在陌生的城市 仿佛看到熟悉的背影 短暂的分离 出国散散心 陌生国度里 还是想起你 在餐厅 听浪漫进行曲 烛光里 欣赏窗外美景 我渴望一段新的恋情 能代替过去的爱情 爱像突如其来的大雨 你听 我悲泣的声音 你听 我离开你的原因 Oh Baby 还记得第一次邂逅的默契 时间缠绵滴答滴答 走下去 相处之后发现勉强在一起 让你受尽委屈 所以才会答应你 爱上你 我深信不疑 渴望幸福甜蜜 可惜我太花心 眼看着你为我痛心 最后只能默默的离开你 原来分手也有假期 想要回去 才发现我无法面对你 曾经对爱的憧憬 拼了命去爱你 而最后 只剩下回忆 原来分手还会想你 保持清醒 只是我再也不会爱你 喜欢孤单的旅行 在陌生的城市 仿佛看到熟悉的背影 我的脚步怎么会犹豫 不敢相信那个人是你 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-2-qi/"},{"title":"每日分享  第1期","content":" 每日鸡汤 我要没点自我安慰的本事，还真活不到现在。 每日冷知识 为了感谢约翰·韦恩（美国西部片演员）对将巴拿马运河的控制权归还给巴拿马的支持，巴拿马当局在巴拿马海岸附近授予了他一座以其名字命名的岛屿。 奇怪的网站 最近在github上看到的： Evil Man - 中国男性之恶 每日音乐 落霜-花粥 一眼望穿 千年是非 难判谁人错与对 两相无言 各自慌乱 不提何处惹尘埃 三生有幸 我至死不渝 陪你一生何俱 四海飘零 你声明狼藉 相思不过一场戏 啊 夜微凉 梦一场 无人在意满地霜 啊 细思量 你在旁 月落他乡心事忙 啊 琴悠扬 醉斜阳 回望路皆是荒凉 啊 醉痴狂 世无双 别时最怕断离肠 九泉之约 十年大业 心如磐石肝似铁 万语千言 百口莫辩 情至深时惹人怨 啊 夜微凉 梦一场 无人在意满地霜 啊 细思量 你在旁 月落他乡心事忙 啊 琴悠扬 醉斜阳 回望路皆是荒凉 啊 醉痴狂 世无双 别时最怕断离肠 ","link":"https://2293736867.github.io/post/mei-ri-fen-xiang-di-1-qi/"},{"title":"关于每日分享","content":"1 为什么要做每日分享 最近疫情肆虐，“大举进攻”各个国家。 先贴一张于2020.06.19截取的疫情数据图： 目前全球累计确诊已超824万。 其实作为一个普通的程序猿，能帮的也极为有限，虽然宅家的时间长了，但是感觉总是不在状态。 人总要做点什么来对抗一下这该死的生活，就像村上春树里面的《当你跑步时，你在想什么》一样。 所以，这是每日分享的缘由。 即使没有什么人看，笔者也不在乎。 只是，想单纯的做下去。 2 分享的是什么 音乐啊，壁纸啊，句子，电影以及一些冷知识之类的。 ","link":"https://2293736867.github.io/post/guan-yu-mei-ri-fen-xiang/"},{"title":"单个java文件打成可执行jar包","content":"1 概述 使用JDK自带的jar与java将单个java文件打成可执行jar包并运行。 当然也可以使用IDE完成，使用Maven只需要一个简单的package，但是单个文件嘛，没必要这么“凶狠”。 2 新建测试文件 著名的Hello World： public class Main { public static void main(String [] args) { System.out.println(&quot;Hello world.&quot;); } } 3 编译 生成jar包需要class文件，换句话说需要先编译，建议先创建一个临时文件夹存放class文件。 mkdir test &amp;&amp; mv Main.java test &amp;&amp; cd test; javac Main.java 4 打包 jar --create --verbose --file Main.jar --main-class Main *.class 说明一下各个参数： --create：创建jar --verbose：打包时产生输出 --file：打包的jar文件名 --main-class：指定入口类 *.class：打包所有的class文件，这里可以接受的参数可以是*，表示打包该目录下所有文件，也可以是目录名，打包指定目录下的所有文件 这里使用默认的包，若是自定义包，使用 --main-class com.xxx.xxx.Main 即可。 注意打包时网上有的教程使用简写： jar -cvf Main.jar *.class 这样确实是能打包，但是直接运行的时候会提示： no main manifest attribute, in Main.jar 可以加上--main-class参数或者直接更新打包后里面的MANIFEST.mf文件，加上： Main-Class: Main 当然还是建议使用上述的方法一步打包到位。 5 运行 java -jar Main.jar ","link":"https://2293736867.github.io/post/dan-ge-java-wen-jian-da-cheng-ke-zhi-xing-jar-bao/"},{"title":"一次使用IDEA中HTTP Client的经历","content":"说好六月停更的。。。。 害。。。 1 开端 HTTP Client是IDEA中自带的一个插件，用于代替原来的REST Client，打开Tools-&gt;HTTP Client-&gt;Test RESTful Web Service，会提示REST Client不推荐使用，推荐使用HTTP Client： 然后当然就点击使用啊，但是，问题来了，一个普通的GET请求都发送不出去？？？？ IDEA的东西估计没这么菜吧？？？ 肯定不会这么菜的。。。 但是为什么就是发不出去？？？ 2 尝试 GET请求对吧，浏览器也可以做，于是，使用了浏览器进行测试，一点问题都没有： 没理由啊，笔者在想，那为什么IDEA不行呢？？ 接着使用了大名鼎鼎的Postman，也是一点问题也没有： Postman也没问题啊，接着试试“情敌”Postwoman，问题来了！ 发送不出去，查看了一下F12控制台，报错如下： 搜索了一下解决办法，是跨域资源请求的问题，在Controller类上加上 @CrossOrigin(value = &quot;http://localhost:3000&quot;) 即可，因为Postwoman默认运行的端口为3000。 这个注解还可以作用在方法上，起作用的就是对应的方法，这里是对整个Controller起作用。 另外这里只使用了最简单的参数，其他的参数还有origins（同value），allowHeaders，exposedHeaders，methods，allowCredentials，maxAge，具体使用不介绍，加上了以后Postwoman就能正常发送请求了： 3 再次尝试 但是IDEA中的HTTP Client还是不行啊，就最最最普通的GET请求，还是返回500： 于是换了一种思路，想再用其他类似插件的方式测试。 所以就想到了VScode，里面有一个类似的扩展叫REST Client，安装以后写了一个普通的GET请求，完全没问题： 但还是想不到为什么IDEA还是不行啊？？？ 还是500 。。。 。。。 但是，反过来想，可能是请求发送不出去，因为如果是接受到了请求的话，肯定会有日志记录的，但是没有，所以原因可能是请求发送不出去。。。 4 最终答案 一个普通的GET请求为什么发送不出去？ 到底是为什么会返回500？ 最后，经过一番痛苦的思考，找到了问题所在：代理！ 发送不出去就是因为设置了本地代理，返回的500，是代理服务器返回的，不是Tomcat返回的。 终于，把代理去掉之后，HTTP Client就可以正常使用了： 没错，“真凶”就是代理。 最后终于打消了笔者的误解，为什么IDEA中的HTTP Client会这么“菜”，连一个普通的GET请求也发送不出去？？ ","link":"https://2293736867.github.io/post/yi-ci-shi-yong-idea-zhong-http-client-de-jing-li/"},{"title":"Tomcat9配置HTTP/2","content":" 1 概述 2 HTTP/2特性 2.1 二进制分帧 2.2 压缩头部 2.3 多路复用 2.4 流优先及流控制 2.5 服务器推送 2.6 应用层协商协议 3 使用mkcert生成证书 3.1 安装mkcert 3.1.1 MacOS 3.1.2 Linux 3.1.3 Windows 3.2 生成证书 3.2.1 安装本地CA证书 3.2.2 利用CA证书签发本地证书 4 配置Tomcat 4.1 使用Nio 4.2 使用APR 1 概述 Tomcat从Tomcat8的一些较新版本就支持HTTP/2了，Tomcat9直接支持，本文首先讲述了相关HTTP/2的特性，接着利用一个简单的开源工具mkcert生成证书并利用该证书配置HTTP/2。 2 HTTP/2特性 首先介绍一下HTTP/2特性，这也从另一方面解释了为什么需要使用HTTP/2。 2.1 二进制分帧 HTTP/2在应用层与传输层增加了一个二进制分帧，能够达到“在不改动HTTP语义，HTTP方法，状态码，URI及首部字段的情况下，突破HTTP/1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。” 2.2 压缩头部 HTTP/2对消息头采用了HPACK进行压缩传输，能够节省消息头占用的网络流量，而HTTP/1.x每次请求都会携带大量的冗余头信息，浪费了很多带宽资源。 2.3 多路复用 简单地说就是所有的请求都通过一个TCP连接并发完成。HTTP/1.x虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应，很容易导致后面的请求被阻塞。而HTTP/2做到了真正的并发请求。 HTTP/2将消息分解为帧，为每帧分配一个流标识符，然后在一个TCP连接上独立发送，HTTP/2将请求帧与响应帧交织在一起，能够让所有请求与响应都在一个套接字上发生，所有请求或响应都无法相互阻塞，减少了延迟，提高了页面加载速度，消除了对HTTP/1.1工具的需求。 2.4 流优先及流控制 消息帧通过对流进行发送，每个流分配了一个优先级，用于确定处理顺序以及收到的资源量，优先级可以是0-256之间的数字，可以定义依赖关系，允许在一个资源之前加载另一个资源。 流控制管理数据的传输，允许接收者停止或减少发送的数据量，比如观看视频暂停时，客户端会通知服务器停止发送视频数据。 2.5 服务器推送 一般情况下需要客户端请求服务器才会响应，HTTP/2中能够先于客户端检测将要请求的资源，提前通知客户端，但是不发送资源只发送URL，客户端收到后会进行验证缓存，发现需要则正式发起请求。 2.6 应用层协商协议 客户端与服务器都升级才能支持HTTP/2，但是有可能存在HTTP/1与HTTP/2并存的情况，如果都使用80端口，需要选择其中一个协议通信。 APLN（Application Layer Protocol Negotiation）就是为了解决这个问题，通过协商选择协议： 首先客户端发起请求，如果支持HTTP/2则带upgrade头部 若服务器不支持则拒绝升级通过HTTP/1.1返回响应 若服务器支持则接受升级，切换到新分帧使用HTTP/2通信 更多请查看RFC7540 官方文档。 3 使用mkcert生成证书 网上大部分的教程都是使用OpenSSL生成根证书，客户端证书以及服务端证书的，一堆参数配置非常复杂，因此这里使用一个简单的一键生成本地证书的开源工具mkcert，无需任何配置。 3.1 安装mkcert 3.1.1 MacOS brew install mkcert brew install nss # 如果使用火狐 使用MacPorts： sudo port selftupdate sudo port install mkcert sudo port install css # 如果使用火狐 3.1.2 Linux 需要先安装certutil： #Debian/Ubuntu sudo apt install libnss3-tools #Red Hat/Fedora/CentOS sudo yum install nss-tools #Arch/Manjaro sudo pacman -S nss #SUSE sudo zypper install mozilla-nss-tools 使用LinuxBrew安装： brew install mkcert 安装LinuxBrew： /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; Arch/Manjaro可以使用pacman安装： sudo pacman -Syu mkcert 或者从源码安装（需要go环境）： git clone https://github.com/FiloSottile/mkcert &amp;&amp; cd mkcert go build -ldflags &quot;-X main.Version=$(git describe --tags)&quot; 或者使用已构建好的版本。 3.1.3 Windows 安装Chocolatey（以管理员运行PowerShell）： Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 或安装Scoop（管理员PowerShell）： Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') # 或 iwr -useb get.scoop.sh | iex 使用Chocolatey或Scoop安装： choco install mkcert #或 scoop bucket add extras scoop install mkcert 或者使用已构建好的版本。 3.2 生成证书 mkcert的命令非常简单，可以使用--help查看帮助： mkcert --help 3.2.1 安装本地CA证书 mkcert -install 默认会在~/.local/share/mkcert生成CA证书。 3.2.2 利用CA证书签发本地证书 mkcert localhost 其中localhost表示签发本地证书，可以换成example.com，*.example.com，example.test，127.0.0.1，::1之类的域名或者ip。 执行后会在当前文件夹下生成localhost-key.pem与localhost.pem，前者是私钥，后者是证书。 4 配置Tomcat Tomcat可以通过两种方式配置HTTP/2，一种是自带的Nio方式，另一种是使用额外库APR，APR-util与TC-Native的方式。 4.1 使用Nio 通过Nio配置HTTP/2需要结合OpenSSL与keytool将证书转换为pkcs#12再转换为jks： openssl pkcs12 -export -inkey localhost-key.pem -in localhost.pem -out localhost.p12 会提示输入导出密码，需要记住，转换成jks时需要用到。 接着转换为jks： keytool -importkeystore -srckeystore localhost.p12 -srcstoretype pkcs12 -destkeystore localhost.jks 这里会提示输入目标keystore与源keystore的密码，目标keystore密码一会在修改server.xml时需要用到，源keystore密码就是上面的导出密码。 接着复制localhost.jks到Tomcat的conf下并修改server.xml： &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt; &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=&quot;conf/localhost.jks&quot; certificateKeystorePassword=&quot;111111&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt; 添加了升级协议（默认HTTP/1.1）： &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt; 另外certificateKeystorePassword是上一步的目标keystore的密码。 完成后开启Tomcat并访问https://localhost:8443： 4.2 使用APR 使用APR不需要对证书进行额外的转换，但是需要安装三个库： APR APR-util TC-Native 笔者的Manjaro可以直接包管理器安装： sudo pacman -S apr apr-util tomcat-native 其他系统请自行使用包管理器或者按上面的官网链接进行编译安装。 复制localhost-key.pem与localhost.pem到Tomcat的conf目录下，并修改server.xml： &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; &gt; &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeyFile=&quot;conf/localhost-key.pem&quot; certificateFile=&quot;conf/localhost.pem&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt; 开启Tomcat后就可以访问https://localhost:8443了： ","link":"https://2293736867.github.io/post/tomcat9-pei-zhi-http2/"},{"title":"残酷游戏","content":" 其实自命受苦都只因我能离不离 看着对你爱得仿似爱情欲避不避 若能耗尽力气 去捕捉你 亦能剩下自己可挽救自己 我也知越是幻想不准想你更记得起 我在故意去将苦涩替代寂寞滋味 用残酷游戏 制造卑微 自由自在莫非惨过永远受气 摊牌， 哦豁， GG。 历史总是惊人的相似， 现实总是太多的无奈。 注孤生。 ","link":"https://2293736867.github.io/post/can-ku-you-xi/"},{"title":"JavaFX+SpringBoot+验证码功能的小型薪酬管理系统","content":" 2020.07.22更新 1 概述 1.1 简介 1.2 响应流程 1.3 演示 2 环境 2.1 本地开发环境 2.2 服务器环境 3 前端代码部分 3.1 前端概述 3.2 概览 3.2.1. 代码目录树 3.2.2 资源目录树 3.2.3 项目依赖 3.3 常量模块 3.4 控制器模块 3.4.1 登录注册界面 3.4.2 用户界面 3.5 实体类模块 3.6 日志模块 3.7 网络模块 3.7.1 request包 3.7.2 requestBuilder包 3.7.3 OKHTTP 3.7.4 HTTPS 3.7.4.1 OkHttp配置 3.7.4.2 服务器设置证书 3.7.5 图片处理 3.8 动画模块 3.9 工具类模块 3.9.1 Conversion 3.9.2 Utils 3.10 视图模块 4 前端UI部分 4.1 fxml 4.2 css 4.3 Stage构建过程 5 后端部分 5.1 后端概述 5.2 概览 5.2.1 代码目录树 5.2.2 依赖 5.3 控制器层 5.4 业务层与持久层 5.5 日志 5.6 工具类 5.7 配置文件 5.7.1 配置文件分类 5.7.2 加密 6 部署与打包 6.1 前端打包 6.1.1 IDEA一次打包 6.1.2 exe4j二次打包 6.1.2.1 exe4j 6.1.2.2 生成jre 6.1.2.3 exe4j打包 6.1.3 Enigma Virtual Box三次打包 6.2 后端部署 7 运行 8 注意事项 8.1 路径问题 8.2 HTTPS 8.3 配置文件加密 8.4 键盘事件 8.5 数据库 8.6 验证码 9 源码 10 项目不足之处 11 参考 2020.07.22更新 1 概述 1.1 简介 一个简单的小型薪酬管理系统，前端JavaFX+后端Spring Boot，功能倒没多少，主要精力放在了UI和前端的一些逻辑上面，后端其实做得很简单。 主要功能： 用户注册/登录 验证码找回密码 用户修改信息，修改头像 柱状图形式显示薪酬 管理员管理用户，录入工资 1.2 响应流程 1.3 演示 登录界面： 用户界面： 管理员界面： 2 环境 2.1 本地开发环境 Manjaro 20.0.3 IDEA 2020.1.1 OpenJDK 11.0.7.u10-1 OepnJFX 11.0.3.u1-1 Spring Boot 2.3.0 MySQL 8.0.20 2.2 服务器环境 CentOS 8.1.1911 OpenJDK 11 Tomcat 9.0.33 MySQL 8.0.17 3 前端代码部分 3.1 前端概述 前端主要分为5个部分实现：控制器模块，视图模块，网络模块，动画模块还有工具类模块。 控制器模块：负责交互事件 视图模块：负责更新UI 网络模块：向后台发送数据请求 动画模块：位移、缩放、淡入/淡出、旋转动画 工具类模块：加密，检查网路连通，居中界面等 3.2 概览 3.2.1. 代码目录树 说明： constant包：项目所需要的字符串常量以及一些枚举常量 controller包：控制器类，负责UI与用户的交互 entity包：实体类 log包：日志类 network包：负责网络请求，包括请求生成以及请求发送 transition包：负责处理动画 utils包：工具类 view包：负责UI的初始化预计更新 3.2.2 资源目录树 说明： css：界面所用到的样式 fxml：一个特殊的xml文件，用于定义界面与绑定Controller中的函数，也就是绑定事件 image：静态图片 key：证书文件，用于OkHttp中的HTTPS连接 properties：项目中的一些常量属性 3.2.3 项目依赖 主要依赖如下： Gson：用于在实体类以及Map与JSON字符串之间进行转换 Log4j2：日志 Lombok：神器不解释，但是有一些声音说不要使用，可以参考这里或这里，看个人啦 OkHttp3：网路请求 Apache Commons：工具类 OpenJFX11：OpenJFX核心 3.3 常量模块 包含程序所需要的字符串以及枚举常量： CSSPath：CSS路径，用于给Scene添加样式，如scene.getStylesheets.add(path) FXMLPath：FXML路径，用于FXMLLoader加载FXML文件，如FXMLLoader.load(getClass.getResource(path).openStream()) AllURL：发送请求到后端的URL BuilderKeys：OkHttp中的FormBody.Builder中使用的常量键名 PaneName：Pane名字，用于在同一个Scene切换不同的Pane ReturnCode：后端返回码，需要与后端协商 ViewSize：界面尺寸 重点说一下路径问题，笔者的css与fxml文件都放在resources下： 其中fxml路径在项目中的用法如下： URL url = getClass().getResource(FXMLPath.xxxx); FXMLLoader loader = new FXMLLoader(); loader.setLocation(url); loader.load(url.openStream()); 获取路径从根路径获取，比如上图中的MessageBox.fxml： private static final String FXML_PREFIX = &quot;/fxml/&quot;; private static final String FXML_SUFFIX = &quot;.fxml&quot;; public static final String MESSAGE_BOX = FXML_PREFIX + &quot;MessageBox&quot; + FXML_SUFFIX; 若fxml文件直接放在resources根目录下，可以使用： getClass().getResource(&quot;/xxx.fxml&quot;); 直接获取。 css同理： private static final String CSS_PREFIX = &quot;/css/&quot;; private static final String CSS_SUFFIX = &quot;.css&quot;; public static final String MESSAGE_BOX = CSS_PREFIX + &quot;MessageBox&quot; + CSS_SUFFIX; 网络请求的URL建议把路径写到配置文件中，比如这里的从配置文件读取： Properties properties = Utils.getProperties(); if (properties != null) { String baseUrl = properties.getProperty(&quot;baseurl&quot;) + properties.getProperty(&quot;port&quot;) + &quot;/&quot; + properties.getProperty(&quot;projectName&quot;); SIGN_IN_UP_URL = baseUrl + &quot;signInUp&quot;; //... } 3.4 控制器模块 控制器模块用于处理用户的交互事件，分为三类： 登录注册界面控制器（start包） 用户界面控制器（worker包） 管理员界面控制器（admin包） 3.4.1 登录注册界面 这是程序一开始进入的界面，会在这里绑定一些基本的关闭，最小化，标题栏拖拽事件： public void onMousePressed(MouseEvent e) { stageX = stage.getX(); stageY = stage.getY(); screexX = e.getScreenX(); screenY = e.getScreenY(); } public void onMouseDragged(MouseEvent e) { stage.setX(e.getScreenX() - screexX + stageX); stage.setY(e.getScreenY() - screenY + stageY); } public void close() { GUI.close(); } public void minimize() { GUI.minimize(); } 登录界面的控制器也很简单，就一个登录/注册功能加一个跳转到找回密码界面，代码就不贴了。 至于找回密码界面，需要做的比较多，首先需要判断用户输入的电话是否在后端数据库存在，另外还要检查两次输入的密码是否一致，还要判断短信是否发送成功，并且检查用户输入的验证码与后端返回的验证码是否一致（短信验证码部分其实不需要后端处理，原本是放在前端的，但是考虑到可能会泄漏一些重要的信息就放到后端处理了）。 3.4.2 用户界面 接着是用户登录后进入的界面，加了渐隐与移动动画： public void userEnter() { new Transition() .add(new Move(userImage).x(-70)) .add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95)) .add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180)) .add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180)) .play(); } public void userExited() { new Transition() .add(new Move(userImage).x(0)) .add(new Fade(userLabel).fromTo(1,0)).add(new Move(userLabel).x(0)) .add(new Scale(userPolygon).ratio(1)).add(new Move(userPolygon).x(0)) .add(new Scale(queryPolygon).ratio(1)).add(new Move(queryPolygon).x(0)) .play(); } 效果如下： 实际处理是把&lt;Image&gt;以及&lt;Label&gt;放进一个&lt;AnchorPane&gt;中，然后为这个&lt;AnchorPane&gt;添加鼠标移入与移出事件。从代码中可以知道图片加上了位移动画，文字同时加上了淡入与位移动画，多边形同时加上了缩放与位移动画。以左下的&lt;AnchorPane&gt;事件为例，当鼠标移入时，首先把图片左移： .add(new Move(userImage).x(-70)) x表示横向位移。 接着是淡入与位移文字： .add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95)) fromTo表示透明度的变化，从0到1，相当于淡入效果。 最后放大多边形1.8倍同时右移多边形： .add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180)) ratio表示放大的倍率，这里是放大到原来的1.8倍。 同理右上方同样需要进行放大与移动： .add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180)) 其中用到的Transition，Scale，Fade是自定义的动画处理类，详情请看&quot;3.8 动画模块&quot;。 3.5 实体类模块 简单的一个Worker： @Getter @Setter @NoArgsConstructor public class Worker { private String cellphone; private String password; private String name = &quot;无姓名&quot;; private String department = &quot;无部门&quot;; private String position = &quot;无职位&quot;; private String timeAndSalary; public Worker(String cellphone,String password) { this.cellphone = cellphone; this.password = password; } } 注解使用了Lombok，Lombok介绍请戳这里，完整用法戳这里。 timeAndSalary是一个使用Gson转换为String的Map，键为对应的年月，值为工资。具体转换方法请到工具类模块查看。 3.6 日志模块 日志模块使用了Log4j2，resources下的log4j2.xml如下： &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;Time:%d{HH:mm:ss} Level:%-5level %nMessage:%msg%n&quot;/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; 这是最一般的配置，pattern里面是输出格式，其中 %d{HH:mm:ss}：时间格式 level：日志等级 n：换行 msg：日志信息 这里前端的日志进行了简化处理，需要更多配置请自行搜索。 3.7 网络模块 网络模块的核心使用了OkHttp实现，主要分为两个包： request：封装发送到后端的各种请求 requestBuilder：创建request的Builder类 OKHTTP：封装OkHttp的工具类，对外只有一个静态send方法，参数只有一个，request包中的类，使用requestBuilder生成。send方法返回一个Object，Object怎么处理需要在用到OKHTTP的地方与返回方法对应 3.7.1 request包 封装了各种网络请求： 所有请求继承自BaseRequest，BaseRequest的公有方法包括： setUrl：设置发送的URL setCellphone：添加cellphone参数 setPassword：添加password参数，注意会经过前端的SHA-512加密 setWorker：添加Worker参数 setWorkers：接受一个List&lt;Worker&gt;，管理员保存所有Worker时使用 setAvatar：添加头像参数 setAvatars：接受一个HashMap&lt;String,String&gt;，键为电话，标识唯一的Worker，值为图片经过Base64转换为的String 唯一一个抽象方法是： public abstract Object handleResult(ReturnCode code)： 根据不同的请求处理返回的结果，后端返回一个ReturnCode，其中封装了状态码，错误信息与返回值，由Gson转为String，前端得到String后经Gson转为ReturnCode，从里面获取状态码以及返回值。 其余的请求类继承自BaseRequest，并且实现不同的处理结果方法，以Get请求为例： public class GetOneRequest extends BaseRequest { @Override public Object handleResult(ReturnCode code) { switch (code) { case EMPTY_CELLPHONE: MessageBox.emptyCellphone(); return false; case INVALID_CELLPHONE: MessageBox.invalidCellphone(); return false; case CELLPHONE_NOT_MATCH: MessageBox.show(&quot;获取失败，电话号码不匹配&quot;); return false; case EMPTY_WORKER: MessageBox.emptyWorker(); return false; case GET_ONE_SUCCESS: return Conversion.JSONToWorker(code.body()); default: MessageBox.unknownError(code.name()); return false; } } } 获取一个Worker，可能的返回值有（返回的是在ReturnCode中定义的枚举值，需要前后端统一）： EMPTY_CELLPHOE：表示发送的get请求中电话为空 INVALID_CELLPHONE：非法电话号码，判断的代码为：String reg = &quot;^[1][358][0-9]{9}$&quot;;return !(Pattern.compile(reg).matcher(cellphone).matches()); CELLPHONE_NOT_MATCH：电话号码不匹配，也就是数据库没有对应的Worker EMPTY_WORKER：数据库中存在这个Worker，但由于转换为String时后端处理失败，返回一个空的Worker GET_ONE_SUCCESS：获取成功，使用工具类转换String为Worker 其他：未知错误 3.7.2 requestBuilder包 包含了对应于request的Builder： 除了默认的构造方法与build方法外，只有set方法，比如： public class GetOneRequestBuilder { private final GetOneRequest request = new GetOneRequest(); public GetOneRequestBuilder() { request.setUrl(AllURL.GET_ONE_URL); } public GetOneRequestBuilder cellphone(String cellphone) { if(Check.isEmpty(cellphone)) { MessageBox.emptyCellphone(); return null; } request.setCellphone(cellphone); return this; } public GetOneRequest build() { return request; } } 在默认构造方法里面设置了URL，剩下就只需设置电话即可获取Worker。 3.7.3 OKHTTP 这是一个封装了OkHttp的静态工具类，唯一一个公有静态方法如下： public static Object send(BaseRequest content) { Call call = client.newCall(new Request.Builder().url(content.getUrl()).post(content.getBody()).build()); try { ResponseBody body = call.execute().body(); if(body != null) return content.handleResult(Conversion.stringToReturnCode(body.string())); } catch (IOException e) { L.error(&quot;Reseponse body is null&quot;); MessageBox.show(&quot;服务器无法连通,响应为空&quot;); } return null; } 采用同步POST请求的方式，用BaseRequest作为基类是因为能在Call中方便地获取URL以及请求体，若数据量大可以考虑异步请求。 另外上面也提到后端返回的是经由Gson转换为String的ReturnCode，所以获取body后，先转换为ReturnCode再处理。 3.7.4 HTTPS 至于HTTPS，由于在Tomcat上进行部署，需要在Tomcat里设置证书，同时也需要在OkHttp中设置以下三部分： sslSocketFactory：ssl套接字工厂 HostnameVerifier：验证主机名 X509TrustManager：证书信任器管理类 3.7.4.1 OkHttp配置 上面提到了需要设置三部分，下面来看看最简单的一个验证主机名部分，利用的是HostnameVerifier接口： OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(1500, TimeUnit.MILLISECONDS) .hostnameVerifier((hostname, sslSession) -&gt; { if (&quot;www.test.com&quot;.equals(hostname)) { return true; } else { HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier(); return verifier.verify(hostname, sslSession); } }).build(); 这里验证主机名为www.test.com就返回true（也可是使用公网ip验证），否则使用默认的HostnameVerifier。业务逻辑复杂的话可以结合配置中心，黑/白名单等进行动态校验。 接着是X509TrustManager的处理（来源Java Code Example）： private static X509TrustManager trustManagerForCertificates(InputStream in) throws GeneralSecurityException { CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in); if (certificates.isEmpty()) { throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;); } char[] password = &quot;www.test.com&quot;.toCharArray(); // Any password will work. KeyStore keyStore = newEmptyKeyStore(password); int index = 0; for (Certificate certificate : certificates) { String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificate); } // Use it to build an X509 trust manager. KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, password); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)){ throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers)); } return (X509TrustManager) trustManagers[0]; } private static KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException { try { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); // 这里添加自定义的密码，默认 InputStream in = null; // By convention, 'null' creates an empty key store. keyStore.load(in, password); return keyStore; } catch (IOException e) { throw new AssertionError(e); } } 返回一个信任由输入流读取的证书的信任管理器，若证书没有被签名则抛出SSLHandsakeException，证书建议使用第三方签名的而不是自签名的（比如使用OpenSSL或者acme.sh生成），特别是在生产环境中千万不要使用自签名的，例子的注释也提到： 最后是SSL套接字工厂的处理： private static SSLSocketFactory createSSLSocketFactory() { SSLSocketFactory ssfFactory = null; try { SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null, new TrustManager[]{trustManager}, new SecureRandom()); ssfFactory = sc.getSocketFactory(); } catch (Exception e) { e.printStackTrace(); } return ssfFactory; } 完整的OkHttpClient构造如下： X509TrustManager trustManager = trustManagerForCertificates(OKHTTP.class.getResourceAsStream(&quot;/key/pem.pem&quot;)); OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(1500, TimeUnit.MILLISECONDS) .sslSocketFactory(createSSLSocketFactory(), trustManager) .hostnameVerifier((hostname, sslSession) -&gt; { if (&quot;www.test.com&quot;.equals(hostname)) { return true; } else { HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier(); return verifier.verify(hostname, sslSession); } }) .readTimeout(10, TimeUnit.SECONDS).build(); 其中/key/pem.pem为resources下的证书文件。 3.7.4.2 服务器设置证书 使用WAR进行部署，JAR部署的方式请自行搜索，服务器Tomcat，其他web服务器请自行搜索。 首先在Tomcat配置文件中的conf/server.xml修改域名： 找到&lt;Host&gt;并复制，直接修改其中的name为对应域名： 接着从证书厂商下载文件（一般都带文档，根据文档部署），Tomcat的是两个文件，一个是pfx，一个是密码文件，继续修改server.xml，搜索8443， 找到如下位置： 其中上面的&lt;Connector&gt;是HTTP/1.1协议的，基于NIO实现，下面的&lt;Connector&gt;是HTTP/2的，基于APR实现。 使用HTTP/1.1会比较简单一些，仅仅是修改server.xml即可，使用HTTP/2的话会麻烦一点，如果基于APR（Apache Portable Runtime）实现需要安装APR，APR-util以及Tomcat-Native，可以参考这里，下面以HTTP/1.1的为例，修改如下： &lt;Connector port=&quot;8123&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;200&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; keystoreFile=&quot;/xxx/xxx/xxx/xxx.pfx&quot; keystoreType=&quot;PKCS12&quot; keystorePass=&quot;YOUR PASSWORD&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;&gt; &lt;/Connector&gt; 修改证书位置以及密码。如果想要更加安全的话可以指定使用某个TLS版本，比如使用TLS1.2版本： &lt;Connector ... sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1.2&quot; &gt; 3.7.5 图片处理 图片原本是想使用OkHttp的MultipartBody处理的，但是处理的图片都不太，貌似没有必要，而且实体类的数据都是以字符串的形式传输的，因此，笔者的想法是能不能统一都用字符串进行传输，于是找到了图片和String互转的函数，稍微改动，原来的函数需要外部依赖，现在改为了JDK自带的Base64： public static String avatarToString(Path path) { try { return new String(encoder.encode(Files.readAllBytes(path))); } catch (IOException e) { MessageBox.avatarToStringFailed(); L.error(e); return null; } } public static void stringToAvatar(String base64Code, String cellphone){ try { if(!Files.exists(TEMP_PATH)) Files.createDirectory(TEMP_PATH); if(!Files.exists(getPath(cellphone))) Files.createFile(getPath(cellphone)); Files.write(getPath(cellphone), decoder.decode(base64Code)); } catch (IOException e) { MessageBox.stringToAvatarFailed(); L.error(e); } } Base64是一种基于64个可打印字符来表示二进制数据的方法，可以把二进制数据（图片/视频等）转为字符,或把对应的字符解码变为原来的二进制数据。 笔者实测这种方法转换速度不慢，只要有了正确的转换函数，服务器端可以轻松进行转换，但是对于大文件的支持不好： 这种方法对一般的图片来说足够了，但是对于真正的文件还是建议使用MultipartBody进行处理。 3.8 动画模块 包含了四类动画： 淡入/淡出 位移 缩放 旋转 这四个类都实现了CustomTransitionOperation接口： import javafx.animation.Animation; public interface CustomTransitionOperation { double defaultSeconds = 0.4; Animation build(); void play(); } 其中： defaultSeconds表示动画默认持续的秒数 build用于Transition中对各个动画类进行统一的build操作 play用于播放动画 四个动画类类似，以旋转动画类为例： public class Rotate implements CustomTransitionOperation{ private final RotateTransition transition = new RotateTransition(Duration.seconds(1)); public Rotate(Node node) { transition.setNode(node); } public Rotate seconds(double seconds) { transition.setDuration(Duration.seconds(seconds)); return this; } public Rotate to(double to) { transition.setToAngle(to); return this; } @Override public Animation build() { return transition; } @Override public void play() { transition.play(); } } seconds设置秒数，to设置旋转的角度，所有动画类统一由Transition控制： public class Transition { private final ArrayList&lt;Animation&gt; animations = new ArrayList&lt;&gt;(); public Transition add(CustomTransitionOperation animation) { animations.add(animation.build()); return this; } public void play() { animations.forEach(Animation::play); } } 里面是一个动画类的集合，每次add操作时先生成对应的动画再添加进集合，最后统一播放，示例用法如下： new Transition() .add(new Move(userImage).x(-70)) .add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95)) .add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180)) .add(new Scale(workloadPolygon).ratio(1.8)).add(new Move(workloadPolygon).x(180)) .play(); 3.9 工具类模块 AvatarUtils：用于本地生成临时图片以及图片转换处理 Check：检查是否为空，是否合法等 Conversion：转换类，通过Gson在Worker/String，Map/String，List/String之间进行转换 Utils：加密，设置运行环境，居中Stage，检查网络连通等 这里说一下Utils与Conversion。 3.9.1 Conversion 转换类，利用Gson在String与List/Worker/Map之间进行转换，比如String转Map： public static Map&lt;String,Double&gt; stringToMap(String str) { if(Check.isEmpty(str)) return null; Map&lt;?,?&gt; m = gson.fromJson(str,Map.class); Map&lt;String,Double&gt; map = new HashMap&lt;&gt;(m.size()); m.forEach((k,v)-&gt;map.put((String)k,(Double)v)); return map; } 大部分的转换函数类似，首先判空，接着进行对应的类型转换，这里的Conversion与后端的基本一致，后端也需要使用Conversion类进行转换操作。 3.9.2 Utils 获取属性文件方法如下： //获取属性文件 public static Properties getProperties() { Properties properties = new Properties(); //项目属性文件分成了config_dev.properties,config_test.properties,config_prod.properties String fileName = &quot;properties/config_&quot;+ getEnv() +&quot;.properties&quot;; ClassLoader loader = Thread.currentThread().getContextClassLoader(); try(InputStream inputStream = loader.getResourceAsStream(fileName)) { if(inputStream != null) { //防止乱码 properties.load(new InputStreamReader(inputStream, StandardCharsets.UTF_8)); return properties; } L.error(&quot;Can not load properties properly.InputStream is null.&quot;); return null; } catch (IOException e) { L.error(&quot;Can not load properties properly.Message:&quot;+e.getMessage()); return null; } } 另一个是检查网路连通的方法： public static boolean networkAvaliable() { try(Socket socket = new Socket()) { socket.connect(new InetSocketAddress(&quot;www.baidu.com&quot;,443)); return true; } catch (IOException e) { L.error(&quot;Can not connect network.&quot;); e.printStackTrace(); } return false; } public static boolean backendAvaliable() { try(Socket socket = new Socket()) { if(isProdEnvironment()) socket.connect(new InetSocketAddress(&quot;www.test.com&quot;,8888)); else socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,8080)); return true; } catch (IOException e) { L.error(&quot;Can not connect back end server.&quot;); L.error(ExceptionUtils.getStackTrace(e)); } return false; } 采用socket进行判断，准确来说是包含检查网络连通以及后端是否连通。 最后是居中Stage的方法，尽管Stage中自带了一个centerOnScreen，但是出来的效果并不好，笔者的实测是水平居中但是垂直偏上的，并不是垂直水平居中。 因此根据屏幕高宽以及Stage的大小手动设置Stage的x和y。 public static void centerMainStage() { Rectangle2D screenRectangle = Screen.getPrimary().getBounds(); double width = screenRectangle.getWidth(); double height = screenRectangle.getHeight(); Stage stage = GUI.getStage(); stage.setX(width/2 - ViewSize.MAIN_WIDTH/2); stage.setY(height/2 - ViewSize.MAIN_HEIGHT/2); } 3.10 视图模块 GUI：全局变量共享以及以及控制Scene的切换 MainScene：全局控制器，负责初始化以及绑定键盘事件 MessageBox：提示信息框，对外提供show()等的静态方法 GUI中的方法主要为switchToXxx，比如： public static void switchToSignInUp() { if(GUI.isUserInformation()) { AvatarUtils.deletePathIfExists(); GUI.getUserInformationController().reset(); } mainParent.requestFocus(); children.clear(); children.add(signInUpParent.lookup(PaneName.SIGN_IN_UP)); scene.getStylesheets().add(CSSPath.SIGN_IN_UP); Label minimize = (Label) (mainParent.lookup(&quot;#minimize&quot;)); minimize.setText(&quot;-&quot;); minimize.setFont(new Font(&quot;System&quot;, 20)); minimize.setOnMouseClicked(v-&gt;minimize()); } 跳转到登录注册界面，是公有静态方法，首先判断是否为用户信息界面，如果是进行一些清理操作，接着是让Parent获取焦点（为了让键盘事件响应），然后将对应的AnchorPane添加到Children，并添加css，最后修改按钮文字与事件。 另外还在MainScene中加了一些键盘事件响应，比如Enter： ObservableMap&lt;KeyCombination,Runnable&gt; keyEvent = GUI.getScene().getAcclerators(); keyEvent.put(new KeyCodeCombination(KeyCode.ENTER),()-&gt; { if (GUI.isSignInUp()) GUI.getSignInUpController().signInUp(); else if (GUI.isRetrievePassword()) GUI.getRetrievePasswordController().reset(); else if(GUI.isWorker()) GUI.switchToUserInformation(); else if(GUI.isAdmin()) GUI.switchToUserManagement(); else if(GUI.isUserInformation()) { UserInformationController controller = GUI.getUserInformationController(); if(controller.isModifying()) controller.saveInformation(); else controller.modifyInformation(); } else if(GUI.isSalaryEntry()) { GUI.getSalaryEntryController().save(); } }); 4 前端UI部分 4.1 fxml 界面基本上靠这些fxml文件控制，这部分没太多内容，基本上靠IDEA自带的Scene Builder设计，少部分靠代码控制，下面说几个注意事项： 根节点为AnchorPane，每个fxml设置一个独立的fx:id以便切换 事件绑定在对应的控件中，比如在一个Label绑定鼠标进入事件，在这个Label上设置onMouseEntered=&quot;#xxx&quot;，其中里面的方法为对应的控制器（fx:controller=&quot;xxx.xxx.xxx.xxxController&quot;）中的方法 &lt;Image&gt;中的URL属性需要带上@，比如&lt;Image url=&quot;@../../image/xxx.png&quot;&gt; 4.2 css JFX中集成了部分css的美化功能，比如： -fx-background-radius: 25px; -fx-background-color:#e2ff1f; 用法是需要先在fxml中设置id。 这里注意一下两个id的不同： fx:id id fx:id指的是控件的fx:id，通常配合Controller中的@FXML使用，比如一个Label设置了fx:id为label1 &lt;Label fx:id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt; &lt;font&gt; &lt;Font size=&quot;18.0&quot; /&gt; &lt;/font&gt; &lt;/Label&gt; 则可以在对应Controller中使用@FXML获取，名字与fx:id一致： @FXML private Label label1; 而id指的是css的id，用法是在css引用即可，比如上面的Label又同时设置了id（可以相同，也可不同）： &lt;Label fx:id=&quot;label1&quot; id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt; &lt;font&gt; &lt;Font size=&quot;18.0&quot; /&gt; &lt;/font&gt; &lt;/Label&gt; 然后在css文件中像引用普通id一样引用： #label1 { -fx-background-radius: 20px; /*圆角*/ } 同时JFX还支持css的伪类，比如下面的最小化与关闭的鼠标移入效果是使用伪类实现的： #minimize:hover { -fx-opacity: 1; -fx-background-radius: 10px; -fx-background-color: #323232; -fx-text-fill: #ffffff; } #close:hover { -fx-opacity: 1; -fx-background-radius: 10px; -fx-background-color: #dd2c00; -fx-text-fill: #ffffff; } 当然一些比较复杂的是不支持的，笔者尝试过使用transition之类的，不支持。 最后需要在对应的Scene里面引入css： Scene scene = new Scene(); scene.getStylesheets().add(&quot;xxx/xxx/xxx/xxx.css&quot;); 程序中的用法是： scene.getStylesheets().add(CSSPath.SIGN_IN_UP); 4.3 Stage构建过程 下面以提示框为例，说明Stage的构建过程。 try { Stage stage = new Stage(); Parent root = FXMLLoader.load(getClass().getResource(FXMLPath.MESSAGE_BOX)); Scene scene = new Scene(root, ViewSize.MESSAGE_BOX_WIDTH,ViewSize.MESSAGE_BOX_HEIGHT); scene.getStylesheets().add(CSSPath.MESSAGE_BOX); Button button = (Button)root.lookup(&quot;#button&quot;); button.setOnMouseClicked(v-&gt;stage.hide()); Label label = (Label)root.lookup(&quot;#label&quot;); label.setText(message); stage.initStyle(StageStyle.TRANSPARENT); stage.setScene(scene); Utils.centerMessgeBoxStage(stage); stage.show(); root.requestFocus(); scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), stage::close); scene.getAccelerators().put(new KeyCodeCombination(KeyCode.BACK_SPACE), stage::close); } catch (IOException e) { //... } 首先新建一个Stage，接着利用FXMLLoader加载对应路径上的fxml文件，获取Parent后，利用该Parent生成Scene，再为Scene添加样式。 接着是控件的处理，这里的lookup类似Android中的findViewById，根据fx:id获取对应控件，注意需要加上#。处理好控件之后，居中并显示Stage，同时，绑定键盘事件并让Parent获取焦点。 5 后端部分 5.1 后端概述 后端以Spring Boot框架为核心，部署方式为WAR，整体分为三层： 控制器层：负责接受前端的请求并调用业务层方法 业务层：处理主要业务，如CRUD，图片处理等 持久层：数据持久化，Hibernate+Spring Data JPA 总的来说没有用到什么高大上的东西，逻辑也比较简单。 5.2 概览 5.2.1 代码目录树 5.2.2 依赖 主要依赖如下： Spring Boot Starter Data JPA：数据持久化 Guava：用于将Iterable&lt;Worker&gt;转换为集合 Lombok：同前端 Gson：JSON转换类 Apache Commons：用于异常处理+随机字符串生成 TencentCloud SDK Java：短信验证码API Jasypt Spring Boot Starter：加密配置文件 5.3 控制器层 控制器分为三类，一类处理图片，一类处理CRUD请求，一类处理短信发送请求，统一接受POST忽略GET请求。大概的处理流程是接收参数后首先进行判断操作，比如判空以及判断是否合法等等，接着调用业务层的方法并对返回结果进行封装，同时进行日志记录，最后利用Gson把返回结果转为字符串。代码大部分比较简单就不贴了，说一下短信验证码的部分。 验证码模块使用了腾讯云的接口，官网这里，搜索短信功能即可。 新用户默认赠送100条短信： 发送之前需要创建签名与正文模板，审核通过即可使用。 可以先根据快速开始试用一下短信功能，若能成功收到短信，可以戳这里查看API（Java版）。 下面的例子由文档例子简化而来： @PostMapping(&quot;sendSms&quot;) public @ResponseBody String sendSms(@RequestParam String cellphone) { String randomCode = RandomStringUtils.randomNumeric(6); if(Check.isEmpty(cellphone)) { L.sendSmsFailed(&quot;null&quot;,randomCode,&quot;cellphone is empty&quot;); return toStr(ReturnCode.EMPTY_CELLPHONE); } if(Check.isInvalidCellphone(cellphone)) { L.sendSmsFailed(cellphone,randomCode,&quot;cellphone is not valid.&quot;); return toStr(ReturnCode.INVALID_CELLPHONE); } ReturnCode s = ReturnCode.SEND_SMS_SUCCESS; try { SmsClient client = new SmsClient(new Credential(secretId,secretKey),&quot;&quot;); SendSmsRequest request = new SendSmsRequest(); request.setSmsSdkAppid(appId); request.setSign(sign); request.setTemplateID(templateId); String [] templateParamSet = {randomCode}; request.setTemplateParamSet(templateParamSet); String [] phoneNumbers = {&quot;+86&quot;+cellphone}; request.setPhoneNumberSet(phoneNumbers); SendSmsResponse response = client.SendSms(request); if(response != null &amp;&amp; response.getSendStatusSet()[0].getCode().equals(&quot;Ok&quot;)) { L.sendSmsSuccess(cellphone,randomCode); s.body(randomCode); } } catch (Exception e) { L.sendSmsFailed(cellphone,randomCode,e); s = ReturnCode.UNKNOWN_ERROR; } return toStr(s); } 其中appId,sign,templateID分别是对应的appid，签名id与正文模板id，申请通过之后会分配的，然后随机生成六位数字的验证码。 request.setPhoneNumberSet()的参数为需要发送的手机号码String数组，注意需要加上区号。发送成功的话手机会收到，失败的话请根据异常信息自行判断修改。 唯一要注意一下的是appid之类的数据通过@Value进行属性注入时，如： @Controller @RequestMapping(&quot;/&quot;) public class SmsController { @Value(&quot;${tencent.secret.id}&quot;) private String secretId; ... } 但是由于sign部分含有中文，所以需要进行编码转换： @Value(&quot;${tencent.sign}&quot;) private String sign; @PostConstruct public void init() { sign = new String(sign.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8); } 5.4 业务层与持久层 由于程序中的业务层与持久层都比较简单就合并一起说了，比如业务层的saveOne方法，保存一个Worker，先利用Gson转换为Worker后直接利用CrudRespository&lt;T,ID&gt;提供的save方法保存： public ReturnCode saveOne(String json) { ReturnCode s = ReturnCode.SAVE_ONE_SUCCESS; Worker worker = Conversion.JSONToWorker(json); if (Check.isEmpty(worker)) { L.emptyWorker(); s = ReturnCode.EMPTY_WORKER; } else workerRepository.save(worker); return s; } 另外由于CrudRepository&lt;T,ID&gt;的saveAll方法参数为Iterable&lt;S&gt;，因此可以直接保存List&lt;S&gt;，比如： public ReturnCode saveAll(List&lt;Worker&gt; workers) { workerRepository.saveAll(workers); return ReturnCode.SAVE_ALL_SUCCESS; } 需要在控制层中把前端发送的String转换为List&lt;S&gt;。 5.5 日志 日志用的是Spring Boot自带的日志系统，只是简单地配置了一下日志路径，除此之外，日志的格式自定义（因为追求整洁输出,感觉配置文件实现得不够好,因此自定义了一个工具类）。 比如日志截取如下： 自定义了标题以及每行固定输出，前后加上了提示符，内容包括方法，级别，时间以及其他信息。 总的来说，除了格式化器外总共有7个类，其中L是主类，外部类只需要调用L的方法，大部分是公有静态方法，其余6个是L调用的类： 如备份成功时调用： public Success { public static void backup() { l.info(new FormatterBuilder().title(getTitle()).info().position().time().build()); } //... } 其中FormatterBuilder是格式化器，用来格式化输出的字符串，方法包括时间，位置，级别以及其他信息： public FormatterBuilder info() { return level(&quot;info&quot;); } public FormatterBuilder time() { content(&quot;time&quot;,getCurrentTime()); return this; } private FormatterBuilder level(String level) { content(&quot;level&quot;,level); return this; } public FormatterBuilder cellphone(String cellphone) { content(&quot;cellphone&quot;,cellphone); return this; } public FormatterBuilder message(String message) { content(&quot;message&quot;,message); return this; } 5.6 工具类 四个： Backup：定时数据库备份 Check：检查合法性，是否为空等 Conversion：转换类，与前端的几乎一致，利用Gson在String与List/Map/Worker之间进行转换 ReturnCode：返回码枚举类 重点说一下备份，代码不长就直接整个类贴出来了： @Component @EnableScheduling public class Backup { private static final long INTERVAL = 1000 * 3600 * 12; @Value(&quot;${backup.command}&quot;) private String command; @Value(&quot;${backup.path}&quot;) private String strPath; @Value(&quot;${spring.datasource.username}&quot;) private String username; @Value(&quot;${spring.datasource.password}&quot;) private String password; @Value(&quot;${spring.datasource.url}&quot;) private String url; @Value(&quot;${backup.dataTimeFormat}&quot;) private String dateTimeFormat; @Scheduled(fixedRate = INTERVAL) public void startBackup() { try { String[] commands = command.split(&quot;,&quot;); String dbname = url.substring(url.lastIndexOf(&quot;/&quot;)+1); commands[2] = commands[2] + username + &quot; --password=&quot; + password + &quot; &quot; + dbname + &quot; &gt; &quot; + strPath + dbname + &quot;_&quot; + DateTimeFormatter.ofPattern(dateTimeFormat).format(LocalDateTime.now())+&quot;.sql&quot;; Path path = Paths.get(strPath); if(!Files.exists(path)) Files.createDirectories(path); Process process = Runtime.getRuntime().exec(commands); process.waitFor(); if(process.exitValue() != 0) { InputStream inputStream = process.getErrorStream(); StringBuilder str = new StringBuilder(); byte []b = new byte[2048]; while(inputStream.read(b,0,2048) != -1) str.append(new String(b)); L.backupFailed(str.toString()); } L.backupSuccess(); } catch (IOException | InterruptedException e) { L.backupFailed(e.getMessage()); } } } 首先利用@Value获取配置文件中的值，接着在备份方法加上@Scheduled。@Scheduled是Spring Boot用于提供定时任务的注解，用于控制任务在某个指定时间执行或者每隔一段时间执行（这里是半天一次），主要有三种配置执行时间的方式： cron fixedRate fixedDelay 这里不展开了，详细用法可以戳这里。 另外在使用前需要在类上加上@EnableScheduling。备份时首先利用URL获取数据库名，接着拼合备份命令，注意如果本地使用win开发备份命令会与linux不同： //win(未经测试，笔者在Linux上开发) command[0]=cmd command[1]=/c command[2]=mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot; //linux(本地Manjaro+服务器CentOS测试通过) command[0]=/bin/sh command[1]=-c command[2]=/usr/bin/mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot; 再判断备份路径是否存在，接着利用Java自带的Process进行备份处理，若出错则利用其中的getErrorStream()获取错误信息并记录日志。 5.7 配置文件 5.7.1 配置文件分类 一个总的配置文件+三个是特定环境下（开发，测试，生产）的配置文件，可以使用spring.profiles.active切换配置文件，比如spring.profiles.active=dev，注意命名有规则，中间加一杠。另外自定义的配置需要在additional-spring-configuration-metadata.json中添加字段（非强制，只是IDE会提示），比如： &quot;properties&quot;: [ { &quot;name&quot;: &quot;backup.path&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;defaultValue&quot;: null }, ] 5.7.2 加密 都2020年了，还在配置文件中使用明文密码就不太好吧？ 该加密了。 使用的是Jasypt Spring Boot组件，官方github请戳这里。 用法这里就不详细介绍了，详情看笔者的另一篇博客，戳这里。 但是笔者实测目前最新的3.0.2版本（本文写于2020.06.05，2020.05.31作者已更新3.0.3版本，但是笔者没有测试过）会有如下问题： Description: Failed to bind properties under 'spring.datasource.password' to java.lang.String: Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String Action: Update your application's configuration 解决方案以及问题详细描述戳这里。 6 部署与打包 6.1 前端打包 先说一下前端的打包过程，简单地说打成JAR即可跨平台运行，但是如果是特定平台的话比如Win，想打成无需额外JDK环境的EXE还是需要一些额外操作，这里简单介绍一下打包过程。 （如果是JDK8可以使用mvn jfx:native打包，这个可以很方便地直接打成DMG或者EXE，但可惜JFX11行不通，反正笔者尝试失败了，如果有大神知道如何使用JavaFX-Maven-Plugin或者在IDEA中使用artifact直接打成exe或dmg欢迎留言补充） 6.1.1 IDEA一次打包 打包需要用到Maven插件，常用的Maven打包插件如下： mave-jar-plugin：默认的打包jar插件，生成的JR很小，但是需要把lib放置与jar相同目录下，用来打普通的JAR包 maven-shade-plugin：提供了两大基本功能，将依赖的jar包打包到当前jar包，能对依赖的JAR包进行重命名以及取舍过滤 maven-assembly-plugin：支持定制化的打包方式，更多的是对项目目录的重新组装 本项目使用maven-shade-plugin打包。 需要先引入（引入之后可以把原来的Maven插件去掉），最新版本戳这里的官方github查看： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 只需要修改主类即可： &lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt; 接着就可以从IDEA右侧栏的Maven中一键打包： 这样在target下就有JAR包了，可以跨平台运行，只需提供JDK环境。 java -jar xxx.jar 下面的两步是使用exe4j与Enigma Virtual Box打成一个单一EXE的方法，仅针对Win，使用Linux/Mac可以跳过或自行搜索其他方法。 6.1.2 exe4j二次打包 6.1.2.1 exe4j exe4j能集成Java应用程序到Win下的java可执行文件生成工具,无论是用于服务器还是用于GUI或者命令行的应用程序。简单地说，本项目用其将jar转换为EXE。exe4j需要JRE，从JDK9开始模块化，需要自行生成JRE，因此，需要先生成JRE再使用exe4j打包。 6.1.2.2 生成jre 各个模块的作用可以这里查看： 经测试本程序所需要的模块如下： java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management 切换到JDK目录下，使用jlink生成JRE： jlink --module-path jmods --add-modules java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management --output jre 由于OpenJDK11不自带JavaFX，需要戳这里自行下载Win平台的JFX jmods，并移动到JDK的jmods目录下。生成的JRE大小为91M： 如果实在不清楚使用哪一些模块可以使用全部模块，但是不建议： jlink --module-path jmods --add-modules java.base,java.compiler,java.datatransfer,java.xml,java.prefs,java.desktop,java.instrument,java.logging,java.management,java.security.sasl,java.naming,java.rmi,java.management.rmi,java.net.http,java.scripting,java.security.jgss,java.transaction.xa,java.sql,java.sql.rowset,java.xml.crypto,java.se,java.smartcardio,jdk.accessibility,jdk.internal.vm.ci,jdk.management,jdk.unsupported,jdk.internal.vm.compiler,jdk.aot,jdk.internal.jvmstat,jdk.attach,jdk.charsets,jdk.compiler,jdk.crypto.ec,jdk.crypto.cryptoki,jdk.crypto.mscapi,jdk.dynalink,jdk.internal.ed,jdk.editpad,jdk.hotspot.agent,jdk.httpserver,jdk.internal.le,jdk.internal.opt,jdk.internal.vm.compiler.management,jdk.jartool,jdk.javadoc,jdk.jcmd,jdk.management.agent,jdk.jconsole,jdk.jdeps,jdk.jdwp.agent,jdk.jdi,jdk.jfr,jdk.jlink,jdk.jshell,jdk.jsobject,jdk.jstatd,jdk.localedata,jdk.management.jfr,jdk.naming.dns,jdk.naming.rmi,jdk.net,jdk.pack,jdk.rmic,jdk.scripting.nashorn,jdk.scripting.nashorn.shell,jdk.sctp,jdk.security.auth,jdk.security.jgss,jdk.unsupported.desktop,jdk.xml.dom,jdk.zipfs,javafx.web,javafx.swing,javafx.media,javafx.graphics,javafx.fxml,javafx.controls,javafx.base --output jre 大小为238M： 6.1.2.3 exe4j打包 exe4j使用参考这里，首先一开始的界面应该是这样的： 配置文件首次运行是没有的，next即可。 选择JAR in EXE mode： 填入名称与输出目录： 这里的类型为GUI application，填上可执行文件的名称，选择图标路径，勾选允许单个应用实例运行： 重定向这里可以选择标准输出流与标准错误流的输出目录，不需要的话默认即可： 64位Win需要勾选生成64位的可执行文件： 接着是Java类与JRE路径设置： 选择IDEA生成的JAR，接着填上主类路径： 设置jre的最低支持与最高支持版本： 下一步是指定JRE搜索路径，首先把默认的三个位置删除： 接着选择之前生成的JRE，把JRE放在与JAR同一目录下，路径填上当前目录下的JRE： 接下来全next即可，完成后会提示exe4j has finished，直接运行测试一遍： 首先会提示一遍这是用exe4j生成的： 若没有缺少模块应该就可以正常启动了，有缺少模块的话会默认在当前exe路径生成一个error.log，查看并添加对应模块再次使用jlink生成jre，并使用exe4j再次打包。 6.1.3 Enigma Virtual Box三次打包 使用exe4j打包后，虽然是也可以直接运行了，但是JRE太大，而且笔者这种有强迫症非得装进一个EXE。所幸笔者之前用过Enigma Virtual Box这个打包工具，能把所有文件打包为一个独立的EXE。 使用很简单，首先添加exe4j打包出来的EXE： 接着新建一个jre目录，添加上一步生成的jre： 最后选择压缩文件： 打包出来的单独exe大小为65M，相比起exe4j还要带上的89M的jre，已经节省了空间。 6.2 后端部署 后端部署的方式也简单，采用WAR部署的方式，若项目为JAR包打包可以自行转换为WAR包，具体转换方式不难请自行搜索。由于Web服务器为Tomcat，因此直接把WAR包放置于webapps下即可，其他Web服务器自请自行搜索。 当然也可以使用Docker部署，但需要使用JAR而不是WAR，具体方式自行搜索。 7 运行 本项目已经打包，前端包括jar与exe，后端包括jar与war，首先把后端运行（先开启数据库服务）： 使用jar： java -jar Backend.jar 使用war直接放到Tomcat的webapps下然后到bin下： ./startup.sh 接着运行前端，Windows的话可以直接运行exe，当然也可以jar，Linux的话jar： java -jar Frontend.jar 若运行失败可以用IDEA打开项目直接在IDEA中运行或者自行打包运行。 8 注意事项 8.1 路径问题 对于资源文件千万千万不要直接使用什么相对路径或绝对路径，比如： String path1 = &quot;/xxx/xxx/xxx/xx.png&quot;; String path2 = &quot;xxx/xx.jpg&quot;; 这样会有很多问题，比如有可能在IDEA中直接运行与打成jar包运行的结果不一致，路径读取不了，另外还可能会出现平台问题，众所周知Linux的路径分隔符与Windows的不一致。所以，对于资源文件，统一使用如下方式获取： String path = getClass().getResource(&quot;/image/xx.png&quot;); 其中image直接位于resources资源文件夹下。其他类似，也就是说这里的/代表在resources下。 8.2 HTTPS 默认没有提供HTTPS，证书文件没有摆上去，走的是本地8080端口。 如果需要自定义HTTPS请修改前端部分的 com.test.network.OKHTTP resources/key/pem.pem 同时后端需要修改Tomcat的server.xml。 有关OkHttp使用HTTPS的文章有不少，但是大部分都是仅仅写了前端如何配置HTTPS的，没有提到后端如何部署，可以参考笔者的这篇文章，包含Tomcat的配置教程。 8.3 配置文件加密 配置文件使用了jasypt-spring-boot开源组件进行加密，设置口令可以有三种方式设置： 命令行参数 应用环境变量 系统环境变量 目前最新的版本为3.0.3（2020.05.31更新3.0.3 ，笔者之前使用3.0.2的版本进行加密时本地测试没问题，但是部署到服务器上老是提示找不到口令，无奈只好使用旧一点的2.x版本，但是新版本出了后笔者尝试过部署到本地Tomcat没有问题但是没有部署到服务器上），建议使用最新版本进行部署： 毕竟前后跨度挺大的，虽然说这是小的bug修复，但是还是建议试试，估计不会有3.0.2的问题了。 另外对于含有中文的字段记得进行编码转换： str = new String(str.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);) 另外笔者已写好了测试文件，直接首先替换掉配置文件原来的密文，填上明文重新加密： 注意如果没有在配置文件中设置jasypt.encryptor.password的话可以在运行配置中设置VM Options（建议不要把口令直接写在配置文件中，当然这个默认是使用PBE加密，非对称加密可以使用jasypt.encryptor.private-key-string或jasypt.encryptor.private-key-location）： 8.4 键盘事件 添加键盘事件可以使用如下代码： scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), ()-&gt;{xxx}); //getAccelerators返回ObservableMap&lt;KeyCombination, Runnable&gt; 响应之前需要让parent获取焦点： parent.requestFocus(); 8.5 数据库 默认使用的数据库名为app_test，用户名test_user，密码test_password，resources下有一个init.sql，直接使用MySQL导入即可。 8.6 验证码 默认没有自带验证码功能，由于涉及隐私问题故没有开放。 如果像笔者一样使用腾讯云的短信API，直接修改配置文件中的对应属性即可，建议加密。 如果使用其他API请自行对接，前端需要修改的部分包括： com.test.network.OKHTTP com.test.network.request.SendSmsRequest com.test.network.requestBuilder.SendSmsRequestBuilder com.test.controller.start.RetrievePasswordController 后端需要修改的部分： com.test.controller.SmsController 需要的话可以参考笔者的腾讯云短信API使用或者自行搜索其他短信验证API。一些写在配置文件中的API需要的密钥等信息强烈 9 源码 前后端完整代码以及打包程序： Github 码云 10 项目不足之处 其实整个项目还有很多的不足之处，比如： 前端的部分Scene切换有问题 可以使用Jackson代替Gson来换取更快的转换速度 没有缓存机制 前端日志不能发送到后端分析 可以使用二进制代替JSON实现更快的传输 不过目前暂时不考虑更新，如果有读者有自己的想法可以按需修改，这里提一下修改的思路。 11 参考 1、CSDN-maven-shade-plugin介绍及使用 2、CSDN-Maven3种打包方式之一maven-assembly-plugin的使用 3、知乎-制作包含Java 11和JavaFX的JRE 4、CSDN-使用exe4j将java文件打成exe文件运行详细教程 5、Github-jasypt-spring-boot issue 6、w3cschool-JavaFX 7、简书-Linux Tomcat+Openssl单向/双向认证 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/javafxspringbootyan-zheng-ma-gong-neng-de-xiao-xing-xin-chou-guan-li-xi-tong/"},{"title":"JFX11+Maven+IDEA 发布跨平台应用的完美解决方案","content":"1 概述 前几天写了两篇关于JFX+IDEA打包跨平台应用的文章，这篇是使用IDEA自带功能打包的，这篇是使用Maven进行打包的，但是效果不太满意，因为从JDK9开始实现模块化，同时JFX部分从JDK中独立出来了，也就是说需要默认JDK不再自带JFX。这意味着外部依赖需要手动处理module-info.java，这是一件非常麻烦的事情。 1.1 不使用Maven 其实不使用Maven也能打包发布跨平台JFX应用，但是没有使用Maven的话，虽然打包出来能直接运行无需jre环境，但是，管理依赖确实麻烦，在使用jlink打包一些外部的jar时，对于一些比较简单的jar还是比较舒服的，参照这里： 首先去下载jar，接着生成module-info.java，然后使用jdeps检查依赖，添加对应的jar到路径中，编译生成module-info.java接着更新原来的jar即可。看起来简单，但是笔者碰到了okhttp这种jar，依赖简直环环相扣导致笔者放弃了这种方式。 1.2 使用Maven 使用Maven可以完美解决依赖问题，多亏与强大的pom.xml，几行&lt;dependency&gt;就可以解决依赖问题，但是，还是需要手动处理module-info.java，而且IDEA文档明确表明仅支持Java8的打包为jar： 因此，这篇文章采取一种最简单的方式利用Maven打包发布JFX11应用。 2 新建Maven工程 默认即可，问题不大。 3 添加依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-base&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;linux&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-base&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;win&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;linux&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;win&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;linux&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;win&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;linux&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt; &lt;version&gt;11&lt;/version&gt; &lt;classifier&gt;win&lt;/classifier&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 需要再哪个平台在classifier中指定即可。这里是linux与win。mac的话直接“mac”。 同时指定编码与JDK： &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; 否则会如此报错： 4 新建Main 新建一个包再新建Main.java，Launcher.java以及Main.fxml： Main.java： package com.test; import javafx.application.Application; import javafx.fxml.FXMLLoader; import javafx.scene.Parent; import javafx.scene.Scene; import javafx.stage.Stage; public class Main extends Application { public void start(Stage stage) throws Exception { Parent root = FXMLLoader.load(getClass().getResource(&quot;/Main.fxml&quot;)); Scene scene = new Scene(root); stage.setScene(scene); stage.setTitle(&quot;Hello World&quot;); stage.show(); } public static void main(String[] args) { launch(args); } } Launcher.java： package com.test; public class Launcher { public static void main(String[] args) { Main.main(args); } } Main.fxml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?import javafx.scene.control.*?&gt; &lt;?import javafx.scene.layout.*?&gt; &lt;?import javafx.scene.text.*?&gt; &lt;AnchorPane prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/10.0.2-internal&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.test.Main&quot;&gt; &lt;Label layoutX=&quot;228.0&quot; layoutY=&quot;185.0&quot; text=&quot;Hello World&quot;&gt; &lt;font&gt; &lt;Font size=&quot;25.0&quot;/&gt; &lt;/font&gt; &lt;/Label&gt; &lt;/AnchorPane&gt; 注意getResource中的fxml路径，Main.fxml文件放在resources下，直接通过根路径读取： getResource(&quot;/Main.fxml&quot;); 5 添加运行配置 此时应该是没有运行配置的状态，点击Add Configuration： 添加Application： 添加Launcher类作为Main class： 这时候run就没问题了： 6 使用默认Maven打包 虽然现在可以run了，但是，如果直接使用默认的Maven打包的话： 在target下有一个jar，直接右键运行： 会提示no main manifest attribute： 也就是找不到Manifest中入口类。 jar实际上是一个class的压缩包，与zip的区别是jar包含了一个MANIFEST.MF，MANIFEST.MF在META-INF下，一个示例文件如下： 有点类似与键值对的格式，MANIFEST.MF包含了jar文件的内容描述，并在运行时向JVM提供应用程序信息。注意该文件有严格的格式限制，比如第一行不能为空，行与行之间不能存在空行。 一个暴力的解决办法是直接解压jar并修改里面的MANIFEST.MF，添加 Main-Class: com.test.Launcher 但是这样会报找不到Application类的异常： 7 添加新的打包插件 理论上来说，只需要jar包内的相同目录下提供了javafx的jar或者class文件就不会抛出异常了，但是，如果依赖很多需要一个一个添加，这是一个痛苦的过程。 所以，为了优雅地解决这个问题，引入一个叫maven-shade-plugin的插件即可： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;com.test.Launcher&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 最新版本请到官方github查看，使用时只需要修改： &lt;mainClass&gt;xxx.xxx.xxx&lt;/mainClass&gt; 修改为程序入口类。 8 打包 此时再从右侧栏打包选中Maven，package即可： 但是会有警告： 因为一些class文件重复了，但是也提到了通常来说这是没有危害的并且可以跳过警告，或者修改pom.xml去手动排除某些依赖。 9 运行 直接在IDEA中右键运行或者-jar运行，可以看到没有异常了： 相比起原来自带的Maven打包插件，主要是多了javafx的一些class以及对应平台所需要的一些动态库文件等，比如win上的.dll与linux上的.so文件。 这样一个跨平台的JFX jar包就制作好了，只需 java -jar 即可跨平台运行。 ","link":"https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/"},{"title":"一个开源的跨平台音乐播放与音乐下载器","content":"跨平台的音乐播放器 目前国内的linux平台上的音乐播放器不多，除了网易云比较多人使用的。 当然Listen1也是一个不错的选择，真正的跨平台，包括Android/Mac/Win/Linux以及Chrome插件，目前尚在维护： Listen1其实非常不错，支持歌单功能，可以方便的播放，但美中不足的是没有下载功能。 因此，这里推荐一个带下载以及播放功能的开源音乐软件：洛雪音乐助手桌面版。 一个基于 Electron + Vue 开发的音乐软件。 UI： 推荐歌单列表： 排行榜： 下载功能： ","link":"https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/"},{"title":"JavaFX获取屏幕尺寸","content":"1 awt Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); double width = screenSize.getWidth(); double height = screenSize.getHeight(); 2 javafx Rectangle2D screenRectangle = Screen.getPrimary().getBounds(); double width = screenRectangle.getWidth(); double height = screenRectangle.getHeight(); ","link":"https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/"},{"title":"OkHttp:NoClassDefFoundError","content":"1 问题描述 使用OkHttp时报错： Caused by: java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics at okhttp3@4.7.2/okhttp3.FormBody$Builder.add(FormBody.kt) 2 原因 由于OkHttp依赖于okio，目前OkHttp最新的版本为4.7.2，使用Maven/Gradle导入的话不会出现该问题，原因应该是只是单纯把OkHttp的jar导入，还需要把okio一并导入，但是需要知道OkHttp对应的okio版本，可以通过Maven导入查看，比如4.7.2对应的是2.6.0。 如果已经添加了okio则可以跳过，另外还需要添加kotlin-stdlib库，使用最新版本即可，目前最新版本为1.3.72。 下载链接戳这里。 3 解决方案 把对应版本的okio以及kotlin-stdlib添加到依赖库即可。 ","link":"https://2293736867.github.io/post/okhttpnoclassdeffounderror/"},{"title":"jasypt-spring-boot提示Failed to bind properties","content":"1 问题描述 在Spring Boot中使用jasypt-spring-boot进行加密，但是提示： Description: Failed to bind properties under 'spring.datasource.password' to java.lang.String: Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String Action: Update your application's configuration 或提示 Description: Failed to bind properties under 'spring.datasource.url' to java.lang.String: Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String Action: Update your application's configuration 最后的异常是这个： 2 解决办法 查阅了相关issue，发现是3.0.2更改了默认的加密算法，最后的办法是把版本降到2.1.2： &lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; 接着重新加密配置，但是2.1.2不支持使用环境变量作为加密的口令，在IDEA中测试的时候需要在运行配置加上 -Djasypt.encryptor.password=xxxx 部署到Tomcat时添加环境变量： export JAVA_OPTS=&quot;-Djasypt.encryptor.password=xxxx&quot; ","link":"https://2293736867.github.io/post/jasypt-spring-boot-ti-shi-failed-to-bind-properties/"},{"title":"JFX11+IDEA跨平台打包发布的完美解决办法","content":"1 概述 IDEA2020.1的文档中提到只有JFX8的工程才支持打成jar包，并且，如果直接使用Build Artifacts的话，会如下提示： IDEA文档有提到这个的解决办法，是使用一些第三方工具。里面介绍了通过IDEA结合自身/Maven/Gradle打包发布JFX11以上版本的方法。但是，不足的地方有： 直接创建JFX工程默认只有一个src目录，不像Maven工程还带有resources与test，给管理资源文件以及外部依赖造成了困难，getClass().getResource()会出现空指针问题，但是好处是只需具备JDK环境，打包出来的文件能带上jmods能跨平台直接运行 直接创建Maven项目虽然是管理依赖以及资源文件方便，但是无论是直接通过Maven打出的jar包还是通过JavaFX Maven Plugins打出来的jar包默认绑定了开发平台的JFX SDK，简单地说就是Linux开发的JFX程序不能直接跑在具有JDK环境的Win上，因为用的是Linux的JFX SDK而不是Win的JFX SDK 因此，本文结合这两者的优点，参照Maven的目录管理，以JFX工程为基础，记录了从新建工程到发布跨平台JFX应用的过程。 2 环境 IDEA 2020.1 OpenJDK 11 OpenJFX 11 Linux SDK OpenJFX 11 Linux/Windows/Mac OS X jmods JDK安装就不说了，JFX直接下载然后在工程中通过外部库引入即可，三种jmods解压出来即可，用于最后生成可执行文件时添加的模块。 下载链接戳这里。 3 新建JFX工程 这里的项目名为TestJFX，对应修改即可。 4 添加JFX11 SDK 添加上一步下载的对应平台的JFX SDK。 5 添加module-info.java 在src目录右键New-&gt;module-info.java，修改如下： module TestJFX { requires javafx.fxml; requires javafx.controls; opens sample to javafx.fxml; exports sample; } 其中TestJFX为新建项目时的项目名，这个创建module-info.java时就默认加上了，sample为默认包，对应修改。 6 添加VM Options 添加 --module-path /usr/local/jfx/lib:out/production 其中 /usr/local/jfx/lib 为下载的JFX JDK的lib目录，后面的out不需要更改，是默认的编译输出的目录。 7 运行 这时候应该可以Shift+F10或者点击绿色小三角运行了： 当然内容是空的，因为什么也没有加。 8 添加资源文件 默认的fxml是放在与Main类同一目录下的，getResource()也没有加路径直接写上文件名： 但是这是src文件夹，放个fxml还勉强可以接受，放张图片总不合适吧？所以，新建一个资源文件夹，把css，fxml什么的都放里面： 直接在IDEA中移动fxml文件，Main中的引用路径也自动更改，不得不说这个特性是真的好用，但遗憾的是，抛出了空指针异常。 因此采取绝对路径来进行读取文件，通过URL+System.getProperty()指定绝对路径： @Override public void start(Stage primaryStage) throws Exception{ String path = System.getProperty(&quot;user.dir&quot;); URL fxmlUrl = new URL(&quot;file:&quot;+path+&quot;/resources/fxml/sample.fxml&quot;); Parent root = FXMLLoader.load(fxmlUrl); primaryStage.setTitle(&quot;Hello World&quot;); Scene scene = new Scene(root); scene.getStylesheets().add(new URL(&quot;file:&quot;+path+&quot;/resources/css/1.css&quot;).toString()); primaryStage.setScene(scene); primaryStage.show(); } 其中 System.getProperty(&quot;user.dir&quot;) 获取项目路径，注意URL前面要加上“file:”，css的获取也同理，只不过是需要转换为String。 9 外部依赖 由于没有了Maven管理依赖，所以外部依赖的管理会相对麻烦一点，基本上是以jar包的形式手动添加，这里以添加Gson为例，戳这里下载jar包，然后在项目目录下新建一个lib文件夹，把jar包放进去： 接着在项目结构中把整个lib文件夹添加到外部库： 然后VM Options中添加lib路径，在上面的VM Options后面加一个冒号和lib就行： 但是，此时可以IDEA还不能进行补全，最后需要修改module-info.java： 加一行requires，此时IDEA能够进行补全了，每个jar包都不同，对应修改即可。 10 制作跨平台镜像 运行没问题之后就可以制作运行时镜像发布了，终端进入项目根路径： jlink --module-path jmod/linux:out/production:lib --add-modules TestJFX --output linux linux/bin/java -m TestJFX/sample.Main 其中 jmod/linux 为开发平台jmod的路径，可以是绝对路径，也可以是相对与项目根目录的相对路径，out/production与上面的VM Options保持一致。 --add-modules 后面跟的是模块名，这是在生成module-info.java时指定的，为项目名。 --output 为输出目录。 后一条命令中-m指定模块名，后面跟包名+主类名。 这样linux平台的镜像就制作好了，Mac与Win的同理，只需要把jmod换成对应平台的jmod即可，但是注意语法有一些差别，Mac的语法同Linux，只需要把jmod路径换一下，但是注意需要整个工程在对应的平台进行jlink： jlink --module-path xxxxx/{MAC_JMOD}:out/production:lib --add-modules TestJFX --output mac mac/bin/java -m TestJFX/sample.Main Win的语法有些区别，一样需要在Win下进行jlink： jlink --module-path &quot;xxxxx/{WIN_JMOD};out/production&quot; --add-modules TestJFX --output win win\\bin\\java -m TestJFX/sample.Main 下面是Win下的截图： 11 demo github 12 参考 Getting Started with JavaFX ","link":"https://2293736867.github.io/post/jfx11idea-kua-ping-tai-da-bao-fa-bu-de-wan-mei-jie-jue-ban-fa/"},{"title":"IDEA通过Maven打包JavaFX工程（OpenJFX11）","content":"1 概述 最近研究JFX，写出来了但是打包不了，这。。。尴尬。。。 IDEA的文档说只支持Java8打成jar包： 尝试过直接使用Maven插件的package，不行，也尝试过Build Artifacts，也不行，各种奇奇怪怪的问题。包括下图中的 Error....fx:deploy is not available in this JDK 不过幸好文档末尾提到可以使用一些第三方工具： 因此记录一下使用IDEA打包JFX11工程的过程。 2 环境 IDEA 2020.1 OpenJDK 11 OpenJFX 11 只需安装IDEA与JDK即可，JFX可以在pom.xml中引入。 3 创建工程 选择Maven，选择Create from archetype，然后Add Archetype并填上GroupId： org.openjfx 与ArtifactId： javafx-maven-archetypes 还有version： 0.0.1 下一步自定义，这里为了方便就直接默认了。 然后修改archetypeArtifactId为 javafx-archetype-fxml 完成即可。 4 检查文件 Maven同步完后，检查项目目录下的module-info.java与pom.xml，其中pom.xml不应该是下图这样的： 而应该是这样的，包含了javafx.controls与javafx.fxml依赖，还有javafx-maven-plugin插件： 同时src下的module-info.java应该长这样： module-info.java包含了所需要的javafx.controls与javafx.fxml这两个模块。 5 修改插件依赖 默认的javafx-maven-plugin版本应该为0.0.1： 整个去掉，修改为： &lt;plugin&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.0.4&lt;/version&gt; &lt;configuration&gt; &lt;stripDebug&gt;true&lt;/stripDebug&gt; &lt;compress&gt;2&lt;/compress&gt; &lt;noHeaderFiles&gt;true&lt;/noHeaderFiles&gt; &lt;noManPages&gt;true&lt;/noManPages&gt; &lt;launcher&gt;launcher&lt;/launcher&gt; &lt;jlinkImageName&gt;output&lt;/jlinkImageName&gt; &lt;jlinkZipName&gt;outputzip&lt;/jlinkZipName&gt; &lt;mainClass&gt;org.openjfx.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; 其中launcher为可执行文件名，jlinkImageName为Image输出目录名，jlinkZipName为zip文件名，mainClass为主类。 6 运行并打包 从右侧栏的Maven通过javafx插件运行并打包： 7 测试 根据修改插件时的目录，进入对应的target下的子目录直接运行即可： 项目目录/target/output/bin/launcher 注意这个是跨平台的，只需具备JDK11环境即可，发布只需要把zip文件发布。 8 demo github 码云 9 扩展阅读 这篇文章是OpenJFX的文档，主要介绍了： 通过三种方式（JFX+Maven+Gradle）运行Hello World 构建运行镜像（CLI+Maven+Gradle+自定义镜像） IntelliJ/NetBeans/Eclipse通过三种方式（IDE自身+Maven+Gradle）运行与打包JFX 链接戳这里。 ","link":"https://2293736867.github.io/post/idea-tong-guo-maven-da-bao-javafx-gong-cheng-openjfx11/"},{"title":"IDEA 配置文件位置","content":"1 IDEA 2020.1 以上 1.1 Win 语法： %APPDATA%\\JetBrains\\&lt;product&gt;&lt;version&gt; Win上的APPDATA默认位置如下： C:\\Users\\用户名\\AppData\\Roaming 例子： C:\\Users\\用户名\\AppData\\Roaming\\JetBrains\\IntelliJIdea2020.1 1.2 MacOS 语法： ~/Library/Application Support/JetBrains/&lt;product&gt;&lt;version&gt; 例子： ~/Library/Application Support/JetBrains/IntelliJIdea2020.1 1.3 Linux 语法： ~/.config/JetBrains/&lt;product&gt;&lt;version&gt; 例子： ~/.config/JetBrains/IntelliJIdea2020.1 2 IDEA 2019.3.x以下 2.1 Win 语法： %HOMEPATH%\\\\.&lt;product&gt;&lt;version&gt;\\config Win的HOMEPATH默认为： \\Users\\用户名 注意，无盘符。 例子： C:\\Users\\用户名\\.IntelliJIdea2019.3\\config 2.2 MacOS 语法： ~/Library/Preferences/&lt;product&gt;&lt;version&gt; 例子： ~/Library/Preferences/IntelliJIdea2019.3 2.3 Linux 语法： ~/.&lt;product&gt;&lt;version&gt;/config 例子： ~/.IntelliJIdea2019.3/config ","link":"https://2293736867.github.io/post/idea-pei-zhi-wen-jian-wei-zhi/"},{"title":"vim与系统剪贴版的交互","content":"1 概述 vim中的复制，删除，替换（d，r，s，x，y等）的内容都会被保存到默认的未命名的寄存器中，之后可以通过p进行粘贴，但是，这个寄存器不是系统的剪贴版，很多时候需要vim与系统剪贴版的交互，那么，具体怎么做呢？ 2 暴力解决 系统剪贴版复制vim时，新建一个文件，直接ctrl+v复制过去然后vim打开。 vim中的内容复制到系统剪贴版，使用cat+grep，在终端ctrl+c复制即可。 这是最简单也是比较通用的方法，不会受到什么vim不支持剪贴版之类的影响。 没错就是简单粗暴。 3 优雅的方案 当然上面的方法想必也不是您想要的，因此，这里介绍一种优雅一点的方法。 3.1 查看剪贴板支持 首先需要知道vim是否支持剪贴版： vim --version | grep clipboard 如果有 +clipboard 就表示支持，没有的话比如笔者这个就不支持，需要安装。 笔者的Manjaro，可以使用yay安装，不过提示过期了： 也可以选择安装gvim，另外，Debian系的可以安装vim-gtk： sudo apt install vim-gtk Redhat系的需要安装vim-X11以及vim-enhanced，然后加个别名： alias vi='vimx' alias vim='vimx' MacOS： sudo brew install vim 3.2 系统剪贴板复制到vim 很简单，使用 &quot;+p 或 &quot;*p 即可，vim提供了 + * 这两个寄存器与系统剪贴板进行交互，大多数系统上这两个系统一样，但在某些linux上可能不等价，以下是官方文档： + 对应ctrl+c，ctrl+v使用的系统剪贴板， * 对应的是鼠标选择的内容，可以使用中间粘贴。 当然高版本的vim还有一种很简单的解决办法：Shift+Insert能直接粘贴。 3.3 vim寄存器复制到系统剪贴板 在vim中使用y进行复制，但是是复制到默认的未命名寄存器的，想要复制到系统剪贴版只需要把y改为 &quot;+y 或 &quot;*y 即可。 3.4 偷懒方法 所谓的偷懒方法就是把默认的未命名寄存器与系统剪贴板关联上，使用 set clipboard=unnamed 即可。vim7.3.74以上的版本可以使用： set clipboard=unnamedplus 这样y，d，s，x等操作就和系统剪贴版关联上了。 4 寄存器相关知识 vim中的y，d，c，x，s等的操作的内容会复制到寄存器中，可以使用 :reg 查看寄存器的内容，使用 :help registers 查看帮助，另外，寄存器的常用操作包括： &quot;{register}y 复制到寄存器，默认register为未命名寄存器 &quot;{register}p 粘贴寄存器的内容 比如 &quot;a4yy &quot;+p vim中提供了多种多样的寄存器，具体来说可以分为10种共48个寄存器。 4.1 未命名寄存器 &quot;&quot; 也叫匿名寄存器，使用d，c，x等删除的字符会存放进匿名寄存器，换句话说，最近一次删除，修改，复制的内容都存放在这里，会覆盖。 4.2 编号寄存器 &quot;0 &quot;1 ... &quot;9 从0到9共10个，可以细分为复制专用寄存器与删除专用寄存器，因为 &quot;0 保存着最近一次y复制的内容，而 &quot;1 ... &quot;9 这9个寄存器保存着最近一次删除（d，c，s，x等）的内容。上一次删除的内容被存放在 &quot;1 上上次的被存放在 &quot;2 以此类推。 注意，只有整行的删除，和通过段落级别的移动指令的删除才会放进 &quot;1 另外当指定寄存器后，比如 &quot;ayy 不会写入到 &quot;0 中，但是 &quot;add 会写入到 &quot;1 中，也就是说，指定寄存器后复制内容不会写入0寄存器，但是删除内容会写入1寄存器。 4.3 小删除寄存器 &quot;- 不足一行的小删除会被放进去，包括s，d，c，x。与 &quot;0 类似，用户指定寄存器后不会被写入。 4.4 命名寄存器 &quot;a &quot;b ... 小写字母组成的26个寄存器，一般用来录制键盘宏，比如有如下内容： iostream string cmath 可以把位置定位到第一行，然后 qaI#include&lt;{ESC}A&gt;{ESC}jq 其中 {ESC} 表示按下ESC键，这样第一行就加上include了，同时把宏记录到了寄存器a，接下来，使用 2@a 即可在剩余两行加上include。 另外，小写对应的大写字母的寄存器用于追加内容，比如： &quot;Ayy 可以向 &quot;a 追加内容。 4.5 只读寄存器 &quot;. 上一次insert插入的内容 &quot;% 当前文件名，从vim的工作目录到该文件的路径 &quot;: 上次命令模式下键入的命令，使用@:执行上次命令， .只能进行一些简单的重复，一些复杂的命令比如替换，需要使用@: 共三个，只读。 4.6 交替文件寄存器 &quot;# 保存着当前窗口的交替文件。 交替文件是缓冲区（Buffer）上的一个文件，而缓冲区其实时vim中打开文件编辑时占用的那部分内存，编辑文件时，只是编辑缓冲区中的文件，当使用 :w 时，会把缓冲区的文件写入磁盘。 4.7 表达式寄存器 &quot;= 计算vim脚本的返回值，输入后会跳转到命令行，此时若输入3+2，回车并p，会粘贴5。 4.8 选择拖放寄存器 上面已经介绍了两个： &quot;+ &quot;* 还有一个是 &quot;~ 其中 &quot;+ &quot;* 在Mac与Windows上指的是系统剪贴板，在大多数X11，也就是带桌面环境的Linux发行版中是有区别的，上面也提到了一点： &quot;+ 系统剪贴板 &quot;* 鼠标选中区域，可以中键粘贴 有文本拖拽到vim时，被存放在 &quot;~ 中，默认会将其中的内容插入到光标位置。 4.9 黑洞寄存器 &quot;_ 所有进入到里面的内容会消失，通常用于脚本中。 4.10 搜索寄存器 &quot;/ 存储上一次搜索的关键词。可写，通过 :let @/ = &quot;123&quot; 下一次搜索可直接 / 不输入关键词回车即可。 注意不存在 &quot;? 寄存器。 5 参考 1.Vim 寄存器完全手册 2.Vim官方文档-1 3.Vim官方文档-2 4.知乎-如何将 Vim 剪贴板里面的东西粘贴到 Vim 之外的地方 ","link":"https://2293736867.github.io/post/vim-yu-xi-tong-jian-tie-ban-de-jiao-hu/"},{"title":"[ERROR]: gitstatus failed to initialize.","content":"1 问题描述 Manjaro升级后，zsh的主题p10k出现的问题。 Your git prompt may disappear or become slow. Run the following command to retry with extra diagnostics: GITSTATUS_ENABLE_LOGGING=1 gitstatus_start -s 1 -u 1 -d 1 -m -1 POWERLEVEL9K OUTPUT: [ERROR]: gitstatus failed to initialize. ...... 2 解决方法 来自gitstatus官方issue，戳这里，其实就是把p10k主题更新到最新版本就好了，用 pacman -Qi zsh-theme-powerlevel10k 查看版本，若不是最新版本，不要使用自带的软件包升级： pcaman -S zsh-theme-powerlevel10k 官方说这是旧的，不要使用： 因此先把配置文件备份： sudo cp ~/.p10k.zsh ~/Desktop 再卸载掉，然后clone安装： pacman -R zsh-theme-powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k # 或使用码云上的镜像 # git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k 在 ~/.zshrc 修改主题： ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 最后把配置文件覆盖： sudo cp ~/.p10k.zsh ~/.p10k.zsh.bak sudo cp ~/Desktop/.p10k.zsh ~/.p10k.zsh ","link":"https://2293736867.github.io/post/error-gitstatus-failed-to-initialize/"},{"title":"MySQL乱码问题","content":"1 概述 乱码问题，除了编码不对应应该没有别的原因了。可以先查看一下自己的编码，进行MySQL命令行，使用 status; 或 show variables like '%char%'; 查看编码是否对应。 2 解决方案 对于windows用户，修改MySQL安装目录下的my.ini文件，对于linux用户，若是编译安装的也是在安装目录下，包管理器安装的在 /etc/my.cnf # 或 /etc/mysql/my.cnf 下，在以下三个字段追加属性： [mysqld] character-set-server=utf8mb4 [mysql] default-character-set=utf8mb4 [client] default-character-set=utf8mb4 对于低版本的MySQL使用utf8就好了： [mysqld] character-set-server=utf8 [mysql] default-character-set=utf8 [client] default-character-set=utf8 MySQL中的utf8并不是真正的utf8，最长只有三个字节，区别可以戳这里或这里。 ","link":"https://2293736867.github.io/post/mysql-luan-ma-wen-ti/"},{"title":"Spring Boot超简单的测试类demo","content":"1 概述 Spring Boot结合Junit的简单测试类demo，流程是先引入依赖，接着编写测试类测试运行即可。 2 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3 编写测试类 在test/java下编写测试类，默认带一个叫项目名+Tests的测试类： import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @SpringBootTest @RunWith(SpringRunner.class) public class ApplicationTests { @Test public void contextLoads() { System.out.println(&quot;--------------------------------------------------&quot;); } } 4 测试 点击方法或类左边的按钮或者Ctrl+Shift+F10进行测试。 ","link":"https://2293736867.github.io/post/spring-boot-chao-jian-dan-de-ce-shi-lei-demo/"},{"title":"Manjaro 蓝牙连接问题","content":"1 问题描述 蓝牙不能连接，或者连接上了没有声音。 2 解决方案 首先确保相应软件包存在： sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa pulseaudio-bluetooth-a2dp-gdm-fix 然后启动蓝牙以及pulseaudio服务： systemctl enable bluetooth systemctl start bluetooth pulseaudio -k # 确保没有pulseaudio启动 pulseaudio --start # 启动pulseaudio服务 然后可以以图形化的方式或者命令行方式就可以连接蓝牙了，这里演示一下命令行方式： bluetoothctl #连接交互命令 power on #开启控制器电源，默认关闭 devices #获取要配对设备的MAC agent on #打开代理 pair MAC_ADDRESS #配对，输入MAC地址即可配对，建议使用Tab connect MAC_ADDRESS #连接，建议使用Tab 最后一步是指定蓝牙音频输出，也就是连接上了如果蓝牙没有声音可能是这一步没有设置，终端输入： pavucontrol ","link":"https://2293736867.github.io/post/manjaro-lan-ya-lian-jie-wen-ti/"},{"title":"IDEA使用JFX的相关问题","content":"1 问题概述 首先是javafx找不到对应的类： 其次是 class com.sun.javafx.fxml.FXMLLoaderHelper (in unnamed module @0x50f36265) cannot access class com.sun.javafx.util.Utils (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.util to unnamed module @0x50f36265 这种问题。 或者是 Error: JavaFX runtime components are missing, and are required to run this application 这样的问题。 2 解决方案 环境Manjaro+OpenJDK11，首先需要确保有OpenJFX，但是，不能直接使用pacman/yaourt安装： 虽然看上去没什么问题，OpenJDK使用的也是pacman安装的，想着JFX也可以这样，安装之后在 /usr/lib/jvm/java-11-openjdk/lib 下面确实有了JFX的文件，但是装了之后IDEA死活识别不出来，没办法，只能手动安装JFX。 手动安装的OpenJFX一加就马上识别出来了，所以，手动安装吧，也不难，戳这里下载所需要的版本，解压到对应的位置，然后在IDEA中的外部库添加其中的lib文件夹即可： 添加之后另一个问题是 class com.sun.javafx.fxml.FXMLLoaderHelper (in unnamed module @0x50f36265) cannot access class com.sun.javafx.util.Utils (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.util to unnamed module @0x50f36265 给出的最多的答案是修改VM Options： --module-path=JFX_LIB_PATH --add-modules=javafx.controls,javafx.fxml 其中JFX_LIB_PATH是JFX下的lib目录路径，但是不行，另一个方案是在源文件目录下添加module-info.java： module javafx.graphics{ exports com.sun.javafx.util } 也不行，直接报错，然后又搜索到了另一个解决办法，额外添加一个类似启动类的java文件，比如叫App.java： import javafx.application.Application; public class App { public static void main(String[] args) { Application.launch(Main.class,args); } } 然后修改IDEA的运行配置，把主类修改为App。 这样笔者的问题就解决了，可以正常运行JFX程序了。 3 其他问题 Caused by: java.lang.NullPointerException: Location is required. 其中一个可能的办法是： Parent root = FXMLLoader.load(getClass().getResource(&quot;xxx.fxml&quot;)); 改为： Parent root = FXMLLoader.load(getClass().getClassLoader().getResource(&quot;xxx.fxml&quot;)); 笔者试过，这个方法不行，另一个解决的方法是，修改pom.xml： &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.fxml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 其中include中的两个星号指的是fxml的文件夹的位置。 笔者试过这个方法可行，若fxml文件在源码根目录，可以修改为： &lt;include&gt;*.fxml&lt;/include&gt; ","link":"https://2293736867.github.io/post/idea-shi-yong-jfx-de-xiang-guan-wen-ti/"},{"title":"图片压缩脚本","content":"1 概述 使用convert命令做的小型图片压缩脚本，只需要一个参数指定压缩质量，会压缩当前文件夹的jpg/jpeg/png。 sh compress.sh 75 压缩完成后会显示最大最小以及平均压缩率。 2 主要流程 先判断当前文件夹是否存在图片，以及获取图片数量： picNums=`ls | grep -iE &quot;*.jpg|*.png|*.jpeg&quot; | grep -v &quot;_compress&quot; | wc -l` 接着计算原来文件大小，并分离文件名，得到主文件名与后缀名： originalSize=`ls -l $i | awk '{print $5}'` basename=`basename $i` filename=&quot;${basename%.*}&quot; suffix=&quot;${basename##*.}&quot; compressFileName=&quot;$filename._compress.$suffix&quot; 再判断主文件名是否含compress（已压缩过的会添加compress，保留原文件），接着计算比率： convert -quality $1 $i $compressFileName compressedSize=`ls -l $compressFileName | awk '{print $5}'` ratio=$(printf &quot;%.2f&quot; `echo &quot;scale=2;$compressedSize/$originalSize&quot;|bc`) if [[ `echo &quot;$ratio&lt;$minRatio&quot; | bc` == 1 ]] then minRatio=$ratio fi if [[ `echo &quot;$ratio&gt;$maxRatio&quot; | bc` == 1 ]] then maxRatio=$ratio fi totalRatio=`echo &quot;$totalRatio+$ratio&quot;|bc` 最后显示结果： 3 完整脚本 github. ","link":"https://2293736867.github.io/post/tu-pian-ya-suo-jiao-ben/"},{"title":"真 ● 禁秘技 ● 奥义 ● 终端美化","content":" 1 概述 2 环境 3 准备工作 3.1 zsh 3.2 oh-my-zsh 4 安装p9k 4.1 安装字体 4.2 安装p9k 5 p9k配置 5.1 开启/关闭提示段 5.1.1 如何使用 5.1.2 开启/关闭整个提示段 5.1.3 系统相关 5.1.4 语言相关 5.1.5 云相关 5.1.6 其他 5.2 位置 5.3 颜色 5.4 图标 5.5 其他 5.5.1 粘合 5.5.2 添加新行 5.5.3 更多 6 p9k与p10k 6.1 两者关系 6.2 提示延迟 6.3 加载速度 6.4 其他 7 安装p10k 7.1 安装字体 7.2 安装p10k 8 p10k配置 8.1 基本配置 8.2 自定义配置 9 配置文件 9.1 p9k 9.2 p10k 1 概述 作为一个程序员，可以没钱，没车，没房，没老婆，没女朋友。 但是，一定要有一个漂亮骚气的终端。 没错，大骚特骚。 说什么大实话。 先来看看原生的终端： 真漂亮啊。 再看看美化过的： 这才叫终端嘛。 美化过的就是不一样。 如果您也想要这样的终端，那这篇文章要仔细看，同时顺手点个赞。 文章讲述了如何使用zsh+oh-my-zsh，配合主题Powerlevel9k/Powerlevel10k（以下简称p9k/p10k）进行终端美化的过程，不废话了，进入正题。 2 环境 笔者环境： Manjaro 20.0 Xfce 自带的Xfce terminal 其他linux基本适用，安装zsh+oh-my-zsh即可，mac用户可以通过homebrew安装zsh+p9k/p10k，至于win用户，自行搜索吧。 3 准备工作 安装zsh+oh-my-zsh。 3.1 zsh Manjaro/Arch： sudo pacman -S zsh Debian系： sudo apt install zsh RedHat系： sudo yum install -y zsh 其他可以来到官方github安装，戳这里。 设为默认shell： chsh -s $(which zsh) 再把原来的别名复制到 ~/.zshrc 3.2 oh-my-zsh 通过脚本安装即可，使用curl或wget： sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; #或 sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 失败的话可以clone仓库安装，戳这里。 4 安装p9k 4.1 安装字体 推荐使用Nerd-Fonts字体，能显示最全的图标。Nerd-Fonts包含了大量的“图标字体”，如下图（来源官方github）： Manjaro/Arch用户： sudo pacman -S ttf-nerd-fonts 其他用户可以戳这里clone下载安装。 p9k默认使用的是Powerline Font字体，Manjaro/Arch用户： sudo pacman -S powerline-fonts 其他可以戳这里clone下来安装。 除此之外官方还建议使用Awesome-Powerline Fonts字体或一些程序员字体（如Source Code Pro等），但是图标可能会显示不全，建议还是使用Nerd-Fonts字体。 安装字体后，在设置p9k主题前，也就是在 ~/.zshrc 设置 ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 之前，设置模式： POWERLEVEL9K_MODE='nerdfont-complete' 如果用的是Powerline-Fonts可以不用设置，如果用的是Awesome-fonts，设置： POWERLEVEL9K_MODE='awesome-fontconfig' #或 POWERLEVEL9K_MODE='awesome-patched' 4.2 安装p9k Manjaro/Arch： sudo pacman -S zsh-theme-powerlevel9k echo 'source /usr/share/zsh-theme-powerlevel9k/powerlevel9k.zsh-theme' &gt;&gt; ~/.zshrc 其他： git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k # 修改~/.zshrc ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 5 p9k配置 p9k配置的主要部分就是自定义提示段（Prompt Segments），包括开启/关闭，位置，颜色，图标等。 5.1 开启/关闭提示段 5.1.1 如何使用 具体请看5.2 位置。 5.1.2 开启/关闭整个提示段 关闭左边/右边整个提示段： #左 POWERLEVEL9K_DISABLE_PROMPT=true #右 POWERLEVEL9K_DISABLE_RPROMPT=true 5.1.3 系统相关 名字 作用 background_jobs 后台任务 battery 电池状态 context 用户名+主机名，基于USER环境变量以及SSH状态 date 日期 dir 当前工作目录 dir_writable 目录可写状态，可写时为空，不可写时出现一个锁 disk_usage 当前分区的磁盘使用百分比 history 历史命令的记录数量 host 主机名 ip 内网ip vpn_ip vpn ip public_ip 公网ip load 机器的平均负载 os_icon 操作系统图标，支持的linux有Alpine，AOSC，Arch，CentOS，CoreOS，Debian，Devuan，Elementary，Fedora，Gentoo，Mageia，Manjaro，Mint，NixOS，OpenSUSE，Sabayon，Slackware，Ubuntu ram 内存可用大小 root_indicator 拥有root权限的提示符 status 前一条命令的结果状态码 swap 交换分区使用情况 time 时间 user 当前用户 vi_mode vi模式 ssh ssh状态 5.1.4 语言相关 名字 作用 go_version Go版本 node_version Node.js安装的版本 nodeenv 使用nodeenv显示Node版本 nvm NVM显示Node版本 php_version php版本 laravel_version Laravel版本 symfony2_test2 Symfony2测试类与代码类的比率 symfony2_version Symfony2版本 virtualenv Python VirtualEnv环境 anaconda Anaconda环境 pyenv pyenv version显示的第一个单词，但是如果是system将不会显示 chruby 使用chruby的Ruby环境 rbenv 使用rbenv的Ruby环境 rspec_stats RSpec中测试类与代码类的比率 rvm 使用GEM_HOME环境变量或者MY_RUBY_HOME环境变量显示的Ruby信息 rust_version Rust版本 swift_version Swift版本 java_version Java版本 openfoam OpenFOAM库版本 5.1.5 云相关 名字 作用 aws 当前的AWS配置 aws_eb_env 当前的Elastic Beanstalk环境 docker_machine 当前的Docker Machine docker_machine kubectl配置 dropbox Dropbox目录以及使用dropbox-cli的同步状态 5.1.6 其他 名字 作用 vcs git/hg仓库的信息 command_execution_time 命令执行时间 todo todo.txt文件中任务数量 detect_virt 使用systemd进行虚拟化检测 newline 另起一行 custom_command 自定义命令，需要以custom_开头 比如，利用 nmcli device wifi 显示wifi速率，首先添加一个函数： wifi_rate(){ local rate=$(nmcli device wifi | grep -E &quot;\\*&quot; | awk '{print $6}') #awk后面的数字可能每个人不同 echo &quot;\\uf0e7 $rate Mbit/s&quot; } 其次添加自定义提示段（以custom开头）： POWERLEVEL9K_CUSTOM_WIFI_RATE=&quot;wifi_rate&quot; 最后在 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS #或 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 加上即可，演示效果： 需要的话，可以根据信号状态定义不同的颜色： 完整配置文件如下，加上了wifi名字： set_wifi(){ wifi_signal=$(nmcli device wifi | grep -E &quot;\\*&quot; | awk '{print $8}') POWERLEVEL9K_CUSTOM_WIFI_NAME_FOREGROUND=&quot;black&quot; POWERLEVEL9K_CUSTOM_WIFI_RATE_FOREGROUND=&quot;black&quot; POWERLEVEL9K_CUSTOM_WIFI_BARS_AND_SIGNAL_FOREGROUND=&quot;black&quot; POWERLEVEL9K_CUSTOM_WIFI_NAME_BACKGROUND=&quot;green&quot; POWERLEVEL9K_CUSTOM_WIFI_RATE_BACKGROUND=&quot;green&quot; POWERLEVEL9K_CUSTOM_WIFI_BARS_AND_SIGNAL_BACKGROUND=&quot;green&quot; if [[ $wifi_signal -lt 50 ]] ; then POWERLEVEL9K_CUSTOM_WIFI_NAME_BACKGROUND=&quot;red&quot; POWERLEVEL9K_CUSTOM_WIFI_RATE_BACKGROUND=&quot;red&quot; POWERLEVEL9K_CUSTOM_WIFI_BARS_AND_SIGNAL_BACKGROUND=&quot;red&quot; elif [[ $wifi_signal -lt 75 ]] ; then POWERLEVEL9K_CUSTOM_WIFI_NAME_BACKGROUND=&quot;yellow&quot; POWERLEVEL9K_CUSTOM_WIFI_RATE_BACKGROUND=&quot;yellow&quot; POWERLEVEL9K_CUSTOM_WIFI_BARS_AND_SIGNAL_BACKGROUND=&quot;yellow&quot; fi } set_wifi wifi_name(){ local name=$(nmcli device wifi | grep -E &quot;\\*&quot; | awk '{print $3}') echo &quot;\\uf502 $name&quot; } wifi_rate(){ local rate=$(nmcli device wifi | grep -E &quot;\\*&quot; | awk '{print $6}') echo &quot;\\uf0e7 $rate Mbit/s&quot; } wifi_bars_and_signal(){ local bars=$(nmcli device wifi | grep -E &quot;\\*&quot; | awk '{print $9}') echo &quot;$bars $wifi_signal %%&quot; } POWERLEVEL9K_CUSTOM_WIFI_NAME=&quot;wifi_name&quot; POWERLEVEL9K_CUSTOM_WIFI_RATE=&quot;wifi_rate&quot; POWERLEVEL9K_CUSTOM_WIFI_BARS_AND_SIGNAL=&quot;wifi_bars_and_signal&quot; POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=( custom_wifi_name custom_wifi_rate custom_wifi_bars_and_signal ) 5.2 位置 可以加上 POWERLEVEL9K_PROMPT_ON_NEWLINE=true 使输入的命令显示在新的一行。 POWERLEVEL9K_RPROMPT_ON_NEWLINE=true 让右边的提示段在新的一行。 在 POWERLEVEL9K_LEFT_PROMPT_ELEMETS #或 POWERLEVEL9K_RIGHT_PROMPT_ELEMETS 中，可以配合newline以及5.1中的提示段自定义位置，比如，笔者的： POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=( os_icon date time newline custom_wifi_rate custom_wifi_bars_and_signal newline background_jobs ram load swap disk_usage newline php_version java_version node_version newline dir dir_writable vcs ) 当然这不是完整的配置文件，还修改了颜色，完整的配置文件在文末给出。 5.3 颜色 修改提示段的前景/背景，直接修改即可，一般的格式为： POWERLEVEL9K_NAME_STATUS_BACKGROUND= POWERLEVEL9K_NAME_STATUS_FOREGROUND= 其中NAME为5.1中对应的提示段，比如可以修改： POWERLEVEL9K_OS_ICON_FOREGROUND=&quot;green&quot; POWERLEVEL9K_PHP_VERSION_BACKGROUND=&quot;010&quot; 颜色可以使用一些常见的red/green等等，也可以使用序号，可以查看这张图： 也可以使用如下命令显示颜色： for i in {0..255}; do print -Pn &quot;%K{$i} %k%F{$i}${(l:3::0:)i}%f &quot; ${${(M)$((i%6)):#3}:+$'\\n'}; done STATUS不是每个提示段都有的，列表如下： 提示段 状态 battery LOW,CHARGING,CHAGED,DISCONNECTED context DEFAULT,ROOT,SUDO,REMOTE,REMOTE_SUDO dir HOME,HOME_SUBFOLDER,DEFAULT,ETC,NOT_WRITABLE dir_writable FORBIDDEN disk_usage NORMAL,WARNING,CRITICAL host LOCAL,REMOTE load CRITICAL,WARNING,NORMAL rspec_stats STATS_GOOD,STATS_AVG,STATS_BAD symfony2_test TESTS_GOOD,TESTS_AVG,TESTS_BAD user DEFAULT,SUDO,ROOT vcs CLEAN,UNTRACKED,MODIFIED vi_mode NORMAL,INSERT,VISUAL 大部分都可以很容易理解，这里以最简单的为例： POWERLEVEL9K_DIR_DEFAULT_BACKGROUND='166' POWERLEVEL9K_DIR_DEFAULT_FOREGROUND='000' POWERLEVEL9K_DIR_ETC_BACKGROUND='226' POWERLEVEL9K_DIR_ETC_FOREGROUND='000' POWERLEVEL9K_DIR_HOME_BACKGROUND='044' POWERLEVEL9K_DIR_HOME_FOREGROUND='000' 设置home目录，etc目录以及默认目录的前景与背景。 5.4 图标 使用 get_icon_names 可以查看内置的图标。 注意这个和字体有关，如果使用默认的PowerlineFonts或者使用AwesomeFonts可能不会完整显示所有图标，请使用Nerd-Fonts。 戳这里查看Nerd-fonts的部分图标，戳这里搜索所有的图标。 官方的例子是自定义vcs的图标： POWERLEVEL9K_VCS_BRANCH_ICON=$'\\uF126' F126可以通过上面的网站搜索得到，是一个分支的图标： 其他git相关图标： 名字 图标字段 Github VCS_GIT_GITHUB_ICON BitBucket VCS_GIT_BITBUCKET_ICON GitLab VCS_GIT_GITLAB_ICON 其他 VCS_GIT_ICON 另外还可以修改提示段前的图标： POWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=&quot;↱&quot; POWERLEVEL9K_MULTILINE_LAST_PROMPT_PREFIX=&quot;↳ &quot; POWERLEVEL9K_MULTILINE_NEWLINE_PROMPT_PREFIX=&quot;xxx&quot; 还可以根据get_icon_names修改默认图标，比如，修改 POWERLEVEL9K_HOME_SUB_ICON=$'\\uf74b' 但是直接改icon的话图标会显示得很小，可以在函数中像上面的wifi一样使用echo自定义。 5.5 其他 5.5.1 粘合 可以添加joined使提示段粘合在一起： POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(history status_joined) 修改前： 修改后： 5.5.2 添加新行 POWERLEVEL9K_PROMPT_ADD_NEWLINE=true 每次输入命令后添加一行空行，可以使用 POWERLEVEL9K_PROMPT_ADD_NEWLINE_COUNT 控制，默认为1。 5.5.3 更多 更多请移步官方文档，太多了，比如电池，自定义充电中或充完电或低电量状态的颜色以及显示状态： 好了，p9k就到这里，下面看看p10k。 6 p9k与p10k 6.1 两者关系 p10k是2019年3月从p9k的仓库fork而来的。p9k已经是一个拥有大量用户的成熟的工程。p10k被分离出来，以更快的速度迭代更新，添加新特性以及改进性能。 p9k与p10k是独立的工程，只能安装其中一个，但是p10k会识别p9k的所有参数。 目前p9k已经不再维护更新，推荐使用p10k。 6.2 提示延迟 p9k已有几个issue反映很慢： 具体内容请查看p9k官方issue，p10k改进了性能，p10k github有一个演示视频，展示了p10k的速度，在Intel i9-7900X+Ubuntu 18.04上，测试提示延迟如下： （来源官方测试） 相对来说，p9k具有可接受的延迟，如果只是需要当前目录而不需要截断或缩短，p9k可以17ms内渲染完成，p10k可以将其提高30倍的渲染速度，但实际上并不需要，因为延迟变得明显的阀值为50ms。官方建议必须小心使用p9k的配置，因为很容易使得提示变慢，但是p10k在任何配置中几乎都是即时的，可以保持远低于50ms。 另外笔者的系统上也测试过，p9k确实要比p10k慢，添加了很多设置后，p9k在终端中连续按Enter，松手之后还在提示，甚至一个普通的ls也有明显的延迟，但是p10k没有这样的问题，很流畅。 6.3 加载速度 p10k比p9k能更快加载，前提是，zsh版本5.4+。 官方建议使用下面的命令测试： time (repeat 1000 zsh -dfis &lt;&lt;&lt; 'source ~/powerlevel10k/powerlevel10k.zsh-theme') 但是笔者没有这个文件，怀疑是位置给错了，修改如下： time (repeat 1000 zsh -dfis &lt;&lt;&lt; 'source /usr/share/zsh-theme-powerlevel10k/powerlevel10k/powerlevel10k.zsh-theme') 笔者的系统上耗时如下： 换了p9k后： time (repeat 1000 zsh -dfis &lt;&lt;&lt; 'source /usr/share/zsh-theme-powerlevel9k/powerlevel9k.zsh-theme') 耗时如下： 不过好像没快多少的样子，可能是zsh版本的问题，装的是目前最新的5.8，可能老一点的版本区别会明显一点。 官方的测试是p10k用了29s，比相同环境下的p9k master分支大约快6倍，比p9k next分支快17倍。笔者认为仅供参考吧，用p10k就对了，毕竟比p9k快。 6.4 其他 p10k默认只开启vcs中git后端的支持，如果需要svn/hg，需要添加到POWERLEVEL9K_VCS_BACKENDS。但是p10k还没有针对svn/hg优化，所以添加的话会让提示变慢 p10k不支持POWERLEVEL9K_VCS_SHOW_SUBMODULE_DIRTY=true p10k会兼容p9k的所有选项，因此，相同配置下如果p9k与p10k看到的图标不一样，可能是设置了POWERLEVEL9K_MODE的原因，请去掉POWERLEVEL9K_MODE p9k不识别ZLE_RPROMPT_INDENT，因此p10相比起p9k会有额外的空格。如果不想要可以设置ZLE_RPROMPT_INDENT=0 p9k在图标附近有不一致的空格，在p10k已经不存在了，不过可以设置POWERLEVEL9K_LEGACY_ICON_SPACING=true显示与p9k中一样的空格 p10k修正了p9k的许多bugs，除了修复空格问题等，最主要是极大地提高了速度 7 安装p10k 7.1 安装字体 Manjaro/Arch用户： sudo pacman -S nerd-fonts-meslo-lg 或手动安装： MesloLGS NF Regular.ttf MesloLGS NF Bold.ttf MesloLGS NF Italic.ttf MesloLGS NF Bold Italic.ttf 7.2 安装p10k Manjaro/Arch： sudo pacman -S zsh-theme-powerlevel10k #如果先前安装了p9k这一步会提示冲突 echo 'source /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme' &gt;&gt;! ~/.zshrc 其他： git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' &gt;&gt;! ~/.zshrc 如果打开zsh时提示找不到powerlevel9k.zsh-theme这个文件，请在zshrc中把 #~/.zshrc source /usr/share/zsh-theme-powerlevel9k/powerlevel9k.zsh-theme 这一行删去。 8 p10k配置 8.1 基本配置 终端输入 p10k configure 就会出现图形化配置向导。首先会问几个问题： 会问三个图标：钻石，锁与Debian，应该是测试有没有安装对应的字体，然后会问图标是否会重叠，接着有四种风格可以选择： 看个人了，笔者选的3 ，接着可以选择： 编码（Unicode/ASCII，一般选Unicode） 时间（不显示/12小时制/24小时制） 分隔符（三角/垂直/斜线/圆角） 提示段头部（三角/渐隐/斜线/垂直） 提示段尾部（垂直/渐隐/三角/倾斜/圆角） 高度（一行/两行） 左右提示段连接方式（无/点状连接/实线连接） 提示段旁的命令提示符（无/左/右/左+右） 颜色（最亮/亮/暗/最暗） 空格（稀疏/紧密） 图标（少/多） 流（简洁/流畅，针对时间等，流畅模式会多一个at与时钟的图标） 临时提示（开启/关闭） 即时提示模式（关闭/安静模式/啰嗦模式，关闭是已经尝试过即时提示模式，但是不兼容zsh配置，需要关闭，安静模式是zsh初始化时不会打印警告信息，啰嗦模式会在zsh初始化时打印警告信息） 覆盖p10k配置文件（如果p10k配置文件已存在，会提示是否覆盖，不覆盖的话也就是相当于此次配置无效，需要覆盖才能生效），覆盖之前原文件会备份 简单配置的效果： 确实比p9k流畅了很多。 8.2 自定义配置 自定义配置与p9k类似，配置文件位置为： ~/.p10k.zsh 由于大部分都是p9k的配置，这里就不重复了，图标，位置大体类似，颜色可以使用如下命令获取： for i in {0..255}; do print -Pn &quot;%K{$i} %k%F{$i}${(l:3::0:)i}%f &quot; ${${(M)$((i%6)):#3}:+$'\\n'}; done 使用时直接加上数字即可。 如果用的是彩虹风格，目录可能在提示段中很难看到，可以直接修改配置文件的颜色，或修改终端全局配置的颜色。 剩下的就个人慢慢摸索了，改颜色，改图标，改位置等等。 最后贴一张配置完成的图： 9 配置文件 笔者的配置文件，仅供参考。 9.1 p9k github 码云 9.2 p10k github 码云 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/zhen-jin-mi-ji-ao-yi-zhong-duan-mei-hua/"},{"title":"unzip解压中文乱码","content":"1 问题描述 直接 unzip xxx.zip 乱码，肯定是编码问题了不用问。但是unzip没有指定编码的选项： 网上的解决方案如下： unzip -O GBK/GB18030CP936 xx.zip 但是没有-O选项啊。 2 解决办法 解决办法是安装unzip-iconv，笔者系统为manjaro，直接安装会提示会与unzip冲突： unzip-iconv是一个补丁，但是好像没被官方接纳，比如Ubuntu下的unzip是带-O的，Archlinux与CentOS下默认没带，安装unzip-iconv即可，也可以在保留unzip的基础上打上unzip-iconv补丁包，参照这里。 安装后，可以先指定编码列出看看： unzip -O gbk -l xxx.zip 这里编码可以用小写，有一个小的bug是，先写-O选项的话，后面的压缩包文件名补全不了，目前笔者还没有找到好的解决办法（不知道你们的会不会这样，反正笔者的补全不了），所以，先-l补全写上文件，再移动到前面加上-O选项。 列出文件没问题的话，解压就行了： unzip -O gbk -d folder xxx.zip -d指定解压目录，如果没加目录的话，直接unzip会把所有文件解压到当前目录。 ","link":"https://2293736867.github.io/post/unzip-jie-ya-zhong-wen-luan-ma/"},{"title":"Manjaro配置攻略","content":" 2020.06.23 更新 1 源 2 输入法 3 AUR助手 4 常用软件 4.1 chrome/chromium 4.2 网易云音乐 4.3 git 4.4 vim 4.5 wps 4.6 VScode 4.7 qq 4.8 微信 4.9 迅雷 4.10 深度截图 4.11 JetBrains 4.12 web服务器 5 deepin-wine常见问题处理 5.1 无法切换中文输入法 5.2 字体发虚 5.3 阴影边框 6 终端美化 6.1 安装zsh 6.2 安装oh-my-zsh 6.3 字体 6.4 主题 6.5 替换bash 6.6 别名 6.7 进一步修改 6.8 终极美化 7 常用别名与脚本 7.1 常用别名 7.2 cd脚本 7.3 rm脚本 2020.06.23 更新 1 源 排列中国镜像的速度，选择一个。 sudo pacman-mirrors -i -c China -m rank 接着更新并导入GPG key： sudo pacman -S archlinuxcn-keyring &amp;&amp; sudo pacman -Syy 2 输入法 sudo pacman -S fcitx-im fcitx-configtool # 输入法看个人，这里装的是谷歌拼音 sudo pacman -S fcitx-googlepinyin #搜狗 #sudo pacman -S fcitx-sogoupinyin #rime #sudo pacman -S fctix-rime #更多输入法使用 #pacman -Ss fcitx #查看 安装完后在~/.profile加上： export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot; 3 AUR助手 AUR是Arch User Repository的缩写，是Arch/Manjaro用户的社区驱动存储库。AUR助手有很多，这里推荐yay。yay是用Go编写的Arch Linux AUR帮助工具，可以帮助以自动方式从PKGBUILD安装软件包。 sudo pacman -S yay 4 常用软件 4.1 chrome/chromium sudo pacman -S google-chrome sudo pacman -S chromium 4.2 网易云音乐 sudo pacman -S netease-cloud-music 4.3 git sudo pacman -S git 4.4 vim 默认只有vi，没带vim。 sudo pacman -S vim 4.5 wps sudo pacman -S wps-office 4.6 VScode sudo pacman -S visual-studio-code 4.7 qq qq可以选择的版本比较多，可以选择wine版的qq，deepinwine版的qq，deepinwine版的tim。这里推荐使用deepinwine的qq或者tim。 直接使用yay安装即可： yay -S deepin-wine-qq yay -S deepin-wine-tim 若直接安装失败可以使用本地打包安装： git clone https://github.com/countstarlight/deepin-wine-tim-arch.git cd deepin-wine-tim-arch makepkg -si git clone https://github.com/countstarlight/deepin-wine-qq-arch.git cd deepin-wine-qq-arch makepkg -si 4.8 微信 微信可以使用electronic-wechat或者deepinwine-wechat，推荐后者。 sudo pacman -S eletronic-wechat yay -S deepin-wine-wechat 若签名出现问题可以加上： yay -S deepin-wine-wechat --mflags --skipinteg 若deepin-wine-wechat安装失败可以从本地打包安装 git clone https://github.com/countstarlight/deepin-wine-wechat-arch.git cd deepin-wine-wechat-arch makepkg -si 但目前从2.8.0.106-1以上的版本开始大图片发送失败，没办法发送压缩包，推荐使用2.7.1.88-1版本，并且关闭自动更新，戳这里下载，然后安装： sudo pacman -U deepin-wine-wechat-2.7.1.88-1-x86_64.pkg.tar.xz 4.9 迅雷 yay deepin-wine-thunderspeed 若失败的话可以从本地打包安装 git clone https://github.com/countstarlight/deepin-wine-thunderspeed-arch.git cd deepin-wine-thunderspeed-arch makepkg -si 4.10 深度截图 sudo pacman -S deepin-screenshot 4.11 JetBrains 对于这种大型的IDE笔者喜欢从官网下载，以PyCharm为例，下载解压移动： tar -zxvf pycharm-professional-2020.1.1.tar.gz sudo mv pycharm-2020.1.1/* /usr/local/pycharm 然后添加.desktop文件： sudo vim /usr/share/applications/pycharm.desktop 加上 [Desktop Entry] Name=PyCharm Type=Application Exec=/usr/local/pycharm/bin/pycharm.sh Icon=/usr/local/pycharm/bin/pycharm.svg 4.12 web服务器 sudo pacman -S tomcat9 apache nginx 5 deepin-wine常见问题处理 5.1 无法切换中文输入法 在 ~/.xinitrc 加上 export XMODIFIERS=@im=fcitx export QT_IM_MODULE=fcitx export GTK_IM_MODULE=fcitx 然后在对应的run.sh加上： env locale=zh_CN export XIM=fcitx export XMODIFIERS=&quot;@im=fcitx&quot; export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx 这里的run.sh位于 /opt/deepinwine/apps/Deepin-xxx 下。 # QQ /opt/deepinwine/apps/Deepin-QQ/run.sh # WeChat /opt/deepinwine/apps/Deepin-WeChat/run.sh # Tim /opt/deepinwine/apps/Deepin-Tim/run.sh 5.2 字体发虚 env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-QQ&quot; winecfg env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-WeChat&quot; winecfg env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-Tim&quot; winecfg 执行其中一个命令，然后修改dpi： 5.3 阴影边框 微信运行后，切换到其他窗口会有一个阴影边框。 对于v2.8.0.133-2之后的版本应该不会出现这个问题，因为自带了shadow.exe，但是不能传输文件与大图片（issue中已有反映，这是一个bug，建议使用2.7版本），对于之前的版本，参照这里的办法，把shadows.exe复制到对应目录： git clone https://github.com/countstarlight/deepin-wine-wechat-arch.git sudo cp deepin-wine-wechat-arch-master/shadow.exe ~/.deepinwine/Deepin-WeChat/drive_c/ 然后修改run.sh： #修改/opt/deepinwine/apps/Deepin-WeChat/run.sh，可以先备份一下 #找到CallApp()，在env WINEDLLOVERRIDS这一行的末尾加上 &amp; #同时在fi后面加上 if [[ -z &quot;$(ps -e | grep -o 'shadow.exe')&quot; ]]; then env WINEPREFIX=&quot;$WINEPREFIX&quot; WINEDEBUG=-msvcrt $WINE_CMD &quot;c:\\\\shadow.exe&quot; &amp; fi 6 终端美化 终端美化当然是用zsh+oh-my-zsh。 6.1 安装zsh 默认安装了，没安装的话： sudo pacman -S zsh 6.2 安装oh-my-zsh sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 6.3 字体 需要安装Powerline字体，不难，clone一下，直接安装就好了。 git clone https://github.com/powerline/fonts.git cd fonts ./install.sh 6.4 主题 oh-my-zsh的配置文件如下： ~/.oh-my-zsh 其中的themes下有不少主题，具体效果可以来这里查看。 这里推荐使用agnoster与powerlevel9k主题（当然还有一个powerlevel10k主题，感兴趣可以自行github），agnoster已自带，powerlevel9k需要安装： sudo pacman -S zsh-theme-powerlevel9k git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 然后修改配置文件： #修改~/.zshrc ZSH_THEME=&quot;agnoster&quot; ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 6.5 替换bash zsh替换默认bash： chsh -s `which zsh` 6.6 别名 原来bash的别名在zsh需要重新配置一下，直接在 ～/.zshrc 加上原来的alias即可。 6.7 进一步修改 笔者用的主题是agnoster，直接使用的话效果不怎么样： 忍不住了，直接去修改配置文件（themes/agnoster-zsh.thene），agnoster的核心函数是这个： 其中prompt_context是用户名与主机名的部分，注释后就不会显示用户名与主机名了，其他也类似，比如prompt_dir是当前工作目录，定位后： prompt_segment接受两个参数，一个背景，一个前景，其中blue就是上图的那个不怎么好看的深蓝色，CURRENT_FG是前景色，这里是黑色，也就是文字颜色。 经过一番摸索 ，发现能支持十六进制RGB，真香： 于是就没有深蓝色的背景啦： 终端为XFCE Terminal，在系统设置中根据个人需要修改背景壁纸，修改文字颜色等： 整体效果： 6.8 终极美化 终极美化使用Powerlevel9k/Powerlevel10k，步骤倒是不多只是配置多，需要耐心仔细去调，具体可以看笔者另一篇文章，链接戳这里。 7 常用别名与脚本 7.1 常用别名 仅供参考，一些常用别名： #.bashrc加上 alias m='sudo mkdir -p' #新建文件夹 alias d='cd ~/Desktop &amp;&amp; ls' alias rrr='shutdown -r now' alias sss='shutdown now' 7.2 cd脚本 使用c代替常用的cd，同时执行完之后自动ls一次： if [ $# -eq 0 ] ; then cd .. &amp;&amp; ls else cd $1 &amp;&amp; ls fi 如果只是输入一个c，回到上层目录并ls，如果带目录参数，切换到对应目录并且ls。需要加上别名使用： alias c='source ~/.cd.sh' #脚本文件名为.cd.sh，位于～下 7.3 rm脚本 使用r代替rm，无需加上rf参数，使用回收站机制，也就是直接移动。 for i in $*; do mv $i /home/YOUR_USER_NAME/.Trash/`basename $i`_`date +%Y_%m_%d__%H_%M_%S` done 移动的文件名后面加上了时间，回收站位置为用户目录下的.Trash，同时加上别名： alias r='sudo sh ~/.rm.sh' # 脚本名字为.rm.sh，用户目录下 alias trash='cd ~/.Trash &amp;&amp; ls' ","link":"https://2293736867.github.io/post/manjaro-pei-zhi-gong-lue/"},{"title":"Manjaro 手动调节屏幕亮度","content":"1 问题描述 manjaro版本20.0，桌面XFCE，设置之类的地方没有屏幕亮度调节的功能。 2 解决方案 解决方案来自arch wiki。 亮度由ACPI内核模块控制，这个模块的接口在以下位置： /sys/class/backlight 笔者的设备上显示： 然后使用root进入这个文件夹，其中max_brightness表示亮度的最大值，笔者的设备显示为120000： 想要修改亮度的话直接修改brightness即可： echo xxxxx &gt; brightness 其中xxxxx为亮度数值，注意一定要root用户。 3 使用脚本加别名 可以使用一个简单的脚本来完成： #!/usr/bin/bash sudo su&lt;&lt;EOF echo $1 &gt; /sys/class/backlight/intel_backlight/brightness EOF 其中intel_backlight请对应修改。 假设文件名为a.sh，放在用户目录下，加上别名： alias changeBrightness='sh ~/a.sh ' 加一个亮度参数，再输入用户密码就可以修改了： ","link":"https://2293736867.github.io/post/manjaro-shou-dong-diao-jie-ping-mu-liang-du/"},{"title":"Manjaro找不到默认键盘布局","content":"1 问题描述 manjaro安装fcitx后，没有默认的键盘布局，不是这样： 而是： 2 解决方案 解决方案在启动fcitx时就已经有提示了： 缺少了libjson-c这个库，直接使用pacman搜索安装不行： 因为只有32位的，笔者manjaro版本为20.0，没办法使用32位的库，因此需要进行编译安装。 json-c，Github戳这里。 git clone https://github.com/json-c/json-c.git mkdir json-c-build cd json-c-build cmake ../json-c # 可以使用cmake .. -LH 查看参数，建议默认即可 make -j n #n为cpu核数 sudo make install 这样就能解决缺失默认键盘布局的问题了。 ","link":"https://2293736867.github.io/post/manjaro-zhao-bu-dao-mo-ren-jian-pan-bu-ju/"},{"title":"源码编译安装MySQL8.0.20","content":" 1 概述 2 源码编译安装的相关知识 2.1 make与configure 2.2 Tarball文件 2.3 源码编译安装相关组件 2.3.1 编译器 2.3.2 make+autoconfig 2.3.3 函数库 2.4 静态库与动态库 2.4.1 静态库 2.4.2 动态库 2.5 编译安装的一般步骤 2.6 编译安装前的心理准备 3 安装MySQL 3.1 安装依赖 3.2 包管理器安装 3.2 编译安装 3.2.1 安装cmake 3.2.2 安装make 3.2.3 安装gcc 3.2.4 安装openssl 3.2.5 下载boost 3.2.6 安装ncurses 3.2.7 安装bison 3.2.8 安装git 3.2.9 后续处理 3.3 下载MySQL社区版 3.4 生成Makefile 3.5 编译与安装 3.6 后续配置 3.6.1 用户组与用户 3.6.2 配置文件 3.7 初始化 3.8 修改密码 3.9 测试 3.10 收尾工作 3.10.1 别名 3.10.2 安装Mycli 4 参考 1 概述 本文章主要讲述了如何从源码编译安装MySQL社区版8.0.20，首先会介绍一些编译安装的相关知识，然后开始编译安装 2 源码编译安装的相关知识 2.1 make与configure make是一个编译的命令，会在当前的目录下寻找Makefile这个文件，Makefile文件记录了源代码如何编译的详细信息。而configure是由软件开发商编写的一个检测程序检测用户的开发环境，检测完毕后生成Makefile文件。通常，configure会检测如下内容： 是否具有合适的编译器 是否具有所需函数库以及其他依赖 是否兼容本系统 是否存在内核头文件 2.2 Tarball文件 Tarball文件其实就是将源代码以tar打后压缩的文件。通常使用gzip进行压缩，一般扩展名为.tar.gz或.tgz，不过由于bzip2以及xz等技术压缩效果比gzip好，因此文件名也会变成扩展名也会变成.tar.bz2或.tar.xz之类的。通常一个Tarball文件有： 源码 检测文件（configure/config） 说明（README/INSTALL） 2.3 源码编译安装相关组件 2.3.1 编译器 需要有编译器才能进行编译操作，通常使用的是gcc。 2.3.2 make+autoconfig 以Tarball形式发布的软件，为了简化编译流程，通常需要make来根据目标文件文件的依赖性进行编译，但是由于make需要Makefile，因此需要autoconfig生成Makefile。 2.3.3 函数库 需要内核提供的库以及相关的include文件。 2.4 静态库与动态库 函数库分为动态库与静态库两种类型，绝大部分放在/lib与/lib64中。 2.4.1 静态库 扩展名为.a，编译时会直接整合到执行程序中，所以利用静态库生成的文件会比较大一些，编译后的可执行文件可以直接运行，无需依赖外部函数库。另外升级难度较大，因为是直接整合进程序中，升级了静态库的话需要重新编译。 2.4.2 动态库 扩展名为.so，在编译时不像静态库一样，动态库在程序中只有一个指针，当可执行程序需要用到函数库的功能时，才会读取函数库来使用，生成的可执行文件会比较小一点，但是不能独立执行编译出来的程序。另外升级比较方便，不需要重新编译，因为执行文件会直接指向新的函数库文件。 2.5 编译安装的一般步骤 （1）获取源码：一般使用wget或curl或从浏览器下载。 （2）查看帮助文件：解压后查看INSTALL或README等文件相关内容 （3）安装依赖：根据官网文档或上一步中得到的信息安装依赖 （4）生成Makefile：一般使用configure/config进行配置，检测操作环境，指定安装位置，开启/关闭对应的功能，指定相关库位置等，确定依赖关系等，一般需要使用--help获取选项帮助，指定对应选项后配置并生成Makefile （5）编译：实际编译步骤，一个简单的make命令，实际包含了头文件预编译，预处理，编译与连接步骤 （6）安装：make install，这一步实际进行安装与操作系统连接两个步骤 注意，以上步骤都是有顺序的，而且前一个步骤执行失败则后一个步骤也不能执行，也就是说需要前一个步骤执行成功才能进行下一步的操作。完成以上六步就能编译安装了，一般需要进行一些后续处理，比如，添加可执行文件路径到PATH，添加头文件与库文件到/usr/include与/etc/ld.so.conf.d中，添加联机帮助文件到/etc/man_db.conf中。 2.6 编译安装前的心理准备 这里是最后的提示了，未安装之前还可以ctrl+w关闭本页面，避免无数的痛苦。 编译安装最常见的问题就是版本与依赖的问题，版本问题容易处理，可以通过包管理器进行升级或者手动升级，至于依赖问题，包管理器安装的话很容易，编译安装的话会非常头疼，因为不知道某个依赖下面还需要安装多少个依赖。 所以，需要准备充足的时间，还有充分的耐心，去解决无数的问题，才能成功进行编译安装MySQL与Workbench这种大型软件。 不废话了，开始吧。 3 安装MySQL 3.1 安装依赖 MySQL所需依赖如下： cmake make（推荐3.75以上） 编译器（GCC5.3+或Clang4.0+或XCode9+或Developer Studio12.6+或Visual Studio2017） SSL库（默认使用系统的OpenSSL） Boost C++库，需要用来构建但不需要使用，无需安装，源码即可 ncurses库 bison2.1+ git 3.2 包管理器安装 笔者的Debian系，使用apt即可： sudo apt-get install -y bison git hostname libncurses-dev libssl-dev make openssl pkg-config doxygen cmake make RedHat8.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen diffutils rpcgen make libtirpc-devel cmake gcc RedHat7.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen cmake gcc 其他自行搜索。 3.2 编译安装 若不想用包管理器安装，可以使用编译安装的方式。 欢迎来折腾。 3.2.1 安装cmake tar -zxvf cmake-3.17.2.tar.gz cd cmake-3.17.2 ./bootstrap --prefix=/usr/local/cmake make clean make -j 6 #6为CPU核数，自定义修改，若失败请使用make make test sudo make install 3.2.2 安装make 没有编译器的情况下无法编译安装，使用软件包安装即可，笔者的Debian系，直接使用apt： sudo apt install make 3.2.3 安装gcc tar -xvf gcc-9.3.0.tar.xz cd gcc-9.3.0 ./contrib/download_prerequisites mkdir build cd build ../configure --prefix=/usr/local/gcc -enable-checking=release -disable-multilib make clean make -j 6 make test sudo make install sudo ln -sv /usr/local/gcc/include /usr/include/gcc #/etc/ld.so.conf.d/gcc.conf加入以下内容 /usr/local/gcc/lib /usr/local/gcc/lib64 3.2.4 安装openssl tar -zxvf openssl-1.1.1g.tar.gz cd openssl-1.1.1g ./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl/ssl #prefix为安装位置，默认/usr/local #openssldir为配置文件位置，同时存放证书与密钥对 make clean make -j 6 make test sudo make install sudo ln -sv /usr/local/openssl/include /usr/include/openssl #/etc/ld.so.conf.d/openssl.conf加上以下内容 /usr/local/openssl/lib 3.2.5 下载boost 官网戳这里。 需要的版本为1.70.0。目前最新的版本为1.73.0,理论上来说更新的版本应该可以，这里下载的是1.70.0。如果不手动下载boost库的话可以在使用cmake生成Makefile时设置DDOWNLOAD_BOOST为1进行下载。 下载后解压既可。 tar -xvf boost_1_70_0.tar.bz2 3.2.6 安装ncurses tar -zxvf ncurses-6.2.tar.gz cd ncurses-6.2 ./configure --prefix=/usr/local/ncurses make -j 6 sudo make install sudo ln -sv /usr/local/ncurses/include /usr/include/ncurses #/etc/ld.so.conf.d/ncurses.conf加入 /usr/local/ncurses/lib 3.2.7 安装bison tar -xvf bison-3.4.tar.xz cd bison-3.4 ./configure --prefix=/usr/local/bison make -j 6 sudo make install #/etc/ld.so.conf.d/bison.conf加入 /usr/local/bison/lib 3.2.8 安装git tar -xvf git-2.26.2.tar.xz cd git-2.26.2 ./configure --prefix=/usr/local/git \\ --with-openssl=/usr/local/openssl \\ --with-libpcre2=/usr/local/pcre2 \\ --with-curl=/usr/local/curl \\ --with-expat=/usr/local/expat \\ --with-iconv=/usr/local/iconv \\ --with-editor=/usr/bin/vim \\ --with-zlib=/usr/local/zlib \\ --with-tcltk=/usr/local/tcl make all doc info sudo make install install-doc install-html install-info 3.2.9 后续处理 修改PATH： #在~/.bash_profile 或 ~/.bashrc加入 export PATH=$PATH:\\ /usr/local/cmake/bin:\\ /usr/local/gcc/bin:\\ /usr/local/openssl/bin:\\ /usr/local/bison/bin:\\ /usr/local/ncurses/bin:\\ /usr/local/git/bin:\\ 使动态库生效： ldconfig 权限不足请加sudo。 3.3 下载MySQL社区版 官网这里。 这里不知道第一个与第二个有什么区别，因为笔者两个都试过都能编译安装成功。虽然上面写着第二个带Boost头，但是貌似没什么用。这里用的是第一个。 校验（可选）： md5sum mysql-boost-8.0.20.tar.gz 3.4 生成Makefile sudo cmake .. \\ -DDEFAULT_CHARSET=utf8mb4 \\ -DDEFAULT_COLLATION=utf8mb4_unicode_ci \\ # -DENABLED_LOCAL_INFILE=ON \\ -DWITH_SSL=system \\ -DCMAKE_INSTALL_PREFIX=/usr/local/mysql/server \\ -DMYSQL_DATADIR=/usr/local/mysql/data \\ -DMYSQL_TCP_PORT=3306 \\ -DDOWNLOAD_BOOST=0 \\ -DWITH_BOOST=~/Desktop/boost DDEFAULT_CHARSET：指定默认字符集为utf8mb4，因为历史遗留问题，MySQL中的utf8不是真正的utf8，而是阉割版的，最长只有三个字节，当遇到四个字节的utf8编码时，会导致存储异常。从5.5.3开始，使用utf8mb4实现完整的utf8。 DDEFAULT_COLLATION：排序规则，默认为utf8mb4_0900_ai_ci，属于utf8mb4_unicode_ci的一种。0900指的是Unicode校对算法版本，ai是指口音不敏感（as表示敏感），ci指不区分大小写（cs表示区分）。utf8mb4_unicode_ci表示基于标准的的Unicode来排序和比较，能够在各种语言之间精确排序，而utf8mb4_general_ci遇到某些特殊的字符集时排序结果可能不一致，准确性较差，但是性能较好，比较和排序时候更快。 DENABLED_LOCAL_INFILE表示能否使用load data命令。 DWITH_SSL表示使用系统的SSL库，若不使用系统的请自定义路径。 DCMAKE_INSTALL_PREFIX：MySQL安装目录。 DMYSQL_DATADIR：MySQL数据目录，初始时为空。 DMYSQL_TCP_PORT：端口，默认3306。 DDOWNLOAD_BOOST：取值0或1，是否下载Boost库。 DWITH_BOOST：若不下载Boost库的话，是本地Boost库的位置，若下载Boost表示下载位置。 其他更多参数请使用 sudo cmake .. -LH 查看。 3.5 编译与安装 sudo make 或 sudo make -j n 笔者试过了make -j 6，失败，无奈换成了make。 make的速度和make -j还是很大差距的。 编译好之后，建议测试一下： make test 然后安装： sudo make install 3.6 后续配置 3.6.1 用户组与用户 新建用户组与用户，同时修改用户数据目录权限： sudo groupadd mysql sudo useradd -r -g mysql -s /bin/false mysql sudo chown mysql:mysql /usr/local/mysql/data sudo chmod 750 /usr/local/mysql/data 数据目录根据需要修改，若后面出现不可写错误请把权限改为777。 3.6.2 配置文件 配置文件为my.cnf，可以放在 /etc/ /etc/mysql/ 安装目录/etc/ ~/ 下，读取顺序从上到下。笔者安装后默认在/etc/mysql/my.cnf，这个是全局配置，~/.my.cnf是用户特定配置，这里直接修改/etc/mysql/my.cnf： [client-server] # Import all .cnf files from configuration directory !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mariadb.conf.d/ [mysqld] port=3306 basedir=/usr/local/mysql/server datadir=/usr/local/mysql/data character-set-server=utf8mb4 [mysql] default-character-set=utf8mb4 [client] port=3306 default-character-set=utf8mb4 其中[mysqld]下面是新添加的字段，数据目录自行修改。 建议字符集改为utf8mb4，因为utf8在MySQL中指的是utf8mb3，支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会插入异常。三字节的utf8最大能编码的Unicode字符为0xffffff，也就是基本多文种平面，Emoji和很多不常用的汉字都不能存储。而utf8mb4是5.5.3之后才支持的，为了兼容性考虑应该统一使用utf8mb4。 3.7 初始化 修改环境变量： #.bashrc或.bash_profile加上 export PATH=$PATH:/usr/local/mysql/server/bin 使用 mysqld --initialize --user=mysql 或 mysqld --initialize-insecure --user=mysql 然后开启ssl与rsa支持（可选）： mysql_ssl_rsa_setup 最后开启服务： mysqld_safe --user=mysql &amp; 3.8 修改密码 使用root登录，如果使用insecure初始化： mysql -u --skip-password 使用initialize初始化： mysql -u root -p 输入初始化出现的密码即可。 然后修改密码： alter user root@localhost identified by 'xxx'; 3.9 测试 使用自带的mysqlshow与mysqladmin： mysqladmin -u root -p version mysqlshow -u root -p 3.10 收尾工作 3.10.1 别名 alias md='mysqld -u mysql &amp;' 这样输入md就可以启动MySQL服务了。 3.10.2 安装Mycli Mycli是一个MySQL命令行客户端工具，具有自动补全和语法高亮的功能。 使用pip安装即可，python2请使用 pip install mycli python3请使用 pip3 install mycli 找不到pip请安装： sudo apt install python-pip#python2 sudo apt install python3-pip 然后使用mycli进入数据库： mycli -u root 愉快地使用补全吧！ 4 参考 1.CSDN-Linux下源码编译安装详解 2.CSDN-utf8 与 utf8mb4，utf8mb4_unicode_ci 与 utf8mb4_general_ci 3.MySQL-官网安装文档 ","link":"https://2293736867.github.io/post/yuan-ma-bian-yi-an-zhuang-mysql8020/"},{"title":"如果你的application.properties中还存在明文密码----加密Spring Boot中的application.properties","content":" 1 概述 2 简单加密 2.1 依赖 2.2 加密口令 2.3 输出密文 2.4 替换配置文件 3 自定义加密 3.1 自定义加密前后缀 3.2 口令参数化 3.3 自定义加密类 4 部署 4.1 jar部署 4.1.1 命令行参数方式 4.1.2 应用环境变量方式 4.1.3 系统环境变量方式 4.2 war部署 4.2.1 jar-war转换 4.2.2 命令行参数方式 4.2.3 应用环境变量方式 4.2.4 环境变量方式 5 非对称加密 5.1 加密 5.2 修改配置文件 1 概述 什么?都2020年了还在Spring Boot的配置文件中写明文密码? 虽然是小项目,明文也没人看. 明文简单快捷方便啊!!! 你看直接用户名root密码123456多么简单!!! ... 不废话了,这篇文章主要讲了如何使用jasypt-spring-boot这个开源组件来进行配置文件的加密,包括简单加密以及非对称加密,同时也介绍了使用jar/war部署时如何输入加密口令. 2 简单加密 jasypt简单加密就是直接把加密口令写死在文件中.(好吧这样就差不多大概跟没加密一样... ) 2.1 依赖 目前最新版本为3.0.2,具体请查看官方github(戳这里). &lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 2.2 加密口令 在application.properties中加上: jasypt.encryptor.password=xxx xxx为对称加密的口令. 默认使用PBE算法进行加密,PBE其实并没有包含真正的加密与解密算法,而是将已有的消息摘要算法(如MD5,SHA等)与对称加密算法(如AES,DES,RC2等)进行了组合,默认组合的是HCMA消息认证算法,SHA512消息摘要算法以及AES256对称加密算法.PBE使用口令与随机生成的盐去生成对应的对称加密密钥,再用密钥去进行对称加密. 2.3 输出密文 这里在配置文件中加一个测试字段password与密钥test进行测试: 这里为了方便就在run里面测试: @SpringBootApplication @EnableEncryptableProperties public class DemoApplication implements CommandLineRunner { private static final Logger l = LoggerFactory.getLogger(DemoApplication.class); @Autowired private StringEncryptor stringEncryptor; @Autowired private ApplicationContext applicationContext; public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @Override public void run(String... args) throws Exception { Environment environment = applicationContext.getEnvironment(); l.info(stringEncryptor.encrypt(environment.getProperty(&quot;password&quot;))); } } 注意使用@Autowired进行StringEncryptor的自动装配时,官方文档说加上 @Configuration @EnableEncryptableProperties 由于 @SpringBootApplication 包含了 @Configuration 因此这里只需要后一个. 运行后获取密文输出: 2.4 替换配置文件 把上面的密文替换到原配置文件,加上前缀ENC(与后缀): 这样就加密成功了,直接获取属性可以看到明文: 3 自定义加密 当然,上面的简单加密不能满足实际使用需求,因此,这里需要进行自定义加密. 3.1 自定义加密前后缀 需要使用一个前后缀区分需要加密与不需加密的字段,默认前缀为 ENC( 后缀为: ) 因此加密时需要加上ENC(与). 自定义前后缀指定两个属性就可以了: 密码字段需要对应修改. 3.2 口令参数化 其实就是在启动的时候加上命令行参数或者应用环境变量,或者通过系统环境变量读取口令,详细使用方式请看第4点部署. 命令行参数: java -jar xxx.jar --jasypt.encryptor.password=xxx 应用环境变量: java -Djasypt.encryptor.password=xxx -jar xxx.jar 系统环境变量: jasypt.encryptor.password=${TEST} 前提是已经设置好对应系统变量. 3.3 自定义加密类 可以实现StringEncryptor接口,重写里面的encrypt与decrypt方法,再定义一个加密配置类,指定加密类的名字: @Configuration @EnableEncryptableProperties public class MyEncryptorConfiguration { @Bean(&quot;MyEncryptor&quot;) public StringEncryptor getStringEncryptor() { return new StringEncryptor() { @Override public String encrypt(String s) { return &quot;111&quot;; } @Override public String decrypt(String s) { return &quot;222&quot;; } }; } } 这里是一个很简单的例子,加密直接返回111,解密直接返回222,具体加解密算法直接替换函数体即可. 注意需要在配置文件中写上Bean的名字: jasypt.encryptor.bean=codeSheepEncryptorBean 使用构造函数注入(Autowired也可以): private final StringEncryptor stringEncryptor; public DemoApplication(MyEncryptorConfiguration encryptorConfiguration) { stringEncryptor = encryptorConfiguration.getStringEncryptor(); } 测试: @Override public void run(String... args) throws Exception { Environment environment = applicationContext.getEnvironment(); l.info(stringEncryptor.encrypt(environment.getProperty(&quot;password&quot;))); l.info(stringEncryptor.decrypt(environment.getProperty(&quot;password&quot;))); } 4 部署 4.1 jar部署 4.1.1 命令行参数方式 这种方式的话先把配置文件中的jasypt.encryptor.password去掉,然后修改在Spring Boot的运行配置,进行本地测试: 打包时,如果测试的话需要设置Maven的参数,不测试的话直接勾选Skip Tests: 打包后(右侧Maven-&gt;package)加上参数运行就可以了: 4.1.2 应用环境变量方式 其实和第一种方式差不多,也是把jasypt.encryptor.password去掉,在VM options中设置参数,Spring Boot运行配置如下: Maven设置(当然也可以跳过测试): 不过遗憾的是笔者测试失败了: 没理由啊,那为什么Spring Boot那里就这样设置就可以.... (有大佬知道为什么会失败的话可以留言,感激不尽.) 这里就直接跳过测试了. 然后就可以愉快地运行了(笔者的win下需要加两个单引号): 4.1.3 系统环境变量方式 设置环境变量这个应该不用怎么说了,直接去设置就行,然后修改一下jasypt.encryptor.password,两个花括号中间是对应的环境变量名: Spring Boot运行配置: Maven: 这次Maven测试就没问题了. 真是奇了怪了. 运行(还是这个舒服,直接-jar): 4.2 war部署 4.2.1 jar-war转换 原来的是jar打包,换成war时,需要修改pom.xml中的&lt;packaging&gt;为war,同时加上tomcat依赖: &lt;packaging&gt;war&lt;/packaging&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 再添加一个ServletInitializer: public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(DemoApplication.class); } } 其中DemoApplication为main函数所在的类. war转为jar时进行对应的相反操作就可以了. 4.2.2 命令行参数方式 Maven设置就不说了,像上面一样,打包之后... 笔者找不到设置Tomcat命令行参数的方式,所以,就跳过这个了... (欢迎大佬找到的留言补充,感激不尽!!!) 笔者太菜了,害. 4.2.3 应用环境变量方式 win下可以直接修改catalina.bat或者进入tomcat9w.exe(tomcat9,tomcat8是tomcat8w.exe)进行图形化修改,这里选择修改catalina.bat的方式,找到setlocal,后面加上 set &quot;JAVA_OPTS=-Djasypt.encryptor.password=test&quot; 然后把war放到webapps下就可以了. 4.2.4 环境变量方式 这种方式最简单,设置好了环境变量,修改配置文件: 直接war打包部署就行. 5 非对称加密 Spring Boot2.2.1之后支持非对称加密,密钥对的格式可以为PEM/DER. 5.1 加密 这里使用的一位大佬的RSA自定义位数加密工具类(戳这里),无需额外依赖,仅自带JDK实现(JDK8+). import java.util.Base64; import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.HashMap; import java.util.Map; /** * Java RSA 加密工具类 * 参考： https://blog.csdn.net/qy20115549/article/details/83105736 */ public class Test { /** * 密钥长度 于原文长度对应 以及越长速度越慢 */ private final static int KEY_SIZE = 2048; /** * 用于封装随机产生的公钥与私钥 */ private static Map&lt;Integer, String&gt; keyMap = new HashMap&lt;Integer, String&gt;(); /** * 随机生成密钥对 */ public static void genKeyPair() throws NoSuchAlgorithmException { // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象 KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;); // 初始化密钥对生成器 keyPairGen.initialize(KEY_SIZE, new SecureRandom()); // 生成一个密钥对，保存在keyPair中 KeyPair keyPair = keyPairGen.generateKeyPair(); // 得到私钥 RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); // 得到公钥 RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); String publicKeyString = Base64.getEncoder().encodeToString(publicKey.getEncoded()); // 得到私钥字符串 String privateKeyString = Base64.getEncoder().encodeToString(privateKey.getEncoded()); // 将公钥和私钥保存到Map //0表示公钥 keyMap.put(0, publicKeyString); //1表示私钥 keyMap.put(1, privateKeyString); } /** * RSA公钥加密 * * @param str 加密字符串 * @param publicKey 公钥 * @return 密文 * @throws Exception 加密过程中的异常信息 */ public static String encrypt(String str, String publicKey) throws Exception { //base64编码的公钥 byte[] decoded = Base64.getDecoder().decode(publicKey); RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(new X509EncodedKeySpec(decoded)); //RSA加密 Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, pubKey); String outStr = Base64.getEncoder().encodeToString(cipher.doFinal(str.getBytes(&quot;UTF-8&quot;))); return outStr; } /** * RSA私钥解密 * * @param str 加密字符串 * @param privateKey 私钥 * @return 明文 * @throws Exception 解密过程中的异常信息 */ public static String decrypt(String str, String privateKey) throws Exception { //64位解码加密后的字符串 byte[] inputByte = Base64.getDecoder().decode(str); //base64编码的私钥 byte[] decoded = Base64.getDecoder().decode(privateKey); RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance(&quot;RSA&quot;).generatePrivate(new PKCS8EncodedKeySpec(decoded)); //RSA解密 Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE, priKey); String outStr = new String(cipher.doFinal(inputByte)); return outStr; } public static void main(String[] args) throws Exception { long temp = System.currentTimeMillis(); //生成公钥和私钥 genKeyPair(); //加密字符串 System.out.println(&quot;公钥:&quot; + keyMap.get(0)); System.out.println(&quot;私钥:&quot; + keyMap.get(1)); System.out.println(&quot;生成密钥消耗时间:&quot; + (System.currentTimeMillis() - temp) / 1000.0 + &quot;秒&quot;); // String message = &quot;RSA测试ABCD~!@#$&quot;; String message = &quot;test&quot;; System.out.println(&quot;原文:&quot; + message); temp = System.currentTimeMillis(); String messageEn = encrypt(message, keyMap.get(0)); System.out.println(&quot;密文:&quot; + messageEn); System.out.println(&quot;加密消耗时间:&quot; + (System.currentTimeMillis() - temp) / 1000.0 + &quot;秒&quot;); temp = System.currentTimeMillis(); String messageDe = decrypt(messageEn, keyMap.get(1)); System.out.println(&quot;解密:&quot; + messageDe); System.out.println(&quot;解密消耗时间:&quot; + (System.currentTimeMillis() - temp) / 1000.0 + &quot;秒&quot;); } } 5.2 修改配置文件 把明文输入,得到密文与私钥后,替换原来的配置文件: 密文复制到对应加密字段,加上前后缀,同时私钥格式选择der,把私钥复制过去: 运行测试没问题就可以了. ","link":"https://2293736867.github.io/post/ru-guo-ni-de-applicationproperties-zhong-huan-cun-zai-ming-wen-mi-ma-jia-mi-spring-boot-zhong-de-applicationproperties/"},{"title":"IDEA中Maven本地仓库与镜像配置","content":"1 Maven Maven是一个用于项目构建与管理的工具,IDEA自带了Maven,在安装目录下的 plugins\\maven\\lib\\maven3 IDEA也可以集成使用非自带的Maven,也就是自己下载的Maven(戳这里官网下载). 2 使用非自带Maven 使用非自带Maven需要先把bin添加到环境变量,还需要手动设置Maven home directory和User settings file,同时User settings file需要勾选Override,LocalRepository一般不需要勾选,在settings.xml中设置即可. 把Maven下的bin加入到环境变量后,User settings file改为conf下的settings.xml,并且修改settings.xml如下: &lt;localRepository&gt;xxx&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://central.maven.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 其中&lt;localRepository&gt;为本地仓库的位置,也就是pom与jar等文件的位置,默认为 C:\\Users\\USER_NAME\\.m2\\repository 也就是说在用户目录下,修改到其他位置即可.&lt;mirrors&gt;中的是两个阿里云的Maven镜像,可以很大程度上避免原来国外镜像下载慢的问题. 3 使用自带Maven 默认会使用自带的Maven,不建议勾选Override,因为修改是针对当前项目,想要做一个全局化修改需要把自带Maven目录下的conf下的settings.xml复制到 C:\\Users\\USER_NAME\\.m2\\ 然后同上修改settings.xml文件. ","link":"https://2293736867.github.io/post/idea-zhong-maven-ben-di-cang-ku-yu-jing-xiang-pei-zhi/"},{"title":"嗝,我饱了——IDEA食用指南","content":" 1 概述 2 新版本特性 2.1 中文 2.2 Java14 2.3 LightEdit模式 2.4 禅模式ZenMode 2.5 javadoc渲染 2.6 导航栏 2.7 改进Http Client 2.8 其他 3 UI篇 3.1 背景 3.2 主题 3.3 字体 3.4 整体风格 3.4.1 字体大小 3.4.2 UI元素以及模式切换 3.4.3 侧栏窗口 3.4.4 编辑器 4 常用设置篇 4.1 控制台 4.2 自动去除未引用的包 4.3 编码统一UTF8 4.4 JDK 4.4.1 编译JDK 4.4.2 项目JDK 4.4.3 模块JDK 4.4.4 已有JDK 4.5 Maven/Gradle 4.6 关闭标签栏 4.7 自动编译 4.8 代码补全不区分大小写 4.9 代码模板/补全 4.9.1 Live Templates 4.9.2 Postfix Completion 4.10 ctrl+滚轮改变字体大小 5 快捷键篇 5.1 编辑 5.2 查找类/方法/变量使用情况 5.3 导航 5.4 搜索/替换 5.5 代码模板 5.6 重构 5.7 调试 5.8 编译和运行 5.9 版本控制系统/本地历史 5.10 通用 5.11 必记 6 插件篇 6.1 自带插件 6.2 Code Glance 6.3 Grep Console 6.4 GsonFormat 6.5 IdeaVim 6.6 Key Promoter X 6.7 Rainbow Brackets 6.8 JRebel and XRebel 6.9 Lombok 6.10 power-mode 6.11 Translation 6.12 Atom Material Icons 6.13 SequenceDiagram 6.14 插件安装 7 参考 1 概述 IDEA全称IntelliJ IDEA,主要用于Java开发的IDE,代码自动提示,重构,JUnit,代码分析等的功能非常牛逼,这篇文章首先介绍目前为止IDEA最新版本的特性,然后从UI,常用设置,快捷键,插件四个部分去食用IDEA.文章内容有点长,慢慢细品. 2 新版本特性 JetBrains在2020年4月9日发布了目前最新的版本:IntelliJ IDEA 2020.1.下面来看看新版本的特性: 2.1 中文 界面支持中文了,需要安装一个叫 Chinses(Simplified) Language Pack 的插件,这个插件是官方提供的. 至于汉化效果....不清楚,笔者不用哈哈. 2.2 Java14 新版本支持Java14,另外可以直接从IDE中下载JDK,不过下载源没有Oracle的... 2.3 LightEdit模式 就是作为简单的文本编辑器模式,无需创建或加载整个项目,就可以在类似文本编辑器中快速修改独立文件. 可以直接右键文件选择IDEA或者使用命令行打开: 界面非常清爽,启动速度非常快,同时菜单栏只剩下了4个: 2.4 禅模式ZenMode 这个模式超赞啊,结合了原来的免打扰模式和全屏模式. 2.5 javadoc渲染 需要设置中开启: 打开一个源码文件,快捷键Ctrl+Alt+Q,渲染后可以调节字体大小. 2.6 导航栏 可以定位到具体字段或方法. 2.7 改进Http Client 可以补全URL路径: 并且对于Spring MVC可以直接创建或者打开现有的HTTP请求文件并导航到HTTP Client: 2.8 其他 终端拆分: JBR11: JBR8成为历史,彻底过渡到JBR11: IntelliJ Light与Windows10 Liight主题: 新字体:JetBrains Mono(支持连字哦): 更多新特性请看官网,戳这里. 3 UI篇 好了,新特性看完了,下面看看如何做出一个漂亮的IDEA. 3.1 背景 一个好看的IDE怎么能没有背景? 可以选择透明度和缩放方式,提供了预览: 整体效果: 3.2 主题 一个好看的IDE怎么能没有一个好看的主题? 戳这里下载主题. 笔者用的是Monokai Sublime Text 3: 下载之后,从Fille处导入: 提示窗口ok就行,然后重启: (这里真心吹一下这个主题...不得不说真的漂亮) 3.3 字体 嗯...字体...这个贼重要!!! 推荐使用等宽字体,例如: Source Code Pro: Consolas: Droid Sans Mono: 或者新字体也不错JetBrains Mono: 下面看看连字字体,首先开启连字设置: 新字体JetBrains Mono是支持连字的: 另一个要推荐的连字字体是Fira Code: 也很不错. 3.4 整体风格 3.4.1 字体大小 如果觉得菜单栏字体小的话可以调大一点,字体建议不要改,改大小就好. 3.4.2 UI元素以及模式切换 建议为工具栏,工具窗口栏,状态栏以及导航栏设置一个快捷键,然后可以快速切换一个简洁模式. 另外为全屏模式/免打扰模式/禅模式设置一个缩写词也是一个不错的选择,方便快速切换: 推荐为其中一个绑定一个鼠标快捷键,比如中键单击,这样就可以中键单击切换. 3.4.3 侧栏窗口 非必要固定建议改成Undock,滑动效果非常不错: 3.4.4 编辑器 第一个是Soft-Wrap,就是对于太长的行显示成多行,但并没有实际插入换行符,相对的是Hard Wrap,可以在Editor-&gt;Code Style中设置. 第二个会对Tab进行显示: 第三个显示行数,第四个是侧栏图标: 关闭后: 第五个是缩进引导线: 第六个&quot;面包屑&quot;(实际上是个导航栏,概念来自童话故事&quot;汉赛尔和格莱特&quot;): 第七个是import时的弹出的窗口. 4 常用设置篇 这部分包含了一些常用的而且有用的设置. 4.1 控制台 Windows下的终端有很多,除了自带的cmd ,powershell ,还有Fluent Terminal,Windows Terminal,ConEmu,Hyper,Cmder,wsl等等,随便美化一下都很不错: 没错来晒终端了. 先来自带的powershell(感谢伟大的oh-my-posh): Fluent Terminal: Windows Terminal: VSCode集成效果: 至于IDEA...显示有点问题,就不截图了,图形显示得有点奇怪,可能是windows上的终端支持得不够好. 搞了这么多最后还是决定把终端给关了(老老实实用Windows Terminal...) IDEA的终端是一个插件,不需要的话关了就好,如果需要的话,可以直接搜索Terminal,在shell Path这里设置默认终端的路径(默认cmd),搜索Console Font修改字体. 4.2 自动去除未引用的包 4.3 编码统一UTF8 4.4 JDK 建议JDK统一. 4.4.1 编译JDK 4.4.2 项目JDK 4.4.3 模块JDK 4.4.4 已有JDK 2020.1版本提供了下载JDK的功能. 4.5 Maven/Gradle 构建工具一般用Maven或Gradle,通常需要用其中一个即可,笔者用的是Maven,以Maven为例. 首先修改用户目录下的.m2/settings.xml,这个是Maven的配置文件,建议修改localRepository: 默认位置如图,对于Windows用户不建议C盘,在其他地方找一个,填绝对路径. 其次在&lt;mirrors&gt;加入如下镜像: &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 然后打开设置就可以看到对应的更改了. 4.6 关闭标签栏 一次只打开一个文件,也就是说没有标签栏,看个人吧. 4.7 自动编译 这功能用起来非常爽,强烈建议开启,配合JRebel,从此让漫长的编译与部署见鬼去吧! 两次shift搜索Registry: 找到compiler.automake.allow.when.app.running: 需要的话可以加上compile.document.save.trigger.delay,这个是针对静态文件如JS,CSS的更新. 4.8 代码补全不区分大小写 看个人,关了匹配大小写的话,直接输入小写字母除了补全变量以外还会补全类,可能会带来一点不方便. 4.9 代码模板/补全 VScode中的syso就可以输出System.out.println,这个应该很多人知道,但是IDEA中不可以(虽然,用的是sout). 如果想用syso输出怎么办呢? 没事,用补全! IDEA中的补全分为两种,一种是模板补全(Live Templates),一种是后缀补全(Postfix Completion). 4.9.1 Live Templates 先看一下自带的模板: 新建一个模板组,叫Java: 然后添加模板: define这里可以选择应用的范围,从上到下是:注释,声明,表达式,智能类型补全,语句,字符串,其他. 然后输入补全的内容,其中 $END$ 表示光标的位置(类似的还有很多,具体查看默认的模板). 如果不想用Tab补全,可以考虑一下空格(不过估计半年后键盘的空格就弹不起来). 当然,这样只能补全自定义的模板,一些自定义的类无法使用空格,可以考虑加一个全局的快捷键: 这样就能实现空格补全了(努力让空格弹不起来吧!!!) 再介绍一个字符串常量补全: 利用了内置的函数capitalizeAndUnderscore(字母大写,并且下划线分隔)与cipboard(调用剪贴板最近一次内容). 首先把变量名复制到剪贴板,然后调用补全&quot;cs&quot;,配置如下: 还有其他很多函数,详见官网文档(戳这里). 4.9.2 Postfix Completion 后缀补全其实就是输入.之后出现的补全,比如: 自带的后缀补全已经很强大了,包括常用的for,fori,if,iter等: 这里添加一个数组输出的补全作为例子: 其中 $EXPR$ 表示目标表达式,上面可以选择应用的表达式类型,这里是数组,也就是说,只有对于数组类型才会出现这个后缀补全: 4.10 ctrl+滚轮改变字体大小 5 快捷键篇 官方快捷键参考列表: 5.1 编辑 键 作用 Ctrl+Space 基本代码补全 Ctrl+Shift+Space 智能代码补全 Ctrl+Shift+Enter 补全语句 Ctrl+Q 快速查看文档 Alt+Insert 生成代码(getter/setter,构造方法,toString等) Ctrl+O 重载方法 Ctrl+I 实现接口方法 Ctrl+Alt+T 代码包裹(if/else/try/catch...) Ctrl+/ 行注释/取消行注释 Ctrl+Shift+/ 块注释/取消块注释 Ctrl+W 扩展选择范围 Ctrl+Shift+W 缩减选择范围 Alt+Enter 快速修复问题和显示猜测动作 Ctrl+Alt+L 重新格式化代码 Ctrl+Shift+I 自动缩进行 Ctrl+Shift+V 从缓冲区粘贴(Ctrl+C过的内容会放进缓冲区,监控系统剪切板) Ctrl+D 复制当前行或选择块 Ctrl+Y 删除当前行 Ctrl+Shift+J 智能连接行 Ctrl+Enter 智能行截断 Shift+Enter 智能新增行 Ctrl+Shift+U 切换光标所在单词或选择块大小写 Ctrl+Shift+[/] 选择到代码块开始/结束 Ctrl+Backspace/Delete 删除到单词首/尾 Ctrl+ +/- 折叠/打开代码块 Ctrl+Shift+ +/- 折叠所有/打开所有 5.2 查找类/方法/变量使用情况 键 作用 Alt/Ctrl+F7 (Ctrl表示在文件中)查找光标所在的类/方法/变量使用情况 Ctrl+Shift+Alt+F7 在文件中高亮光标所在的类/方法/变量 Ctrl+Alt+F7 显示使用情况 5.3 导航 键 作用 Ctrl+N 定位到类 Ctrl+Shift+N 定位到文件 Ctrl+Alt+Shift+N 定位到标记 Alt+Right/Left (建议改成Ctrl+Tab/Ctrl+Shift+Tab)切换到下一个/上一个标签 ESC 回到编辑器 Shift+ESC 隐藏当前或者上一次激活的窗口 Ctrl+G 定位到行 Ctrl+E 定位到最近打开的文件 Ctrl+Shift+Backspace 定位到上一个编辑位置 Ctrl+B 定位到声明 Ctrl+U 定位到父类/夫方法 Alt+Up/Down 定位到上一个/下一个方法 Ctrl+[/] 定位到代码块开始/结束 Ctrl+H 类型层次结构 Ctrl+Shift+H 方法层次结构 Ctrl+Alt+H 调用层次结构 F2/Shift+F2 下一个/上一个高亮错误 F11 切换书签状态 Ctrl+ 0-9 定位到书签 Shift+F11 显示书签 5.4 搜索/替换 键 作用 Shift两次 搜索所有 Ctrl+F 搜索 F3/Shift+F3 搜索下一个/上一个 Ctrl+R 替换 Ctrl+Shift+F 全局搜索 Ctrl+Shift+R 全局替换 5.5 代码模板 键 作用 Ctrl+Alt+J 模板包裹 Ctrl+J 插入模板 5.6 重构 键 作用 F5 复制 F6 移动 Alt+Delete 安全删除 Shift+F6 重命名 Ctrl+F6 重构类/方法 Ctrl+Alt+N 内联 Ctrl+Alt+M 提取当前选择为方法 Ctrl+Alt+V 提取当前选择为变量 Ctrl+Alt+F 提取当前选择为字段 Ctrl+Alt+C 提取当前选择为常量 Ctrl+Alt+P 提取当前选择为参数 5.7 调试 键 作用 F8/F7 step over/into Shift+F8/Shift+F7 智能step over/into Alt+F9 运行到光标处 Alt+F8 计算表达式 F9 恢复程序 Ctrl+F8 切换断点 Ctrl+Shift+F8 查看断点 5.8 编译和运行 键 作用 Ctrl+F9 构建工程 Ctrl+Shift+F9 编译选择的文件/包/模块 Alt+Shift+F10/F9 选择配置运行/调试 Shift+F10/F9 运行/调试 5.9 版本控制系统/本地历史 键 作用 Ctrl+K/T 提交工程到VCS/从VCS更新 Alt+Shift+C 查看文件最近变化 Alt+反引号 VCS操作窗口 5.10 通用 键 作用 Alt+0 信息窗口 Alt+1 项目窗口 Alt+2 收藏窗口 Alt+3 查找 Alt+4 运行窗口 Alt+5 无 Alt+6 TODO窗口 Alt+7 项目结构窗口 Alt+8 服务窗口 Alt+9 版本控制 Alt+Shift+F 添加到收藏 Ctrl+反引号 切换主题 Ctrl+Alt+S 设置窗口 Ctrl+Alt+Shift+S 项目结构窗口 Ctrl+Shift+A 查找动作 Ctrl+Tab 切换窗口/标签 5.11 必记 记一些必要的就好了. 重载/接口方法:Ctrl+O/I 代码包裹:Ctrl+Alt+T 注释:Ctrl+/ Ctrl+Shift+/ 选择:Ctrl+W Ctrl+Shift+W 万能搜索:两次Shift 定位文件:Ctrl+E 定位行:Ctrl+G 搜索/替换:Ctrl+(Shift+)F Ctrl+(Shift+)R 代码模板:Ctrl+(Alt+)J 重构:Ctrl+Alt+C/V/M 调试:F7 F8 Shift+F9 运行:Shift+F10 VCS:Alt+反引号 切换窗口:Alt+数字 6 插件篇 6.1 自带插件 IDEA自带的插件分为了18类,分别是 Android Build Tools Code Coverage Database Deployment HTML and XML IDE Settings JavaScript Frameworks and Tools JVM Frameworks Languages Plugin Development Style Sheets Swing Template Languages Test Tools Themes Version Controls Other Tools 建议不需要的可以选择关闭,只是Java开发的话,可以关掉Android,Build Tools中的Ant与Gradle,JavaScript Frameworks and Tools中的CoffeeScript等等.另外新版本带了一个win10主题插件: 是亮色主题,不需要也可以顺便关了. 对于VCS,大部分人应该用的是Git与Github,可以把Mercuial,Perforce,Subversion关了. 作为一个牛逼的IDE,除了自带的插件外,当然需要安装额外的插件,那么,下面就是激动人心的插件推荐环节. 6.2 Code Glance 代码小地图,默认快捷键Ctrl+Shift+G: 6.3 Grep Console 控制台高亮输出,默认配置有一个叫default的组,里面按照日志的等级划分,可以进行不同颜色的高亮,需要手动配置. 6.4 GsonFormat 根据JSON自动生成对应的字段与getter/setter. 6.5 IdeaVim Vim键位绑定,神器不解释. 6.6 Key Promoter X 快捷键提示工具,每次使用鼠标点击操作会提示这个操作的快捷键和个人使用次数,如果没有快捷键的话会提示绑定快捷键. 6.7 Rainbow Brackets 看名字就知道了,彩色的括号: 6.8 JRebel and XRebel 热部署插件,有了它,不用再等待漫长的编译和部署. 具体使用看笔者的另一篇文章,戳这里. 6.9 Lombok 强大的注解工具,常用的注解有: @Getter/@Setter:可以作用与类或成员上,作用与类上生成所有成员的getter/setter,作用与成员生成该成员的getter/setter. @ToString:作用与类上,覆盖默认的toString,可以通过of/exclude限定/排除某些字段. @EqualsAndHashCode:作用与类上,覆盖默认的equals与hashCode. @NonNull:作用与成员变量/参数,标识不能为空. @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor:作用与类上,分别表示生成无参构造方法,生成包含final与@NonNull的成员变量的构造方法,生成所有成员变量的构造方法. @Data:作用与类上,等价于@ToString+@EqualsAndHashCode+@Getter+@Setter+@RequiredArgsConstructor. 具体使用方式自行搜索. 6.10 power-mode 敲代码爽得飞起: 设置在Apperance中,建议把SHAKE!(晃动),FLAMES!(火焰)与POWER INDICATOR!(右下角的小窗口)关闭. 6.11 Translation 谷歌翻译插件,直接右键翻译即可. 设置目标语言为中文. 6.12 Atom Material Icons 一个好看的IDE怎么能没有一款好看的图标呢？ 推荐Atom Material Icons，或者Extra Icons也不错。 效果： 6.13 SequenceDiagram 类调用时序图，方法上右键-&gt;Sequence Diagram即可生成： 6.14 插件安装 如果直接从插件仓库安装得慢的话可以直接下载插件从本地安装. 以上插件合集: Github 码云 7 参考 1.Idea使用指南--实用版 2.【开发工具】IDEA简明使用指南 3.程序员必备编译器 IntelliJ IDEA使用指南 4.IntelliJ IDEA 2020.1 正式发布，15 项重大特性、官方支持中文了！ 5.IntelliJ Idea 常用快捷键列表 6.Lombok的基本使用 ","link":"https://2293736867.github.io/post/ge-wo-bao-liao-idea-shi-yong-zhi-nan/"},{"title":"TP6学习笔记一:安装与基本配置","content":" 1 说明与概述 1.1 说明 1.2 概述 2 TP6 3 TP6主要新特性 4 安装 4.1 安装要求 4.2 Composer 4.2.1 Composer简介 4.2.2 Composer安装 4.2.3 (可选)换镜像 4.2.4 安装TP6稳定版 4.2.5 安装TP6开发版 4.2.6 调试模式 4.2.7 测试 5 规范 6 单应用模式与多应用模式 7 目录结构 7.1 app 7.2 config 7.3 extend 7.4 public 7.5 route 7.6 runtime 7.7 vendor 7.8 view 8 配置 8.1 单应用配置 8.2 多应用配置 8.3 环境变量 8.4 Config类 8.5 使用Yaconf进行配置处理 8.5.1 Yaconf介绍 8.5.2 使用 1 说明与概述 1.1 说明 以下内容大部分来源于TP6完全开发手册,以手册为主附上个人理解,仅作学习使用. 1.2 概述 第一篇学习笔记,主要记录TP6的基础,包括TP6简介,安装,Hello World,目录结构,配置等. 2 TP6 TP是一个免费的开源的,快速的,简单的面向对象的轻量级的PHP开发框架,是为了敏捷WEB应用开发和简化企业应用开发而诞生的.TP遵循Apache2开源许可协议发布,意味着可以免费使用TP,甚至允许基于TP开发的应用开源或商业产品发布/销售. 3 TP6主要新特性 采用PHP7强类型(严格模式) 支持更多PSR规范 多应用支持 ORM组件独立 改进的中间件机制 更强大和易用的查询 全新的事件系统 支持容器invoke回调 模板引擎组件独立 内部功能中间优化 SESSION机制改进 缓存及日志支持多通道 引入Filesystem组件 对Swoole以及协程支持改进 对IDE更加友好 统一和精简大量用法 4 安装 4.1 安装要求 在安装TP6之前,需要先安装: PHP ( &gt;= 7.1.0) Composer 4.2 Composer 4.2.1 Composer简介 Composer是PHP5.3以上用来管理依赖关系的工具,可以在自己的项目中声明所依赖的外部工具库,Composer会安装这些依赖的库文件. 4.2.2 Composer安装 Linux/Mac: curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer Windows:戳这里. 笔者的是win环境,以win为例:首先用上面的链接下载Composer-Setup.exe. 选择php.exe的位置. 这里笔者遇到的问题是firebird与oci这两个模块缺失的问题,解决方法戳这里. . 好了之后会修改php.ini的默认配置,原来的会备份,next修改即可. 下一步是代理设置,不需要的直接next. 然后说提示Failed to decode zlib stream. (如果没遇到这种问题直接使用exe安装成功的可以略过下面) 其实linux下这种问题是很容易解决的,编译安装zlib就是了,但是win下就有点麻烦了.于是搜了以下zlib在win下的安装方法,需要使用VS,下面是Github上的zlib资源: 可能这真的是一个&quot;wrong place&quot;... 好吧不废话了,笔者平时不需要用VS,为了一个zlib去下一个VS这怎么看也不划算.找了一下其他的安装方法,使用另一个文档安装(戳这里): 然后终于成功了: 4.2.3 (可选)换镜像 官方建议使用国内的阿里云镜像: composer config -g repo.packagist composer https://mirrors.aliyun.com/composer 这是一种全局的修改配置文件的方式,还可以修改当前项目的配置文件,进入项目的根目录(composer.json所在的目录),执行: composer config repo.packagist composer https://mirrors.aliyun.com/composer 其实相比起全局就是少了一个-g. 上面的命令会在当前项目中的composer.json末尾添加镜像配置信息(当然可以直接手动添加): &quot;repositories&quot;: { &quot;packagist&quot;: { &quot;type&quot;:&quot;composer&quot;, &quot;url&quot;:&quot;https://packagist.phpcomposer.com&quot; } } 4.2.4 安装TP6稳定版 cd切换到项目目录, cd project composer create-project topthink/think tp6 其中tp6就是应用根目录,可以随意修改. 如果之前已经安装过,可以切换到项目目录,使用以下命令更新: composer update topthink/framework (会删除thinkphp目录重新安装新版本) 4.2.5 安装TP6开发版 同样切换到项目目录: cd project composer create-project topthink/think=6.0.x-dev tp6 这里笔者用的是开发版,但是出现openssl错误: 在php.ini中把openssl扩展开启就行了. 然后会多一个叫tp6的文件夹. 4.2.6 调试模式 默认是部署模式,开发阶段可以修改APP_DEBUG开启调试模式.使用create-project安装的tp6默认会带一个.example.env的文件,默认已开启调试模式: 4.2.7 测试 php think run 提示: 浏览器输入: http://localhost:8000 默认用的是8000端口,可以使用-p指定端口,比如80端口: php think run -p 80 然后使用 http://localhost 访问. 5 规范 PHP PSR规范官网. 中文翻译. 至于这个.... 6 单应用模式与多应用模式 PHP支持多应用部署,实际目录结构取决于单应用还是多应用模式. 默认安装后的目录结构是单应用模式.多应用模式与单应用模式的主要不同就是app目录,多应用模式下面有多个应用目录,而单应用模式默认只有一个controller,而且官方建议多应用模式的话把controller删除,系统会根据该目录作为判断是否是单应用的依据. 7 目录结构 相对于TP5.1,TP6的主要变化是核心框架纳入vendor,原来的application变为app目录. 这里以单应用模式进行目录结构的说明,项目目录下(这个例子是上面安装的tp6目录)有8个子目录:app,config,extend,public,route,runtime,vendor,view. 7.1 app app是应用目录,包含一个controller控制器目录(默认有一个Index.php)与以下php文件: AppService.php:应用服务类,包含服务注册与服务启动两个方法. BaseController.php:控制器基础类,包含验证初始化方法. common.php:应用公共文件,默认为空. event.php:事件定义文件. ExceptionHandle.php:应用异常处理类.包括记录与渲染方法. middleware.php:全局中间件定义文件,默认返回空. provider.php:容器provider定义文件. Request.php:应用请求对象类,继承于think\\Request. service.php:系统服务定义文件,服务在完成全局初始化之后执行. 除此之外还有一个叫.htaccess的文件,这个也叫分布式配置文件,全称是Hypertext Access,提供了针对目录改变配置的方法,即在一个特定的文档目录放置一个包含一个或多个指令的文件,以作用于此目录及其所有子目录. .htacess是Apache服务器的一个配置文件,负责相关目录下的网页配置,通过.htaccess可以实现网页301重定向,自定义404错误页面等功能.默认是 deny from all 无条件禁止访问. 7.2 config config是配置目录,包含以下php文件: app.php:应用配置文件,包含应用地址,应用命名空间,是否开启路由,默认应用,默认时区,应用映射,域名绑定,禁止RUL访问的应用列表,异常页面的模板文件,错误显示信息,显示错误信息等配置. cache.php:缓存设置,包括默认缓存驱动,驱动方式,缓存保存目录,缓存前缀,缓存有效期,缓存标签前缀,序列化机制等配置. console.php:控制台配置,默认包含指令定义的配置. cookie.php:cookie配置,包括保存时间,保存路径,有效域名,是否启用安全传输,是否使用setcookie,httponly等配置. database.php:数据库配置,包含数据库连接(包括类型,地址,库名,用户名,密码,连接参数,默认编码,表前缀,部署方式:0代表集中式,1代表分布式,是否开启读写分离,读写分离后的主服务器数量,指定的从服务器序号,是否严格检查字段存在,是否断线重连,监听SQL,开启字段缓存,字段缓存路径),时间查询规则,自动写入时间戳字段,时间字段取出后的默认格式等配置. filesystem.php:文件系统配置,包含默认磁盘,磁盘列表,磁盘类型,磁盘路径,磁盘路径对应的外部URL路径,可见性等配置. lang.php:多语言配置,包括默认语言,允许的语言列表,多语言自动侦测变量名,是否使用cookie,多语言cookie变量,扩展语言包,Accept-Language转义为对应的语言包名称,是否支持语言分组等配置. log.php:日志配置,包括默认日志记录通道(包括日志记录方式,保存目录,单文件日志写入,独立日志级别,最大日志文件数量,使用JSON格式记录,日志处理器,是否关闭通道日志写入,日式出书格式化格式,是否实时写入),日志记录级别,日志类型记录通道,是否关闭全局日志写入,全局日志处理器等配置. middleware.php:中间件配置. route.php:路由配置,包括pathinfo分隔符,URL伪静态后缀,URL普通方式参数,是否开启 路由延迟解析,是否强制使用路由,合并路由规则,路由是否完全匹配,访问控制器层名称,空控制器名,是否使用控制器后缀,是否开启请求缓存,请求缓存有效期,全局请求缓存排除规则,默认控制器名,默认操作名,操作方法后缀,默认JSONP格式返回处理方法,默认JSONP处理方法等配置. session.php:会话配置,包括会话名称,会话ID,驱动方式,存储连接标识,过期时间,前缀等配置. trace.php:Trace配置,开启调试模式后有效. view.php:模板配置,包括模板引擎类型,默认模板渲染规则,模板目录名,模板后缀,模板文件名分隔符,模板引擎普通标签开始/结束标识,标签库标签开始/结束标记等配置. 7.3 extend 扩展类库目录,默认只有一个.gitignore. 7.4 public 对外访问目录,默认包含: static文件夹:静态资源文件夹,默认带一个.gitignore. .htaccess:Apache配置文件,用于Apache的重写. favicon.ico:标签图标. index.php:入口文件. robots.txt:一个遵循Robots协议(也叫爬虫协议,机器人协议等,全称为网络爬虫排除标准)的txt,是搜索引擎中访问网站时要查看的第一个文件,告诉蜘蛛程序在服务器上什么文件是可以被查看的.默认的配置表示所有的搜索引擎可以查看,禁止列表为空. router.php:快速测试文件. 7.5 route 路由定义目录,默认包含一个app.php,路由定义文件. 7.6 runtime 应用的运行时目录,默认只有.gitignore. 7.7 vendor Composer类库目录,包含 bin:包含一个叫var-dump-server的脚本与一个叫var-dump-server.bat批处理文件,是Laravel5.7的新特性,引入Laravel Dump Server扩展包. composer:包含一些自动加载的php文件(autoload_classmap.php,autoload_files.php,autoload_namespaces.php,autoload_psr4.php,autoload_real.php,autoload_static.php)与一个类加载器ClassLoader.php,还有一个installed.json,包含一些安装信息. league:Laravel基于Frank de Jonge开发的PHP包Flysystem,提供了强大的文件系统抽象层处理,Laravel集成Flysystem以便使用不同的驱动简化对文件系统的操作. opis:闭包处理相关. psr:PHP规范处理,包括PSR缓存,PSR简单缓存,PSR容器以及PSR日志. symfony:基于MVC架构的PHP框架Symfony. topthink:TP框架,包括四个子文件夹:framework,think-helper,think-orm,think-trace.framework是TP6框架核心,think-helper是TP6常用的一些扩展类库,think-orm是基于PHP7.1+和PDO实现的ORM,支持多数据库,think-trace是TP6页面Trace扩展,支持Html页面和浏览器控制台两种方式输出. autoload.php:Composer生成的自动加载文件. services.php:安装TP自动生成的文件,默认返回一个长度为1的数组. 7.8 view 视图目录,如果不适用视图可以删除该目录. 8 配置 8.1 单应用配置 单应用模式的根目录下的config目录就是所有配置文件,里面的文件会被自动读取,如果存在子目录可以通过Config的load方法手动加载,如: //加载config/extra/config.php,读取到extra. \\think\\facade\\Config::load('extra/config','extra'); 8.2 多应用配置 多应用配置的话根目录下的config就是全局配置文件,而每个应用的配置文件在对应的应用目录下的config中,相同的参数会覆盖全局配置. |--app | |--app1 | | |--config(应用配置) | | | |--xxxconfig.php | | | |... | |--app2 | | |--config(应用配置) | | | |--xxxconfig.php | | | |... |--config(全局配置) | |--xxxconfig.php 8.3 环境变量 官方建议,除了一级配置外,配置参数的名字建议使用小写,以下配置只能在环境变量中修改: app_debug 描述 app_debug 应用调试模式 config_ext 配置文件后缀 开发过程中的.env文件(默认为.example.env)可以模拟环境变量配置,采用ini格式. 如果部署环境中单独使用配置了环境变量(前缀PHP_),需要删除.env配置文件避免冲突. 获取环境变量需要先引入think\\facde\\Env,然后使用: Env::get('xxx'); 获取.环境变量获取不区分大小写,支持默认值. 8.4 Config类 使用Config类需要先引入: use think\\facade\\Config 用以下方法读取一级配置: Config::get('app'); 读取单个配置参数: Config::get('app.app_name'); 判断是否存在某个设置参数: Config::has('template'); 设置参数: Config::set(['name1'=&gt;'value1','name2'=&gt;'value2'],'config'); 8.5 使用Yaconf进行配置处理 8.5.1 Yaconf介绍 Yaconf是一个高性能的配置管理扩展,在PHP启动时处理所有要处理的配置,所有配置的内容都是immutable的,支持丰富的配置类型,包括字符串,数组,分节,分节继承,并且可以在配置中直接写PHP常量与环境变量等. 8.5.2 使用 TP中使用的Yaconf不支持动态设置,使用前需要先安装think-yaconf扩展,安装之后不再区分全局与应用配置. 安装think-yaconf扩展: composer require topthink/think-yaconf 在app下的provider.php添加: 'think\\Config' =&gt; '\\think\\Yaconf' 然后使用setYaconf指定Yaconf使用的独立配置文件,如: think\\facade\\Config::setYaconf('thinkphp'); 设置后只需要在thinkphp.ini一个文件进行项目的配置. 更多Yaconf用法戳这里. ","link":"https://2293736867.github.io/post/tp6-xue-xi-bi-ji-yi-an-zhuang-yu-ji-ben-pei-zhi/"},{"title":"PHP :Unable to load dynamic library 'pdo_firebird' and 'pdo_oci'","content":"1 pdo_firebird 启动PHP提示: PHP Startup:Unable to load dynamic library 'pdo_firebird' (tried:xxxxx\\pdo_firebird(The specified module could not be found),xxxx\\ext\\php_pdo_firebird.dll(The specified module could not be found.)) 去Firebird的官网(戳这里),下载对应版本的Firebird库,这里笔者的是win环境: 解压之后有一个fbclient.dll文件: 放到PHP根目录(php.ini所在目录)下就可以了. 2 pdo_oci 这是Oracle C接口的一部分,除非使用Oracle,否则建议注释掉.如果要使用Oracle,需要安装Oracle Instant Client.下载链接戳这里. 由于笔者不需要Oracle就不安装了,安装Instant Client可以参考官网或者这里 . ","link":"https://2293736867.github.io/post/php-unable-to-load-dynamic-library-pdo_firebird-and-pdo_oci/"},{"title":"IDEA/JRebel实现内部/外部/远程Tomcat热部署Spring Boot","content":" 1 概述 2 环境 3 IDEA热部署 3.1 工程部分 3.1.1 新建工程 3.1.2 测试文件 3.2 内部Tomcat热部署 3.2.1 IDEA设置 3.2.2 测试 3.3 外部Tomcat热部署 3.3.1 外部Tomcat配置 3.3.2 测试 3.4 远程Tomcat热部署 3.4.1 服务器的Tomcat设置 3.4.2 IDEA中的服务器设置 3.4.3 IDEA中的Tomcat设置 3.4.4 测试 4 JRebel热部署 4.1 JRebel简介 4.2 安装 4.3 内部Tomcat热部署 4.4 外部Tomcat热部署 4.5 远程Tomcat热部署 4.5.1 打包上传 4.5.2 新建脚本 4.5.3 添加远程服务器 4.5.4 测试 5 附录:jar打包 1 概述 所谓热部署,对于Java应用程序来说,就是在运行时更新Java类文件.IDEA可以使用自带的Spring Boot热部署的方式进行本地/远程热部署,或者使用JRebel进行本地/远程热部署,不过需要安装JRebel and XRebel for IntelliJ这个插件.本文将会介绍这两种方式来进行热部署,这应该是网上能找到的最详细的IDEA热部署的文章,相信在看完之后,开发效率会大大提升,不再需要像以前那样手动打jar/war包然后上传到服务器等一系列繁琐操作. 2 环境 IDE:IntelliJ IDEA 2019.3.1 本地Tomcat:9.0.30 JRebel and XRebel for IntelliJ:2020.2.0 服务器:CentOS 8.1.1911 服务器Tomcat:9.0.33 3 IDEA热部署 3.1 工程部分 3.1.1 新建工程 这里新建一个Spring Boot工程来进行热部署的测试. 打包方式改为war,因为后面要使用外部Tomcat: 勾上热部署工具Spring Boot DevTools与使用内嵌Tomcat的Spring Web. 3.1.2 测试文件 新建一个响应Get请求的Controller: 这里添加了一个控制台信息方便查看. 3.2 内部Tomcat热部署 Spring Boot内嵌了一个Tomcat,可以直接使用其进行热部署. 3.2.1 IDEA设置 首先需要开启Compiler中的Build project automatically: 然后按两下shift,切换到Action,搜索Registry: 把compiler.automake.allow.when.app.running开启: 最后编辑运行设置: 以下两项选择Update classed and resources: 3.2.2 测试 IDEA自带了一个HTTP client(其实是一个插件,不需要可以关闭),可以发送HTTP请求,新建一个HTTP Request: 名字随便: 添加一个GET请求: 修改路径与端口,注意路径对应: 切换回Spring Boot的运行设置,shift+F10运行: 然后就可以发送HTTP请求了,点击一下绿色的小三角: 返回了对应信息,控制台也有对应输出: 然后修改Controller里面的test,改为test1: 不用重新运行项目,切换一下窗口让IDEA进行Update操作: 控制台会重新打印Spring字样,Messages中会看到Build completed successfully的信息,表示Update操作成功. 重新发送原来的HTTP请求,报错: 因为此时已经没有响应localhost:8080/test的方法了,改为test1后: 3.3 外部Tomcat热部署 由于已经配置好了IDEA的相关设置,这里就不重复了,没配置的按上面的方式配置,然后需要增加一个外部的Tomcat配置. 3.3.1 外部Tomcat配置 需要增加一个外部Tomcat的运行配置: 添加Tomcat,选择local: 没有显示Tomcat的话在more items这里. 改个名字,Configure选择本地Tomcat的路径,同时把下面的Build去掉. 部署这里要选择exploded的: 改回根路径: 回到Server选项卡,修改以下两项为Update classed and resources: 3.3.2 测试 注意外部的Tomcat热部署不能使用Run运行,不能像内部的一样直接Shift+F10,要使用Debug运行,Shift+F9: 需要确保默认的8080端口不被占用,先把刚才的Spring Boot应用暂停,在run这里,Tomcat在services这里. 测试文件还是刚才的test1,发送请求: 然后修改test1的方法体: 切换窗口后会提示class reloaded: 再次发送刚才的HTTP请求: 成功! 不过,这种热部署只能修改方法体,如果增加了一个方法或者修改了原来的方法名等,会提示热交换失败,虚拟机不支持该操作: 去万能的百度查了一下: 说是Java HotSwap的限制,HotSwap是一个JVM补丁,这里就略过了.同时后面提到一些类似JRebel的第三方工具可以支持这种类型的修改,当然,下面会有详细介绍. 3.4 远程Tomcat热部署 远程Tomcat热部署比较麻烦,细节很多,一个端口错误就一堆异常,所以请耐心细看.需要三个步骤:设置服务器的Tomcat,设置IDEA的服务器配置,设置IDEA的Tomcat运行配置.最后进行测试. 3.4.1 服务器的Tomcat设置 需要处理四个端口:Tomcat的HTTP端口,JMX端口,RMI端口与调试端口. 其中HTTP端口就是常说的Tomcat端口,浏览器输入http://ip:port就可以访问到Tomcat的默认首页,在server.xml中设置,这里的是在69行的位置,使用默认的8080. 在Tomcat的bin目录下新建一个setenv.sh: CATALINA_OPTS=&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888 -Dcom.sun.management.jmxremote.rmi.port=8888 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=ip -agentlib:jdwp=transport=dt_socket,address=0.0.0.0:12345,suspend=n,server=y&quot; 其中JMX与RMI端口设为一致,只要没有占用随便取即可,address后面的12345是调试端口,根据需要设置即可.ip是服务器的ip地址 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false 这两行表示不使用ssl连接与使用JMX客户端连接到Tomcat时不需要认证. 注意要加上 -Dcom.sun.management.jmxremote.rmi.port=8888 这个RMI端口,很多文章都没有加上这个导致部署失败. 最后修改执行权限并启动tomcat: chmod 750 setenv.sh ./startup.sh 可以查看一下端口监听: netstart -ano | grep -E &quot;8080|8888|12345&quot; 三个端口都监听到了,表示配置成功,若没有监听到这三个端口,请检查Tomcat日志. 同时注意防火墙与安全组的问题,如果开启了防火墙请允许这三个端口通过,安全组也要开启对应端口规则. 3.4.2 IDEA中的服务器设置 新建一个SFTP部署: ip为服务器ip,port为ssh端口,认证方式可以密码或者密钥,按需要选择,Root path设为tomcat的webapps路径,如果有乱码问题把下面的高级选项的编码改为utf-8. 设置好了以后测试一下. 映射:下面有完整的说明,Local path是本地的项目路径,Deployment path是相对与webapps的路径(上面设置了Root path为webapps),Web path是相对与url的路径. 3.4.3 IDEA中的Tomcat设置 新建一个Tomcat Remote: 这里是最重要的设置,设置JMX端口(这里是上面3.4.1设置的8888),Host选择上一步创建的服务器,Path from root为根路径,Mapped as为webapps路径,Host下面的端口为TomcatHTTP端口(这里使用默认的8080,3.4.1中的配置有详细说明). 部署这里选择exploded的war包,Application context选择根路径. Debug这里修改3.4.1中设置的端口: 3.4.4 测试 需要以Debug模式(Shift+F9)运行,不能直接Run(Shift+F10): 首先会提示连接到服务器和虚拟机: 然后提示成功部署: 这时候应该会自动打开浏览器,因为这里设置了运行后打开该URL: 修改方法体后按Ctrl+F9,提示重新加载类: Debug信息提示已重新加载类: 这样就热部署成功了. 当然,像上面的使用外部Tomcat一样,如果修改方法名或者增加方法,会提示虚拟机不支持操作(解决方法是使用下面的JRebel): 4 JRebel热部署 4.1 JRebel简介 JRebel是一个集成了应用服务器的JVM代理,可以使用现有的类加载器重新加载类.只有修改后的类会在运行中的应用程序被重新编译和即时重新加载. 4.2 安装 从设置中的Plugins安装,搜索即可: 如果速度慢的话可以从官网(戳这里)去下载,然后从本地安装: 4.3 内部Tomcat热部署 内部Tocmat热部署非常简单,选中SpringBoot的运行配置以后,直接点击Rebel Run即可: 控制台提示重新加载类并且重新配置bean,表示成功. 当然这样做的前提是默认的Spring Boot配置已经像上面的3.2一样配置好,比如如果修改为: 这样JRebel就会没有效果. 4.4 外部Tomcat热部署 像上面的3.3一样配置好外部Tomcat后,也是直接一键Rebel Run即可. 注意保证端口不被占用. 这里与默认的热部署相比,最大的不同是允许增加与改变方法,而不仅仅是修改方法体(不然的话也不会出现3.3的那个问题). 下面是原来的Controller中的方法: 添加一个方法后: 提示已重新加载,表示成功,而不是提示Operation not supported by VM. 4.5 远程Tomcat热部署 使用JRebel进行的远程Tomcat热部署需要先打包上传,然后才能热部署. 4.5.1 打包上传 热部署之前,需要先手动打包: 上传到服务器的Tomcat的webapps下. 4.5.2 新建脚本 选择运行在远程服务器或虚拟机,然后选择Tomcat: 按提示新建脚本: 实测还需要修改脚本权限,750: 启动之后可以看到JRebel的输出:JRebel started in remote server mode: 这样就能成功监控到变化了. 4.5.3 添加远程服务器 服务器名字随便,URL为ip+端口(注意服务器的防火墙还有安全组规则开放端口),如果设置了服务器认证(通过 java -jar xxx.jar -set-remote-password PASSWORD 设置),则需要勾选Server authentication并填上密码. 如果Tomcat设置了访问密码(设置方法这里查看),则需要勾选HTTP Basic authentication,并填上用户名与密码: 测试一下连接: 没问题就下一步. 4.5.4 测试 然后,打开JRebel,选择部署的项目: 下面是打包时的Controller方法,只有一个test: 测试(注意test前的路径为打包的名字,要对应): 然后加上test1方法,ctrl+F9,构建: 服务器端提示重新加载类: 再次输入test1: 这样就远程热部署成功了! 5 附录:jar打包 由于Spring Boot内嵌了Tomcat,可以打成jar包的形式使用内嵌的Tomcat,这样,可以避免一系列的包括目录映射,端口等繁琐的Tomcat配置.在原来的war打包形式的基础上,修改pom.xml中的&lt;packing&gt;: 加上maven插件(默认已加上): 可以把原来的ServletInitializer删去: 使用Maven打包: 可以先在本地测试一下: java -jar demo.jar 没问题的话就可以上传到服务器了,或者直接使用热部署,注意Tomcat与JRebel需要修改相应的配置,具体就不详细说了. ","link":"https://2293736867.github.io/post/ideajrebel-shi-xian-nei-bu-wai-bu-yuan-cheng-tomcat-re-bu-shu-spring-boot/"},{"title":"如何快速获取一个免费又好看的个人博客网站?看这里!","content":"1 概述 博客这种东西,怎么说呢,多点写写吧,总会有好处的.国内有很多这种类似的博客平台,比如CSDN,博客园,掘金,开源中国,SegmentFault,51CTO,简书等等.还有一些个人博客客户端,比如Leanote(跨平台,开源,Github目前9.3k,个人免费一个月,有不少主题),还有利用Github Pages搭建博客的客户端,比如Gridea(免费,一个静态博客写作客户端,Github目前5.3k,主题还算不上很多,搭建教程可以看这篇笔者的文章). 当然还可以自己从WordPress开始搭建,WordPress是PHP开发的博客平台,非常强大,不过需要自己购买服务器,买域名,买证书,步骤比较繁琐. 好了,说了这么多,好像还没进入正题.这篇文章主要是教你如何&quot;快速&quot;获取&quot;免费&quot;+&quot;好看&quot;的个人博客网站. 快速:利用别人已搭建好的框架 免费:不需要买服务器,买域名等等,当然也离不开万能的Github 好看:利用别人做好的主题,当然你自己可以魔改,emmmm.... 这里用的是博客园提供的自定义主题功能的博客,先上图,这是原博主的博客: 可能静态图看的有点单调,那就来几张gif: 2 实现 由于这个大佬已经把主题的代码开源了,Github这里,所以直接按文档拿来用就行. 2.1 博客园设置 首先去博客园注册一个账号,然后在博客设置里开通js权限: 把皮肤改成SimpleMemory: 禁用模板默认的CSS: 然后开启选项中的公告: 2.2 复制 去github上面复制代码,切换到最新的标签,目前是1.2.9: 复制src/style下的base.min.css到自己的页面定制CSS中: 复制以下代码到博客侧边栏公告中: &lt;script type=&quot;text/javascript&quot;&gt; window.cnblogsConfig = { GhVersions : 'v1.2.9', // 版本 blogUser : &quot;userName&quot;, // 用户名 blogAvatar : &quot;https://xxxx.png&quot;, // 用户头像 blogStartDate : &quot;2016-11-17&quot;, // 入园时间，年-月-日。入园时间查看方法：鼠标停留园龄时间上，会显示入园时间 } &lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v1.2.9/src/script/simpleMemory.min.js&quot;&gt;&lt;/script&gt; 2.3 测试 可以打开自己的网站看看了,比如没修改过任何东西的: 3 个性化 好吧,这个才是文章的重点.(以下是文档的教程,官方文档可以戳这里) 3.1 基础信息 在window.cnblogsConfig中: 用户名:blogUser 用户头像:blogAvatar 入园时间:blogStartDate 3.2 标签 失去焦点标签文字:webpageTitleOnBlur 失去焦点变化延时:webpageTitleOnBlurTimeOut 获取焦点标签文字:webpageTitleFocus 获取焦点变化延时:webpageTitleFocusTimeOut 标签图标:webpageIcon 直接在上面的cnblogsConfig中加上即可: window.cnblogsConfig={ webpageTitleOnblur: '(oﾟvﾟ)ノ Hi', webpageTitleOnblurTimeOut: 500, webpageTitleFocus: '(*´∇｀*) 欢迎回来！', webpageTitleFocusTimeOut: 1000, webpageIcon: &quot;https://xxxxx.xxxx&quot; }; 3.3 日夜模式 window.cnblogsConfig={ switchDayNight: { enable:true,//开启切换按钮 auto: { enable:true//开启自动切换 dayHour:5//日间模式开始时间,整数,24小时制 nightHout:19//类似上面,夜间 } } }; 3.4 图标 这个主题用的是Iconfont上的图标,可以使用自己自定义扩展的图标,先进入Iconfont,选中自己喜欢的图标进行收藏,然后没有项目的话新建项目,有项目的话添加到项目: 然后点击自己的收藏: 新建/添加到项目: 选中Font class,查看并生成链接: 添加到fontIconExtend即可: window.cnblogsConfig={ fontIconExtend:&quot;//at.alicdn.com/t/xxxx.css&quot;, }; 3.5 菜单 使用menuCustomList包含: window.cnblogsConfig={ menuCustomList: { &quot;标题&quot;: { &quot;data&quot;: [ [&quot;name1&quot;,&quot;url1&quot;], [&quot;name2&quot;,&quot;url2&quot;] ], }, &quot;icon&quot;:&quot;Fonticon中的icon名字,需要前一步引入&quot; }, }; 比如笔者的: menuCustomList: { &quot;知乎&quot;: { &quot;data&quot;: [ [&quot;氷泠酒&quot;,&quot;https://www.zhihu.com/people/blue-69-47&quot;], ], &quot;icon&quot;:&quot;icon-zhihu&quot; }, &quot;Github&quot;: { &quot;data&quot;: [ [&quot;bingling&quot;,&quot;https://github.com/2293736867&quot;] ], &quot;icon&quot;:&quot;icon-Github1&quot; } }, 菜单导航用menuNavList: window.cnblogsConfig = { menuNavList: [ ['name1', 'url1'], ['name2', 'url2'], ], } 默认在&quot;管理&quot;的下面: 背景用: window.cnblogsConfig = { menuUserInfoBgImg: 'https://xxx,jpg', } 不过好像有点..... 3.6 进度条 window.cnblogsConfig = { progressBar: { color : '#77b6ff', height : '2px', duration: 0.2,//单位s,是页面滑动后进度条移动到相应位置的时间,比如页面从0滑动到50%,进度条花0.2s从0到达50% }, } 3.7 Loading 这里是页面刚进去的图形旋转的配置. loading: { rebound: {//以下两项控制旋转速度 tension: 16, friction: 5, }, spinner: { id: 'spinner', radius: 90,//图形半径,控制图形大小 sides: 3,//边数,3是三角形,4是正方形 depth: 4,//深度,也就是有多少图形堆叠在一起旋转 colors: { background: '#f0f0f0',//整个页面的背景 stroke: '#272633',//旋转图形边缘颜色 base: null,//原始位置的颜色,比如如果设成红色,未开始旋转的位置对应的有一个红色的图形(取决于上面的sides,n边形),不过看起来效果... child: '#272633',//旋转图形的颜色 }, alwaysForward: true, // false的话会加一点看起来回旋的效果,由于速度太快这个设为true/false看起来差别不大 restAt: 0.5, //0.1-0.9,null为完全旋转 renderBase: false,//如果上面设置了base的颜色要把这个设为true } } 默认loading: window.cnblogsConfig = { loading: { rebound: { tension: 16, }, spinner: { id: 'spinner', radius: 90, } }, } 3.8 动效 3.8.1 主页(气泡效果) 开启: window.cnblogsConfig = { homeTopAnimationRendered: true,//默认true } 设置: window.cnblogsConfig = { homeTopAnimation: { radius: 15,//半径 density: 0.2,//密度,越大越密 color: 'rgba(255,255,255, .2)', // 颜色设置，“random” 为随机颜色 clearOffset: 0.3,//移动到距离页面底部百分比多少就消除 }, } 3.8.2 文章页 开启: window.cnblogsConfig = { essayTopAnimationRendered: true, } 设置: window.cnblogsConfig = { essayTopAnimation: { triW : 14,//三角形宽 triH : 20,//高 neighbours: [&quot;side&quot;, &quot;top&quot;, &quot;bottom&quot;],//随机邻居三角形的位置,三角形竖直放置 speedTrailAppear : .1,//路径出现速度 speedTrailDisappear : .1,//路径消失速度 speedTriOpen : 1,//三角形打开的时间,时间快的话打开得很快,慢的话可能没有完全打开路径就消失 trailMaxLength : 30,//路径最大长度 trailIntervalCreation : 100,//路径创建的时间间隔,单位ms delayBeforeDisappear : 2,//消失之前延迟2s colorsRandom: false, //是否开启随机颜色,其实开启随机色的话笔者觉得效果不怎么好(不信可以自己试试...) colors: [ //三角形的颜色从这八种颜色中随机取值,若自定义的颜色不满八种会使用默认值填满八种颜色 //也可以直接在八种的基础上增加自己的颜色,建议配合背景设置 '#96EDA6', '#5BC6A9', '#38668C', '#374D84', '#BED5CB', '#62ADC6', '#8EE5DE', '#304E7B' ], }, } 3.8.3 页面背景 开启: window.cnblogsConfig = { bgAnimationRendered: true, } 设置: window.cnblogsConfig = { backgroundAnimation: { colorSaturation: &quot;60%&quot;,//颜色饱和度 colorBrightness: &quot;50%&quot;,//颜色亮度 colorAlpha: 0.5,//颜色透明度 colorCycleSpeed: 5,//颜色循环速度,慢的话会趋近同一种颜色,快的话有类似彩虹的效果(针对每条丝带) verticalPosition: &quot;random&quot;,//随机垂直位置 horizontalSpeed: 200,//水平移动速度 ribbonCount: 3,//&quot;折&quot;的数量 strokeSize: 0,//笔触大小,建议调小,调大的话会有比较明显的直线痕迹 parallaxAmount: -0.2,//这个不清楚 animateSections: true//是否断开,true为断开 }, } 3.9 主页 3.9.1 图片 图片: window.cnblogsConfig = { homeTopImg: [ &quot;https://xxx.png&quot;, &quot;https://xxx.png&quot; ], } 多张的话每次随机刷新一张. 3.9.2 标语 window.cnblogsConfig = { homeBannerText: &quot;text&quot;, } 默认为空,每次自动获取,设置了之后会固定显示. 标语获取源可以选择每日一句或每次一句古诗词: window.cnblogsConfig = { homeBannerTextType: &quot;one&quot;,//每日一句,另一个取值为jinrishici,每次一句古诗词 } 3.10 文章页 3.10.1 banner window.cnblogsConfig = { essayTopImg: [ &quot;https://xxx.png&quot;, &quot;https://xxx.png&quot; ], } 多张的话每次随机一张. 3.10.2 文章尾 window.cnblogsConfig = { essaySuffix: { codeImgUrl : '', //左侧图片设置，不配置使用 window.cnblogsConfig.blogAvatar aboutHtml : '关于博主', // 关于博主，不配置使用默认 copyrightHtml: '版权声明', // 版权声明，不配置使用默认 supportHtml : '声援博主', // 声援博主，不配置使用默认 }, } 3.11 打赏 window.cnblogsConfig = { reward: { enable: true,//开启 wechatpay: 'url',//微信收款码url alipay: 'url',//支付宝收款码url }, } 会在右下角: 3.12 代码 3.12.1 限制高度 window.cnblogsConfig = { codeMaxHeight: true, } 代码框高度不会超过页面可视区域的70%,隐藏部分通过滚动的方式查看,默认不开启. 3.12.2 样式统一设置 window.cnblogsConfig = { essayCode: { fontFamily: &quot;'Ubuntu Mono',monospace&quot;//字体 fontSize: &quot;16px&quot;,//大小 }, } 大佬说目前只有这两项设置. 3.12.3 高亮 文档提供了三种高亮的方式,一种是默认的博客园的高亮方式,一种通过highlightjs渲染,一种通过prettify渲染,建议使用第二种,第一种的样式....嗯.....第三种目前只有五个样式可以选择: 使用highlighjs的话,加上: window.cnblogsConfig = { essayCodeHighlightingType: &quot;highlightjs&quot;, essayCodeHighlighting: &quot;从下面列表选择喜欢的主题&quot;, } default、a11y-dark、a11y-light、agate、an-old-hope、androidstudio、arduino-light、arta、ascetic 、atelier-cave-dark、atelier-cave-light、atelier-dune-dark、atelier-dune-light、atelier-estuary-dark 、atelier-estuary-light、atelier-forest-dark、atelier-forest-light、atelier-heath-dark 、atelier-heath-light、atelier-lakeside-dark、atelier-lakeside-light、atelier-plateau-dark、atelier-plateau-light 、atelier-savanna-dark、atelier-savanna-light、atelier-seaside-dark、atelier-seaside-light 、atelier-sulphurpool-dark、atelier-sulphurpool-light、atom-one-dark-reasonable、atom-one-dark、atom-one-light 、brown-paper、codepen-embed、color-brewer、darcula、dark、darkula、docco、dracula、far 、foundation、github-gist、github、gml、googlecode、grayscale、gruvbox-dark、gruvbox-light、hopscotch 、hybrid、idea、ir-black、isbl-editor-dark、isbl-editor-light、kimbie.dark、kimbie.light、lightfair 、magula、mono-blue、monokai-sublime、monokai、nord、obsidian、ocean、paraiso-dark、paraiso-light、pojoaque 、purebasic、qtcreator_dark、qtcreator_light、railscasts、rainbow、routeros、school-book、shades-of-purple 、solarized-dark、solarized-light、sunburst、tomorrow-night-blue、tomorrow-night-bright 、tomorrow-night-eighties、tomorrow-night、tomorrow、vs、vs2015、xcode、xt256、zenburn 可以在这里在线查看效果. 以下是笔者的代码配置: codeMaxHeight: true, essayCode: { fontFamily: &quot;Fira Code&quot;, fontSize: &quot;14px&quot;, }, essayCodeHighlightingType: &quot;highlightjs&quot;, essayCodeHighlighting:&quot;monokai-sublime&quot;, 主题用的是monokai(不得不吹一下这个主题真的漂亮),大小14px应该足够了,字体选用的是Fira Code,不贪图什么,就贪图一个不等于号(看起来真的太爽了): 3.13 页脚 3.13.1 样式 window.cnblogsConfig = { footerStyle: 1,//1或2,默认2 } 提供了两种样式,1或2选择即可,效果就不截图了. 3.13.2 友链 window.cnblogsConfig = { bottomBlogroll: [&quot;name1&quot;, 'url1'], [&quot;name2&quot;, 'url2'], ], } 3.13.3 标语 window.cnblogsConfig = { bottomText: { icon: &quot;❤️&quot;, left : &quot;冲冲冲&quot;, right: &quot;继续冲&quot;, }, } 默认会在一对方括号中间. 3.14 控制台输出 window.cnblogsConfig = { consoleList: [ ['name1', 'url1'], ['name2', 'url2'], ], } 3.15 播放器 在页脚加入: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt; &lt;!-- require MetingJS --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt; &lt;meting-js id=&quot;594243151&quot; lrc-type=&quot;0&quot; server=&quot;netease&quot; order=&quot;random&quot; type=&quot;playlist&quot; fixed=&quot;true&quot; list-olded=&quot;true&quot;&gt; &lt;/meting-js&gt; 把其中的id换成自己网易云音乐的id. 获取id:点击自己的歌单,生成外链播放器, 0后面就是自己的id. 4 这里的才叫自定义修改 好吧,上面的那些都是原作者提供的简单修改配置选项,这里的才叫真正的自定义修改,主要修改两个:侧栏,播放器. 4.1 去除一些默认配置 笔者直接把页脚与一些其他不需要的直接删除或者隐藏: getById(&quot;rightMenu&quot;).style.display = &quot;none&quot;; getById(&quot;footer&quot;).style.display = &quot;none&quot;; getById(&quot;sideBar&quot;).style = &quot;height:0;width:0;&quot;; var loginTips = getByClass(&quot;login_tips&quot;); if (loginTips.length != 0) loginTips[0].style.display = &quot;none&quot;; 其中getById就是document.getElementById,getByClass就是document.getElementsByClassName,你可能会问为什么不直接jQuery: $(&quot;#rightMenu&quot;).remove(); $(&quot;#footer&quot;).remove(); 默认自带了2.2版本的jQuery,用了之后的效果很奇怪,chrome不一定每次都能删除成功,edge与手机测试完全不行,所以,没办法了,直接用原生的js.(顺便好好怀念一下很久没用的document.getElementById而不是$). 4.2 侧栏 感觉原来的侧栏不怎么好看: 修改后: 笔者喜欢比较简洁的风格,只留下了一个头像与四个外链,其他什么日历,随笔,归档之类的全部去掉了,点击头像会跳转到首页. 首先把原来的侧栏效果与日历什么的去掉,同时换背景 然后加入外链: 最后修改一下按钮事件,因为原来的设计话背景图片刚好把按钮给遮挡住了,设成半透明侧栏后,可以看到按钮: 因此需要把这个按钮给隐藏掉: css: 4.3 播放器 4.3.1 修改效果 一开始的修改很简单,直接把fixed改成false就行,让播放器充满页脚: 原效果: 修改后: 但是想了一下感觉这个播放器还是太太太太大了(即使是原来的左下角的播放器,没办法笔者喜欢极简风格),原本想着用三个按钮代替就好了.然后笔者就去Iconfont找了一些按钮的图片: 然后...直接上图吧: 页脚只有一个播放图片,悬浮有平滑缩放效果,点击播放后会自动出现下一首与上一首,同时播放改成暂停,点击暂停后隐藏下一首与上一首按钮,并改暂停为播放. 4.3.2 准备图片 这个不难,准备四个按钮的图片就好了:播放,暂停,下一首,上一首.笔者这里用的大小是32px*32px. 4.3.3 APlayer 这个想法还是挺好的,但是一开始的时候并不知道怎么实现,加几个按钮倒是不难,css这些也不难加,问题是,找不到api. 因为做出这个主题的大佬提供的是meting-js实现的播放器(官方github这里,目前319stars). Quick Start这里很简单,引入js与css后,加一个meting-js的标签,然后改id就可以看到自己的歌单了. 问题是....接口在哪? 笔者需要的是播放/暂停的接口啊.... (然后又胡乱找了一通资料,终于功夫不负什么人...) 搜了一下资料得知Meting-js用的是APlayer(官方github这里,目前4.7k),看了一下APlayer的文档(可以戳这里),结合原来的提供的meeting-js,就直接添加了一个播放器了: 为了方便直接新建了一个html测试: 效果: 4.3.4 添加音乐 因为什么音乐都没有添加,所以只有上面这种效果,看一下文档继续完善: window.ap = new APlayer({ container: document.getElementById('aplayer'), loop: 'all',//列表循环 order: 'random',//播放顺序 listFolded: false,//播放列表折叠 audio: [ { name: '你的酒馆对我打了烊',//歌曲名 artist: '陈雪凝',//歌手 url: 'http://music.163.com/song/media/outer/url?id=1341964346.mp3',//音乐url cover: 'http://p1.music.126.net/LiRR__0pJHSivqBHZzbMUw==/109951163816225567.jpg?param=130y130',//封面 }, ] }); 这里说一下封面与url如何获取,url很简单,首先拿到音乐的id: 然后url就是: http://music.163.com/song/media/outer/url?id=xxxx.mp3 封面的话,直接看源码,F12搜索 u-cover u-cover-6 f-fl 就可以看到img的src了. 回到测试的页面,就可以看到这首歌了: 由于笔者这个不需要把播放器显示出来,所以没必要加cover,name与artist,只需要url,而url只与id有关,所以准备一个音乐id列表,然后使用文档自带的list.add方法添加: ap.list.switch是为了每次随机播放开始音乐,而不是每次固定某一首歌开始. 4.3.5 添加按钮 这一步就是加上四个按钮了(实质是三个,播放/暂停只是图片更换),首先需要把新添加的播放器隐藏: 然后插入三张图片: 4.3.6 添加单击事件 单击事件需要三个函数: 切换播放状态:toggle() 上一首:skipBack() 下一首:skipForward() 还需要一个属性判断播放状态,用于显示播放/暂停图片以及上一首/下一首的显隐: ap.audio.paused 返回是否暂停. 下一首与上一首的单击事件: 4.3.7 平滑旋转缩放 用到了两个简单的css属性:transform与transition: 这样就大功告成了! 5 源码 github 码云 6 博客地址 快来点我!!! ","link":"https://2293736867.github.io/post/ru-he-kuai-su-huo-qu-yi-ge-mian-fei-you-hao-kan-de-ge-ren-bo-ke-wang-zhan-kan-zhe-li/"},{"title":"Apache配置虚拟目录+Zend Studio访问","content":"1 概述 Apache配置虚拟目录,然后可以通过Zend Studio的工程去访问,只需要修改Apache的httpd.conf文件. 2 修改httpd.conf 找到Apache安装目录下的httpd.conf,在末尾加上: &lt;IfModule dir_module&gt; DirectoryIndex index.html intex.htm index.php Alias /alias path &lt;Directory path&gt; Options All AllowOverride None Require all granted &lt;/Directory&gt; &lt;/IfModule&gt; 其中alias是别名,path是文件夹路径. 比如,这里设置了: &lt;IfModule dir_module&gt; DirectoryIndex index.html intex.htm index.php Alias /111 D:/Desktop/111 &lt;Directory D:/Desktop/111&gt; Options All AllowOverride None Require all granted &lt;/Directory&gt; &lt;/IfModule&gt; 别名为111,路径在 D:/Desktop/111 最后重新Apache服务. 3 Zend Studio工程 进入Zend Studio新建一个工程: 工程名字要与上面的配置文件对应,放在相应的Location下. 补全index.php: 把其中的&lt;none&gt;替换成localhost即可: 然后就可以访问了. ","link":"https://2293736867.github.io/post/apache-pei-zhi-xu-ni-mu-lu-zend-studio-fang-wen/"},{"title":"OkHttp配置HTTPS访问+服务器部署","content":" 1 概述 2 OkHttp介绍 3 准备工作 4 OkHttp部分 4.1 暴力方案 4.2 推荐方案 4.2.1 HostnameVerifier 4.2.2 X509TrustManager 5 服务器部署 5.1 上传工程 5.2 Tomcat配置 6 验证与源码 7 常见问题 7.1 Tomcat HTTPS无法访问 7.2 OkHttp HTTPS无法访问 8 参考链接 1 概述 OkHttp配置HTTPS访问,核心为以下三个部分: sslSocketFactory() HostnameVerifier X509TrustManager 第一个是ssl套接字工厂,第二个用来验证主机名,第三个是证书信任器管理类.通过OkHttp实现HTTPS访问需要自己实现以上三部分.另外还简单提及了服务器端的部署,用的是Tomcat9,最后是一些常见问题的可能解决方案. 2 OkHttp介绍 OkHttp是一款开源的处理网络请求的轻量级框架,有Square公司贡献,用于替代HttpUrlConnection与Apache HttpClient,目前Github上有36.4k的star.优点有 共享socket,HTTP/2支持所有连接到同一个主机的请求共享socket 连接池可以减少请求延迟 缓存响应数据减少重复的网络请求 自动处理gzip压缩 总的来说OkHttp是一款支持get/post请求,支持文件上传/下载的优秀的HTTP框架. 3 准备工作 一台服务器 一个域名 一个证书 什么?都没有?买! 当然证书可以不用买,可以使用Openssl之类的工具生成,不过自签名的证书后面验证的时候会有点麻烦,建议还是购买. 4 OkHttp部分 4.1 暴力方案 public static String test() { OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(createSSLSocketFactory(), new TrustAllCerts()) .hostnameVerifier(new TrustAllHostnameVerifier()).build(); String url = &quot;https://xxxxxxx&quot;; //修改成自己的url Request request = new Request.Builder().url(url).build(); Call call = build.newCall(request); Response response = call.execute(); if(response.body() != null) { String result = response.body().string(); //处理result } } private static class TrustAllCerts implements X509TrustManager { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public X509Certificate[] getAcceptedIssuers() {return new X509Certificate[0];} } private static class TrustAllHostnameVerifier implements HostnameVerifier { public boolean verify(String hostname, SSLSession session) { return true; } } private static SSLSocketFactory createSSLSocketFactory() { SSLSocketFactory ssfFactory = null; try { SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null, new TrustManager[]{new TrustAllCerts()}, new SecureRandom()); ssfFactory = sc.getSocketFactory(); } catch (Exception e) { e.printStackTrace(); } return ssfFactory; } 这是一种暴力的方案,看类名就知道了,信任所有的证书与主机: public boolean verify(String hostname, SSLSession session) { return true; } 这个方法直接返回true,也就是信任所有的主机. public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} 这里两个check函数没有做任何的工作,表示接受任意的客户端与服务端的证书.这样写的话相当于是使用了一个没用的TrustManager,这样还不如不加密,不推荐使用. 4.2 推荐方案 从两方面入手修改,一是从X509TrustManager入手,二是从HostnameVerifier入手. 4.2.1 HostnameVerifier 先说个简单的,这里主要是验证主机名,简单的话,可以如下实现: HostnameVerifier hnv = new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { if(&quot;www.test.com&quot;.equals(hostname)){ return true; } else { HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier(); return hv.verify(hostname, session); } } }; 这里验证主机名是www.test.com就返回true(也可以使用服务器ip进行验证),实现得比较简单,业务复杂的话可以结合配置中心,黑/白名单等动态校验. 4.2.2 X509TrustManager 接着是X509TrustManager的处理,这里其实有两种方式,一种是以流的方式添加信任证书(来源:Java Code Example): private static X509TrustManager trustManagerForCertificates(InputStream in) throws GeneralSecurityException { CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in); if (certificates.isEmpty()) { throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;); } char[] password = &quot;password&quot;.toCharArray(); // 这里可以使用任意密码 KeyStore keyStore = newEmptyKeyStore(password); int index = 0; for (Certificate certificate : certificates) { String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificate); } // Use it to build an X509 trust manager. KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, password); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) { throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers)); } return (X509TrustManager) trustManagers[0]; } 返回一个信任由输入流读取的证书的信任管理器,若证书没有被签名则抛出SSLHandsakeException,证书建议使用第三方签名的而不是自签名的（比如使用openssl生成）,特别是在生产环境中,例子的注释也提到: 完整代码见文末.这里把工具类的方法实现成了静态,调用时可以直接: OKHTTP.send(&quot;https://xxxxx&quot;); 另一种方式是直接自定义一个TrustManager,重写里面的三个方法: SSLContext context = SSLContext.getInstance(&quot;TLS&quot;); context.init(null, new TrustManager[]{ new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] chain,String authType) throws CertificateException {} @Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException { for (X509Certificate cert : chain) { // Make sure that it hasn't expired. cert.checkValidity(); // Verify the certificate's public key chain. try { cert.verify(((X509Certificate) ca).getPublicKey()); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (NoSuchProviderException e) { e.printStackTrace(); } catch (SignatureException e) { e.printStackTrace(); } } } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } }, null); 第一个方法为 @Override public void checkClientTrusted(X509Certificate[] chain,String authType) throws CertificateException {} 该方法检查客户端的证书,由于不需要对客户端进行认证,默认即可. 第二个方法为 @Override public void checkServerTrusted(X509Certificate[] chain,String authType) 该方法检查服务器的证书,若不信任该证书则抛出异常,通过自己实现该方法可以信任任何自己指定的证书,不做任何处理的话,不会抛出任何异常,相当于信任所有证书.这里检查了证书是否过期以及证书的签名是否匹配. 第三个方法为 @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } 返回受信任的X509证书数组. 这种方法笔者没有试过,仅供参考. 5 服务器部署 服务器用的是Tomcat,简单介绍一下部署. 5.1 上传工程 后端处理用的Spring Boot的工程,就不演示了,使用IDEA打成war包后上传到webapps下即可. 5.2 Tomcat配置 重点说一下Tomcat的配置,首先需要一个域名,修改conf/server.xml文件,找到默认的名叫localhost的Host: 然后直接复制Host标签,把name修改成自己的域名即可. 然后是证书的配置,笔者的证书在某某云上购买的,这里提供了几种格式的证书下载: Tomcat的是两个文件,一个是pfx文件,一个是密码文件,把pfx文件上传到服务器的Tomcat后,继续修改server.xml,搜索8443找到如下位置(Tomcat版本9.0.33): 一些Tomcat8的高版本提供了HTTP/2的实现,默认使用apr实现的,这里使用的是HTTP/1.1,使用HTTP/2需要额外安装Apr,Apr-util以及Tomcat-native,因此这里采用HTTP/1.1实现.使用HTTP/2可以参考这里. 修改如下: 添加了scheme,secure,keystoreFile,keystoreType,keystorePass,clientAuth,sslProtocol配置,同时去掉里面的&lt;SSLHostConfig&gt;,keystoreFile是刚才的pfx文件,采用绝对路径,keystorePass是密码. 另外默认的端口为8443,这里修改成了8123. 如果想要更安全的话可以手动指定TLS的版本: &lt;Connector ... sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1.3&quot; &gt; 重启Tomcat后输入 https://www.test.com:port 进行测试 这样就成功了. 6 验证与源码 这个因为没有完整的Demo很难做验证,具体来说前端用的OkHttp核心都介绍了,后端的话服务器Tomcat也介绍了,用Spring Boot做个Demo应该不难. 这里只给出了工具类OKHTTP的源码: github 7 常见问题 7.1 Tomcat HTTPS无法访问 证书文件错误,不过这个可能性比较少. 配置错误,请检查配置文件是否正确,可以ps -ef | grep tomcat查看Tomcat是否开启以及查看logs/catalina.out日志. 端口错误,访问的端口需要与&lt;Connector&gt;中的端口对应(Tomcat默认的HTTPS端口为8443,笔者居然看成了8433,然后netstat 无数次都没有看到被监听...) 安全组/防火墙问题,云服务器的话需要在安全组配置中开启相应端口,同时应查看有没有把某个ip列入黑名单导致无法访问.防火墙的话这里主要指iptables,如果没有开启的话不需要理会,如果开启的话需要开放对应端口. 7.2 OkHttp HTTPS无法访问 无法读取证书文件:需要把证书文件放在工程对应路径下读取,比如AS中放在assets下然后使用getAssets().open(&quot;xxx.xxx&quot;)获取,Maven工程的话放在resources下直接使用FileInputStream获取. singed fields invalid: 证书文件格式错误,使用.crt/.pem等证书. Signature does not match:这个有可能是使用openssl自生成证书在验证的时候出现的异常,可能的解决办法是转换证书的格式,如果不行就重新生成一次证书. 8 参考链接 1.苹果核 - Android App 安全的HTTPS 通信 2.Android OkHttp实现HTTPS访问,支持Android 4.X系统HTTPS访问 3.Android使用OkHttp请求自签名的https网站 ","link":"https://2293736867.github.io/post/okhttp-pei-zhi-https-fang-wen-fu-wu-qi-bu-shu/"},{"title":"application.properties提示Cannot resolve configuration property 'xxxx'","content":"1 问题描述 在IDEA的Spring Boot工程中的application.properties文件中,如果自定义属性会如下提示: Cannot resolve configuration property 'xxxx' 2 解决方式一 这其实是一个警告,可以不用理会,正常运行, @Value(&quot;${}&quot;) 可以正常获取到值,最暴力的方法就是关闭这个检查: 进入设置中的Editor--&gt;Inspection--&gt;Spring--&gt;Spring Boot--&gt;Spring Boot application properties,去掉右边勾选. 3 解决方式二(推荐) 这里提示Defind Configuration key a,然后按Alt+Shift+Enter后,就会创建一个addtional-spring-configuration-metadata.json的文件: 这里name是指定属性名字,type是类型,可以加上defaultValue指定默认值: 这样就不会有警告了: ","link":"https://2293736867.github.io/post/applicationproperties-ti-shi-cannot-resolve-configuration-property-xxxx/"},{"title":"Android Activity四种加载方式","content":" 1 概述 2 standard 3 singleTop 4 singleTask 5 singleInstance 6 总结 1 概述 Android中的Activity共有四种加载方式,可以在AndroidManifest.xml中对应的activity的android:launchMode中指定,四种方式如下: standrad singleTop singleTask singleInstance 其中,standard是默认的加载方式,singleTop是栈顶单例模式,singleTask是Task内单例模式,singleInstance是全局单例模式,下面一一进行说明. 2 standard standard是默认模式,每次通过这种模式启动时,都会为Activity创建一个新的实例,并将这个新的实例添加到栈顶,每次按返回键就会一直出栈,处于栈顶的实例就算用户看到的界面. 下面测试一下,新建一个Activity与一个Intent,加上一个Button与startActivity: 加上调试信息以及设置好logcat过滤后,测试: 可以看到每次点击按钮都是一个新的实例,置于Task栈顶,示意图如下: 然后,每次返回,栈顶的Activity出栈,直到栈为空. 3 singleTop singleTop允许一个Activity实例化多个对象,与standard唯一的不同就算,当将要启动的Activity位于栈顶时,不会创建新的实例,而是直接复用已有实例. 另外,如果要启动的Activity没有位于栈顶,系统会创建新的实例,并加载到栈顶. 下面使用两个Activity测试一下,增加一个按钮和事件绑定,同时修改AndroidManifest.xml的android:launchMode为singleTop: 这里FirstActivity用的是singleTop,SecondActivity是standard. 一开始点击First Activity没反应,因为此时First Activity位于栈顶,然后点击了两次Second,创建了两个Second Activity实例,然后再次点击First,此时FirstActivity没有位于栈顶,因此新建First Activity的实例并放置于栈顶,此时栈示意图如下: 然后点击返回依次退栈. 4 singleTask singleTask表示同一个Task内只有一个实例,当准备实例一个Activitty时,会查看栈中有没有这个Activity的实例对象,如果不存在,就创建一个实例,并放置于栈顶,如果已存在,则会移除此实例上面的所有实例移出栈,使目标实例位于栈顶. 下面来测试一下,修改FirstActivity的launchMode为singleTask,SecondActivity不变: 首先进入First Activity,然后开启了四个Second Activity,此时的栈如下: 然后点击First的按钮后,上面的四个Second Activity全部出栈: 因此上面的图会看到连续有四个destroy. 5 singleInstance singleInstance是会使用一个全新的Task栈来存放该Activity实例,也就是说,Activity独占一个Task栈.下面把First Activity改成singleInstance,Second Activity不变: 一开始在Task id为587的Task栈创建First Activity的一个实例,然后在Task id为588的Task栈创建了三个Second Activity实例,示意图如下: 退栈时,首先在当前Activity所在的Task栈进行退栈操作,而不是按照进栈的顺序进行退栈,即先把当前Task出栈完成,再出栈其他Task.因此会先出栈First Activity,然后再出栈三个Second Activity. 6 总结 一个表总结: 操作顺序 standard singleTop singleTask singleInstance 初始状态 First-&gt;First First-&gt;Second Second-&gt;First First-&gt;Second ","link":"https://2293736867.github.io/post/android-activity-si-chong-jia-zai-fang-shi/"},{"title":"MySQL8开启ssl加密","content":"1 概述 MySQL从5.7开始默认开启SSL加密功能,进入MySQL控制台后输入status可以查看ssl的状态,出现下图表示在使用ssl: 另外,ssl加密需要密钥与证书,可以使用openssl手动生成或使用mysql_ssl_rsa_setup自动生成,这里使用了mysql_ssl_rsa_setup. 下面从安装开始. 2 安装(可选) 系统CentOS,直接使用yum安装(编译安装可以看这里),先用list查看一下: 这里的版本是8.0.17,不算太旧,就不去官网下载了,直接install: yum install mysql yum install mysql-server 好了之后启动服务: systemctl start mysqld 然后获取临时密码后修改root密码: grep password /var/log/mysql/mysqld.log 这里显示密码为空,直接root登录修改密码: mysql -u root -p alter user root@localhost identified by 'xxxxx 3 生成证书与密钥 首先查看有没有开启ssl,MySQL控制台输入 show variables like '%ssl%'; 这里have_ssl显示yes,表示已经开启了,表示本地的使用了ssl连接,如果显示为no,使用MySQL自带的工具即可开启ssl: mysqld_ssl_rsa_setup 然后默认在/var/lib/mysql下会有几个pem文件(ls查看),说明如下: 名字 描述 ca-key.pem CA私钥 ca.pem 自签名的CA证书 client-key.pem 连接服务器提供的私钥 client-cert.pem 连接服务器需要提供的证书 server-key.pem 服务器端私钥 server-client.pem 服务器端证书 pulibc_key.pem 密钥对公钥 private_key.pem 密钥对私钥 接着重启服务: systemctl restart mysqld 4 测试 进入服务器的MySQL控制台,新建两个测试用户,一个使用ssl,一个不使用ssl: 然后在本机上测试,首先测试不需要ssl的用户,输入密码123456后可以直接登录: 然后测试需要ssl的用户: 输入密码123456后登录不了,使用scp从服务器复制CA证书与客户端证书与私钥: scp username@xxx.xxx.xxx.xxx:/var/lib/mysql/\\{ca.pem,client-key.pem,client-cert.pem} . 然后在登录时加上 --ssl-ca=ca.pem --ssl-cert=client-cert.pem --ssl-key=client-key.pem 登录成功. ","link":"https://2293736867.github.io/post/mysql8-kai-qi-ssl-jia-mi/"},{"title":"ssh+scp基本使用","content":"1 ssh ssh一般用于连接服务器，可以使用密码认证与密钥认证的方式。 1.1 密码认证 直接使用ssh即可： ssh username@xxx.xxx.xxx.xxx username为用户名，后面为公网ip. 若需要使用特定端口登录，加上p参数，比如使用12345端口： ssh -p 12345 username@xxx.xxx.xxx.xxx 1.2 密钥认证 密钥认证需要先生成密钥，然后把公钥使用scp上传到服务器，接着修改服务器的ssh配置文件。 1.2.1 生成密钥 ssh-keygen -t rsa -b 4096 -C &quot;email&quot; -f /xxx/id_rsa t表示加密算法，b指定位数，C表示注释，识别这个密钥，一般用邮箱即可。f表示生成的私钥文件位置（需要加上文件名），公钥会放在同一文件夹下。 1.2.2 上传公钥 使用scp上传公钥到服务器，注意是公钥，ssh-keygen会生成一个公钥与私钥，pub结尾的文件就是公钥，默认叫id_rsa.pub . scp /xxxx/id_rsa.pub username@xxx.xxx.xxx.xxx:/root/ 这里就直接放到服务器上的/root下。 1.2.3 修改ssh配置文件 先使用ssh密码认证的方式登录服务器，然后修改/etc/ssh/sshd_config： cd /etc/ssh cp sshd_config sshd_config.bak vim sshd_config 找到PubKeyAuthentication这一行，修改如下： 如果需要修改端口的，搜索Port，直接修改： 接着重启sshd服务： systemctl restart sshd 1.2.4 测试连接 ssh -i /xxx/id_rsa -p port username@xxx.xxx.xxx.xxx 其中i后为私钥的位置，p参数如果修改了默认的端口（22）则需要加上自定义端口。 如果在windows上生成的私钥，可能会有如下问题： 这里提示私钥的权限是755，也就是其他用户可读，需要修改为600： chmod 600 /xxx/id_rsa 如果用的是wsl可能会修改失败，需要加上wsl的配置，修改/etc/wsl.conf（如果没有就新建） vim /etc/wsl.conf 输入： [automount] enabled = true options = &quot;metadata,umask=22,fmask=11&quot; mountFsTab = false 退出wsl重启，然后再修改权限，应该就没问题了。 2 scp scp是secure copy的缩写，一般用于从服务器下载文件或上传文件到服务器，与ssh类似，可以使用密码认证或密钥认证或指定端口。 2.1 上传文件（夹）到服务器 scp localFile username@xxx.xxx.xxx.xxx:/xxxx scp -r localDir username@xxx.xxx.xxx.xxx:/xxx 上面是密码认证的方式，密钥认证请加上i参数，指定私钥位置： scp localFile username@xxx.xxx.xxx.xxx:/xxx scp -i /xxx/id_rsa -r localDir username@xxx.xxx.xxx.xxx:/xxxx 需要特定端口请加上P参数（注意是大写，不是ssh的小写p端口参数） scp -i /xxx/id_rsa -P xx localFile username@xxx.xxx.xxx.xxx 2.2 从服务器下载文件（夹） scp username@xxx.xxx.xxx.xxx:/xxx /localDir scp -r username@xxx.xxx.xxx:/xxx /localDir 第一个是下载文件，第二个是下载文件夹，需要加上r参数。 同理，密钥认证加i参数，端口加P参数： scp -i /xxx/id_rsa -P xx username@xxx.xxx.xxx.xxx:/xxx /localDir scp -i /xxx/id_rsa -P xx -r username@xxx.xxx.xxx.xxx:/xxx /localDir ","link":"https://2293736867.github.io/post/sshscp-ji-ben-shi-yong/"},{"title":"Nginx/Apache + acme.sh 实现https访问","content":" 1 概述 2 准备工作 2.1 域名与服务器 2.2 域名解析 2.2 端口 3 Nginx 3.1 编译安装的Nginx(1.17.9) 3.1.1 安装Nginx 3.1.2 证书处理 3.1.3 Nginx配置 3.1.4 测试 3.2 从仓库安装Nginx(1.16.1) 3.2.1 安装Nginx 3.2.2 证书处理 3.2.3 Nginx配置 3.2.4 测试 4 Apache 4.1 编译安装的Apache(2.4.41) 4.1.1 安装Apache 4.1.2 证书处理 4.1.3 Apache配置 4.1.4 测试 4.2 从仓库安装的Apache(2.4.6) 4.2.1 安装Apache 4.2.2 证书处理 4.2.3 Apache配置 4.2.4 测试 5 总结 1 概述 acme.sh实现了acme协议，可以从Let‘s Encrypt生成免费的ssl证书用于实现https，本文介绍了常见的两种服务器Apache与Nginx上利用acme.sh配置https服务。 约定: APACHE_INSTALL_DIR --- Apache安装目录 NGINX_INSTALL_DIR --- Nginx安装目录 www.test.com --- 测试域名,请按需要换成自己的域名 2 准备工作 一个域名 一台云服务器 2.1 域名与服务器 域名与服务器直接买就好了，笔者的都是在阿里云上买的。 2.2 域名解析 需要确保域名可以解析到对应的ip上面，一般的域名购买商会提供解析服务，按图形界面操作即可，以阿里云为例，选择域名进行解析： 主机记录填www，记录值填服务器公网ip. 间隔十分钟左右可以ping一下自己的域名，如果显示服务器ip则解析成功。 2.2 端口 服务器要开启80与443端口，80用于HTTP测试，443用于HTTPS访问。以阿里云为例: 3 Nginx Nginx有两种安装方式，一种是仓库形式安装，另一种是从源码编译安装。 3.1 编译安装的Nginx(1.17.9) 3.1.1 安装Nginx 先去下载源码，上传到服务器，解压： tar -zxvf nginx-1.17.9.tar.gz cd nginx-1.17.9 可以先使用 ./configure --help 查看选项帮助，这里要注意一下pcre与openssl，是源码目录，不是安装目录，安装之后删了源码的，重新来这里下载pcre与这里下载openssl，注意一定需要http_ssl_module这个模块，不要漏了。 ./configure --prefix=/xxxxx --with-pcre=/xxxxx --with-openssl=/xxxx --with-http_ssl_module make sudo make install 好了之后进入安装目录下的sbin，启动服务。 cd NGINX_INSTALL_DIR/sin ./nginx 然后可以在浏览器输入服务器公网ip测试一下： 3.1.2 证书处理 首先安装acme.sh curl https://get.acme.sh | sh . ~/.bashrc 生成证书 acme.sh --issue -d www.test.com --webroot NGINX_INSTALL_DIR/html webroot的话就直接使用Nginx的默认文档根目录。好了之后会看到这样的提示： 接着安装证书： acme.sh --installcert \\ -d www.test.com \\ --keypath /xxxx/xxx.key \\ --fullchainpath /xxx/xxx.pem 路径与名字随便，后缀不能变。 3.1.3 Nginx配置 修改Nginx配置文件： cd NGINX_INSTALL_DIR/conf cp nginx.conf nginx.conf.bak vim nginx.conf 找到HTTPS server这一行，这里是96行，把从server开始到最后一个花括号的代码全部去掉注释。 然后修改这三行，server_name填域名，ssl_certificate填刚才的pem文件路径，ssl_certificate_key填刚才的key文件路径。路径建议绝对路径，可以不加双引号。 记得记得要加上一行ssl协议： 3.1.4 测试 可以先使用-t测试语法错误： cd NGINX_INSTALL_DIR/sbin ./nginx -t ok的话，重启服务并输入域名测试： cd NGINX_INSTALL_DIR/sbin ./nginx -s stop ./nginx 成功！ 3.2 从仓库安装Nginx(1.16.1) 3.2.1 安装Nginx 从仓库安装就简单多了，一行就可以了，系统Centos，其他自行搜索： yum install nginx 可以先测试一下，直接用 nginx 开启服务，然后浏览器输入公网ip： （笔者有点怀疑是不是装了个假的Nginx，两个的主页居然不一样。。。。） 3.2.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot /usr/share/nginx/html 安装证书： acme.sh --installcert \\ -d www.test.com \\ --keypath /xxxx/xxx.key \\ --fullchainpath /xxx/xxx.pem 3.2.3 Nginx配置 同样先备份： cd /etc/nginx cp nginx.conf nginx.conf.bak vim nginx.conf 这里的配置比编译安装的又多了不少，一样从server（61行）开始去掉注释： 然后修改三行： server_name填域名，ssl_certificate填pem文件，ssl_certificate_key填key文件。 最后增加一行ssl协议： 3.2.4 测试 可以先用-t测试语法错误： nginx -t ok的话重启服务： nginx -s stop nginx 浏览器输入域名访问： 4 Apache Apache也有两种安装方式，从源码编译安装与从仓库安装。 4.1 编译安装的Apache(2.4.41) 4.1.1 安装Apache 编译安装Apache比较麻烦，需要安装pcre，apr，apr-util，生成Makefile时需要指定以下几个选项： --with-apr \\ --with-apr-util \\ --with-pcre \\ --enable-ssl \\ --with-ssl 具体可以看这里。 安装好了之后需要先确定ssl模块是否存在： cd APACHE_INSTALL_DIR/modules ls | grep ssl 如果没有显示mod_ssl.so，则需要重新安装，确定生成Makefile时没有漏掉 --enable-ssl 与 --with-ssl 如果有ssl模块，直接修改配置文件测试一下。 cd APACHE_INSTALL_DIR/conf vim httpd.conf 修改ServerName为 localhost:80 启动服务输入localhost测试： cd APACHE_INSTALL_DIR/bin ./apachectl 页面只有一行It works!： （话说这和仓库安装的Apache首页差距这么大。。。） 4.1.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot APACHE_INSTALL_DIR/htdocs 这里webroot为Apache默认的文档根目录. 安装证书： acme.sh --installcert -d www.test.com \\ --key-file /xxxx/xxx.key \\ --cert-file /xxxx/xxxx.crt \\ --fullchain-file /xxx/xxxfullchain.crt 路径与名字随便，后缀名不能变。 4.1.3 Apache配置 首先修改conf/httpd.conf： cd APACHE_INSTALL_DIR/conf cp httpd.conf httpd.conf.bak vim httpd.conf 找到这三行，去掉注释。 然后修改httpd-ssl.conf: cd extra cp http-ssl.conf http-ssl.conf.bak vim httpd-ssl.conf DocumentRoot可以默认，ServerName改成 www.test.com:443 然后修改这三行，把证书的文件相应填入。 4.1.4 测试 语法检查： cd APACHE_INSTALL_DIR/bin ./apachectl -t 没有错误之后重启服务： ./apachectl stop ./apachectl 浏览器输入域名访问： 4.2 从仓库安装的Apache(2.4.6) 4.2.1 安装Apache yum install httpd 修改配置文件并进行测试： cd /etc/httpd/conf cp httpd.conf httpd.conf.bak vim httpd.conf 找到ServerName改成 localhost:80 开启服务后输入localhost:80. systemctl start httpd 另外要确保ssl模块存在： cd /etc/httpd/modules ls | grep ssl 如果没有输出的话，证明没有ssl模块，需要安装： yum install mod_ssl 再一次grep： ls | grep ssl 4.2.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot /var/www/html 其中/var/www/html为Apache默认文档根目录。 安装证书： acme.sh --installcert -d www.test.com \\ --key-file /xxxx/xxx.key \\ --cert-file /xxxx/xxxx.crt \\ --fullchain-file /xxx/xxxfullchain.crt 4.2.3 Apache配置 修改ssl.conf: cd /etc/httpd/conf.d cp ssl.conf ssl.conf.bak vim ssl.conf 修改ServerName与DocumentRoot，ServerName填域名，DocumentRoot直接去掉注释。接着修改以下三行，根据刚才生成的三个文件对应填入即可。 4.2.4 测试 apachectl -t 没有语法错误就重启服务： systemctl stop httpd systemctl start httpd 浏览器输入访问： 5 总结 其实这里采用了比较麻烦的方式手动安装证书，acme.sh其实还有更简单的不需要webroot的命令： acme.sh --issue -d www.test.com --apache acme.sh --issue -d www.test.com --nginx 另外还可以通过手动dns的方式： acme.sh --issue -d www.test.com --dns dns_xxx 这种方式可以利用域名解析商提供的api自动添加记录完成认证，可以参考这里。 另外文章没有说到证书过期更新的问题，可以看官方中文说明，这里。 除此之外还可以利用openssl使安全性的评分更高，测试网站这里，修改配置这里。 还有最后一个,现有云服务器厂商提供了免费的证书购买，如阿里云，可以直接购买免费证书然后利用文档安装到服务器上。 祝你们早日有一个属于自己的https的网站。 ","link":"https://2293736867.github.io/post/nginxapache-acmesh-shi-xian-https-fang-wen/"},{"title":"Github Pages+Gridea搭建个人博客","content":"1 概述 Github Pages可以用来托管个人网站，静态的，便于用来实现博客，可以在一个仓库的settings中开启： Gridea是一个静态博客写作客户端，所有文件都在本地，没有数据库，实现简单，支持Markdown。 好了不多说开始动手。 2 准备工作 一个Gthub账号 一个Github Pages的仓库 一个Gridea客户端（支持Mac，Windows，Linux） （可选）一个域名 3 Github Pages 仓库名是: 用户名.github.io 需要公开仓库与一个REDAME文件,然后创建. 进入设置开启Github Pages: 下拉找到Github Pages: 默认使用master分支,可以选择主题. 然后在浏览器输入刚才创建的仓库名就可以访问了. 4 Gridea 理论上来说这样就完成了,但是如果想更好看和更方便管理一些,就要用Gridea. 先去下载,官网这里. 下载之后直接打开,进入设置: 域名与仓库名一样,分支填master,email自己填,这里说一下Token.打开设置中的开发者设置: 新建一个Token: 只需要勾选仓库相关的权限,名字可以随便. 复制填入. 然后可以测试一下连接: 若失败请返回前几步看看哪里出错. 设置好了之后可以设置主题等,自定义美化. 设置好了之后可以先预览再同步. 同步完成后就可以在浏览器输入 用户名.github.io 进行访问了. 5 绑定域名(可选) 如果购买了域名的话,可以绑定到自己的域名上面,笔者的域名是阿里云上购买的,因此这里以阿里云的为例,进入域名的解析页面,添加两个记录: 第一个记录类型是CNAME,主机记录是www,记录值为仓库的名字. 第二个记录类型是A,主机记录是@,记录值为ping仓库名字得到的ip. 若成功的话会这样显示: 添加之后在Gridea的客户端中设置的CNAME添加域名: 使用左下角的按钮测试一下,测试通过之后就可以通过域名访问了. 如果想通过https访问,直接在Github Pages中设置Enforce HTTPS即可(解析域名之后需要一定时间才可以勾选). 之后就可以通过https访问了. ","link":"https://2293736867.github.io/post/github-pagesgridea-da-jian-ge-ren-bo-ke/"},{"title":"编译安装Apache遇到的缺少expat.h与undefined reference to `XML_GetErrorCode'错误","content":"1 缺少expat.h 编译安装Apache需要apr-util，而在编译安装apr-util时提示说缺少expat.h，此时直接安装expat库即可（centos）： yum install expat-devel 2 undefined reference to `XML_GetErrorCode' 首先安装libxml2-devel包： yum install libxml2-devel 接着删除apr-util安装目录并重新编译安装： sudo rm -rf /usr/local/apr-util cd apr-util make clean ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr make make install 目录的话根据需要修改，最后重新编译安装apache： cd httpd-xxxxx make clean ./configure \\ --prefix=/usr/local/apache \\ --with-apr=/usr/local/apr \\ --with-apr-util=/usr/local/apr-util \\ --with-pcre=/usr/local/pcre 同样目录按需修改。 ","link":"https://2293736867.github.io/post/bian-yi-an-zhuang-apache-yu-dao-de-que-shao-expath-yu-undefined-reference-to-xml_geterrorcodecuo-wu/"},{"title":"Android Activity间跳转与传递数据","content":" 1 概述 2 Activity间跳转 2.1 直接跳转 2.2 回调 3 Activity间传递数据 3.1 传递普通数据 3.2 传递一组数据 3.3 传递对象 4 源码 1 概述 Activity之间的跳转主要使用 startActivity(Intent intent); startActivityForResult(Intent intent,int requestCode); 这两个函数,传递数据的话利用Intent进行传递,负责数据需要配合Bundle使用.这篇文章讲述了如何利用这两个函数在Activity之间的跳转以及传递数据. 2 Activity间跳转 2.1 直接跳转 这里有两个Activity:FirstActivity与SecondActivity,从FirstActivity中跳转到SecondActivity中只需要一个startActivity()即可: startActivity(new Intent(this,SecondActivity.class)); 一般需要在SecondActivity中加上finish()函数,表示这个Activity结束,比如这里直接在SecondActivity的按钮事件里面加上了finish(): 2.2 回调 很多情况下需要在FirstActivity跳转到SecondActivity后,在SecondActivity进行相应的操作,如更新数据之类,然后返回FirstActivity,通知FirstActivity执行某些操作,这时候就需要使用startActivityForResult(). startActivityForResult有两个参数,一个是Intent,表示将要跳转的Activity,一个是requestCode(int类型),表示请求码,用于调用Activity的onActivityResult()函数. 如FirstActivity中: startActivityForResult(new Intent(this,SecondActivity.class),11); 这里11就是请求码,然后在SecondActivity中,使用setResult()函数: setResult(22,new Intent().putExtra(&quot;str&quot;,&quot;from second activity&quot;)); setResult()接受两个参数,第一个参数表示resultCode,从这个SecondActivity返回的结果码,另一个Intent,表示要返回给FirstActivity的数据. 最后在FirstActivity中重载onActivityResult(): onActivityResult中判断请求码与结果码后进行相应操作. 3 Activity间传递数据 3.1 传递普通数据 传递普通类型的数据直接使用Intent的putExtra()即可,putExtra接受两个参数,第一个是一个String,表示键,第二个是值,类型可以是byte,char,short,long等基本类型与这些基本类型组成的数组,当然String也可以. 比如在FirstActivity中,传递数据给SecondActivity: 然后在SecondActivity中使用getIntent()获取Intent后,再从里面获取数据: 如果想从SecondActivity中返回数据给FirstActivity,也就是从被调用的Activity中返回数据,可以使用前面介绍过的setResult()方法. 其中第二个参数是一个用于存储数据的Intent,把数据put进去即可. 最后记得在onActivityResult做相应的判断处理: 3.2 传递一组数据 当数据的种类变多时,比如混合了int,String,byte,char等,可以对逐个类型使用putExtra(),但更好的方法是使用Bundle. Bundle的使用与Intent类似,也是对于不同的类型采用键值对的添加方法,直接putXXX: 数据添加完毕之后,在intent中使用putExtras(bundle): 然后就可以在SecondActivity中接收数据了. 首先需要使用getIntent().getExtras()获取Bundle,再获取里面的数据. 注意一下获取到的Bundle有可能为null,取数据前需要判断一下. 3.3 传递对象 如果想要传递的数据是一个对象怎么办?难道对每一个属性都使用getter再放进去吗? 并不是,Bundle提供了一个处理序列化对象的方法: 只要对象实现了Serializable,就可以被Bundle处理,比如这里有一个测试类Student: 然后在FirstActivity中直接new一个,并使用Bundle的putSerializable即可. 接着再SecondActivity中通过Intent取出Bundle后,使用其中的getSerializable()取出对象,最后使用强制类型转换: 4 源码 github 码云 ","link":"https://2293736867.github.io/post/android-activity-jian-tiao-zhuan-yu-chuan-di-shu-ju/"},{"title":"一文吃透jQuery选择器!","content":" 1 jQuery选择器 2 基本选择器 2.1 id选择器 2.2 元素选择器 2.3 类选择器 2.4 通配符选择器 2.5 组合选择器 3 层级选择器 3.1 后代选择器 3.2 子代选择器 3.3 相邻选择器 3.4 兄弟选择器 4 过滤选择器 4.1 基本过滤器 4.1.1 两端类 4.1.2 范围索引类 4.1.3 奇偶类 4.1.4 其他 4.2 内容过滤器 4.3 可见性过滤器 4.4 属性过滤器 4.5 子元素过滤器 4.5.1 索引过滤器 4.5.1.1 first-child与last-child 4.5.1.2 nth-child与nth-last-child(1.9+) 4.5.2 类型过滤器(1.9+) 4.5.3 唯一过滤器 4.6 表单对象属性过滤器 5 表单选择器 5.1 文本框类 5.2 选择框类 5.3 按钮类 5.4 其他 5.5 例子 1 jQuery选择器 jQuery选择器用于选择DOM元素进行相应操作,允许通过多种方式选择,包括标签名,属性名,类名,id等对元素进行选择,基于CSS选择器.jQuery中所有的选择器都以$符号开头,后面加一对括号. jQuery选择器可以分为基本选择器,层次选择器,过滤选择器与表单选择器. 2 基本选择器 基本选择器可以分成五个: id选择器 元素选择器 类选择器 通配符选择器 组合选择器 2.1 id选择器 id选择器根据给定的id匹配一个元素,以 # 开头,如有: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 则选择器 $(&quot;#div1&quot;) 会选择 如果id中含有特殊字符,比如点: &lt;div id=&quot;div1.1.1&quot;&gt;&lt;/div&gt; 则需要使用双反斜杠转义: $(&quot;#div1\\\\.1\\\\.1&quot;) 2.2 元素选择器 根据元素的标签名查找所有符合的元素.假设有: &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; 选择器 $(&quot;div&quot;) 会选择所有div元素. 2.3 类选择器 根据给定的css类名匹配元素,以 . 开头.如有: &lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; &lt;p class=&quot;class1&quot;&gt;&lt;/p&gt; &lt;div class=&quot;class2&quot;&gt;&lt;/div&gt; 选择器 $(&quot;.class1&quot;) 会选择: 选择器 $(&quot;.class2&quot;) 会选择: 2.4 通配符选择器 选择所有的元素. &lt;div&gt;div&lt;/div&gt; &lt;p&gt;p&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; $(&quot;*&quot;) 会显示 也就是说整个&lt;html&gt;都在选择范围内,不仅仅是&lt;body&gt;. 若要选择&lt;body&gt;内的元素,可用 $(&quot;body *&quot;) 2.5 组合选择器 组合选择器就是多个选择器的组合,用 , 分隔每一个选择器,如有: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;class2&quot;&gt;&lt;/div&gt; $(&quot;#div1,p,.class2&quot;) 会选择 3 层级选择器 层级选择器共有四种:后代选择器,子代选择器,相邻选择器,兄弟选择器. 3.1 后代选择器 根据祖先元素选择所有的后代元素,使用空格分隔,如有 &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; $(&quot;#div1 div&quot;) 会选择 3.2 子代选择器 选择给定父元素下的所有子元素,使用 &gt; 分隔,同样上面的例子: $(&quot;#div1&gt;div&quot;) 会选择 两者的区别在于后代选择器会选择所有的后代,不管里面有多少后代(层),而子选择器只会选择直接后代,也就是只选择&quot;一代&quot;后代(层). 3.3 相邻选择器 选择紧接在指定元素后面的元素,用 + 分隔,如有 &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; $(&quot;#div1+p&quot;) 会选择 可用 .next() 代替,如上面的例子可以变为 $(&quot;#div1&quot;).next() 3.4 兄弟选择器 选择之后的所有兄弟元素,用 ~ 分隔,如有 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; 则 $(&quot;div~p&quot;) 会选择 可用 .nextAll() 代替,如上面的例子可以表示为: $(&quot;div&quot;).nextAll(&quot;p&quot;) 如果没有加上p选择器: $(&quot;div&quot;).nextAll() 会选择 等价于 $(&quot;div~*&quot;) 与相邻选择器的区别:兄弟选择器会选择后面所有的兄弟,而相邻选择器只选择第一个兄弟. 4 过滤选择器 过滤选择器种类最多,可以分为: 基本过滤器 内容过滤器 可见性过滤器 属性过滤器 子元素过滤器 表单对象属性过滤器 下面一个个进行说明. 4.1 基本过滤器 根据某类过滤规则进行选择,以 : 开头. 4.1.1 两端类 过滤器 作用 :first 选择第一个元素 :last 选择最后一个元素 html: &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div&gt;p:first&quot;) $(&quot;div&gt;p:last&quot;) 4.1.2 范围索引类 过滤器 作用 :eq(index) 选择指定索引值元素 :gt(index) 选择大于给定索引值元素 :lt(index) 选择小于给定索引值元素 注意索引从0开始,要与下面的:nth-child/:nth-last-child/:nth-of-type/:n-last-of-type区分. html: &lt;div&gt; &lt;p id=&quot;index0&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index5&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div&gt;p:eq(3)&quot;) $(&quot;div&gt;p:lt(2)&quot;) $(&quot;div&gt;p:gt(4)&quot;) 4.1.3 奇偶类 选择索引值为奇/偶的元素,从0开始计数. 过滤器 作用 :odd 选择索引值为奇数的元素 :even 选择索引值为偶数的元素 html: &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div&gt;p:odd&quot;) $(&quot;div&gt;p:even&quot;) odd为什么是246?even为什么是135? 难道结果错了? 并不是,下标从0开始计数,下标为0的&lt;p&gt;的id为p1,算进去偶数里了. 4.1.4 其他 过滤器 作用 :header 选择标题元素,如&lt;h1&gt;,&lt;h2&gt; :animated 选择正在执行动画效果的元素 :focus(1.6+) 选择当前获取焦点的元素 :root(1.9+) 选择根元素,也就是&lt;html&gt; :target(1.9+) 这个比较特殊,与URI有关,选择ID和特定标识符相匹配的元素比如给定了URI http://xxx.com#ttt , $(&quot;p:ttt&quot;)会选择&lt;p id=&quot;ttt&quot;&gt; :lang(language)(1.9+) 选择指定语言的所有元素 :not(selector) 反选器 挑取一些简单演示,html: &lt;div lang=&quot;en&quot;&gt; &lt;h1 id=&quot;h1&quot;&gt;&lt;/h1&gt; &lt;h2 id=&quot;h2&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div lang=&quot;zh-CN&quot;&gt;&lt;/div&gt; &lt;div lang=&quot;en&quot;&gt;&lt;/div&gt; 选择器: $(&quot;:header&quot;) $(&quot;:root div&quot;) $(&quot;div:not(:lang(zh-CN))&quot;) 4.2 内容过滤器 四种: 过滤器 作用 :contains(text) 选择包含给定文本的元素 :has(selector) 选择含有过滤器所匹配的元素的元素 :empty 选择不包含子元素或文本为空的元素 :parent 选择含有子元素或文本为的元素 html: &lt;div id=&quot;div1&quot;&gt;123&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;123&lt;/div&gt; &lt;div id=&quot;div5&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; 选择器: $(&quot;body *:contains(123)&quot;) $(&quot;body *:has(#div3)&quot;) $(&quot;body *:empty&quot;) $(&quot;div:parent&quot;) 4.3 可见性过滤器 过滤器 作用 :visible 选择可见元素 :hidden 选择不可见元素 html: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; 选择器: $(&quot;body *:hidden&quot;); $(&quot;body *:visible&quot;); 4.4 属性过滤器 属性过滤器针对元素的属性进行过滤,包括有没有该属性,该属性的值,以某些值开头/结尾,包含某些值等,使用 [] 表示属性过滤器. 过滤器 作用 [attr] 选择包含attr属性的元素,常见的是[id],选择包含id属性的元素. [attr=value] 选择attr属性为value的元素,如[name=123],[id=div1] [attr!=value] 选择不含有attr属性,或含有attr属性,但是值不为value的元素.等价于:not([attr=vale])如果想要选择包含特定属性但是属性值不为value的元素请使用[attr]:not([attr=value]) [attr^=value] 选择attr属性值是以value开始的元素 [attr$=value] 选择attr属性值是以value结尾的元素 [attr*=value] 选择attr属性值是包含value的元素 html: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot; name=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot; name=&quot;div3&quot;&gt;&lt;/div&gt; 选择器: $(&quot;[id]&quot;) $(&quot;[id$=3]&quot;) $(&quot;body *[name!=div2]&quot;) $(&quot;body *[name*=div]&quot;) 4.5 子元素过滤器 可以按照索引顺序(即第一个,倒数第几个等)或者按照类型或者按照唯一性对子元素进行过滤. 4.5.1 索引过滤器 过滤器 作用 :first-child 选择第一个子元素,等价于:nth-child(1) :last-child 选择最后一个子元素 :nth-child 选择第n个子元素 :nth-last-child 选择倒数第n个子元素 4.5.1.1 first-child与last-child 先来看看first-child与last-child: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:first-child&quot;) $(&quot;div p:last-child&quot;) 注意与:first/:last的区别,:first/:last只会选择整个父级元素的第一个/最后一个元素,但是:first-child/:last-child会选择每个父级元素的第一个/最后一个元素. :first/:last把所有符合的元素看作一个整体,即使其中有并列的父级元素,而:first-child/:last-child把每个父级元素单独看待,选择每个父级元素的第一个/最后一个元素. 4.5.1.2 nth-child与nth-last-child(1.9+) nth-child选择父元素下第n个元素,注意,从1开始计数. &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:nth-child(3)&quot;) 注意与:eq的区别,有点类似:first/:first-child的区别,:eq会把所有符合条件的元素看作一个整体,而且不要忘记:eq是从0开始计数. 另一方面,nth-child支持奇偶与代数表达式,比如: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p7&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p8&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p9&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p10&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p11&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:nth-child(odd)&quot;) $(&quot;div p:nth-child(even)&quot;) $(&quot;div p:nth-child(3n+1)&quot;) $(&quot;div p:nth-child(4n-3)&quot;) 计数也是从1开始. nth-last-child与nth-child类似,需要1.9以上的版本,看名字就知道,是选择倒数第n个的,同样支持奇偶与代数表达式. $(&quot;div p:nth-last-child(2)&quot;) $(&quot;div p:nth-last-child(odd)&quot;) $(&quot;div p:nth-last-child(even)&quot;) $(&quot;div p:nth-last-child(3n+1)&quot;) 对于nth-last-child的odd/even/代数表达式来说,从最后一个符合条件的开始选择,但是按原来的顺序排列. 4.5.2 类型过滤器(1.9+) 有四种: :first-of-type :last-of-type :nth-of-type :nth-last-of-type first-of-type会选择符合条件的元素的父元素的第一个该类型的子元素. 例如, &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;p:first-of-type&quot;) 若使用id选择器: $(&quot;#p2:first-of-type&quot;) 则结果为空. 为什么? 因为此时选择的是id为p2的元素,但是这个 &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; 的前面有一个 &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; 也就是说 &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; 不是第一个孩子,因此选择为空,此时若把第一个孩子注释: &lt;div id=&quot;div1&quot;&gt; &lt;!-- &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; --&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 则 $(&quot;#p2:first-of-type&quot;) 会选择 多个父级元素也是一样的道理: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p class=&quot;a&quot; id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;/div&gt; $(&quot;.a:first-of-type&quot;) last-of-type/nth-of-child/nth-last-of-type类似,要注意的是nth-of-child/nth-last-of-type都支持奇偶与代数表达式,计数从1开始. 4.5.3 唯一过滤器 两种: only-child only-of-type(1.9+) 如果某个元素是它父元素的唯一子元素,则only-child会选择该(子)元素. &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div p:only-child&quot;) 会选择 注意文本并不会影响选择的结果,也就是说,改成 &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; 456 &lt;p id=&quot;p3&quot;&gt;123&lt;/p&gt; 456 &lt;/div&gt; 后,选择器不变,选择的结果只是p里面多了文字: 而如果某个元素的父元素只有唯一一个该元素类型的子元素,则only-of-type会选择该元素,注意是类型,不是数量. 上面的only-child指的是数量,也就是只有一个孩子,这里only-of-type指的是类型,只有一个这种类型的孩子,而不管孩子数量. &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; $(&quot;div p:only-of-type&quot;) 会选择 而如果选择器换成only-child: $(&quot;div p:only-child&quot;) 则会选择 4.6 表单对象属性过滤器 选择以下三种状态的元素: 可用 不可用 选中 过滤器 作用 :enabled 选择可用元素 :disabled 选择不可用元素 :checked 选择所有被选中的元素 :selected 选择所有被选中的option元素(针对&lt;select&gt;) &lt;input type=&quot;checkbox&quot; checked/&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;input type=&quot;radio&quot; id=&quot;disabled&quot; disabled/&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;select&gt; &lt;option value=&quot;1&quot;&gt;&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;&lt;/option&gt; &lt;/select&gt; $(&quot;body *:enabled&quot;) $(&quot;:disabled&quot;) $(&quot;:selected&quot;) $(&quot;:checked&quot;) 5 表单选择器 5.1 文本框类 过滤器 作用 :text 选择所有文本框 :password 选择所有密码框 5.2 选择框类 过滤器 作用 :radio 选择所有单选框 :checkbox 选择所有多选框 5.3 按钮类 过滤器 作用 :submit 选择所有提交按钮 :reset 选择所有重置按钮 :button 选择所有按钮 5.4 其他 过滤器 作用 :image 选择所有图像域 :file 选择所有文件域 5.5 例子 &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;input type=&quot;radio&quot; /&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;input type=&quot;button&quot; /&gt; &lt;input type=&quot;image&quot; /&gt; &lt;input type=&quot;file&quot; /&gt; $(&quot;:text&quot;) $(&quot;:password&quot;) $(&quot;:radio&quot;) $(&quot;:checkbox&quot;) $(&quot;:submit&quot;) $(&quot;:reset&quot;) $(&quot;:button&quot;) $(&quot;:image&quot;) $(&quot;:file&quot;) ","link":"https://2293736867.github.io/post/yi-wen-chi-tou-jquery-xuan-ze-qi/"},{"title":"Android Studio sync失败","content":"1 原因 sync失败或gradle同步慢的原因基本上就是网络的问题,这里采用的办法是在Maven的设置文件添加国内镜像. 2 添加镜像 Maven的settings.xml中,在&lt;mirrors&gt;中添加: &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这样android studio同步的速度就会很快了. ","link":"https://2293736867.github.io/post/android-studio-sync-shi-bai/"},{"title":"jQuery hello world","content":"1 jQuery jQuery是一个js库,一个js文件,极大地简化了编程,官网链接在这里,有compressed,uncompressed版本,使用时一样. 2 hello world &lt;html&gt; &lt;head&gt; &lt;title&gt;jquery hello world&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;p&quot;).html(&quot;hello world&quot;); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; jQuery使用时直接从官网引入文件即可,这里用的是3.4.1版本. $(function()) 是 $(document).ready(function(){}) 的缩写,这个函数会在DOM加载完成后执行. $(&quot;p&quot;) 表示选择页面的所有&lt;p&gt;元素,html()可以设置元素的内容. ","link":"https://2293736867.github.io/post/jquery-hello-world/"},{"title":"MySQL数据类型全解析","content":"1 概述 本文主要介绍了MySQL的各种数据类型,版本为8.x, MySQL的数据类型可以分为六类:数值类型,日期时间类型,字符串类型,二进制类型,JSON类型与空间数据类型. 2 数值类型 数值类型是最基本的类型,可以分为整数类型与浮点数类型. 2.1 整型 类型 字节数 无符号范围 有符号范围 TINYINT 1 [0,255] [-128,127] SMALLINT 2 [0,65535] [-32768,32767] MEDIUMINT 3 0-1677w +-838w INT/INTEGER 4 0-42e +-21e BIGINT 8 0-18446744e +-9223372e 没写出的具体的精确值无符号的范围计算公式如下: 有符号的计算公式如下: 所有整形如果允许NULL的话默认为NULL,不允许为NULL的需要手动设置默认值. 如果插入或修改的数据范围不符合会提示操作失败,如上图提示列c_mediumint的数据超出范围. 2.2 浮点型 可以用两种方式来表示小数,分别是浮点数类型与定点数类型. 浮点数用于不需要太精确的小数场合,类型包括FLOAT与DOUBLE,定点数类型就是DECIMAL. 类型 字节数 范围 FLOAT 4 +- 1.17e-38 - 3.4e+38 和 0 DOUBLE 8 +- 2.22e-308 - 1.79e+308 和 0 DEC(M,D)/DECIMAL(M,D) 取决于M与D 取决于M与D 下面是测试的待插入的数据: 插入之后再查询: 可以看到,float的精度最高为6位,后面的进行四舍五入,DOUBLE的最高精度为15位. 下面来说一下DECIMAL. 2.3 DECIMAL DECIMAL也可用DEC来表示,用于计算精确的小数值,DECIMAL通常如下表示: DECIMAL(M,D) 类型 含义 取值范围 默认值 M 十进制有效数字总个数 1-65 10 D 小数点后十进制数字个数 0-30(D&lt;=M) 0 如果要计算所占用的字节数,需要分为整数与小数两部分,分开计算再相加,每部分又按照9位数字去拆分,计算规则如下: 位数 占用字节数 1-2 1 3-4 2 5-6 3 7-9 4 也就是说对于 DECIMAL(24,8) 整数部分24-8=16位,小数部分8位,小数部分的8位根据规则所占用的字节数为4个,整数部分按每9位进行拆分,16=9+7,9位的部分占4个字节,7位的部分按照规则也占4个字节,所以整数部分占8个字节,加上小数部分的4个字节,总共占12个字节. 至于NUMERIC,在MySQL中,NUMERIC被实现为DECIMAL: 3 日期与时间类型 总共有五类:YEAR,TIME,DATE,DATETIME,TIMESTAMP. 3.1 日期 日期有两种类型:YEAR与DATE,YEAR表示年,DATE表示日期. 类型 字节数 取值范围 YEAR 1 [1901,2155] DATE 3 [1000-01-01,9999-12-31] DATE中的年月日插入时可以不分隔或者用各种符号进行分隔,比如 ! @ # $ % ^ &amp; * ( ) - / \\ [ ] { } : ; ' &quot; | , . &lt; &gt; ? 上图中的date都是合法的,插入之后MySQL都会统一用横杠代替: YEAR的话MySQL其实允许两位数的YEAR,其中00-69表示2000-2069,70-99表示1970-1999. 其他插入方式的话可以用CURRENT_DATE,CURRENT_DATE(),CURDATE(),NOW(),CURTIME(),CURRENT_TIME,CURRENT_TIME(): 3.2 时间 时间就一种类型:TIME. TIME所占的字节数为3个字节,取值范围为: [-838:59:59,838:59:59] 插入时时分秒可以不分隔或者必须以冒号分隔. 插入后统一变为冒号分隔: 可以使用CURRENT_TIME或CURRENT_TIME(),CURTIME()或NOW()插入: 甚至也可以使用CURDATE(),不过此时插入的是零值: 3.3 日期+时间 TIMESTAMP与DATETIME: 类型 字节数 取值范围 DATETIME 8 [1000-01-01 00:00:00,9999-12-31 23:59:59] TIMESTAMP 4 [19700101080001,20380119111407] DATETIME就是DATE与TIME的结合,先DATE再TIME,空格分隔. TIMESTAMP表示时间戳,表示当前时间到1970年1月1日0时0分0秒经过的秒数,中的写法是年月日时分秒,比如 19700101080001 表示 1970年1月1日8时0分01秒 这里之所以使用080001是因为中国的时区. 19700101000000 会报错,范围不允许. 19700101080000 也不行. 在插入时可以指定默认值,使用now()或CURRENT_TIMESTAMP: 插入后DATETIME与TIMESTAMP存储的形式一致,横杠分隔日期,冒号分隔时间,时间与日期用空格隔开. 也可以使用CURTIME()或CURDATE()插入,对于CURTIME(),日期采用当前日期,对于CURDATE(),时间采用 00:00:00 4 字符串类型 4.1 CHAR/VARCHAR 类型 最大长度 特点 CHAR 255个字符 长度固定,CHAR(M)表明CHAR的长度为M个字符,所占用的字节数为字符个数*每个字符所占用字节数,也就是说与字符集有关,定长的效率较高,一般用于存储固定位数的数据或经常需要更新的数据,如电话号码,身份证,MD5值等.保存CHAR时,会在末尾填充空格用于对齐,查询时自动把空格删除 VARCHAR 65535字节,字符个数为(最大行大小-NULL标识-长度标识)/字符集单字符最大字节数,可以看这里 长度不固定,实际占用的空间为字符串实际长度+1/2,也就是说需要额外的1或2个字节记录字符串的长度.相对来说VARCHAR比CHAR更节省空间,但是在UPDATE时可能会使行变得更长,需要做额外的工作.VARCHAR适合存储字段更新少,字符串平均长度不稳定的情况 无论是CHAR还是VARCHAR,超过了创建时指定的长度便插入失败: 4.2 TEXT TEXT是一种专用于存储长文本的变长数据类型,包括TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT: 类型 允许长度(字节) 存储空间 TINYTEXT [0,255] 长度+2字节 TEXT [0,65535] 长度+2字节 MEDIUMTEXT 0-1677w 长度+3字节 LONGTEXT 0-42e 长度+4字节 TEXT在插入时超过最大允许长度会插入失败. 4.3 ENUM 枚举类型,在创建表时enum的取值范围以列表的形式指定: ENUM('value1','value2',...,'valuen') ENUM占用1或2个字节,列表中最多能有65535个值,每个值末尾的空格都会被删除,列表中的每个值独有一个顺序排列的编号,MySQL会存入这个编号而不是对应的值. 等价于 即取值列表的编号从1开始. 4.4 SET SET占用1或2或3或4或8个字节,取决于里面元素的数量,最大数量为64.SET可以是一个或多个元素的组合,值后面多余的空格会被删除,取多个元素时,不同元素用逗号隔开. 如: 插入前: 插入后: 5 二进制类型 5.1 BIT BIT在创建时指定最大长度: BIT(M) M表示最大二进制数的位数,M取值1-64,默认1,插入数据时,如果数据在BIT允许的范围则插入成功,否则插入失败. 插入时需要加上b前缀,后面跟的字符串由0与1组成: 查询之后就变成了十进制: 5.2 BLOB BLOB是特殊的二进制数据类型,用来保存数据量很大的二进制数据,如图片等,BLOB包括TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOG,与TEXT类似: 类型 允许长度(字节) 存储空间 TINYBLOB [0,255] 长度+2字节 BLOB [0,65535] 长度+2字节 MEDIUMBLOB 0-1677w 长度+3字节 LONGBLOB 0-42e 长度+4字节 5.3 BINARY/VARBINARY BINARY(M)/VARBINARY(M)中的M指的是字节长度,由于BINARY/VARBINARY存储的是二进制字符串,因此没有字符集的概念. 类型 最大长度 特点 BINARY 255字节 定长,允许长度0-M的二进制字符串,不足最大长度的空间由0x00补全,查询时不会截断后面的0x00,比较时所有字节都有效 VARBINARY 65535字节 变长,不会在后面填充0x00. 下面的例子演示了插入时填充0x00: 这里的BINARY为3个字节,插入了a,等价是插入了 a\\0\\0 两个\\0填充后面两个字节,因此,前面两个比较的结果都为0. 比较时按照二进制值进行比较,这与CHAR/VARCHAR有很大不同. CHAR/VARCHAR比较的是字符值,忽略后面的空格,因此比较结果为1,但是BINARY比较的是二进制值,'a'的二进制值化为十六进制为61,'a '的二进制值化为十六进制为6120,因此比较结果为0. 6 JSON类型 JSON存储的数据不能是NULL,只能是JSON格式的数据,否则会报错, 创建很简单,直接为JSON类型: 插入时可以使用一个JSON对象或JSON数组,数组用方括号,一个对象用花括号: MySQL同时提供了一组操作JSON的函数,具体看这里. 这里演示了json_object函数,用来创建一个JSON对象: 插入后: 7 空间数据类型 Spatial数据,又叫空间或几何数据,包含的数据类型有 GEOMETRY POINT LINESTRING POLYGON 其中GEOMETRY可用于存储任意几何类型.其他集合类型的空间数据类型如下: MULTIPOINT MULTILINESTRING MULTIPOLYGON GEOMETRYCOLLECTION 其中GEOMETRYCOLLECTION可以存储任意类型的集合. 下面仅对POINT的使用作简单介绍. 插入数据使用st_geomfromtext()函数,参数是一个point(),里面的参数标识x,y坐标,空格分隔. 查询时直接 SELECT * FROM 会返回BLOB数据,需要使用st_astext(),参数为列名. 增加几行数据后,继续查询: 使用了st_x()与st_y()两个函数,分别取得point的x,y坐标. ","link":"https://2293736867.github.io/post/mysql-shu-ju-lei-xing-quan-jie-xi/"},{"title":"Chrome/Chromium的实验性功能+扩展推荐，让你的Chrome/Chromium起飞!","content":" 1 实验性功能 1.1 平滑滚动 1.2 悬停标签 1.4 并行下载 1.5 强制黑暗模式 1.6 阅读模式 1.7 扩展菜单栏 1.8 渲染级别数据优化 2 扩展推荐 2.1 AdGuard/uBlock 2.2 better-onetab 2.3 Dark Reader 2.4 Extensions Manager 2.5 Imagus 2.6 Infinity Pro 2.7 Minimal Scrollbar 2.8 Similar Sites 2.9 Tampermonkey 2.10 Vimuim 3 最后 1 实验性功能 Chrome/Chromium内置了一些很酷的实验性功能,打开 chrome://flags 即可访问.打开这些实验性功能后,浏览器的使用体验会更好,这里Chrome的版本为80.0.3987.132, Chromium的版本为82.0.4080.0,不同的版本中有不同的实验性功能,具体每一项请打开上面的访问地址进行查看. 1.1 平滑滚动 1.2 悬停标签 鼠标悬停标签显示网址与网页缩略图. 1.4 并行下载 1.5 强制黑暗模式 对所有内容使用黑暗模式. 1.6 阅读模式 开启之后会在某些页面的地址栏的在最右边的收藏五角星符号旁边多一个阅读视图的符号。 1.7 扩展菜单栏 这样就不用每次都打开&quot;更多工具&quot;了. 1.8 渲染级别数据优化 2 扩展推荐 先来一张图，这是笔者自用的扩展： 扩展不在多而在精，原本是有20多个的，然后不断精简，优化，替换，就剩下了13个扩展。 2.1 AdGuard/uBlock 去广告的扩展，原本用的是什么广告终结者，AdBlock，后来就改成了这两个。 2.2 better-onetab 原本用的是onetab，onetab其实做的不错了，只是UI确实比better-onetab差。。。 这个扩展是用于标签管理的，最常见的功能是，需要关闭浏览器，但是目前开了很多个标签，想在下一次打开浏览器时恢复这些标签，但是又不想一个一个加进收藏夹，因为完全没必要而且大部分都是一次性使用，此时better-onetab便派上了用场，单击扩展存储全部标签即可。 由于这个可能经常使用，建议打开 chrome://extensions/shortcuts 增加快捷键。 笔者这里加了两个，一个是显示扩展页面的，一个是存储所有标签的。 2.3 Dark Reader 这个嘛，看名字就知道了，黑暗模式，支持一键切换，支持不同站点，也支持亮度，对比度等的调节，非常实用，也建议加上快捷键。 比如这里加的快捷键为alt+q，然后按一下就可以切换黑暗/正常模式了。 2.4 Extensions Manager 扩展管理器，可以管理所有的扩展，一键开启/关闭，同时也支持不同环境下的快速切换扩展，常见的场景是一般浏览使用默认配置，然后开发环境使用另一套扩展，切换非常的简单，首先在设置里添加。 然后单击该扩展就可以进行切换了： 2.5 Imagus 这个扩展主要用于预览图片，鼠标悬停可以放大预览图片，还可以对临时的预览图片进行缩放，旋转等功能。 可以打开设置修改默认的快捷键，默认q垂直翻转，w水平翻转，e逆时针旋转，r顺时针旋转，剩下的就不说了，按需要自定义。 2.6 Infinity Pro 一个非常漂亮的新标签页扩展，建议注册一个账号去开启Pro功能，开启Pro后可以支持文件夹的创建，还可以把数据备份到云端，然后切换浏览器可以一键恢复数据。 可以自定义的设置非常丰富，包括布局行列数，行宽，列宽，图标大小，阴影，圆角，透明度，字体大小，阴影，颜色，自定义/随机壁纸，搜索栏显隐等，自行体会。 2.7 Minimal Scrollbar 最小化滚动条，这个没啥好说的，自己对比一下安装扩展后的变化就好了。 2.8 Similar Sites 可以发现类似的网站，比如，打开csdn时，显示了github，stackoverflow，博客园等网站。 2.9 Tampermonkey 这个很出名啊，油猴，有一个类似的，叫暴力猴。油猴这个扩展主要是用来管理脚本的，也就是说，单单安装这个扩展啥用也没有，需要安装脚本，这里推荐这个网站：Greasy Fork. 具体就不多说了，有些奥秘需要自己去探个究竟。 2.10 Vimuim 这个压轴登场的扩展，是vim与chromium的结合体，换句话说，在浏览器中集成vim的操作。 比如hjkl是最常见的vim操作，对应页面的滚动，分别是左/下/上/右滚，f是页面跳转功能，比如一个页面按f前： 按了f后： 可以看到多了很多字母对吧，如果此时再输入对应的字母，便会在当前页面跳转到目标页面，比如此时再输入le，便会跳转到“这份Android Studio快捷键大全....”这个页面，大写F实现的功能类似，不过是在新标签页打开。 另一个非常实用的功能是搜索框，按下o/O即可出现： 这个框可以直接输入链接跳转，或者输入字符进去搜索，可以在vimuim的设置里设置默认的搜索引擎： 这里默认的搜索引擎是百度，下面的设置可以自定义搜索引擎，比如第一行为 g : https://www...... 冒号前面的g表示关键字，后面的搜索关键字用 %s 代替，然后在搜索框中输入关键字+空格+字符就可以用该关键字对应的搜索引擎进去搜索了。 这里演示一下添加搜索引擎的方法，以github为例，打开github随便搜索123： 复制这个地址，加上关键字与替换123： 别忘了底部的保存按钮。 然后输入关键字+空格+搜索字符进行搜索即可。 再说一下书签功能，输入b/B可以直接访问书签（强大吧），比如笔者这里的书签有四个文件夹： 输入的标签以斜杠符号开始，后面加对应的文件夹以及对应的网站，这里不用担心输错，因为有自动显示的功能，输错的话下面没有书签显示： 还有很多功能就不逐一介绍了，可以输入?查看帮助： 3 最后 现在主流的Chrome已经很强大了，加上这些实验性功能与推荐的扩展，希望你们能有一个更舒服的上网冲浪的环境。 ","link":"https://2293736867.github.io/post/chromechromium-de-shi-yan-xing-gong-neng-kuo-zhan-tui-jian-rang-ni-de-chromechromium-qi-fei/"},{"title":"Linux下PHP7安装与Apache配置","content":"1 PHP 1.1 准备工作 需要先安装Apache，已安装的可以跳过，没安装的可以看这里。 1.2 下载 官网 1.3 解压 tar -zxvf php-7.4.3.tar.gz cd php-7.4.3 1.4 编译安装 ./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache/bin/apxs prefix为安装位置，后面的选项为apache安装目录bin下的apxs。好了之后： make sudo make install 1.5 配置文件 需要复制一份php.ini文件： sudo cp php.ini-development /usr/local/lib/php.ini 2 Apache 在conf/httpd.conf最后加上： LoadModule php7_module modules/libphp7.so &lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 若是php5请修改为： LoadModule php5_module modules/libphp5.so 最后重启apache服务： /usr/local/apache/bin/apachectl restart 3 测试 在apache目录下的htdocs下新建一个test.php： &lt;?php phpinfo() 浏览器输入apache配置文件中的ServerName加上文件名，笔者的是localhost:80。 localhost:80/test.php 显示以上信息即成功。 ","link":"https://2293736867.github.io/post/linux-xia-php7-an-zhuang-yu-apache-pei-zhi/"},{"title":"Linux编译安装Apache","content":"1 前言 编译安装Apache HTTP Server，目前最新的版本为2.4.41，做好apr，apr-util，pcre的安装后编译安装即可。 2 准备工作 三个：apr，apr-util，pcre，已安装的可以跳过。 2.1 apr 下载：链接 tar -zxvf apr-1.7.0.tar.gz cd apr-1.7.0 ./configure --prefix=/usr/local/apr/apr make sudo make install 安装位置自定义。 2.2 apr-util 下载：链接 tar -zxvf apr-util-1.6.1.tar.gz cd apr-util-1.6.1 ./configure --prefix=/usr/local/apr/util --with-apr=/usr/local/apr/apr 安装位置自定义，如果另外如果在上一步更改了apr的默认安装位置需要使用 --with-apr 指定自定义的apr的安装位置。 然后编译安装： make sudo make install 2.3 pcre 下载：链接 tar -zxvf pcre-8.44.tar.gz cd pcre-8.44 ./configure --prefix=/usr/local/pcre make sudo make install 3 Apache 3.1 下载 官网 3.2 解压 tar -zxvf httpd-2.4.41.tar.bz2 cd httpd-2.4.41 3.3 安装 ./configure --prefix=/usr/local/httpd 由于修改了apr的默认安装位置，这里提示找不到apr，因此使用 ./configure --help 查看一下选项帮助。 选项挺多的不过需要的有关apr的选项： ./configure --help | grep -i “apr” 因此加上选项： ./configure --prefix=/usr/local/httpd \\ --with-apr=/usr/local/apr/apr \\ --with-apr-util=/usr/local/apr/util 若出现pcre找不到再加上： --with-pcre=/usr/local/pcre 3.4 编译并安装 make sudo make install 3.5 修改默认配置 vim PREFIX/conf/httpd.conf 其中PREFIX为安装位置。根据需要修改服务器名，端口等。 搜索ServerName，初始的配置可以修改为： ServerName localhost:80 3.6 启动服务 PREFIX/bin/apachectl -k start PREFIX为安装位置，权限拒绝请加sudo. 3.7 测试 浏览器输入刚才的自定义的ServerName： 成功，这里显示的是安装目录下htdocs/index.html. ","link":"https://2293736867.github.io/post/linux-bian-yi-an-zhuang-apache/"},{"title":"Linux下MySQL  8.0.19 编译安装","content":" 1 前言 2 准备工作 2.1 gcc 2.2 boost 2.3 cmake 2.4 其他 2.4.1 Red Hat系 2.4.2 ubuntu系 3 下载与解压 3.1 下载 3.2 解压 3.3 创建临时bld文件夹 4 编译与安装 4.1 cmake 4.2 编译 4.3 安装 4.4 测试 5 配置MySQL 5.1 新建用户组与用户 5.2 修改数据目录所有者与权限 5.3 my.cnf 5.4 初始化 5.5 支持ssl与rsa（可选） 5.6 开启服务 5.7 修改root密码 5.8 测试 6 后续处理 6.1 删除文件 6.2 别名 1 前言 linux下安装MySQL的方式有很多种，包括以仓库的方式安装(yum,apt,zypper)，以包的方式安装(rpm,deb)，以docker方式安装，从压缩包解压安装，从源码编译安装，这里使用的是最后一种，从源码编译安装。 编译安装需要大量的耐心与时间，而且还会遇到非常多奇奇怪怪的问题，因此，需要极大的毅力，很有可能一万次失败也换不来一次的成功，请做好心理准备。 2 准备工作 下面是安装要求，已安装的可以跳过。 cmake boost gcc ncurses openssl bison doxygen 2.1 gcc gcc的话一般linux都配备，最低要求版本为5.3，需要更新的话可以看笔者的另一篇博客。 2.2 boost boost不需要手动安装，后面运行cmake脚本的时候会自动下载安装，当然也可以手动安装，官网的文档说是需要特定版本，这里的MySQL Server 8.0.19需要的是1.70.0，目前最新的boost库为1.72.0。 2.3 cmake 看笔者的另一篇博客。 2.4 其他 其他一般使用仓库安装即可，当然也可以每一个都去折腾从源码安装，你喜欢就好。 2.4.1 Red Hat系 7.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen 8.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen diffutils rpcgen make libtirpc-devel 2.4.2 ubuntu系 sudo apt-get update sudo apt-get install -y bison git hostname libncurses-dev libssl-dev make openssl pkg-config doxygen 3 下载与解压 3.1 下载 MySQL Server下载 这里不知道带boost与不带boost的有什么区别，后面使用cmake的时候都需要手动下载boost，所以就随便选一个吧。有知道的大神可以留言，小弟感激不尽。 3.2 解压 tar -zxvf mysql-boost-8.0.19.tar.gz cd mysql-8.0.19 3.3 创建临时bld文件夹 mkdir bld cd bld 4 编译与安装 4.1 cmake cmake .. \\ -DDOWNLOAD_BOOST=1 \\ -DWITH_BOOST=. \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DENABLED_LOCAL_INFILE=ON \\ -DWITH_SSL=system \\ -DCMAKE_INSTALL_PREFIX=/usr/local/mysql/server \\ -DMYSQL_DATADIR=/usr/local/mysql/data \\ -DMYSQL_TCP_PORT=3306 \\ 安装了boost的可以不需要： -DDOWNLOAD_BOOST=1 -DWITH_BOOST 安装位置与数据位置根据需要自定义： -DCMAKE_INSTALL_PREFIX= -DMYSQL_DATADIR= 4.2 编译 make -j n n为cpu核心数，若失败请直接使用 make 这里编译需要比较长的时间，有进度提示。 4.3 安装 sudo make install 这里笔者遇到了libstdc++.so.6这个库的问题，MySQL Server 8.0.19安装需要GLIBCXX_3.4.25. 可以看看自己的libstdc++.so.6的路径： sudo find / -name lidstdc++.so.6 找到路径之后： strings /xxx/libstdc++.so.6 | grep GLIBCXX 笔者这里只有GLIBCXX_3.4.22，由于之前手动更新了gcc，在gcc的lib目录中： 因此只需要根据sudo make install的提示把这个libstdc++.so.6复制到/lib/： sudo cp libstdc++.so.6 /lib/x86_64-linux-gnu/ 另一种解决办法是（针对Ubuntu系），添加ppa源，然后update： sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade 其他的也类似，更新gcc，手动指定lib的位置。 安装成功。 4.4 测试 make test 测试通过。 5 配置MySQL 安装完成后还需要进行MySQL的配置。 5.1 新建用户组与用户 sudo groupadd mysql sudo useradd -r -g mysql -s /bin/false mysql 5.2 修改数据目录所有者与权限 数据目录根据需要修改。 sudo chown mysql:mysql /usr/local/mysql/data sudo chmod 777 /usr/local/mysql/data 这里官网的文档写的是750权限，但是后面会出现不可写错误，755也不行，所以直接改成了777。 5.3 my.cnf my.cnf在/etc或/etc/mysql下，笔者这里安装后默认有一个my.cnf在/etc/mysql下： /etc/mysql/my.cnf是全局配置，~/.my.cnf是用户特定的配置，这里直接修改/etc/mysql/my.cnf： [mysqld] port=3306 basedir=/usr/local/mysql/server datadir=/usr/local/mysql/data character-set-server=utf8mb4 [mysql] default-character-set=utf8 [client] port=3306 default-character-set=utf8 参数根据需要可以后期添加，这里如果使用utf8： [mysqld] character-set-server=utf8 会有警告，因为MySQL5.5.3之后增加了utf8mb4，mb4是most bytes 4的意思，专门用来兼容四字节的unicode，utf8指的是utf8mb3，支持的utf8编码最大字符长度为3字节，警告提示改成utf8mb4: [mysqld] character-set-server=utf8mb4 （额外阅读：utf8与utf8mb4） 5.4 初始化 进入到MySQL Server的安装目录下的bin： mysqld --initialize-insecure --user=mysql 这里使用-insecure是因为后面不用输入随机密码。当然也可以去掉insecure，这样就会有一个随机密码，要记住。 mysqld --initialize --user=mysql 5.5 支持ssl与rsa（可选） mysql_ssl_rsa_setup 这个一般服务器需要。 5.6 开启服务 mysqld_safe --user=mysql &amp; 5.7 修改root密码 先用root登录 mysql -u root --skip-password 如果是使用initialize初始化的，输入 mysql -u root -p 输入刚才的临时密码。 进去之后，使用alter修改root密码： alter 'root'@'localhost' identified by 'xxxxx' 5.8 测试 使用自带的mysqlshow与mysqladmin: mysqladmin -u root -p version mysqlshow -u root -p 完成，至此MySQL Server8.0.19安装完毕。 6 后续处理 6.1 删除文件 可以先把安装文件给删去： sudo rm -rf mysql-8.0.19* 另外，根据刚才cmake的时候的boost目录可以把boost库给删去： sudo rm -rf boost_1_70_0* 因为文档说只是需要boost去build，不需要使用。 6.2 别名 加个别名只是为了方便使用，这里笔者的做法其实很偷懒，默认root登录，修改~/.bash_aliases： alias mysqld=&quot;/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;&quot; alias mysql=&quot;/usr/local/mysql/bin/mysql -u root -p&quot; 使用MySQL之前使用mysqld启动服务挂后台，然后使用mysql登录，默认root用户。 当然更偷懒的做法是 alias mysql=&quot;/usr/local/mysql/bin/mysql -u root --password=xxxx&quot; 这样密码都不用输了。 ","link":"https://2293736867.github.io/post/linux-xia-mysql-8019-bian-yi-an-zhuang/"},{"title":"Linux安装CMake","content":"1 概述 Linux下安装CMake，目前最新的版本为3.17.0-rc2，安装的方式一共有三种：通过软件包仓库安装，通过编译好的版本进行安装，从源码手动编译安装。 2 仓库安装 笔者的是deepin，可以直接apt安装： sudo apt install cmake 安装是没问题了，但是版本有点旧，3.7的，不满意，所以就卸了： sudo apt autoremove cmake 其他的请自行搜索。 3 通过编译好的版本安装 先去官网下载： 解压并进入目录： tar -zxvf cmake-3.17.0-rc2-Linux-x86_64.tar.gz cd cmake-3.17.0-rc2-Linux-x86_64/bin 这样就可以了，直接 cmake -version 可以查看版本。 一般需要加个软链： sudo ln -s cmake /usr/bin/cmake 4 手动编译安装 手动编译安装其实也不难，官网的文档是三步： 4.1 下载 这里 4.2 解压 tar -zxvf cmake-3.17.0-rc2.tar.gz cd cmake-3.17.0-rc2 4.3 配置 ./bootstrap --prefix=/usr/local/cmake 加个安装位置即可。 出现上图说明成功，如果失败，请根据错误信息自行判断，笔者这里遇到的问题是gcc与g++的版本不匹配，因为是先更新gcc到了9.2.0，g++的软链忘记改，导致了g++是6.3.0的版本，而gcc是9.2.0的版本。 4.4 编译 make -j 6 笔者的为6核，-j可以为并行优化，默认为1。 安装时有进度提示，笔者在这里没有问题，出现其他问题自行搜索。 4.5 安装 make install 成功之后，在bash_aliases加个别名： vim ~/.bash_aliases 加上 alias cmake=/usr/local/xxxxx/cmake/bin/cmake :wq后： source ~/.bash_aliases 或 . ~/.bash_aliases 使用 cmake -version 测试 成功。 ","link":"https://2293736867.github.io/post/linux-an-zhuang-cmake/"},{"title":"Linux 更新Python3.8","content":"1 下载源码 地址 选版本下载即可，目前最新为3.8.2版本。 2 解压 tar -zxvf Python-3.8.2.tgz cd Python-3.8.2 3 新建安装目录 安装目录在/usr/local/python38: sudo mkdir /usr/local/python38 4 安装 ./configure --prefix=/usr/local/python38 &amp;&amp; make &amp;&amp; make install 笔者这里安装遇到的是安装目录的权限问题，直接改为775，776都不行，改为777： sudo chmod 777 /usr/local/python38 5 链接 可以先把以前的备份一下： sudo cp /usr/bin/python /usr/bin/python2.bak 链上python3： sudo ln -s /usr/local/python38/bin/python3.8 /usr/bin/python 6 测试 成功。 7 删除 可以把安装文件删除了。 rm -rf Python3.8.2* ","link":"https://2293736867.github.io/post/linux-geng-xin-python38/"},{"title":"Linux下更新GCC","content":"1 下载源码 链接 目前最新为9.2版本。 2 解压 tar -zxvf gcc-9.2.0.tar.gz cd gcc-9.2.0 3 download_prerequisites脚本 运行这个脚本: ./contrib/download_prerequisites 4 临时目录 建立临时目录，用于放置中间文件。 mkdir gcc_9_2_0_build cd gcc_9_2_0_build 5 生成makefile文件 ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib 不对，是这张： 下面说一下几个选项： -enable-checking / -disable-checking 表示编译器在编译过程中是否做额外检查。 -enable-languages 表示支持的语言，可以支持 ada c c++ d fortran go jit lto objc obj-c++ -disable-multilib 关闭多架构支持，可以支持arm，m68，mips，msp430，powerpc架构。 6 编译 sudo make -j6 -jn 选项表示为多核处理器优化，n为核心数，笔者的为6核。 此操作极为耗时，建议准备充足时间，如果出现错误一般一两分钟左右停止，不成功请直接使用 sudo make 7 安装 sudo make install 8 验证 gcc -v 如果还是旧版本，请重启再试一次。 下面是成功截图： 9 删除 可以把安装文件以及压缩包删了。 rm -rf gcc* 注意所在的目录... ","link":"https://2293736867.github.io/post/linux-xia-geng-xin-gcc/"},{"title":"PyCharm安装与配置","content":"1 下载 官网 2 安装 选位置即可. 接下来是几个选项:快捷方式,环境变量PATH,右键菜单添加&quot;Open Folder as Project&quot;,文件关联,按需要选择. 3 初始配置 首次运行不需要导入设置. 选主题. 下一个是选插件,分别是vim,markdown支持,R支持,AWS工具箱. 4 配置 进入settings: 可以先把主题与界面字体大小改一下. 主题可以在插件处搜索安装. 显示行号,方法分隔符,空白字符: 字体,笔者用的是Fira Code. 编码,统一utf8: ","link":"https://2293736867.github.io/post/pycharm-an-zhuang-yu-pei-zhi/"},{"title":"PHP环境搭建+Hello World","content":" 1 概述 2 安装php 2.1 下载 2.2 安装 2.3 测试 3 IDE 3.1 下载 3.2 安装 3.3 配置 4 安装MySql 4.1 安装介绍 4.2 下载 4.3 配置文件 4.4 环境变量 4.5 初始化 4.6 改密码 5 安装Apache HTTP Server 5.1 下载 5.2 安装 5.3 测试 6 Hello world 1 概述 基础教程,搭建PHP入门基本环境.环境win10. 2 安装php 2.1 下载 官网点击这里 2.2 安装 其实只需要添加环境变量即可.win+Pause,高级系统设置: Path这里新建一个,刚才的php目录. 2.3 测试 打开cmd,输入php -v: 这样就安装成功了. 3 IDE 这里用的IDE是Php Storm. 3.1 下载 官网点击这里 直接下载就行. 3.2 安装 挑个位置. 下面这些根据个人需要勾选即可,分别是快捷方式,添加运行目录到环境变量,右键菜单添加&quot;作为一个工程打开&quot;,文件关联. 安装后以后直接run. 3.3 配置 其他配置按需要,这里主要说一下php: 改个名字后选择刚才安装php的路径: 然后如果该目录内没有php.ini的话会提示配置文件php.ini不存在: 点击How To Fix后提示: 它说创建php.ini文件在这个目录,在这个目录内可以找到两套模板:php.ini-development与php.ini-production,前者是默认设置,后者是推荐设置,那既然后面那个是推荐设置那就把它复制一下改名字: 然后就不会有警告了: 4 安装MySql 4.1 安装介绍 MySql有以下版本: Enterprise Edition,企业版,可免费试用30天. Standard Edition,标准版,收费. Classic Edition,经典版,只可作为一个嵌入式数据库用于ISVs(独立软件开发商),OEMs(原始设备制造商),VARs(增值经销商)的授权. Cluster CGE,高级集群版,收费. Embedded,嵌入式版,相比起经典版,ISV/OEM用户可以有更多选择. Community Server,社区版,开源免费. 一般用社区版即可,下面介绍社区版的安装流程. MySql有三种安装包,分别是安装器,压缩包与Docker镜像. 一般选择安装器安装或压缩包解压.这里使用的是压缩包,压缩包包含了完整的MySQL Server,解压之后需要额外的手动配置. 4.2 下载 官网这里,直接下载即可. 4.3 配置文件 解压之后,在解压目录新建一个叫my.ini的配置文件,输入以下内容: [mysqld] port=3306 basedir=E:\\Mysql datadir=E:\\Mysql\\data max_connections=200 max_connect_errors=12 character-set-server=utf8 default-storage-engine=INNODB [mysql] default-character-set=utf8 [client] port=3306 default-character-set=utf8 basedir与datadir是安装目录与数据存放目录,按需要修改即可. 4.4 环境变量 添加安装目录/bin到环境变量Path.不截图了. 4.5 初始化 打开cmd,执行: mysqld --initialize --consle 若出现以下问题: 可以看一下这个链接. 此时会出现root的初始密码,需要记住. 然后输入 mysqld --install 这里笔者之前安装过了,所以显示已存在. 4.6 改密码 好了之后输入 net start mysql 启动服务之后,输入: mysql -u root -p 输入刚才的随机密码. 然后修改root密码: alter user 'root'@'localhost' identified by 'xxxx'; 修改root密码后就可以用新密码登录了. 5 安装Apache HTTP Server 5.1 下载 官网 官网说只提供源码,需要自己编译,这里推荐了几个编译好的网站,去下载即可. 如果需要自己编译,看了一下文档,四个步骤,先下载源码,还有apr,apr-util,apr-iconv,把它们放到对应文件夹,然后运行perl命令. 笔者没有安装perl,也不懂perl,所以就弱弱地用别人编译好的了,点第一个即可: 64位,点击下载即可. 5.2 安装 解压之后移动到想要的目录,首先去修改conf下的httpd.conf第40行SRVROOT这里: 修改成安装目录即可. 然后打开cmd进入该目录下的bin,输入: httpd -k install 然后打开服务去开启服务: 5.3 测试 浏览器输入 localhost:80 会出现以下主页. 6 Hello world 打开IDE,新建一个空项目,创建一个php文件: 输入echo: 然后移动到右上角的那个小方块: ok! ","link":"https://2293736867.github.io/post/php-huan-jing-da-jian-hello-world/"},{"title":"熵权可拓物元模型","content":" 1 概述 2 概念 2.1 物元 2.2 可拓 2.3 相容与不相容问题 2.4 物元分析 2.5 物元可拓分析 2.6 熵权法 3 步骤 3.1 确定物元 3.2 确定经典域 3.3 确定节域 3.4 确定待评物元 3.5 确定关联函数 3.6 确定关联度 3.7 确定权重 3.7.1 确定初始矩阵 3.7.2 指标归一 3.7.3 计算熵值 3.7.4 计算熵权 3.8 确定综合关联度 4 源码 5 参考 1 概述 物元分析方法是中国学者蔡文于20世纪80年代提出的用于解决矛盾问题的技术方法,是研究物元及其变化规律,解决现实世界中不相容问题的有效方法,可应用于生态环境,水资源承载力,农用地分级和土地生态水平等综合评价研究中. 本文主要介绍了熵权可拓物元模型的相关概念与该模型的建立过程. 2 概念 2.1 物元 物元分析法的主要思想是把事物用&quot;事物,特征,量值&quot;(分别用N,C,V表示)3个要素以有序三元组的形式来描述,这个三元组就叫物元. 2.2 可拓 可拓学是以蔡文,杨春燕研究员等为首的中国学者创立的新学科. 可拓学是研究事物拓展的可能性和开拓创新的规律与方法,并用以解决矛盾问题,是一门交叉学科,基本理论是可拓论,特有的方法是可拓方法,逻辑基础是可拓逻辑,与各领域的交叉融合形成可拓工程.可拓论,可拓方法(也叫可拓创新方法),可拓工程构成了可拓学. (图源) 可拓评价法是综合评价法的重要分支,通过借助可拓学的基本理论,从定性和定量两个角度将矛盾问题转化为多个特性的择近原则问题,从而得出事物之间的内部规律. 2.3 相容与不相容问题 当所给的条件能达到要实现的目标时,称为相容问题,当所给的条件不能达到要实现的目标时,则为不相容问题.不相容问题在一定条件下不能用常规办法解决,用数学公式表示,就是: W = R × r 其中W表示问题,R表示目标,r表示条件,在条件处于r的情况下,通过一般常规方法,不能实现目标R,这时问题W就是不相容问题.不相容问题具有时效性,因为一些不相容问题,虽然只能用非常规办法解决,但随着时代发展,又可以用常规方法加以解决. 2.4 物元分析 物元分析是研究物元,探讨如何求解不相容问题的一种方法,以研究促进事物转化,解决不相容问题为核心内容,是研究求解不相容问题时出点子,想办法的规律与方法的理论.物元分析的突出特点是创立了物元这一新概念,并建立了物元变换理论.求解不相容问题,必须同时考虑质和量,才可以使问题得到解决. 2.5 物元可拓分析 物元可拓分析是利用物元模型与可拓集合把系统研究中的实际问题转化为形式化的问题模型以及描述问题解决过程的模型,从而有效地解决矛盾,为决策提供数据,将不相容问题转化为相容问题,使问题得到合理解决. 2.6 熵权法 传统的AHP法等确定评价指标权重的方法往往比较主观,容易造成评价结果由于人的主观因素而形成偏差.熵权法根据评价指标变异程度的大小来确定指标权重,指标变异程度越大,信息熵越小,该指标权重值越大,反之则越少.熵权法的主要目的是减少主观性,使对评价对象进行的评价更加客观化. 3 步骤 3.1 确定物元 将要评价的事物记作N,其特征记为c,特征量值记为v,假设N有多个特征: 这n个特征对应的量值为: 则可表示为: R为n维物元,简记为: c表示要评价的物元的n个特征: v表示n个特征的量值: 3.2 确定经典域 经典域是根据将要评价的物元的特征及其量值所在的区间确定的,假设将评价等级分为m级,用 表示第j个等级,用 表示第i个评价指标,用 表示在等级j下第i个评价指标的取值范围,这个取值范围用区间 表示,则N,c,v以有序三元组的形式结合起来即为经典域物元Rj: 3.3 确定节域 节域用Rp表示,vpi为节域物元关于特征ci的量值范围: 其中 就是 第i个指标的所有范围的并集. 节域物元Rp可表示为: 3.4 确定待评物元 设有y个待评事物,把待评对象Nx的物元表示为Rx: 3.5 确定关联函数 令有界区间X 的模定义为: 某一点x到区间X的距离为: 则关联函数的k定义为: 3.6 确定关联度 关联函数表达式为: 其中kxj(vi)表示第x个待评物元,第j个等级,第i个指标的关联度,vxi为第x个待评价物元的第i个量值,vji为第j个经典域物元第i个指标的量值范围,|vji|为3.5中定义的区间的模,vpi为节域物元第i个指标的量值范围. 为3.5中的公式,表示第x个待评物元第i个量值vi与对应经典域量值范围vji的有限区间的距离. 通过该式子会计算出y × n × m个关联度(y为待评物元个数,n为指标的个数,m为划分的等级的个数): 3.7 确定权重 需要计算n个指标对应的n个权重: 四个步骤:确定初始矩阵,归一处理,计算熵值,计算熵权. 3.7.1 确定初始矩阵 初始矩阵即为要评价的y个物元中的n个指标的量值构成的矩阵,用X表示: 3.7.2 指标归一 将初始矩阵归一化处理,得到归一化矩阵B: 其中: min(xi)/max(xi)为矩阵X第i行的最小/最大值. 另一种计算方式为: 3.7.3 计算熵值 需要计算n个熵值: m为划分的等级的个数. fij为: 分子为bij,分母为矩阵B第i行之和. 一般为了使对数有意义,需要对上式进行修正,分子分母都&quot;加1&quot;: 因此修正后的熵值Hi为: 3.7.4 计算熵权 计算n个指标对应的n个熵权: n个熵权,满足和等于1: 3.8 确定综合关联度 需要计算y*m个综合关联度,用K表示: 其中 Nx表示第x个评价事物,wi为第i个指标的熵权,kj(vi)为第j个等级第i个指标的关联度. (注:x其实不一定从1开始,如评价的事物与年份有关,则x从年份开始,如x=2000,y=2010). 4 源码 java版： github 码云 5 参考 参考相关论文以及网站合集 ","link":"https://2293736867.github.io/post/shang-quan-ke-tuo-wu-yuan-mo-xing/"},{"title":"每天AC系列(十三):两数相除","content":"1 题目 LeetCode第29题,计算两数相除的商，不允许使用乘法，除法，求模运算符。 2 减法 首先判断结果是否需要加上负号，将商置为0后，被除数不断减去除数，同时商自增。最后根据是否有负号返回相应的商。 boolean negative = true; if((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) negative = false; dividend = dividend &gt; 0 ? dividend : -dividend; divisor = divisor &gt; 0 ? divisor : -divisor; int result = 0; while(dividend &gt;= divisor) { dividend -= divisor; ++result; } return negative ? -result : result; 3 思考 3.1 溢出 -2147483648与2147483647这两个数，是4字节的int的最小值与最大值，在java中，它们可用Integer.MIN_VALUE与Integer.MAX_VALUE表示，当一个int为Integer.MIN_VALUE时，取反也是这个数： 最简单最粗暴的解决方案就是使用long，long可以放下-Integer.MIN_VALUE，因此，直接将被除数与除数的类型改成long，返回值转为long即可。 但是提交了一下，超时： 所以对除数1与-1进行特判一下： if(divisor == 1) return dividend; if(divisor == -1) { if(dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE; return -dividend; } 若除数是1直接返回被除数，这时不需要考虑溢出，若是除数是-1，需要特判一下被除数是否为int的最小值，因为-Intger.MIN_VALUE也是Intger.MIN_VALUE，题目也说了返回int的最大值。 然后信心十足地提交了： 惨淡。 3.2 负数 溢出的原因，就算因为负数的存储范围比正数多1，就算因为那两个可恶的-2147483648与2147483647. 上面的做法是判断结果的负号，然后将被除数与除数都转为正数来计算，可以换一种思路，将被除数与除数都转为负数来计算： dividend = dividend &gt; 0 ? -dividend : dividend; divisor = divisor &gt; 0 ? -divisor : divisor; int result = 0; while(dividend &lt;= divisor) { dividend -= divisor; ++result; } if(negative) { if(-result == Integer.MIN_VALUE) return Integer.MIN_VALUE; return -result; } else { if(result == Integer.MIN_VALUE) return Integer.MAX_VALUE; return result; } 结果从0开始自增，while循环的条件改成被除数小于等于除数而不是之前的被除数大于等于除数，然后对得出的商判断正负与边界，如果是负数，判断商的相反数是否是int的最小值，若是的话，表示真正的商为2147483648，负溢出，返回int的最小值，若不是负数，判断商是否为int的最小值，若是的话，表示真正的商为2147483648，正溢出，返回int的最大值。 快了600ms，还是有效果的。 3.3 翻倍与移位 速度慢的原因，是因为减法。因此需要改进减法，使被除数更快地逼近除数。 对于被除数为2147483647，除数为1的情况，需要减2147483647次，才能得出结果，所以，使用翻倍，第一次减1，第二次减2，第三次减4，以此类推。 但是怎么翻倍怎么操作呢? a *= 2 ? 题目说不能用乘法运算符。 作为一个现代的程序员，总不能这样翻倍吧？ a += a; 这时就轮到位移运算符登场了，左移一位，相当于乘2，右移一位相当与除2： a &lt;&lt;= 1; // a *= 2 a &gt;&gt;= 1; // a /= 2 总体思路是设置一个tempResult与一个tempDivisor，不断将tempResult与tempDivisor翻倍，直到被除数大于等于tempDivisor或tempDivisor溢出，然后把tempResult增加到result上面。 while(dividend &lt;= divisor) { int tempDivisor = divisor; int tempResult = 1; while(dividend &lt; (tempDivisor&lt;&lt;1) &amp;&amp; tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1)) { tempDivisor &lt;&lt;= 1; tempResult &lt;&lt;= 1; } dividend -= tempDivisor; result += tempResult; } 其中： tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1) 这个while中的判断很重要，如果tempDivisor大于int的最小值的一半，则tempDivisor左移1位后会小于Integer.MIN_VALUE，也就是小于int的最小值，会溢出，跳出循环后会导致被除数减去一个正数而不是一个负数，这样相当于增大了被除数导致计算的结果错误。 4 递归 递归可以减少设置一个result变量，直接在返回值里加上即可： public int div(int dividend,int divisor) { if(dividend &lt;= divisor) { int tempDivisor = divisor; int tempResult = 1; while(dividend &lt; (tempDivisor&lt;&lt;1) &amp;&amp; tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1)) { tempDivisor &lt;&lt;= 1; tempResult &lt;&lt;= 1; } return tempResult + div(dividend-tempDivisor,divisor); } return 0; } 代码与迭代基本相同，结束条件为被除数大于除数，在进入递归前需要对被除数与除数处理正负： public int divide(int dividend,int divisor) { boolean negative = (dividend &gt; 0) ^ (divisor &gt; 0); int result = div(dividend &gt; 0 ? -dividend : dividend,divisor &gt; 0 ? -divisor : divisor); if(negative) return -result; return result == Integer.MIN_VALUE ? Integer.MAX_VALUE : result; } 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-san-liang-shu-xiang-chu/"},{"title":"每天AC系列(十二):K个一组翻转链表","content":"1 题目 LeetCode第25题,每K个节点一组进行翻转,剩下不足K个的保留原状. 2 直接翻转 将链表分成三部分，已翻转，待翻转，未翻转三部分： 首先，用一个指针t表示要插入的位置的前驱，一边把head移动k遍，一边插入在t后面（下图假设k=3）： int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { temp = head.next; head.next = t.next; t.next = head; head = temp; } 直接插在t的后面，一轮循环之后，移动t与head. t的新位置为未插入head之前的head的位置，因此在插入之前把head的位置保存下来，直接使t移动到该位置，head的位置为自然移动到的位置，不需改变。 ListNode nextTPosition = head; ListNode temp; int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { temp = head.next; head.next = t.next; t.next = head; head = temp; } if(i == k) t = nextTPosition; 接着再翻转，到达7后，7不需要翻转，因为剩下的节点数不足： 这时就需要i发挥作用了，i表示已翻转的节点的值，因为只是一次遍历，每遍历k次便翻转k次，若i小于k，由于已经翻转了剩下的i个节点，因此需要再将这剩下的i个节点翻转一次： if(i == k) t = nextTPosition; else { for(head = t.next,t.next=null;head!=null;) { temp = head.next; head.next = t.next; t.next = head; head = temp; } break; } 对剩下的i个节点再次翻转时，不需要修改t的位置，使head指向t.next，再把t.next置为null，因为此时t为 4-&gt;7 若不把t.next置为null，在 head.next = t.next 这一步会使head.next指向错误的t.next，导致会在最后一个节点不断循环。 翻转最后的i个节点后，跳出循环，返回结果。 3 递归 递归的话思路也类似，遍历k次，翻转k个，若还有需要翻转的节点，递归翻转，若没有，翻转剩下的i个节点。 if(i == k) t.next = reverse(head,k); 大部分代码与循环相同就不贴了，最大的不同是这里，这里的t为原来未遍历前的head，因为改成递归后，不需要使用t作为移动的指针指示插入的位置，t.next就相当于翻转后的最后一个节点，把递归的结果插入到这个节点的后面。 4 使用额外空间--栈 因为题目规定只能使用常数的额外空间，因此应该只有这两种方法了，但是，如果允许使用额外的空间，可以使用栈优化直接翻转的算法。 因为出栈的次序正是翻转的顺序，每遍历k个节点就压栈k个节点，若剩余不足k个节点，把head连上dummy，若还有多余的节点或者刚好遍历完，把出栈的节点依次连上主链。 while(true) { Stack&lt;ListNode&gt; s = new Stack&lt;&gt;(); ListNode temp = head; int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { s.add(new ListNode(head.val)); head = head.next; } if(i == k) { for(i=0;i&lt;k;++i) { t.next = s.pop(); t = t.next; } } else if(head == null) { t.next = temp; break; } } 其中for循环为遍历压栈，i==k判断是否翻转链表。 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-er-k-ge-yi-zu-fan-zhuan-lian-biao/"},{"title":"每天AC系列(十一):删除排序数组中的重复项","content":"1 题目 LeetCode第26题,给出一个非降序的数组,删除重复的元素. 2 覆盖移动 题目明确要求不能使用额外的数组空间,一开始,没想到什么好的算法. 但是,它又有提示,不需要考虑数组中超出新长度后面的元素,所有,就想到了覆盖移动这样的方法. 思想很简单,就是使用两个下标,一个下标表示要返回的下一个要被替换的数,同时这个下标加1代表要返回的长度,一个下标为遍历数组的下标. 首先,遍历数组,若遇到大于nums[index]的数,首先判断当前下标是否为index的下一个,如果是下一个的话覆盖相当于重复了,把自己赋给自己,若i与index的距离大于1,则在自增index的同时,把i处的值覆盖到index处,这样就不用移动后面的数了,而且可以保证这样的数有序,最后返回index+1,表示不重复的元素的个数,即新数组的长度. int index = 0; for(int i=1;i&lt;nums.length;++i) { if(nums[i] &gt; nums[index]) { if(i &gt; ++index) nums[index] = nums[i]; } } return index+1; 嗯,一次就AC,舒服. 其他解法?不清楚,看了别人的题解差不多都是这样的,不过叫法不一样,叫双指针,快慢指针,本质都是一样. 4 再来一题 实在没想到上一题这么不堪一击,然后下一题是LeetCode的27题,与上一题有点类似,给定一个数组,删除数值等于指定值的所有元素. 5 解法 int index = -1; for (int i = 0; i &lt; nums.length; ++i) { if(nums[i] != val) { if (i &gt; ++index) nums[index] = nums[i]; } } return index + 1; 还是一样的解法啊,覆盖移动,快慢指针,这是上次的代码改了if的判断条件,然后就: 不想说什么了. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-yi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"},{"title":"每天AC系列(十):两两交换链表中的节点","content":"1 题目 LeetCode第24题,交换链表的相邻节点. 2 直接交换 直接交换的思想很简单,遍历一次链表,进行两两交换. ListNode newHead = new ListNode(0); newHead.next = head; ListNode before = newHead; ListNode first = head; ListNode second = head.next; ListNode move; while(true) { move = second.next; first.next = second.next; second.next = first; before.next = second; before = first; first = move; if(move != null &amp;&amp; move.next != null) { second = move.next; move = move.next.next; } else break; } return newHead.next; 虽然思想简单,但是,并不好实现,有点绕,首先增加一个头节点,first,second当前要交换的两个节点,before为first的前一个节点,用来连上first,move是为了更新first与second节点的节点,进入while循环后,首先把first与second交换,接着用before连上first同时更新before,然后利用move更新first与second. 3 递归交换 递归交换就是每次只交换头两个节点,然后把第三个节点作为下一次递归交换的头结点继续递归交换. if(head != null &amp;&amp; head.next != null) { ListNode t = head.next; head.next = swapPairs(t.next); t.next = head; return t; } return head; 要注意交换的顺序,先赋值head.next,head.next为剩下的节点,然后把t连上head. 4 插入法 新建一个链表,采用尾插法,依次插入交换的节点. 对于原链表设置两个指针a与b,令a指向首个节点,b指向第二个节点,然后对于新链表,先插入b,再插入a,最后更新a,b,使a,b都指向后继的后继,这样依次插入b与a就会得到所需的链表. if(head == null || head.next == null) return head; ListNode a = head; ListNode b = head.next; ListNode newHead = new ListNode(0); ListNode t = newHead; while(a != null &amp;&amp; b != null) { t.next = new ListNode(b.val); t = t.next; t.next = new ListNode(a.val); t = t.next; if(b.next != null) b = b.next.next; a = a.next.next; } if(a != null) t.next = new ListNode(a.val); return newHead.next; 在更新a,b时,对于a不需要判断a.next是否为空,因为a.next肯定为b,肯定不为空,但是对于b,当到达最后一个节点时,b.next为空,因此需要加上判断.当a,b其中一个为空后跳出循环,最后的判断a是否为空表示节点个数为奇数,此时a指向最后一个节点,直接插入a. 5 插入法改进 对于上面的插入法,由于ab是连在一起的,因此可以只使用其中一个,再优化判空与插入操作. ListNode newHead = new ListNode(0); ListNode t = newHead; while(head != null) { if(head.next != null) { t.next = new ListNode(head.next.val); t = t.next; } t.next = new ListNode(head.val); t = t.next; if(head.next == null) break; head = head.next.next; } return newHead.next; 要注意while中的判空条件,因为节点的个数有可能是奇数,在插入后一个节点前需要先判断是否为空,再插入前一个节点. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/"},{"title":"每天AC系列(九):合并K个排序链表","content":"1 题目 LeetCode第23题,合并k个有序的链表. 2 暴力法 直接遍历所有链表,取出所有节点的值,用数组存储,非降序排序,然后创建一个新链表用头插法依次插入节点. List&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(ListNode x:lists) { while(x != null) { s.add(x.val); x = x.next; } } s.sort((a,b) -&gt; {return a.compareTo(b);}); ListNode result = new ListNode(0); ListNode t = result; for(Integer x:s) { t.next = new ListNode(x); t = t.next; } return result.next; 这里要注意一下,sort那里不能写成: s.sort((a,b)-&gt;{return a&gt;b ? 1 : -1;}); 没有考虑到等于的情况,所以用compareTo代替: s.sort((a,b)-&gt;{return a.compareTo(b);}); 3 直接合并法 每次遍历所有链表,取出首节点的值,各个比较然后得出最小值,将最小值插入新链表,然后移动最小值所在的链表的指针,直到所有链表为空. ListNode result = new ListNode(0); ListNode t = result; int len = lists.length; int nullNodeNums = 0; for(boolean [] b = new boolean[len];nullNodeNums&lt;len;) { int min = Integer.MAX_VALUE; int minIndex = -1; for(int index = 0;index&lt;len;++index) { ListNode x = lists[index]; if(x == null) { if(!b[index]) { b[index] = true; ++nullNodeNums; } } else if(x.val &lt; min) { min = x.val; minIndex = index; } } if(minIndex != -1) { t.next = new ListNode(min); t = t.next; lists[minIndex] = lists[minIndex].next; } } return result.next; 这里使用了一个布尔数组判断是否某个节点已经移动到尾部,即表示是否为空,为空的话跳过这个节点,不为空的话取其值,计算是否为最小值.得到最小值后,添加到结果节点中,并移动最小值所在链表的指针. 这个方法看起来慢得很啊. 4 优先队列 优先队列是上两个方法的结合,遍历所有节点,取值并根据其值确定优先级添加到优先队列中,然后依次出队,将出队的值直接插入到新链表中. PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(ListNode x:lists) { while(x != null) { queue.add(x.val); x = x.next; } } ListNode s = new ListNode(0); ListNode t = s; while(!queue.isEmpty()) { t.next = new ListNode(queue.poll()); t = t.next; } return s.next; java的优先队列可以直接add即可,按照默认出队序列(对于整数是小的先出)使用尾插法插入到新链表中. 嗯,好像还可以的样子,但是还是不够快. 5 两两合并法 合并k个链表,相当于合并2个链表k-1次,利用递归的思想,每次合并两个链表,将合并后的链表后返回作为下一个要合并的链表继续合并. public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) return null; ListNode t = lists[0]; for(int i=1;i&lt;lists.length;++i) t = merge(t, lists[i]); return t; } //public ListNode merge(ListNode a,ListNode b) merge为直接合并两个链表的操作,不难,就不贴代码了,首先赋值t为第一个链表,然后依次合并t与剩下的n-1个链表. 好慢啊. 6 分治法 分治法是两两合并法的改进,两两合并每次合并两个链表,分治法每次合并一半数量的链表,总体思想是这样的:想要得到最终有序的链表,若左半部分的链表与右半部分的链表都有序,则相当于合并两个有序链表,为了得到左半部分的有序链表,需要继续对左半部分进行一半的分割,再次分成左半部分与右半部分,然后再分,直到某部分只有一个链表,然后返回,以合并两个普通有序链表的方式合并两个返回的链表. public ListNode f(int start,int end) { int len = end - start; if(len &lt;= 1) return lists[start]; ListNode l = f(start,start+len/2); ListNode r = f(start+len/2,end); return merge(l, r); } 代码非常简洁,一开始为判断递归的条件,区间长度小于等于1直接返回[start]的节点,然后递归合并左半部分与右半部分的节点. 一个字,舒服. 真快. 7 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-jiu-he-bing-k-ge-pai-xu-lian-biao/"},{"title":"每天AC系列(八):括号生成","content":"1 题目 LeetCode第22题,根据一个整数生成所有的有效的括号组合,这个整数表示括号的对数. 2 暴力法 对于n对括号,总共2n个字符,每个字符可以为左括号或右括号,所以总共2^(2n)中组合,暴力法就是枚举各个组合,然后判断它们是否为有效的组合: public void f(char c[],int pos,List&lt;String&gt; result) { if(pos == c.length) { if(valid(c)) result.add(Arrays.toString(c).replaceAll(&quot;(\\\\[)|(\\\\])| |,&quot;,&quot;&quot;)); } else { c[pos] = '('; f(c,pos+1,result); c[pos] = ')'; f(c,pos+1,result); } } public boolean valid(char [] f) { int len = 0; for(char c:f) { if(c == '(' ) { if(++len &gt; f.length/2) return false; } else if(len-- &lt;=0) return false; } return len == 0; } 首先加上左括号,进入下一轮递归,同时把加括号的位置加1,然后到达2n长度后,判断是否有效,有效的话加入结果数组,然后回到上一层的递归,把当前位置的括号换成右括号,接着再次进入下一轮递归,一样直到2n长度,继续判断是否有效,这样不断递归就会枚举了所有的组合. 看来不太理想啊. 3 深搜 深搜的话是暴力的改进,暴力的话不管序列是什么状态都直接添加括号,而深搜的话,当序列有效时才添加括号. 添加左括号的条件:当前的左括号数量小于n. 添加右括号的条件:当前左括号的数量小于右括号的数量. public void f(String c,int n,int l,int r,List&lt;String&gt; result) { if(l == n &amp;&amp; r == n) result.add(c); else { if(l &lt; r) return ; if(l &lt; n) f(c+&quot;(&quot;,n,l+1,r,result); if(r &lt; n) f(c+&quot;)&quot;,n,l,r+1,result); } } c为上一次递归的结果,l,r分别表示左括号与右括号的数量,递归的结束条件是左右括号的数量均为n,继续递归的条件是左右括号的数量小于n. 4 动态规划 设f(n)表示n对括号的所有有效序列,则有 具体来说: f(3) = ( + f(0) + ) + f(2) f(3) = ( + f(1) + ) + f(1) f(3) = ( + f(2) + ) + f(0) 这三个都是三对括号的有效序列,因此f(3)最后的结果是这三个有效序列组成的数组. 因为f(n)不一定为一个有效序列,因此返回值为一个数组,剩下的只需要遍历这个数组,把它们添加到最终结果数组中去: public List&lt;String&gt; f(int n) { List&lt;String&gt; s = new ArrayList&lt;&gt;(); if(n == 0) s.add(&quot;&quot;); for(int i=0;i&lt;n;++i) { List&lt;String&gt; l = f(i); List&lt;String&gt; r = f(n-i-1); for(String ll:l) { for(String rr:r) { s.add(&quot;(&quot;+ll+&quot;)&quot;+rr); } } } return s; } 若n为0,添加一个空序列然后返回,若n不为0,l表示i对括号的所有有效序列,r表示n-i-1对括号的所有有效序列,然后只需要遍历这两个序列,在两边加上左括号与右括号即可. 这个...好像没有深搜快. 5 动规优化 上面的递归的动规没有保存之前计算过的结果,比如计算n=3的时候, f(3) = ( + f(0) + ) + f(2) f(3) = ( + f(1) + ) + f(1) f(3) = ( + f(2) + ) + f(0) f(2): f(2) = ( + f(1) + ) + f(0) f(2) = ( + f(0) + ) + f(1) f(1) f(1) = ( + f(0) + ) + f(0) 只是计算f(3),计算了 f(2):2次 f(1):2+2*2=6次 f(0):2+2*2+6*2=18次 当n增大时,计算的重复度会变得更大,因此可以考虑用一个数组存储之前计算的结果,需要时直接取出来即可. public List&lt;String&gt; generateParenthesis(int n) { List&lt;List&lt;String&gt;&gt; s = new ArrayList&lt;&gt;(); s.add(Arrays.asList(&quot;&quot;)); s.add(Arrays.asList(&quot;()&quot;)); for(int n1 = 2;n1&lt;=n;++n1) { List&lt;String&gt; t = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n1;++i) { List&lt;String&gt; l = s.get(i); List&lt;String&gt; r = s.get(n1-i-1); for(String ll:l) { for(String rr:r) { t.add(&quot;(&quot;+ll+&quot;)&quot;+rr); } } } s.add(t); } return s.get(n); } 可以先看最后的return,因为s保存了0到n的所有结果,所以,直接get即可. 然后设置一个临时的n1,表示当前要计算的n1对括号的序列,当n1增加时,表示已经完成了计算n1对括号的序列,t为结果,添加到s中去.直到n1与n相等,计算完最后一个n1后,直接返回s的最后一个序列. 嗯,快了1ms,看来优化还是有效果的. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-ba-gua-hao-sheng-cheng/"},{"title":"正则表达式匹配方括号","content":"Java代码: String s = &quot;[1,2,3]+[4,5,6]&quot;; System.out.println(s.replaceAll(&quot;(\\\\[)&quot;,&quot;&quot;)); //匹配左方括号 System.out.println(s.replaceAll(&quot;(\\\\])&quot;,&quot;&quot;)); //匹配右方括号 System.out.println(s.replaceAll(&quot;(\\\\[)|(\\\\])&quot;,&quot;&quot;)); //匹配左右方括号 结果: 需要使用replaceAll而不是replace. ","link":"https://2293736867.github.io/post/zheng-ze-biao-da-shi-pi-pei-fang-gua-hao/"},{"title":"每天AC系列(七):合并两个有序链表","content":"1 题目 LeetCode第21题,合并两个有序链表. 2 直接合并 因为已经有序了,类似归并排序中的合并一样,操作不难,直接上代码了. ListNode t = new ListNode(0); ListNode head = t; while(l1 != null &amp;&amp; l2 != null) { if(l1.val &lt; l2.val) { t.next = l1; l1 = l1.next; } else { t.next = l2; l2 = l2.next; } t = t.next; } while(l1 != null) { t.next = l1; l1 = l1.next; t = t.next; } while(l2 != null) { t.next = l2; l2 = l2.next; t = t.next; } return head.next; 3 递归合并 这个可以采用递归优化,而且不用额外设置一个移动的临时结点t.首先对两个指针进行判空操作,其中一个为空的话返回另一个,然后进行递归合并,首先创建一个head结点,进行赋值后递归合并next结点,将返回值赋给head.next,最后返回head. if(l1 == null) return l2; if(l2 == null) return l1; ListNode head = null; if(l1.val &lt; l2.val) { head = l1; head.next = mergeTwoLists(l1.next, l2); } else { head = l2; head.next = mergeTwoLists(l1, l2.next); } return head; 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-qi-he-bing-liang-ge-you-xu-lian-biao/"},{"title":"每天AC系列(六):有效的括号","content":"1 题目 LeetCode第20题,这题比较简单,匹配括号. 2 栈 这是栈的典型应用,括号匹配,当然不需要直接使用栈,使用一个StringBuilder即可: if(s.isEmpty()) return true; char a = s.charAt(0); if (a != '(' &amp;&amp; a != '[' &amp;&amp; a != '{') return false; StringBuilder t = new StringBuilder(); int len = -1; for(char c:s.toCharArray()) { if(c == '(' || c == '[' || c == '{') { t.append(c); ++len; } else { if(len == -1) return false; char cc = t.charAt(len); if( (c == ')' &amp;&amp; cc != '(') || (c == ']' &amp;&amp; cc != '[') || (c == '}' &amp;&amp; cc != '{') ) return false; t.deleteCharAt(len--); } } return len == -1; 首先判断是否为空,再判断第一个字符,然后进入逐个循环判断,若表示左边的括号则append,若表示右边的括号首先判断len,然后取出len处字符进行判断是否匹配,不匹配直接返回false,匹配的话则删除这个字符.最后根据len是否为-1返回最终结果. 3 优化 其实就是简化一下代码,直接开辟一个大的空间,不需要进行append与delete,只需移动栈顶指针.栈顶指针从1开始,若从0开始的话对于&quot;]&quot;这种情况会报下标越界错误,压栈就是++p,压入字符,出栈直接- - p,然后判断是否匹配即可. char[] t = new char[s.length() + 1]; int p = 1; for (char c : s.toCharArray()) { if (c == '(' || c == '[' || c == '{') t[p++] = c; else { --p; if ((c == ')' &amp;&amp; t[p] != '(') || (c == ']' &amp;&amp; t[p] != '[') || (c == '}' &amp;&amp; t[p] != '{')) return false; } } return p == 1; 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-liu-you-xiao-de-gua-hao/"},{"title":"每天AC系列(五):删除链表的倒数第N个节点","content":"1 题目 LeetCode第19题,删除链表倒数的第n个结点. 2 两趟扫描 两趟扫描的思想很简单,第一趟扫描确定长度,第二趟扫描定位到目标结点并进行删除操作. public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null || head.next == null) return null; ListNode head_copy = head; int length = 0; while(head != null) { head = head.next; ++length; } head = head_copy; ListNode before = head; int i = 0; for(;i&lt;length-n;++i) { before = head; head = head.next; } if(i == 0) return head.next; else before.next = before.next.next; return head_copy; } 3 一趟扫描 当然,来刷题的话不能就这样就算了,肯定得把它弄成一趟扫描,对吧? 两趟扫描的目的是获取长度再进行定位,因此,为了能一次定位,可以使用两个头指针,对于给定的n,先让第一个头指针访问n次,第二个头指针不动,当第一个头指针访问n次后,第一个头指针继续访问直到最后一个,第二个头指针与第一个头指针并行访问,这样,当第一个头指针访问到最后一个时,第二个头指针就指向倒数第N个节点. public ListNode removeNthFromEnd(ListNode head, int n) { ListNode a = head; ListNode b = head; ListNode t = head; for(int i=0;i&lt;n;++i) a = a.next; if(a == null) return head.next; while(a != null) { t = b; a = a.next; b = b.next; } t.next = t.next.next; return head; } 总的来说这个只需要一趟扫描即可,针对只有两个结点或者一个结点的要判断一下. 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-wu-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/"},{"title":"Android+Spring Boot 选择,上传,下载文件","content":" 1 概述 2 环境 3 android 3.1 准备工作 3.1.1 新建工程 3.1.2 AndroidManifest.xml 3.1.3 build.gradle 3.1.4 上传文件 3.1.5 布局 3.2 选择文件 3.2.1 申请权限 3.2.2 Intent选择文件 3.3 上传文件 3.4 下载文件 4 Spring Boot 4.1 准备工作 4.1.1 新建工程 4.1.2 application.properties 4.1.3 pom.xml 4.2 处理上传文件 4.3 处理下载文件 5 测试 5.1 postman测试 5.1.1 上传测试 5.1.2 下载测试 5.2 android端测试 5.2.1 上传测试 5.2.2 下载测试 6 部署到服务器 6.1 部署 6.1.1 改变打包方式 6.1.2 去除tomcat依赖 6.1.3 修改Main 6.1.4 修改路径 6.1.5 设置打包名字 6.1.6 打包 6.1.7 上传到服务器 6.1.8 运行 6.2 测试 6.2.1 postman测试 6.2.2 android端测试 7 最最最喜欢的 坑 7.1 权限 7.2 路径 7.3 有关http的问题 7.3.1 okhttp的stream关闭 7.3.2 http 7.3.3 线程 7.3.4 AVD 7.4 ip 7.5 判空处理 8 源码 1 概述 前端android,上传与下载文件,使用OkHttp处理请求,后端使用spring boot+MVC,处理android发送来的上传与下载请求.这个其实不难,就是特别多奇奇怪怪的坑,因此,希望看到的,不要像笔者这样踩的那么痛苦了... 2 环境 win10 Spring Boot 2.2.2 RELEASE IDEA 2019.3.1 Android Studio 3.6RC1 Tomcat 9.0.30 3 android 3.1 准备工作 3.1.1 新建工程 这次用一个全新的例子写博客,因此从新建工程开始: 3.1.2 AndroidManifest.xml 加入 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;application android:usesCleartextTraffic=&quot;true&quot;&gt; 网络权限,读写SD卡权限,当然还有允许http请求的权限. 3.1.3 build.gradle 加入 compileOptions { sourceCompatibility = 1.8 targetCompatibility = 1.8 } 这个是支持JDK8的. 还有这两个okhttp与conscrypt,最新版本okhttp可以在这里查看,最新版本conscrypt在这里: implementation 'com.squareup.okhttp3:okhttp:4.3.1' implementation 'org.conscrypt:conscrypt-android:2.2.1' 3.1.4 上传文件 手动上传一些文件到AVD设备,为下一步选择与上传文件做准备,先把这个窗口工具栏打开: 打开后,打开在右侧栏中的Device File Explorer: 然后选择sdcard文件夹上传文件即可,其他文件夹一般没有权限. 3.1.5 布局 添加三个button(上传/下载/选择文件),一个EditText(上传文件名与下载文件名),一个ImageView(显示下载的图片). 直接拖放改一下id. 3.2 选择文件 3.2.1 申请权限 首先申请动态读写文件权限(其实选择文件只需要读权限,因为后面的下载需要写权限所以这里就一起申请了): 使用checkSelfPermission检查权限,参数为一个Context与String,String表示相应的权限,如果有了这个权限就会返回 PackageManager.PERMISSION_GRANTED 没有就会返回 PackageManager.PERMISSION_DENIED 没有就利用requestPermissions()申请,参数为Content,String[],int,String[]表示要申请的所有权限,int是一个requestCode. 3.2.2 Intent选择文件 新建一个Intent后,设置选择类型,然后就重写onActivityResult: 这是简化了的处理,因为选择的是图片,选择其他文件的话可以参照这里. 其中path是选择的文件的路径,可能你会问: String path = dir.toString().substring(0,dir.toString().indexOf(&quot;0&quot;)+2) + DocumentsContract.getDocumentId(uri).split(&quot;:&quot;)[1]; 这个是怎么来的,其实是拼凑过来的,因为这是图片,是这个的简化版: (博客在这里) 3.3 上传文件 参数为文件路径与文件名,然后使用OkHttpClient,因为是文件,用的body是MultipartBody,增加一个叫file的FormDataPart与一个叫filename的FormDataPart.然后使用execute()发送请求,body()获取响应内容,这里假设了后端响应一个布尔,表示上传成功或失败,url的话使用了本地的路径,注意不能是localhost,使用内网ip,然后还要与后端对应. 3.4 下载文件 参数为一个文件名,根据这个文件名返回对应的文件,返回一个File,这里请求体可以选择FormBody或MultipartBody,因为这是一个文件名参数,这里笔者为了统一就选择了MultipartBody,使用FormBody的话,只需要将RequestBody的那一行改为: RequestBody body = new FormBody.Builder().add(&quot;filename&quot;,filename).build(); 有了请求体后发送请求获取响应体,进而获取输入流,然后首先需要判断是否为空,但不能直接这样判断: inputStream == null 因为后端是这样的: 从响应体获取的inputStream肯定不为null,需要先进行一次读取(也就是判断里面的文件是否为null),若为null的话删除这个文件,不为null的话继续读取并写入文件. 4 Spring Boot 4.1 准备工作 用的是IDEA,其他IDE请自行搜索如何新建一个SpringBoot工程. 4.1.1 新建工程 打包的话可以jar或war,不用部署的话jar即可,要部署的话后期也可以改成war. 两个,一个Spring Web,用于MVC等,一个模板引擎,用于显示视图,如果不需要显示可以不选. 4.1.2 application.properties 作为一个示例demo,属性就直接在application.properties中配置了,实际情况请在相应的配置文件中配置相应属性. 需要配置上传文件的大小限制与上传文件夹的路径. 4.1.3 pom.xml 这里其实不需要干什么,只是如果下载依赖慢的话,可以这样设置settings.xml文件,在&lt;mirrors&gt;中加上: &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; windows用户的话这个文件在 C:\\Users\\{username}\\.m2\\settings.xml linux的话在 ~/.m2/settings.xml 4.2 处理上传文件 首先对应的post映射路径为/upload,与android端的路径对应,然后需要一个表示文件的MultipartFile与一个表示文件名的String,判断这两个是否为空后,如果上传的文件夹不存在则先创建,存在的话直接进行复制,然后根据复制成功或失败返回布尔值.复制使用了Files.copy(),第一个InputStream为上传文件的输入流,第二个Path为存储文件的路径,resolve(filename)相当于在上传目录下的filename文件.输出的话建议使用日志代替. 4.3 处理下载文件 下载的话可以选择使用get或post请求,这里选择了post请求,因为android端是post请求,需要对应.get请求的话可以从浏览器发起. 首先根据文件名获取对应文件,判断文件是否存在后返回一个ResponseEntity,需要设定content-type与body,content-type根据需要设置即可,这里是图片,默认.jpg或.png,body的话使用FileSystemResource,直接new一个放进body即可. 如果不存在相应的文件则返回null,这里需要注意一下前端的判断,不能直接判断ResponseBody是否为null. 5 测试 5.1 postman测试 postman只能测试与后端的连接,上传等是否有问题,可以用来定位后端的问题. 5.1.1 上传测试 再Headers中设置了Content-Type为multipart/form-data后: 在body添加一个叫file的文件与一个叫filename的字符串表示文件名: 发送,返回true. 服务器端有输出提示: 查看文件夹: 5.1.2 下载测试 把file参数关掉,保留filename,修改路径. 然后发送,postman可以直接显示图片: 5.2 android端测试 5.2.1 上传测试 后端提示: 查看文件夹: 5.2.2 下载测试 输入文件名后直接下载: 默认的话是放在这里,按需要更改位置即可,注意加上写权限: 若看不到文件选择synchronize即可. 6 部署到服务器 服务器用的是tomcat,需要修改一些Spring Boot的部分. 6.1 部署 6.1.1 改变打包方式 pom.xml中jar改成war. 6.1.2 去除tomcat依赖 pom.xml加入: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 6.1.3 修改Main 修改Main类,让其继承SpringBootServletInitializer,重载configure(),同时main()保持不变. 修改前: 修改后: 6.1.4 修改路径 这个按需要修改即可,在这里不需要,注意就是@PostMapping,@GetMapping等都是相对于 tomcat/webapps/项目/ 目录下的. 6.1.5 设置打包名字 build加上&lt;finalName&gt;. 6.1.6 打包 6.1.7 上传到服务器 打包后的文件放在target下,使用scp上传即可,这里是本地的tomcat,就这接移动war了. 6.1.8 运行 开启tomcat,双击startup.bat即可. linux的话: cd xxxx/tomcat/bin ./startup.sh 6.2 测试 在测试前需要确保没有占用相应端口,默认8080,也就是说,如果不改端口的话,需要关闭IDEA运行中的SpringBoot应用. 6.2.1 postman测试 上传测试,注意需要改路径,加上打包项目名,ip的话可以使用localhost或者内网ip. 服务器这边收到了,因为上传路径只是直接写名字,因此会与startup.bat同一路径. 下载测试: 服务器的输出: 6.2.2 android端测试 android端需要修改路径即可,加上war打包的名字. 这里打包的名字是kr,直接加上即可. 上传那里也是要加上,然后: 服务器的输出: 查看文件: 7 最最最喜欢的 坑 7.1 权限 android需要读权限才能读取文件并上传,需要写权限才能保存从服务器返回的文件,在AndroidManifest.xml中加入: &lt;manifest&gt;... &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;application&gt;...&lt;/application&gt; 这是外部设备的读写权限.当然,加入这个还不能访问,因为,android6.0以后还需要动态申请权限,所以: String [] permission = new String[]{ &quot;android.permission.READ_EXTERNAL_STORAGE&quot;, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; }; if( ActivityCompat.checkSelfPermission(this,permission[0]) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this,permission[1]) != PackageManager.PERMISSION_DENIED ) { ActivityCompat.requestPermissions(this,permission,1); } 7.2 路径 需要保证下面几个路径正确,还有可读,可写等: url路径不能错. 前端上传文件的路径. 后端接收前端上传文件的路径. 后端发送前端需要下载的文件的路径. 前端接收下载文件的路径. 7.3 有关http的问题 7.3.1 okhttp的stream关闭 若前端是这样写的,在工具类中返回了之后Response已经关闭,因此需要读取输入流之类的需要先读取再返回,而不是返回一个ResponseBody或InputStream进行读取,否则会提示&quot;closed&quot;. 7.3.2 http Android P开始默认禁用http,因此可以使用https或者在AndroidManifest.xml中允许http连接: &lt;application android:usesCleartextTraffic=&quot;true&quot;&gt; 7.3.3 线程 网络请求不能在主线程中,新开一个线程即可. 7.3.4 AVD 若检查过了服务器与android端没问题,那么有可能是AVD的问题,解决方法很简单,卸载,重启AVD,注意一定要卸载再重启. 7.4 ip 在本地测试的话后端可以直接localhost,在android端不能直接localhost,可以使用ipconfig或ifconfig查看内网ip,输入内网ip即可. 若在服务器上测试直接使用服务器ip. 7.5 判空处理 对于前端,应该判断存储路径是否为空,是否为null等,再传给后端,对于后端,要判断文件是否存在等,不存在就返回null,这时又需要前端进行判断返回的null,在下载文件时,虽然对不存在的文件后端返回null,但是,前端收到的是一个InputStream,不能直接判断是否为null,需要先读取一次,再进行剩下的读取: 8 源码 github 码云 ","link":"https://2293736867.github.io/post/androidspring-boot-xuan-ze-shang-chuan-xia-zai-wen-jian/"},{"title":"每天AC系列(四):四数之和","content":"1 题目 Leetcode第18题,给定一个数组与一个target,找出数组中的四个数之和为target的不重复的所有四个数. 2 暴力 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length == 4 &amp;&amp; nums[0] + nums[1] + nums[2] + nums[3] == target) result.add(Arrays.asList(nums[0], nums[1], nums[2],nums[3])); else if (nums.length &gt; 4) { Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resultSet = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length-3;++i) { for(int j=i+1;j&lt;nums.length-2;++j) { for(int k=j+1;k&lt;nums.length-1;++k) { for(int m=k+1;m&lt;nums.length;++m) { if(nums[i]+nums[j]+nums[k]+nums[m] == target) resultSet.add(Arrays.asList(nums[i],nums[j],nums[k],nums[m])); } } } } result.addAll(resultSet); Collections.sort(result,(t1,t2)-&gt; { if(t1.get(0) &gt; t2.get(0)) return 1; if (t1.get(0) &lt; t2.get(0)) return -1; if (t1.get(1) &gt; t2.get(1)) return 1; if (t1.get(1) &lt; t2.get(1)) return -1; if (t1.get(2) &gt; t2.get(2)) return 1; if (t1.get(2) &lt; t2.get(2)) return -1; if (t1.get(3) &gt; t2.get(3)) return 1; if (t1.get(3) &lt; t2.get(3)) return -1; return 0; }); } return result; 判断长度,然后排序,直接上四个for,然后... 好! 惨败. 3 优化 3.1 去掉结果排序 首先最后的排序是不必要的,也就是后面的 Collections.sort(result,(t1,t2)-&gt; { if(t1.get(0) &gt; t2.get(0)) return 1; if (t1.get(0) &lt; t2.get(0)) return -1; if (t1.get(1) &gt; t2.get(1)) return 1; if (t1.get(1) &lt; t2.get(1)) return -1; if (t1.get(2) &gt; t2.get(2)) return 1; if (t1.get(2) &lt; t2.get(2)) return -1; if (t1.get(3) &gt; t2.get(3)) return 1; if (t1.get(3) &lt; t2.get(3)) return -1; return 0; }); 对结果进行排序不必要,虽然会在测试时与答案有差别,但是提交的话不需要排序. 3.2 stream去重 之前的操作用的是HashSet进行去重,有一个符合的四元组就直接添加进集合中,现在采用了stream+distinct去重: return result.stream().distinct().collect(Collectors.toList()); 3.3 双指针+最大最小剪枝 可以利用类似三数之和的思想,固定一个数,双指针分别指向两端的两个数,这里的话,四个数,选择固定两个数,计算它们的和并把它们看作一个数,即可利用双指针. for(int i=0;i&lt;nums.length-3;++i) { for(int j=i+1;j&lt;nums.length-2;++j) { int m = nums[i] + nums[j]; int left = j+1; int right = nums.length-1; while(left &lt; right) { int temp = m + nums[left] + nums[right]; if(temp == target) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); --right; ++left; } else if(temp &gt; target) --right; else ++left; } } } m为固定的数,left与right就是双指针,根据&quot;三数&quot;之和判断与目标值的大小移动双指针. 最小剪枝就是首先计算&quot;三数&quot;的最小值,若大于目标值就可以跳过,最大剪枝就是计算&quot;三数&quot;的最大值,若小于目标值则跳过,进入下一个循环: int m = nums[i] + nums[j]; int left = j+1; int right = nums.length-1; if(m + nums[left] + nums[left+1] &gt; target) continue; if (m + nums[right-1] + nums[right] &lt; target) continue; 3.4 提交 呃...好了那么一点点吧. 4 来来来再快一点 4.1 初始判断 首先,初始的判断可以再简单一点,如果数组为空或长度小于4,直接返回. List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums == null &amp;&amp; nums.length &lt; 4) return result; 4.2 一次不够,就再剪几次 上面的算法中,只是在两层for里面进行了一次最大最小剪枝,可以在没进入for之前剪一次: Arrays.sort(nums); int len = nums.length; if( nums[0] + nums[1] + nums[2] + nums[3] &gt; target || nums[len-4] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target ) return result; for(int i=0;i&lt;len-3;++i) 注意要先排序,然后直接判断整个数组的最大最小值并与target判断. 然后在进入第一层for之后再剪一次: for(int i=0;i&lt;len-3;++i) { if(nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target) break; if(nums[i] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target) continue; for(int j=i+1;j&lt;len-2;++j) } 因为数组是升序排序的,因此,&quot;最左边&quot;四个数肯定是最小值,若这个最小值大于target,可以直接break了,但是,最右边三个数与nums[i]相加不一定为最大值,因此判断之后若小于target只能continue. 4.3 去重 4.3.1 双指针去重 首先,在双指针的循环中,若发现了有四个数符合条件,可以尝试多次移动指针: result.add(Arrays.asList(nums[i], nums[j], nums[left++], nums[right--])); while(left &lt; right &amp;&amp; nums[left] == nums[left-1]) ++left; while(left &lt; right &amp;&amp; nums[right] == nums[right+1]) --right; 因为值一样的可以一次性移动指针,不需要再次进行和的判断. 呃,可以尝试提交了. 咦,不对啊,做了这么多,没快多少啊... 为啥呢... ... 4.3.2 外循环去重 找了很久,发现是这里的原因: return result.stream().distinct().collect(Collectors.toList()); 这里去重的话,用是用的很舒服,一个stream(),一个distinct()就好了,问题是...还是很慢啊!!! 所以呢,需要手动去重,出现重复的原因就是数组中有重复的数,比如: [1,1,1,1,2,2,2,2],target=6 顺序判断时,会好几个 [1,1,2,2] 因此,对于重复的数,进行跳过处理,在第一层for中,对重复过的进行跳过: for(int i=0;i&lt;len-2;++i) if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue; 其次,在第二层for中,也对重复过的进行跳过: for(int j=i+1;j&lt;len-2;++j) if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue; 这样的话,例如对于上面的(不同的1用字母区分) [1(a),1(b),1(c),1(d),2,2,2,2] 一开始是a处的1与b处的1,然后到了第二层循环,因为此时j=i+1,指向b处的1,因此不会跳过1,会进入双指针循环,第二次j指向c处的1,出现重复,j不断跳过直到j指向2.然后2结束后,到了i这层循环,因为1出现过,i不断跳过直到i指向2. 没错,说了这么多,去重不需要什么HashSet,不需要什么stream,只需两行: if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue; if(j&gt;i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; 4.4 提交 尽力了. 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-si-si-shu-zhi-he/"},{"title":"@Scheduled注解","content":" 1 概述 2 cron 2.1 cron通配符 2.2 cron示例 3 fixedRate 3.1 fixedRate 3.2 fixedRateString 4 fixedDelay 4.1 fixedDelay 4.2 fixedDelayString 5 initialDelay 5.1 initialDelay 5.2 initialDelayString 1 概述 @Scheduled注解是spring boot提供的用于定时任务控制的注解,主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意需要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay. 2 cron cron是@Scheduled的一个参数,是一个字符串,以5个空格隔开,只允许6个域(注意不是7个,7个直接会报错),分别表示秒,分,时,日,月,周. 单位 允许值 允许通配符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * / ? L W 月 1-12 或 JAN-DEC(大小写均可) , - * / ? 周 1-7 或 SUN-SAT(大小写均可) , - * / ? L # 2.1 cron通配符 符号 含义 * 所有值.在秒字段上表示每秒执行,在月字段上表示每月执行 ? 不指定值,不需要关系当前指定的字段的值,比如每天都执行但不需要关心周几,就可以把周的字段设为? - 区间,如秒的0-2,表示0秒,1秒,2秒都会触发 , 多个值,比如在0秒,20秒,25秒触发,可以把秒的字段设为0,20,25 / 递增触发,比如秒的字段上设0/3,从第0秒开始,每隔3秒触发 L 最后,只允许在日字段或周字段上,在日字段上使用L表示当月最后一天,在周字段上使用3L表示该月最后一个周四 W 只允许用在日字段上,表示距离最近的该日的工作日.工作日指的是周一至周五 # 只允许在周字段上,表示每月的第几个周几,如2#3,每月的第3个周二 2.2 cron示例 @Scheduled(cron = &quot;0 * * * 1 SAT&quot;) //每年的1月的所有周六的所有0秒时间执行 @Scheduled(cron = &quot;0 0 0 1 Jan ?&quot;) //每年的1月的1日的0时0分0秒执行 cron支持占位符,若在配置文件中有 cron = 2 2 2 2 2 ? 则 @Scheduled(cron = &quot;${cron}&quot;) 表示每年的二月二号的两时两分两秒执行. 3 fixedRate 3.1 fixedRate fixedRate表示自上一次执行时间之后多长时间执行,以ms为单位. 如 @Scheduled(fixedRate = 1000 * 5) 自上次执行之后5秒再执行. 3.2 fixedRateString 有一个类似的参数叫fixedRateString,是字符串的形式,支持占位符. 如 @Scheduled(fixedRateString = &quot;1000&quot;) 自上次执行1秒再执行. 若在配置文件中有相应的属性,可以用占位符获取属性,如在application.properties中有 interval=2000 可以使用 @Scheduled(fixedRateStirng=&quot;${interval}&quot;) 表示2秒间隔. 4 fixedDelay 4.1 fixedDelay fixedDelay与fixedRate有点类似,不过fixedRate是上一次开始之后计时,fixedDelay是上一次结束之后计时,也就是说,fixedDelay表示上一次执行完毕之后多长时间执行,单位也是ms. @Scheduled(fixedDelay = 1000 * 3600 * 12) //上一次执行完毕后半天后再次执行 4.2 fixedDelayString 与fixedRateString类似,也是支持占位符 @Scheduled(fixedDelayString = &quot;${fixedDelay}&quot;) 5 initialDelay 5.1 initialDelay initialDelay表示首次延迟多长时间后执行,单位ms,之后按照cron/fixedRate/fixedRateString/fixedDelay/fixedDelayString指定的规则执行,需要指定其中一个规则. @Scheduled(initialDelay=1000,fixedRate=1000) //首次运行延迟1s 5.2 initialDelayString 与initialDelay类似,不过是字符串,支持占位符. @Scheduled(initialDelayString = &quot;${initialDelay}&quot;,cron = &quot;0 0 0 14 4 ?&quot;) //按照配置文件initialDelay指定的时间首次延迟,并于每年4月14日0时0分0秒执行 ","link":"https://2293736867.github.io/post/scheduled-zhu-jie/"},{"title":"每天AC系列(三):电话号码的字母组合","content":"1 题目 Leetcode第17题。 数字2-9映射字母，给出一个包含字符串的数字，列出字母的所有组合。 2 递归 拿到这样的题目想到了递归实现，创建一个Map映射对应的字母，然后把它传给递归函数，同时创建一个临时变量temp，保存每一次添加字母的结果，递归的结束条件是数字串的长度为0. public void one(String digits,List&lt;String&gt; result,HashMap&lt;Integer,String&gt; ss,String temp) { if(digits.length() &gt; 0) { String s = ss.get((int)(digits.charAt(0))-48); for(int i=0;i&lt;s.length();++i) one(digits.substring(1),result,ss,temp+s.charAt(i)); } else result.add(temp); } 3 提交 直接一次AC. 4 优化 其实可以不需要Map的，可以直接使用一个字符串数组，因为是数字到字符串的映射，对于数字可以用下标代替。其次，为了更快的速度可以使用StringBuilder代替String. 还有就是用下标代替了截断digits，对于digits其实没必要使用截断，只需要一个下标表示范围即可，对于StringBuilder，因为没有像String这样的+，因此需要在使用append后对其进行删除处理。 public void one(String digits,int index,StringBuilder temp) { if(index &lt; digits.length()) { String d = s[digits.charAt(index)-'0']; for(int i=0;i&lt;d.length();++i) { one(digits,index+1,temp.append(d.charAt(i))); temp.deleteCharAt(index); } } else result.add(temp.toString()); } 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-san-dian-hua-hao-ma-de-zi-mu-zu-he/"},{"title":"每天AC系列(二):最接近的三数之和","content":"1 题目 leetcode第16题，给定一个数组与一个目标数，找出数组中其中的三个数，这三个数的和要与目标数最接近。 2 暴力 按惯例先来一次O(n3)的暴力： int temp = nums[0]+nums[1]+nums[2]; for(int i=0;i&lt;nums.length;++i) for(int j=i+1;j&lt;nums.length;++j) for(int k=j+1;k&lt;nums.length;++k) { int temp1 = nums[i]+nums[j]+nums[k]; if(Math.abs(temp-target) &gt; Math.abs(temp1-target)) { temp = temp1; if(temp == target) return target; } } return temp; 然后。。。。 受宠若惊啊，直接暴力居然给过了。。。 3 O(n2) 算了，这种暴力笔者自己也看不下去，搞点正经事，暴力的话直接三个循环，每一次都加三个数并判断与target的距离，如果是target直接返回，如果不是则继续，但是...O(n3)啊... 其实这也可以用笔者上一篇文章中提到的双指针法，先对数组排序，然后固定一个数，再用两个指针指向起始端与末端，然后不断向中间逼近。 Arrays.sort(nums); int t1 = nums[0]+nums[1]+nums[2]; for(int i=0;i&lt;nums.length-2;++i) { int left = i+1; int right = nums.length-1; while(left &lt; right) { int t2 = nums[i]+nums[left]+nums[right]; if(t2 == target) return target; else if(t2 &gt; target) --right; else ++left; if(abs(t1-target) &gt; abs(t2-target)) { t1 = t2; } } } return t1; 首先将数组排序，nums[i]为固定的数，left和right为两个两个指针，根据计算的t2=nums[i]+nums[left]+nums[right]判断与target关系，大于的话向左移动右指针，小于的话向右移动左指针，直到两指针相遇。排序需要O(n log n)，两个循环需要O(n2)，总的时间复杂度为O(n2). 4 冲击2ms 去看了一下第一的那个解答，2ms，确实是快，主要是手写了快排，然后在for里面的循环中用了最大最小剪枝。 4.1 手写快排 去查了一下Arrays.sort()的算法，它是几种算法的组合： （图片来源） 只有当数组的长度小于286大于等于47时，才会调用快速排序，因此这里直接手写了一个快排，无论长度多少都直接使用快排。 （原理就不多说了，手写快排还是稍微有那么一点难度的...） public void qs(int [] nums,int l,int r) { if(l &lt; r-1) { int t = l; int ll = l+1; int rr = r-1; int temp; while(true) { while(t &lt; rr &amp;&amp; nums[t] &lt; nums[rr]) --rr; if(t &lt; rr) { temp = nums[rr]; nums[rr] = nums[t]; nums[t] = temp; t = rr--; } else break; while(ll &lt; t &amp;&amp; nums[ll] &lt; nums[t]) ++ll; if(ll &lt; t) { temp = nums[ll]; nums[ll] = nums[t]; nums[t] = temp; t = ll++; } else break; } qs(nums,l,t); qs(nums,t+1,r); } } 原本两个while循环中的条件是 while(ll &lt; rr &amp;&amp; ...) 后来出了bug，调了一下，发现范围不对，改成了两个while： while(t &lt; rr &amp;&amp; ...) while(ll &lt; t &amp;&amp; ...) 4.2 最大最小剪枝 最小剪枝就是计算固定的那个数，还有两个最小的数之和，判断与目标值的大小，如果这个最小值大于目标值，那么，结果有可能是这个最小值，但是，不可能是其他值，因为这个值最小了，而且大于目标值，再与其他值相加的话只会离目标值更远，因此判断是最小值后可以直接break. 最大剪枝也类似，计算最大的两个数与固定的那个数之和，判断与目标值的大小，如果小于目标值，则结果有可能是这个最大值，不可能是其他值，判断完后也是直接break. int left = i+1; int right = nums.length-1; if(left &lt; right) { int min = nums[i] + nums[left] + nums[left+1]; if(min &gt; target) { if(abs(min - target) &lt; abs(t1 - target)) t1 = min; continue; } } int max = nums[i] + nums[right] + nums[right-1]; if(max &lt; target) { if(abs(max - target) &lt; abs(t1 - target)) t1 = max; continue; } 4.3 噢... 一个字，开心。 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-er-zui-jie-jin-de-san-shu-zhi-he/"},{"title":"自定义GRUB主题","content":" 1 概述 2 下载主题 3 解压 4 安装 5 效果 6 改进 6.1 progress_bar 6.2 boot_menu 6.3 image 6.4 /etc/default/grub 6.5 /boot/grub/grub.cfg 6.6 背景 7 最终效果 8 配置文件 1 概述 自定义GRUB引导菜单的主题，笔者的Linux是deepin，感觉默认的grub主题不太好看，嗯，没办法，就是想改了。 这篇文章主要是修改/boot/grub/grub.cfg以及/boot/grub/themes/.../theme.txt这两个文件，修改之前要备份，不要问为什么。 2 下载主题 到这里下载自己喜欢的主题。这是笔者下载的主题。 3 解压 tar -zxvf xxxx.tar.gz 4 安装 直接在解压后的文件夹运行： sudo ./install.sh 输入y： 5 效果 6 改进 还不满意，嗯。。。 6.1 progress_bar 这个是进度条的设置，如果觉得进度条不满意可以直接去修改/boot/grub/themes/主题名/theme.txt下的progress_bar设置： 可以修改（距离左边和顶部的）位置，宽度，高度，是否显示文本，设置文本等，还可以设置前景颜色（fg_color）与背景颜色（bg_color），还有进度条的风格，就是显示哪一些图片等。 6.2 boot_menu 这个是启动项菜单的设置，可以调整启动项的位置，字体大小，启动项高度，各个启动项之间的间隔，启动项前的图标大小等。 6.3 image 笔者的这个theme.txt有一个image,用来显示KDElogo的，这个可以选择直接不要，删除全部即可，如果想更换成自己喜欢的图片，可以直接修改文件位置，或者再新建一个image: 如果是自己的文件需要把图片放到与theme.txt同一个文件夹，其他宽度，高度之类的，设置合适就好了。 6.4 /etc/default/grub 一些系统相关的基本上不用改，经常改的是默认项，timeout这几个。 GRUB_DEFAULT：设置默认启动项，按menuentry排序（menuentry顺序可以通过/boot/grub/grub.cfg查看），从0开始计数，从0开始计数，从0开始计数，重要的事再说一遍不是从1开始计数，若设为“saved”的话表示保存上次项，需要配合GRUB_SAVEDEFULT使用。 GRUB_SAVEDEFAULT：当GRUB_DEFAULT设置为“saved”时这个选项才生效，默认为false，设为true的话默认的启动项是上次启动项。 GRUB_TIMEOUT：进入默认项的等待时间，单位秒，有其他键被按下这个时间会取消，默认为5，设为0表示立即启动，不会显示启动项菜单，设为-1的话表示无限等待。 GRUB_TIMEOUT_STYLE：默认为&quot;menu&quot;（不设置这个值与设为“menu”等价），表示显示启动项菜单，如果设为&quot;countdown&quot;，不会显示启动项菜单，会显示一行倒计时文字，若设为“hidden”，效果与“countdown”类似，不过不会显示倒计时文字，等待GRUB_TIMEOUT结束后启动默认启动项。若设为&quot;countdown&quot;或&quot;hidden&quot;，想要显示启动项菜单按Esc即可。 不过这里其实有一个坑，就是只需要按Esc一次即可显示启动项菜单，一次即可，两次就会进入grub中的shell，这个要把握好时机，按快了的话没效果或者会进入grub，按慢了就直接启动默认启动项了，当然这个如果GRUB_TIMEOUT稍微大一点就无所谓，笔者说这个因为经历过把GRUB_TIMEOUT设为1，然后GRUB_TIMEOUT_STYLE设为了“hidden”这样的情形，然后就悲剧了。。。想进去启动菜单要重启好几次。。。。因此，GRUB_TIMEOUT_STYLE不太建议设为“countdown”或“hidden”，笔者“血的教训”。。。 /etc/default/grub还有其他设置，不过一般不怎么用，需要的话可以来这里看一下。 6.5 /boot/grub/grub.cfg 执行update-grub后会更新这个文件，手动修改这个文件是因为想修改启动项的文字，因为太长了，感觉没必要。 注意，如果手动修改过/etc/default/grub，也就是需要执行update-grub后使其生效后，需要重新修改/boot/grub/grub.cfg. sudo vim /boot/grub/grub.cfg 笔者只是想改文字，因此这里搜索找到menuentry直接修改： 改短一点就好了，submenu同理： 6.6 背景 这个比较简单，这接把想要的背景复制到/boot/grub/themes/主题名/下，重命名叫background.png即可，或者可以在theme.txt中修改： 7 最终效果 这是笔者的最终效果，主要就是加了一个头像，换个背景啥的。(手机问题。。。) 8 配置文件 这是需要的配置文件以及主题。 github ","link":"https://2293736867.github.io/post/zi-ding-yi-grub-zhu-ti/"},{"title":"每天AC系列(一):三数之和","content":"1 题目 LeetCode第15题,难度中等,题目描述: 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 2 解法 什么也不管先来个O(n3): for(int i=0;i&lt;nums.length;++i) { for(int j=i+1;j&lt;nums.length;++j) { for(int k=j+1;k&lt;nums.length;++k) { if(nums[i]+nums[j]+nums[k] == 0) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(nums[i]); arrayList.add(nums[j]); arrayList.add(nums[k]); result.add(arrayList); } } } } well. 3 优化 上面暴力算法的思想就是单纯三个循环,优化的方法可以考虑降低一个循环,使用&quot;双指针&quot;的思想,首先对数组进行排序,然后一开始固定一个数,然后让两个指针一个指向这个数的右区间的起点,一个指向终点,不断计算这三个值的和,根据得出的和移动左指针或者右指针,一共三种情况: 和等于0,同时移动左右指针,两者向中间方向移动. 和大于0,说明取值过大,需要把右指针向左移动. 和小于0,说明取值过小,需要把左指针向右移动. 基于以上的三种情况,写出了如下代码: List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length == 3 &amp;&amp; nums[0] + nums[1] + nums[2] == 0) result.add(Arrays.asList(nums[0], nums[1], nums[2])); else if (nums.length &gt; 3) { Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resultSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2 &amp;&amp; nums[i] &lt;= 0; ++i) { int left = i + 1; int right = nums.length - 1; while (left &lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { if (!resultSet.contains(Arrays.asList(nums[i], nums[left], nums[right]))) resultSet.add(Arrays.asList(nums[i], nums[left], nums[right])); --right; ++left; } else if (sum &gt; 0) --right; else ++left; } } result.addAll(resultSet); } 首先判断数组的长度是否大于等于3,小于3的话直接返回一个空List,等于3判断是否这三个数之和为0,大于3的话,首先排序,接着需要确保被确定的相对不移动的数为负数,这样的话剩下两个数的和才有可能为正数,否则的话会造成全部都是正数还要进行判断的局面.接着计算left指针与right指针的值,一直判断直到两指针相遇. 4 提交 AC! 5 完整代码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-yi-san-shu-zhi-he/"},{"title":"Java备份MySQL","content":" 1 概述 2 创建备份路径 3 执行命令 4 执行 5 其他问题 1 概述 使用java备份mysql数据库,主要是使用mysqldump与Runtime().getRuntime().exec(). 2 创建备份路径 如果没有备份的存储路径首先创建路径. Path path = Paths.get(xxxx); try { Files.createDirectories(path); } catch(IOException e) { //xxxx } 3 执行命令 如果是直接用shell执行的话: mysqldump -u user_name -p database_name &gt; xxxx\\database_name.sql 使用-u与-p分别指定用户与密码,最后重定向到文件. 但是,要注意再java中用exec()时,千万千万不能使用-p选项,-p是交互式输入密码的,使用了-p的话导出的文件是0KB的,需要使用 --password 代替. String command = &quot;mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 要注意一下路径问题,另外,在windows下,需要使用cmd: String command = &quot;cmd /c mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 这需要把 %MYSQL_HOME%/bin 加入到环境变量,如果没有加入的话输入绝对路径: String command = &quot;cmd /c C:\\\\Program Files\\\\mysql\\\\bin\\\\mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 4 执行 try { Runtime.getRuntime().exec(command); } catch(IOException e) { //xxxx } 5 其他问题 如果没有导出文件或者导出的文件为0KB,可能原因是: 语法错误:命令的空格使用不当,路径设置错误,使用了错误的参数等. 环境问题:如在windows下没有添加到环境变量,没有加上&quot;cmd /c&quot;. 用户名/密码错误:这个.... 权限问题:用户没有相应权限,要登陆到mysql中授权. ","link":"https://2293736867.github.io/post/java-bei-fen-mysql/"},{"title":"Python生成词云","content":" 1 概述 2 准备工作 2.1 安装anaconda 2.2 安装cython 2.3 安装wordcloud 3 使用 3.1 打开Jupyter 3.2 创建文字库 3.3 生成词云 3.4 注意事项 1 概述 利用Python生成简单的词云,需要的工具是cython,wordcloud与anaconda. 2 准备工作 包括安装cython,wordcloud与anaconda. 2.1 安装anaconda 下载官网 选择对应的版本下载即可. 2.2 安装cython cython是为了安装wordcloud准备的. pip -m pip install --upgrade cython 2.3 安装wordcloud 安装wordcloud前需要先安装Microsoft Visuall C++ 14.0. 这里下载 安装好了以后重启,输入 python -m easy_install wordcloud 3 使用 3.1 打开Jupyter 打开Jupyter Notebook. 然后会在浏览器打开这个页面,新建一个notebook. 先把需要的库导入: from wordcloud import WordCloud import matplotlib.pyplot as plt 3.2 创建文字库 简单的文字库可以直接选择一个txt文件,复杂的话可以选择创建一个excel,导出为csv文件,然后利用pandas库的read_csv()读入文件.这里创建一个txt,空格分隔单词即可. 然后上传到Jupyter中: 3.3 生成词云 首先读入文件: text = open('1.txt').read() 然后使用WordCloud().generate(text),在里面设置各种属性. wc=WordCloud( width=800, repeat=True, height=800).generate(text) 这里设置了高度与宽度,允许重复. plt.imshow(wc,interpolation=&quot;bilinear&quot;) plt.axis(&quot;off&quot;) plt.show() 显示词云, interpolation='bilinear' 会使显示平滑更加平滑,axis(&quot;off&quot;)表示不显示坐标轴. 下面是效果: 3.4 注意事项 如果含有汉字,首先在读取时设置编码: text = open('1.txt',encoding='utf-8') 然后再生成词云时设置字体: wc = WordCloud(font_path=r'C:\\Windows\\Fonts\\simfang.ttf') 测试: text=open('1.txt',encoding='utf-8').read() wc=WordCloud( width=1300, repeat=True, font_path=r'C:\\Windows\\Fonts\\simfang.ttf', height=1300).generate(text) plt.imshow(wc,interpolation=&quot;bilinear&quot;) plt.axis(&quot;off&quot;) plt.savefig('aaaa.jpg') ","link":"https://2293736867.github.io/post/python-sheng-cheng-ci-yun/"},{"title":"git push时出现Permission denied(publickey)的解决","content":"1 问题描述 push的时候出现上述错误,它说请确保有足够的权限和这个仓库存在,仓库不存在...这个估计不是,所以是权限的问题,准确来说是sshkey的问题. 2 重新生成ssh key ssh-key -t rsa -b 4096 -C xxxx@xxxxx 这是gitub推荐的生成新ssh key的方法.注意,请不要使用默认的名字,第一个就会提示输入名字,请使用自定义的名字. 3 修改~/.ssh/config 移动公钥和私钥到~/.ssh下. mv xxx xxx.pub ~/.ssh 修改~/.ssh/config: vim ~/.ssh/config 输入 Host github.com HostName github.com User git IdentityFile ~/.ssh/name 其中name为上一步的自定义的key名字,是私钥,不是.pub结尾的公钥. 4 添加公钥到github 在github首页中,点击右上角头像进入设置. 选择: 输入名字与公钥的内容,保存. 5 push 成功! ","link":"https://2293736867.github.io/post/git-push-shi-chu-xian-permission-deniedpublickeyde-jie-jue/"},{"title":"vim替换命令","content":"1 语法 :[range]s/source/target/[option] 2 range range表示要替换的范围,想要全局替换的话,可以使用一个百分号. :%s/xxx/xxxx 另外,小数点表示当前行,美元符号表示最后一行,数字表示范围. :1,.s 替换第一行到当前行 :.,$s 替换当前行到最后一行 :1,$s 替换第一行到最后一行,相当于 :%s 3 source与target 表示源字符串与目标字符串,如 :1,.s/123/456 表示把第一行到当前行的首次出现的123替换成456,注意是首次出现,如果要替换某一行全部源字符串需要在后面加上 /g 另外,对于一些特殊字符比如小数点,斜杠,双引号等需要转义,方式是使用反斜杠,在需要转义的字符面前加一个反斜杠 如把 &quot;123//&quot; 替换为 '123\\\\' 命令如下: :s/\\&quot;123\\/\\/\\&quot;/\\'123\\\\\\\\\\'/g 因为 &quot;123//&quot; 中 &quot; 转义为 \\&quot; / 转义为 \\/ '123\\\\' 中 ' 转义为 \\' \\ 转义为 \\\\ 4 option 选项如下: /g 全局替换 /c 确认 /p 替换结果逐行显示 注意选项的组合结果是 /cg /pc 这样的形式,而不是 /c/g /g/p 这样的形式. 5 总结 全局替换的话,使用 :%s/source/target/g 局部替换的话,使用 :n,ms/source/target n,m为行数,表示要替换的范围. 注意如果字符串需要转义要加上反斜杠. ","link":"https://2293736867.github.io/post/vim-ti-huan-ming-ling/"},{"title":"Spring Boot上传文件+部署到Tomcat","content":" 1 概述 2 环境 3 新建工程 4 新建包 5 exception 5.1 StorageException 5.2 StorageFileNotFoundException 6 properties 7 service 7.1 init 7.2 deleteAll 7.3 load 7.4 loadAll 7.5 loadAsResource 7.6 store 8 controller 8.1 listUploadedFiles 8.1.1 RequestMapping 8.1.2 Model 8.2 serveFile 8.3 handleFileUpload 8.4 handleStorageFileNotFound 9 main 10 application.properties 11 测试 12 打包部署到Tomcat上 12.1 改变打包方式 12.2 去除Tomcat依赖 12.3 修改Main类 12.4 路径问题 12.4.1 action 12.4.2 @GetMapping 12.4.3 @PostMapping 12.4.4 redirect 12.5 设置打包名字 12.6 Maven打包 12.7 打包完成 12.8 上传到服务器 12.9 开启Tomcat 12.10 测试 13 源码 14 参考 1 概述 Spring Boot上传文件,根据官方uploadfile示例修改的,可以打成war放到服务器上(笔者使用的是Tomcat).主要步骤是创建异常类,属性类,接口类与控制器类,最后进行少量修改打包部署到服务器上. 2 环境 win10 Tomcat 9.0.30 IDEA 2019.03 Spring boot 2.2.2 RELEASE 3 新建工程 选择spring initializer: 改一下包名,打包选项这里可以jar可以war,选jar的话可以在build的时候再生成war. 这里用的是模板引擎Thymeleaf,选择spring web与Thymeleaf. 最后点击finish. 4 新建包 4个包,service,properties,controller,exception. 5 exception 处理两个异常,分别是存储异常与存储文件找不到异常. 5.1 StorageException package kr.test.exception; public class StorageException extends RuntimeException { public StorageException(String message) { super(message); } public StorageException(String message,Throwable cause) { super(message,cause); } } 5.2 StorageFileNotFoundException package kr.test.exception; public class StorageFileNotFoundException extends StorageException { public StorageFileNotFoundException(String message) { super(message); } public StorageFileNotFoundException(String message,Throwable cause) { super(message,cause); } } Exception(String message,Throwable cause); 这个构造函数中的cause是引起这个异常的异常,允许空值,如果是空值则表示这个引起这个异常的异常不存在或者未知. 6 properties 新建StorageProperties.java,设定存储文件的位置,就是location的值,可以使用&quot;../../&quot;这样的值,什么也不加的话会在项目路径下新建文件夹,若有同名的文件夹会被删除再重新创建. 注意一下权限的问题,后面部署到Tomcat上面时可能会因为没有写权限而不能写入文件,要确保文件夹拥有写权限. package kr.test.properties; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(&quot;storage&quot;) public class StorageProperties { private String location = &quot;upload_dir&quot;; public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } } 这里使用@ConfigurationProperties会报红,提示没有@EnableConfigurationProperties: 可以先不管,后面会在Main类中添加@EnableConfigurationProperties(StorageProperties.class). 7 service 先加一个StorageService接口: package kr.test.service; import org.springframework.core.io.Resource; import org.springframework.web.multipart.MultipartFile; import java.nio.file.Path; import java.util.stream.Stream; public interface StorageService { void init(); void store(MultipartFile file); Stream&lt;Path&gt; loadAll(); Path load(String filename); Resource loadAsResource(String filename); void deleteAll(); } 然后新建一个FileSystemStorageService实现该接口: package kr.test.service; import kr.test.exception.StorageException; import kr.test.exception.StorageFileNotFoundException; import kr.test.properties.StorageProperties; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.Resource; import org.springframework.core.io.UrlResource; import org.springframework.stereotype.Service; import org.springframework.util.FileSystemUtils; import org.springframework.util.StringUtils; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardCopyOption; import java.util.stream.Stream; @Service public class FileSystemStroageService implements StorageService { private final Path rootLocation; @Autowired public FileSystemStroageService(StorageProperties properties) { this.rootLocation = Paths.get(properties.getLocation()); } @Override public void init() { try { Files.createDirectories(rootLocation); } catch (IOException e) { throw new StorageException(&quot;Could not initialize storage&quot;,e); } } @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } @Override public Path load(String filename) { return rootLocation.resolve(filename); } @Override public Stream&lt;Path&gt; loadAll() { try { return Files.walk(rootLocation,1) .filter(path -&gt; !path.equals(rootLocation)) .map(rootLocation::relativize); } catch (IOException e) { throw new StorageException(&quot;Failed to read stored file.&quot;,e); } } @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if(resource.exists() || resource.isReadable()) { return resource; } else { throw new StorageFileNotFoundException(&quot;Could not read file: &quot;+filename); } } catch (MalformedURLException e) { throw new StorageFileNotFoundException(&quot;Could not read file : &quot;+filename,e); } } @Override public void store(MultipartFile file) { String filename = StringUtils.cleanPath(file.getOriginalFilename()); try { if(file.isEmpty()) { throw new StorageException(&quot;Failed to store empty file : &quot;+filename); } if(filename.contains(&quot;..&quot;)) { throw new StorageException(&quot;Cannot store file with relative path outside current directory&quot;+filename); } try(InputStream inputStream = file.getInputStream()) { Files.copy(inputStream,rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new StorageException(&quot;Failed to store file : &quot;+ filename,e); } } } 7.1 init @Override public void init() { try { Files.createDirectories(rootLocation); } catch (IOException e) { throw new StorageException(&quot;Could not initialize storage&quot;,e); } } 使用java.nio.file.Files.createDirectories()创建存储目录,可以建立多级目录. 7.2 deleteAll @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } 使用工具类FileSystemUtils的方法递归删除文件与文件夹.参数是一个File. 下面是方法源码: public static boolean deleteRecursively(File root) { if (root != null &amp;&amp; root.exists()) { if (root.isDirectory()) { File[] children = root.listFiles(); if (children != null) { for (File child : children) { deleteRecursively(child); } } } return root.delete(); } return false; } 首先判断根是否为空,不为空的话判断是否是目录,不是目录的话直接删除,是目录的话,利用listFiles()获取所有文件及文件夹,判断是否为空并进行递归删除. 7.3 load @Override public Path load(String filename) { return rootLocation.resolve(filename); } Path.resolve(String)返回相对于this的路径,具体来说,等于执行 cd rootLocation cd filename pwd 返回pwd的值. 7.4 loadAll @Override public Stream&lt;Path&gt; loadAll() { try { return Files.walk(rootLocation,1) .filter(path -&gt; !path.equals(rootLocation)) .map(rootLocation::relativize); } catch (IOException e) { throw new StorageException(&quot;Failed to read stored file.&quot;,e); } } Files.walk遍历目录,返回一个Stream&lt;Path&gt;,返回的Stream包含打开的一个或多个目录的引用,会在Stream关闭时关闭,第二个参数1表示遍历的最大深度. 然后对这个Stream进行filter过滤,这里是把与rootLocation不相等的Path留下,注意是不相等,就是留下filter()中条件为真的Path,不是把条件为真的Path给&quot;删去&quot;. 最后进行map,relativize返回参数相对于调用者的路径,这里是返回Stream中的每个Path相对于rootLocation的路径. 对于relativize,无论什么情况下: Path a = xxxx; Path b = xxxx; 都有 a.relativize(a.resolve(b)).equals(b) 为真. 7.5 loadAsResource @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if(resource.exists() || resource.isReadable()) { return resource; } else { throw new StorageFileNotFoundException(&quot;Could not read file: &quot;+filename); } } catch (MalformedURLException e) { throw new StorageFileNotFoundException(&quot;Could not read file : &quot;+filename,e); } } 这里的Resource是org.springframework.core.io.Resource,是一个接口,可以通过它访问各种资源,实现类有UrlResource,InputStreamResource等,这里利用Path.toUri()把file转换为Resource后,判断这个源是否存在或者是否可读并返回,否则抛出存储文件找不到异常. 7.6 store @Override public void store(MultipartFile file) { String filename = StringUtils.cleanPath(file.getOriginalFilename()); try { if(file.isEmpty()) { throw new StorageException(&quot;Failed to store empty file : &quot;+filename); } if(filename.contains(&quot;..&quot;)) { throw new StorageException(&quot;Cannot store file with relative path outside current directory&quot;+filename); } try(InputStream inputStream = file.getInputStream()) { Files.copy(inputStream,rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new StorageException(&quot;Failed to store file : &quot;+ filename,e); } getOriginalFilename()获取文件原名字,然后通过StringUtils.cleanPath()将其标准化,.处理掉&quot;.&quot;与&quot;..&quot;,然后判断文件是否为空与是否包含相对路径,没有的话利用Files.copy()进行复制,resolve获取filename相对于rootLocation的值,复制选项是REPLACE_EXISTING. StandardCopyOption有三个可选值: ATOMIC_MOVE:原子性的移动操作,一般在移动文件或目录时使用. COPY_ATTRIBUTES:复制属性,可以保留源文件或源目录的属性. REPLACE_EXISTING:替换已存在的文件. 8 controller 新建FileUploadController. package kr.test.controller; import kr.test.exception.StorageFileNotFoundException; import kr.test.service.StorageService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.Resource; import org.springframework.http.HttpHeaders; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import java.util.stream.Collectors; @Controller public class FileUploadController { private final StorageService storageService; @Autowired public FileUploadController(StorageService storageService) { this.storageService = storageService; } @GetMapping(&quot;/&quot;) public String listUploadedFiles(Model model) { model.addAttribute(&quot;files&quot;,storageService.loadAll().map( path -&gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, &quot;serveFile&quot;,path.getFileName().toString()).build().toString()) .collect(Collectors.toList())); return &quot;uploadForm&quot;; } @GetMapping(&quot;/files/{filename:.+}&quot;) @ResponseBody public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) { Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot;).body(file); } @PostMapping(&quot;/&quot;) public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) { storageService.store(file); redirectAttributes.addFlashAttribute(&quot;message&quot;,&quot;You successully uploaded &quot;+file.getOriginalFilename()+&quot;!&quot;); return &quot;redirect:/&quot;; } @ExceptionHandler(StorageFileNotFoundException.class) public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException e) { return ResponseEntity.notFound().build(); } } 8.1 listUploadedFiles @GetMapping(&quot;/&quot;) public String listUploadedFiles(Model model) { model.addAttribute(&quot;files&quot;,storageService.loadAll().map( path -&gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, &quot;serveFile&quot;,path.getFileName().toString()).build().toString()) .collect(Collectors.toList())); return &quot;uploadForm&quot;; } @GetMapping是@RequestMapping(method = RequestMethod.GET)的简化写法,将HTTP GET路径映射到特定的处理方法上. 方法的参数是spring MVC中的Model,Model实质上是一个Map,添加的key可以在视图中用${key}获取值,比如,这里添加了&quot;files&quot;作为key,则在视图中可用 ${files}获取值. MvcUriComponentsBuilder可以为Controller指定uri,fromMethod简单地说就是会调用FileUploadController的serveFile(),参数是path.getFileName().toString(),由于serveFile()返回的是Stream&lt;Path&gt;,利用Stream的collect将其转换成List添加到model中,然后返回uploadForm,表示这是视图的名称,会到resource/templates下寻找. 这里说一下RequestMapping与Model: 8.1.1 RequestMapping 可以用@RequestMapping()来映射URL,可以映射到某个类或某个具体方法.@RequestMapping常用的有以下属性: value:请求的URL路径,支持URL模板,正则表达式. method:HTTP请求方法,如GET,POST,PUT,DELTE等. consumes:允许的媒体类型,如consumes=&quot;application/json&quot;.对应于HTTP请求的Content-Type. produces:相应的媒体类型,如produces=&quot;application/json&quot;,对于HTTP请求的Accept. params:请求参数,如params=&quot;action=update&quot;. headers:请求头. Spring提供了简化的@RequestMapping,提供了新的注解来标识HTTP方法: @GetMapping @PostMapping @PutMapping ... 所以这里的@GetMapping是简化了的@RequestMapping. 8.1.2 Model 可以向Model添加视图所需要的变量,Model主要有以下方法: Model addAttribute(Object value); Model addAttribute(String name,Object value); Model addAllAttributes(Map attributes); Model addAllAttributes(Collection&lt;?&gt; attributes); Model mergeAttributes(Map attributes); boolean containAttribute(String name); addAttribute()添加一个变量,对于两个参数的,使用name作为变量名称,后面的是值,对于只有一个Object的,变量的名字就是类名字首字母小写后转为的java变量. addAttributes()添加多个变量,如果变量存在则覆盖,其中参数为Collection&lt;?&gt;的方法添加变量名时与addAttribute(Object)的命名规范类似. mergeAttributes()也是添加多个变量,不过变量已存在的话会忽略. containAttributte()判断是否存在变量. 8.2 serveFile @GetMapping(&quot;/files/{filename:.+}&quot;) @ResponseBody public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) { Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot;).body(file); } 这里的@GetMapping用来表示显示的用来供下载的文件名,@ResponseBody表示直接返回内容而不是视图名,因为默认返回的是视图名称,@ResponseBody对于String直接返回,否则默认使用Jackson进行序列化. @PathVariable表示这是@GetMapping中的参数的值,可以省略,默认同名,就是形参的名字与GetMapping中的名字一样,从中取值赋给形参,通过filename加载资源后,作为ResponseEntity的请求体. ResponseEntity从HttpEntity继承而来,ResponseEntity.ok()是一个静态方法,表示构建一个状态为&quot;ok&quot;的ResponseEntity,然后添加请求头. HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot; content_disposition表示文件是直接在浏览器打开还是下载,attachment表示是要下载,文件名为file.getFilename(). 8.3 handleFileUpload @PostMapping(&quot;/&quot;) public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,RedirectAttributes redirectAttributes) { storageService.store(file); redirectAttributes.addFlashAttribute(&quot;message&quot;,&quot;You successully uploaded &quot;+file.getOriginalFilename()+&quot;!&quot;); return &quot;redirect:/&quot;; } @PostMapping()与@GetMapping()类似,只不过方法不是GET而是POST.@RequestParam表示请求参数,里面的是请求参数的名字,使用MultipartFile来处理文件上传. RedirectAttributes是用于重定向使用的,可以附带参数,RedirectAttributes有两种带参的形式: addAttribute(String name,Object value); addFlashAttribute(String name,Object value); addAttribute()相当于直接在重定向的地址添加 name=value 这样的形式,会将参数暴露在重定向的地址上. 而addFlashAttribute()隐藏了参数,只能在重定向的页面中获取参数的值,用到了session,session跳转到页面后就会删除对象. handleFileUpload首先保存文件,然后添加一个保存成功的信息,由于Controller中重定向可以返回以&quot;redirect:&quot;或以&quot;forward:&quot;为前缀的URI,因此返回&quot;redirect:/&quot;,重定向到根. 8.4 handleStorageFileNotFound @ExceptionHandler(StorageFileNotFoundException.class) public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException e) { return ResponseEntity.notFound().build(); } @ExceptionHandler()注解会处理Controller层抛出的所有StorageFileNotFoundException类及其子类的异常,ResponseEntity.notFound()相当于返回404标识码. 9 main package kr.test; import kr.test.properties.StorageProperties; import kr.test.service.StorageService; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; @SpringBootApplication @EnableConfigurationProperties(StorageProperties.class) public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Bean CommandLineRunner init(StorageService storageService) { return (args) -&gt; { storageService.deleteAll(); storageService.init(); }; } } 在原来的基础上添加 @EnableConfigurationProperties(StorageProperties.class) 与 @Bean CommandLineRunner init(StorageService storageService) { return (args) -&gt; { storageService.deleteAll(); storageService.init(); }; } @EnableConfigurationProperties可以为带有@ConfigurationProperties注解的Bean提供有效的支持,将带有@Configuration注解的类注入为Spring的Bean,在这里是使StorageProperties的@ConfigurationProperties生效,如果没有这一行会报红: @Bean标注在方法上,等价于spring的xml配置文件的&lt;bean&gt;,注册bean对象. CommandLineRunner接口用于应用初始化后去执行一段代码逻辑,这段代码在整个应用周期只执行一次. 10 application.properties 这里可以设置一些环境配置属性,Spring Boot允许准备多个配置文件,在部署时可以指定那个配置文件覆盖默认的application.properties.这里是有关上传文件的设置: 默认如下: spring.servlet.multipart.enabled=true spring.servlet.multipart.file-size-threshold=0 spring.servlet.multipart.location= spring.servlet.multipart.max-file-size=1MB spring.servlet.multipart.max-request-size=10MB spring.servlet.multipart.resolve-lazily=false enabled表示允许上传,file-size-threshold表示上传文件超过一定长度就先写入临时文件,单位MB或KB,location是临时文件存放目录,不设定的话使用web服务器提供的临时目录.max-file-size表示单个文件最大长度,默认1MB,max-request-size为单次HTTP请求上传的最大长度,默认10MB,resolve-lazily表示文件和参数被访问的时候再解析成文件. 在这里只需把max-size调大一点即可. 11 测试 这是在本地进行的测试.直接在IDE上点击运行应用,然后打开浏览器输入: localhost:8080 12 打包部署到Tomcat上 Spring Boot通常打成jar包或war包,这里部署到Tomcat上的是打成war包. 12.1 改变打包方式 pom.xml中,&lt;packaing&gt;改成war: 12.2 去除Tomcat依赖 Spring Boot默认自带了一个嵌入式的Tomcat,需要把Tomcat依赖方式改为provided. pom.xml中,在&lt;dependencies&gt;添加: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 12.3 修改Main类 修改Main类,让其继承SpringBootServletInitializer,重载configure(),同时main()保持不变. @SpringBootApplication public class MainClass extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(MainClass.class); } //main()不变 } 12.4 路径问题 这个很重要,设置不当的话就无法访问了,主要就是四个路径: action: @GetMapping @PostMapping redirect 12.4.1 action 这个是绝对路径,要加上/war项目名. /war项目名/上传路径名 比如这里war项目名是kr,上传路径名是upload. 12.4.2 @GetMapping 这个是相对路径,相对于当前项目的路径,不用加上/war项目名. /上传路径名 这里是upload. 12.4.3 @PostMapping 与@GetMapping一样,上传路径名. /上传路径名 12.4.4 redirect 这个是返回的重定向的路径名,相对路径,与上两个一样,也是上传路径名. /上传路径名 12.5 设置打包名字 在&lt;build&gt;中添加&lt;finalName&gt;,指定打包出来的war名,注意这个要与上面的war项目名一样,这里设置的是kr. 12.6 Maven打包 运行 mvn package 即可打包,对于IDEA,可以在IDEA右侧栏的Maven中,打开Lifecycle,选择package: 12.7 打包完成 打包后的war默认放在target下,名字默认为&lt;artifactId&gt;+&lt;version&gt;. 12.8 上传到服务器 上传的话笔者用的是密钥认证的scp: scp -i xxxx\\id_rsa kr.war username@ip:/usr/local/tomcat/webapps 放到服务器的Tomcat下的webapps目录. 12.9 开启Tomcat 进入到Tomcat目录的bin下: cd /usr/local/tomcat/bin ./startup.sh 如果正在运行的话就不用启动了,因为会自动检测到webapps目录的变化,把新的war自动解包. 12.10 测试 略,与本地测试类似,不过要注意的是上传的文件夹是在tomcat/bin下,想要修改的话可以修改StorageProperties的location. 13 源码 github 码云 14 参考 1.ConfigurationProperties 2.CommandLineRunner 3.RedirectAttribute ","link":"https://2293736867.github.io/post/spring-boot-shang-chuan-wen-jian-bu-shu-dao-tomcat/"},{"title":"软件工程学习笔记(三):需求工程","content":" 1 概述 2 需求获取 2.1 软件需求 2.1.1 功能需求 2.1.2 性能需求 2.1.3 用户或人的因素 2.1.4 环境需求 2.1.5 界面需求 2.1.6 文档需求 2.1.7 数据需求 2.1.8 资源使用需求 2.1.9 安全保密需求 2.1.10 可靠性需求 2.1.11 软件成本消耗与开发进度需求 2.1.12 其他非功能性需求 2.2 需求获取的方法即策略 2.2.1 建立顺畅的通信途径 2.2.2 访谈与调查 2.2.3 观察用户操作流程 2.2.4 成立联合小组 2.2.5 用况 3 需求分析 3.1 原则 3.2 信息域 3.2.1 信息内容 3.2.2 信息流 3.2.3 信息结构 3.3 需求协商 3.4 需求建模 4 需求规约 4.1 引言 4.2 信息描述 4.3 功能描述 4.4 行为描述 4.5 检验标准 4.6 参考书目 4.7 附录 5 需求验证 6 需求管理 1 概述 需求工程是应用已证实有效的技术与方法开展需求分析,确定客户需求,帮助分析人员理解问题,评估可行性,协商合理的解决方案,无歧义地规约方案,确认规约以及将规约转换到可运行系统时的需求管理.需求工程是一个不断反复的需求定义,文档记录,需求演进的过程,并最终在验证的基础上冻结需求.需求工程可以分为六个阶段:需求获取,需求分析与协商,系统建模,需求规约,需求验证,需求管理. 2 需求获取 需求获取阶段分析人员通过与用户的交流,对现有系统的观察以及对任务进行分析,确定系统或产品范围的限制性描述,与系统或产品有关的人员及特征列表,系统的技术环境的描述,系统功能列表及应用于每个需求的领域限制,描述不同运行条件下系统或产品使用状况的应用场景等,为需求分析打下基础. 2.1 软件需求 软件需求是指用户对目标软件系统在功能,行为,性能,设计约束等方面的期望,包括: 2.1.1 功能需求 考虑系统要做什么,在何时做,在何时及如何修改或升级等. 2.1.2 性能需求 考虑软件开发的技术性指标,例如,存储容量限制,执行速度,响应时间以及吞吐量. 2.1.3 用户或人的因素 考虑用户的类型,例如用户对使用计算机的熟练程度,需要接受的训练,用户理解,使用系统的难度,用户错误操纵系统的可能性等. 2.1.4 环境需求 考虑未来软件应用的环境,包括硬件和软件,对硬件设备的需求包括机型,外设,接口,地点,分布,温度,湿度,磁场干扰等.对软件的需求包括操作系统,网络,数据库等. 2.1.5 界面需求 考虑来自其他系统的输入,到其他系统的输出,对数据格式的特殊规定,对数据存储介质的规定. 2.1.6 文档需求 考虑需要哪些文档,文档针对的读者. 2.1.7 数据需求 考虑输入,输出数据的格式,接受,发送数据的频率,数据的准确度与精度,数据流量,数据需保持的时间等. 2.1.8 资源使用需求 考虑软件运行时所需要的数据,其他软件,内存空间等资源.软件开发,维护所需的人力,支撑软件,开发设备等. 2.1.9 安全保密需求 考虑是否需要对访问系统或系统信息加以控制,隔离用户数据与方法,用户程序如何与其他程序和操作系统隔离以及系统备份要求等等. 2.1.10 可靠性需求 考虑系统的可靠性技术,系统是否必须监测和隔离错误,出错后重启系统允许的时间等. 2.1.11 软件成本消耗与开发进度需求 考虑开发是否有规定的时间表,软硬件投资有无限制等. 2.1.12 其他非功能性需求 如采用某种开发模式,确定质量控制标准,里程碑和评审,验收标准,各种质量要求的优先级等,以及可维护性方面的需求. 2.2 需求获取的方法即策略 2.2.1 建立顺畅的通信途径 在用户,系统分析人员,软件开发小组,管理人员之间建立良好的沟通方式,以保证能顺利地对问题进行分析. 2.2.2 访谈与调查 分析人员要从分析已经存在的同类的软件产品,或从行业标准,规则中提取初步需求,然后以个别访谈的形式或小组会议的形式开始与用户进行初步的沟通.除了进行面谈外,可以进行市场调查,了解市场对将开发的软件有什么样的要求,可以采取多种调查方式,指定调查提纲,向不同层次的用户发调查表,或访问用户和领域专家. 2.2.3 观察用户操作流程 到用户的实际工作环境中对用户的工作流程进行观察,了解用户的实际操作环境,操作过程与操作要求,对照用户提交的问题陈述,对用户需求可以有更全面细致的认识. 2.2.4 成立联合小组 采用一种叫FAST(facilitated application sepcification techniques)的技术用户与开发方成立一个联合小组,发挥各自的长处,共同负责项目的推进.FAST鼓励建立用户与开发者队伍之间的合作,共同工作来标识问题,提出解决方法的要素,商议不同的方法以及刻画初步的解决方案. 它已经成为信息系统使用的主流技术,该技术为改善各种应用中的相互通信提供了潜在的可能.FAST团队由来自市场,软件与硬件工程以及制造方的代表组成,并选择外来人员作为协调者.该方法有一下基本原则: 在中立的地点举行由开发者和用户出席的会议 建立准备和参与会议的规则 建立一个足够正式的议程以便可以进行自由的交流 由一个&quot;协调者&quot;(用户,开发者,或其他人)来控制会议 使用一种&quot;定义机制&quot;(工作表,图标等) 目标是标识问题,提出解决方案的要素,商议不同的方法以及在有利于完成目标的氛围中刻画出初步的需求 2.2.5 用况 用况常被称为用例,应该包含: 执行者完成的主要任务或功能 执行者将获取,生产或改变什么信息 执行者是否必须通知系统关于外部环境的变化 执行者希望从系统获得什么信息 执行者是否希望被通知未预期的变化 3 需求分析 3.1 原则 必须能够表示和理解问题的信息域 必须能够定义软件将完成的功能 必须能够表示软件的行为 必须划分描述的数据,功能和行为的模型 分析过程应该从要素信息移向细节信息 3.2 信息域 信息域包括信息内容,信息流以及信息结构. 3.2.1 信息内容 信息内容表示了单个数据和控制对象,目标软件所有处理的信息集合由它们构成. 3.2.2 信息流 信息流表示了数据和控制在系统中流动时的变化方式,输入对象被变换为中间信息,然后进一步被变换为输出. 3.2.3 信息结构 信息结构表示了各种数据和控制项的内部组织形式. 3.3 需求协商 需求很容易出现冲突,这就需要进行协商,讨论需求冲突,通常会议是解决冲突最快的方式. 3.4 需求建模 创建模型是需求分析的重要活动.模型以一种简洁,准确,结构清晰的方式系统地描述了软件需求,从而帮助分析员理解系统的信息,功能与行为,模型还将成为软件设计的基础,为设计者提供软件要素的表示视图. 4 需求规约 需求规约是分析任务的最终产物,通过建立完整的信息描述,详细的功能和行为描述,性能需求和设计约束的说明,合适的验收标准,给出对目标软件的各种需求.软件需求规约的框架主要分为5部分: 4.1 引言 引言陈述软件目标,在基于计算机的系统语境内进行描述,包括系统参考文献,整体描述,软件项目约束等. 4.2 信息描述 信息描述给出软件必须解决的问题的详细描述,记录信息内容,信息流,信息结构. 4.3 功能描述 功能描述用以描述解决问题所需要的每个功能,其中包括为每个功能说明一个处理过程,叙述设计约束,叙述性能特征,用一个或多个图形来形象地表示软件的整体结构和软件功能与其他元素间的相互影响. 4.4 行为描述 行为描述用以描述作为外部事件和内部产生的控制特征的软件操作. 4.5 检验标准 检验标准描述检验系统成功的标志,即对系统进行什么样的测试,得到什么样的结果,就表示系统已经成功实现了.检验标准是确认测试的基础. 4.6 参考书目 对所有和该软件相关文档的引用,包括其他的软件工程的文档,技术参考文献,厂商文献和标准. 4.7 附录 包含了规约的补充信息,表格数据,算法的详细描述,图表和其他材料. 5 需求验证 需求验证的目的是检验是否能够反映用户的意愿,需要对需求文档中定义的需求执行多种检查,评审团队应该检查需求的有效性,一致性和作为一个整体的完备性.包括系统定义的目标是否与用户的要求一致,系统需求分析阶段提供的文档资料是否齐全,被开发的数据流与数据结构是否确定且充足,主要功能是否已包括在规定的软件范围之内,是否都已充分说明,设计的约束条件或限制条件是否符合实际,开发的技术风险是什么,是否详细制定了检验标准,它们能否对系统定义进行确认. 6 需求管理 需求管理是一组用于帮助项目组在项目进展中的任何时候去标识,控制和跟踪需求的活动.在需求管理中,每个需求被赋予唯一的标识符,一旦标示出需求,就可以为需求建立跟踪表,每个跟踪表标示需求与其他需求或设计文档,代码,测试用例的不同版本间的关系.这些跟踪表可以用于需求跟踪,在整个开发过程中,进行需求跟踪的目的是为了建立和维护从用户需求开始到测试之间的一致性与完整性.确保所有的实现是以用户需求为基础,所有的输出符合用户需求,并且全面覆盖了用户需求. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-san-xu-qiu-gong-cheng/"},{"title":"软件工程学习笔记(二):系统工程","content":" 1 系统工程 2 系统工程的任务 2.1 识别用户的要求 2.2 系统建模与模拟 2.2.1 硬件系统模型 2.2.2 软件系统模型 2.2.3 人机接口模型 2.2.4 数据模型 2.3 成本估算及进度安排 2.4 可行性分析 2.4.1 经济可行性 2.4.1.1 成本 2.4.1.2 效益 2.4.1.3 货币的时间价值 2.4.1.4 投资回收期 2.4.1.5 纯收入 2.4.2 技术可行性 2.4.2.1 风险分析 2.4.2.2 资源分析 2.4.2.3 技术分析 2.4.3 法律可行性 2.5 生成系统规格说明 1 系统工程 软件工程中的系统是指基于计算机的系统,而基于计算机的系统是指通过完成处理某些预定义目标而组织在一起的元素的集合或排列.系统工程过程依赖于应用领域而呈现不同的形式,当工作的语境集中于业务企业时,进行业务过程工程,当关注产品生产的过程时,称为产品工程. 2 系统工程的任务 系统工程主要包括以下5个方面的任务: 2.1 识别用户的要求 系统工程的第一步就是识别用户对基于计算机的系统的总体要求,标识系统的功能和性能范围,确定系统的功能,性能,约束和接口. 2.2 系统建模与模拟 系统模型通常可用图形来描述,配合相应的文字说明,.必要时在系统建模后可构造原型,进行系统模拟,以分析所建的模型是否满足整个基于计算机的系统的要求.一个基于计算机的系统通常可以考虑一下的模型: 2.2.1 硬件系统模型 硬件系统模型描述基于计算机系统中的硬件配置,通信协议,拓扑结构,以及确保基于计算机系统的安全性,可靠性,性能等要求的措施. 2.2.2 软件系统模型 基于计算机系统中的软件部分可以分为若干个子系统,软件系统模型描述各个子系统的功能,性能等要求,各软件子系统在硬件系统中的部署情况,以及软件子系统之间的交互. 2.2.3 人机接口模型 人机接口模型描述人如何与基于计算机的系统进行交互,包括用户环境,用户的活动,人机交互的语法与语义等. 2.2.4 数据模型 数据模型主要描述基于计算机的系统使用了哪些数据库管理系统,如果使用多个数据库管理系统还应描述它们之间的数据转换方式,必要时可给出主要的数据结构. 2.3 成本估算及进度安排 开发一个基于计算机的系统需要一定的资金投入和时间约束,因此在系统工程阶段对需开发的基于计算机的系统进行成本估算,并作出进度安排. 2.4 可行性分析 可行性分析主要从三方面进行: 2.4.1 经济可行性 主要进行成本效益分析,从经济角度确定系统是否值得开发. 2.4.1.1 成本 购置硬件,软件和设备的费用 系统的开发费用 系统安装,运行与维护费用 人员培训费用 2.4.1.2 效益 效益可以分为社会效益与经济效益,经济效益包括使用基于计算机的系统后可增加的收入和可节省的运行费用.社会效益指使用基于计算机的系统后对社会产生的影响,通常社会效益只能定性地估计,经济效益通常可用货币的时间价值,投资回收期和纯收入来度量. 2.4.1.3 货币的时间价值 通常可以利用年利率来衡量货币的时间价值,设银行储蓄的年利率为i,现存入钱P,在n年后可得到的钱F,则 因此,n年后得到的F,折合成现在的钱P的公式为: 2.4.1.4 投资回收期 投资回收期是指累计的经济效益正好等于投资成本所需的时间,投资回收期通常是用于评价开发一个工程的价值的重要经济指标. 2.4.1.5 纯收入 纯收入指出了若干年扣除成本后的实际收入: 纯收入 = 累计经济效益 - 成本. 2.4.2 技术可行性 技术可行性主要根据系统的功能,性能,约束条件等,分析在现有资源和技术条件系统下能否实现.主要包括: 2.4.2.1 风险分析 风险分析主要分析在给定的约束条件下设计和实现系统的风险,在可行性分析时,风险分析的目的是找出风险,评价风险的大小,分析能否有效地控制和缓解风险. 2.4.2.2 资源分析 资源分析主要论证是否具备系统开发所需的各类人员,软件,硬件等资源和相应的工作环境. 2.4.2.3 技术分析 技术分析主要分析当前的科学技术是否支持系统开发的各项活动.在技术分析过程中,分析员收集系统的性能,可靠性,可维护性和生产率方面的信息,分析实现系统功能,性能所需的技术,方法,算法或过程,从技术角度分析可能存在的风险,以及这些技术问题对成本的影响. 2.4.3 法律可行性 法律可行性主要研究系统开发过程中可能涉及到的合同,侵权,责任以及各种与法律相关抵触的问题.《中华人民共和国著作权法》与《计算机软件保护条例》是可行性分析的主要依据. 2.5 生成系统规格说明 完成以上任务后应生成一份系统规格说明,作为以后开发基于计算机的系统的依据.系统规格说明描述基于计算机的系统的功能,性能与约束条件,描述系统的输入与输出控制信息给出各系统元素的模型,进行可行性分析,最后给出成本估算以及进度安排计划. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-er-xi-tong-gong-cheng/"},{"title":"软件工程学习笔记(一):软件工程","content":" 1 计算机软件 1.1 软件 1.2 软件特点 1.3 软件分类 1.3.1 系统软件 1.3.2 支撑软件 1.3.3 应用软件 2 软件语言 2.1 需求定义语言 2.2 功能性语言 2.3 设计性语言 2.4 程序设计语言 2.5 文档语言 3 软件工程 4 软件工程的基本原则 4.1 适宜的开发规范 4.2 合适的设计方法 4.3 高质量的工程支持 4.4 有效的软件工程管理 5 软件生存周期 5.1 计算机系统工程 5.2 需求分析 5.3 设计 5.4 编码 5.5 测试 5.6 运行与维护 6 CMM 6.1 初始级 6.2 可重复级 6.3 已定义级 6.4 已管理级 6.5 优化级 7 CMMI 7.1 阶段式模型 7.1.1 初始的 7.1.2 已管理的 7.1.3 已定义的 7.1.4 定量管理的 7.1.5 优化的 7.2 连续式模型 7.2.1 CL0 7.2.2 CL1 7.2.3 CL2 7.2.4 CL3 7.2.5 CL4 7.2.6 CL5 8 软件过程模型 8.1 瀑布模型 8.1.1 优点 8.1.2 缺点 8.2 增量模型 8.2.1 优点 8.2.2 缺点 8.3 原型模型 8.3.1 优点 8.3.2 缺点 8.4 螺旋模型 8.4.1 优点 8.4.2 缺点 8.5 喷泉模型 8.5.1 优点 8.5.2 缺点 8.6 基于构件的开发模型 8.6.1 优点 8.6.2 缺点 8.7 形式化方法模型 8.7.1 优点 8.7.2 缺点 1 计算机软件 1.1 软件 计算机软件是指计算机系统中的程序以及文档,程序是计算任务处理对象和处理规则的描述. 1.2 软件特点 一种逻辑实体. 维护工作量大. 维护软件过程中会引入副作用. 1.3 软件分类 1.3.1 系统软件 最靠近硬件的一层,比如操作系统. 1.3.2 支撑软件 软件开发,维护与运行的软件,比如各种IDE等. 1.3.3 应用软件 应用于特定领域的软件. 2 软件语言 软件语言主要包括需求定义语言,功能性语言,设计性语言,程序设计语言与文档语言. 2.1 需求定义语言 用于书写软件需求定义的语言,包括功能需求与非功能需求.典型的语言有PSL. 2.2 功能性语言 书写软件功能规约的语言,描述软件做什么以及只做什么.典型语言有广谱语言,Z语言. 2.3 设计性语言 书写软件设计规约的语言,是软件设计的严格而完整的描述.典型语言有PDL. 2.4 程序设计语言 即编程语言,可以分为低级语言与高级语言,过程式语言与非过程式语言,通用语言与专用语言,交互式语言与非交互式语言,顺序语言与并发语言与分布语言. 2.5 文档语言 书写软件文档使用的语言,比如Z语言. 3 软件工程 软件工程是建立和使用一套合理的工程原则,以便获得经济的软件,这种软件是可靠的,可以在实际机器上高效地运行.软件工程是应用计算机科学理论以及工程管理原则的方法,按预算与进度实现满足用户要求的软件产品的工程,或以此为研究对象的学科. 4 软件工程的基本原则 4.1 适宜的开发规范 选用适宜的开发规范,以保证软件开发的可持续性,并使最终的软件产品满足客户的需求. 4.2 合适的设计方法 要考虑软件的模块化,信息隐藏,局部化,一致性以及适应性等问题,采用合适的设计方法有助于支持问题的解决与实现. 4.3 高质量的工程支持 需要提供高质量的工程支持,例如配置管理,质量保证等. 4.4 有效的软件工程管理 软件工程的管理直接影响可用资源的有效利用,以提高软件组织的生产能力. 5 软件生存周期 软件生存周期分为6个阶段: 5.1 计算机系统工程 计算机系统工程的任务是确定待开发软件的总体要求与范围,以及该软件与其他计算机系统元素之间的关系,进行成本估算,作出进度安排,并进行可行性分析. 5.2 需求分析 需求分析主要解决待开发软件要做什么的问题,确定软件的功能,性能,数据,界面等要求,生成软件需求规约. 5.3 设计 软件设计主要解决待开发软件怎么做的问题,通常可以分为系统设计与详细设计,系统设计的任务是设计软件系统的体系结构,详细设计的任务是设计各个组成成分的实现细节. 5.4 编码 利用程序设计语言进行编码. 5.5 测试 发现并纠正软件中的错误与缺陷,包括单元测试,集成测试,确认测试与系统测试. 5.6 运行与维护 软件运行期间需要进行维护,对软件进行修改. 6 CMM CMM是能力成熟度模型,定义了5个软件过程成熟度等级,包括初始级,可重复级,已定义级,已管理级,优化级. 6.1 初始级 软件过程的特点是无秩序的,甚至是混乱的,几乎没有什么过程是经过妥善定义的. 6.2 可重复级 建立了基本的项目管理过程来跟踪成本,进度与功能特性.制定了必要的过程纪律,能重复早先类似应用项目取得的成功. 6.3 已定义级 已将管理和工程活动两方面的软件过程文档化,标准化,并综合成该组织的标准软件过程.所有项目均使用经批准,剪裁的标准软件过程来开发与维护软件. 6.4 已管理级 收集对软件过程和产品质量的详细度量值,对软件过程和产品都有定量的理解与控制. 6.5 优化级 过程的量化反馈和先进的新思想,新技术促使过程不断改进. 7 CMMI CMMI是若干过程模型的综合与改进,是支撑多个工程学科和领域的系统的,一致的过程改进框架,能适应现代工程的特点与需要,能提高过程的质量与工作效率.CMMI有两种表示法:阶段式模型与连续式模型. 7.1 阶段式模型 阶段式模型的结构类似于CMM,分为5个成熟度等级: 7.1.1 初始的 过程不可预测且缺乏控制. 7.1.2 已管理的 过程为项目服务. 7.1.3 已定义的 过程为组织服务. 7.1.4 定量管理的 过程已度量和控制. 7.1.5 优化的 集中与过程改进. 7.2 连续式模型 连续式模型关注每个过程域的能力,一个组织对不同的过程域可以达到不同的过程域能力等级. CMMI包含了6个过程域能力等级,等级号为0-5,能力等级表明了单个过程域中组织执行的好坏程度.能力等级包括共性目标及相关的共性实践,可以独立地应用于任何单独的过程域,各能力等级的含义: 7.2.1 CL0 未完成的,过程域未执行或未达到CL1中定义的所有目标. 7.2.2 CL1 已执行的,其共性目标是过程可以将标识的输入工作产品转换成可标识的输出工作产品,以实现支持过程域的特定目标. 7.2.3 CL2 已管理的,共性目标是集中于已管理的过程的制度化.根据组织政策规定过程的运作将使用哪个过程,项目遵循已文档化的计划和过程描述,所有正在工作的人都有权使用足够的资源,所有工作任务和工作产品都被监督,控制和评审. 7.2.4 CL3 已定义的,共性目标是集中于已定义的过程的制度化.过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的,还必须收集过程资产和过程的度量,并用于将来对该过程的改进上. 7.2.5 CL4 定量管理的,共性目标是集中于可定量管理的过程的制度化.使用测量与质量保证来控制和改进过程域,建立和使用关于质量和过程执行的定量目标作为管理准则. 7.2.6 CL5 优化的,使用量化手段改变和优化过程域,以应对客户的要求的改变与持续改进计划的过程域的功效. 8 软件过程模型 软件过程模型习惯上也叫软件开发模型,是软件开发全部过程,活动和任务的结构框架. 8.1 瀑布模型 1970年由W.Royce提出,给出了软件生存周期活动的固定顺序,上一阶段的活动完成后向下一阶段活动过渡,最终得到开发的软件产品.瀑布模型中上一阶段的活动完成并经过评审后才能开始下一阶段的活动,特征是: 接受上一阶段活动的结果作为本阶段活动的输入. 依据上一阶段活动的结果实施本阶段应完成的活动. 对本阶段的活动进行评审. 将本阶段活动的结果作为输出,传递给下一阶段. 8.1.1 优点 最早出现应用最广泛的模型,确保软件开发的顺利进行,对提高软件项目的质量和开发效率起到重要作用. 8.1.2 缺点 用户难以清晰描述所有需求,开发过程中需求也有可能发生改变. 发现错误时,为了改正错误要回到前一阶段,造成瀑布倒流. 在测试完成后才可以看到可运行的软件,发现问题的修改代价极大. 8.2 增量模型 增量模型将软件的开发过程分成若干个日程时间交错的线性序列,每个线性序列产生一个可发布的增量版本,后一个版本是对前一个版本的修改和补充,重复增量发布的过程,直至产生最终的完善产品. 8.2.1 优点 适用于需求经常发生变化的软件开发,以后的增量中可以逐渐加入需求,另外可以有计划地管理技术风险. 8.2.2 缺点 需要良好的架构设计,避免加入的构件破坏已构造好的系统部分,需要对系统有好的全盘分析,否则容易退化成边做边改模型. 8.3 原型模型 原型是预期系统的一个可执行版本,反映了系统性质的一个选定的子集.一个原型不必满足目标软件的所有约束,目的是可以快速,低成本地构建原型.步骤是: graph TB 定义总体目标 --&gt; 标识需求 标识需求 --&gt; 指定原型开发计划 指定原型开发计划 --&gt; 确定原型目标和范围 确定原型目标和范围 --&gt; 快速设计建模 快速设计建模 --&gt; 构建原型 构建原型 --&gt; 交付使用 交付使用 --&gt; 收集反馈意见 收集反馈意见 --下一轮原型迭代开发--&gt; 定义总体目标 8.3.1 优点 用户与开发者在原型上达成一致,减少错误,缩短开发周期,加快进度,降低成本. 8.3.2 缺点 不利于原型系统作为最终产品,原型被建造仅仅是用户用来定义需求,之后便会被部分或全部抛弃,准确的原型设计比较困难,不利于开发人员创新. 8.4 螺旋模型 螺旋模型将原型实现的迭代特征与瀑布模型中的控制的和系统化的方面结合起来,增加了风险分析.螺旋模型沿着螺线自内向外旋转,4个任务区域(4个象限)内分别完成以下任务: 第一象限:风险分析,评价所选方案,识别风险,清楚风险. 第二象限:制订计划,确定软件目标,选定实施方案,弄清项目开发的限制条件. 第三象限:客户评估,评价开发工作,提出修正建议. 第四象限:工程实施,实施软件开发,验证工作产品. (图片来源:https://www.itread01.com/content/1544588849.html) 8.4.1 优点 设计灵活,成本计算容易,客户始终参加每个阶段的开发,可以进行有效的互动. 8.4.2 缺点 周期长,需要丰富的风险评估经验以及专门知识,如果未能及时标识风险,势必造成重大损失. 8.5 喷泉模型 喷泉模型是一种支持面向对象开发的过程模型.喷泉体现了面向对象的迭代与无间隙特性. 8.5.1 优点 各个阶段没有明显的边界,开发人员可以进行同步开发,提高软件项目的开发效率,节省开发时间. 8.5.2 缺点 不利于项目管理,要求严格编写文档,审核难度大. 8.6 基于构件的开发模型 利用预先包装的构件来构造应用系统.构件可以是内部开发的构件,也可以是商业化的构件. 8.6.1 优点 构件可重用,易于维护,对提高软件生产率,提高软件质量,降低成本有很大的帮助. 8.6.2 缺点 很难找到100%合适的构件,就是现有的构件不一定很适合使用,但基于已有构件构造出的构件未必经过100%的测试,难以保证质量. 8.7 形式化方法模型 形式化方法是建立在严格的数学基础上的一种软件开发方法,用严格的数学语言和语义描述功能规约与设计规约,通过数学的分析与推导,易于发现需求的歧义性,不完整性与不一致性,易于对分析模型,设计模型和程序进行验证.通过数学的演算,使得从形式化功能规约到形式化设计规约,以及从形式化设计规约到程序代码的转换成为可能. 8.7.1 优点 用数学语言解决了规格说明的二义性问题,提高了精确性用数学提供了确认手段,使得证明与验证软件按程序满足用户和系统的需求成为可能,可以可视化地模拟/执行模型. 8.7.2 缺点 形式化的方法比其他技术的抽象级别要低,容易陷入细节,需要提早确定系统边界,通常限于正确一致的模型,但大多数情况下模型并非正确与一致. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-yi-ruan-jian-gong-cheng/"},{"title":"Win10美化,让你的Win10独一无二,与众不同!","content":" 2020.06.23 更新 1 原则 2 桌面 2.1 桌面图标 2.2 任务栏 3 字体 4 开始菜单 5 透明化任务栏 5.1 TranslucentTB 5.2 Stardock Start10 5.3 TrayS 6 右键菜单 6.1 备份 6.2 修改 6.3 子菜单 6.4 隐藏菜单 7 资源合集 2020.06.23 更新 1 原则 美化之前,得先有一个目标对不对,笔者是一个喜欢简单的人,因此美化本着三大原则:简单,干净,整洁. 呃....好像很抽象的样子,上图吧.反正没图没真相. 怎么样,还可以吧,没有任何多余的东西. 再来一张美女: 嗯...看得挺舒服,算了还是换一点正常一点的. 嗯,大概就这样子了,下面是一个&quot;未处理前&quot;的win10,一步一步来. 2 桌面 首先第一步是修改可以看得见的东西,比如,桌面. 2.1 桌面图标 进入设置,个性化: 主题,桌面图标设置. 选择对应关闭即可. 2.2 任务栏 任务栏的图标可以直接右键选择取消固定,另外可以在设置里面进行进一步的设置.看个人喜好. 比如笔者喜欢只留下网络. 然后可以右键任务栏进行进一步的设置,如关闭搜索与任务视图按钮等. 然后就变成了这样: 3 字体 美化怎么能不美化字体呢?所以,一个好的字体很重要,这里笔者用的是Fira Code字体(好吧....这其实是编程专用的支持连字符的字体,用来做UI....好像不太恰当),纯碎是因为看习惯了.更换字体的工具很多,这里用的是软媒美化大师. 首先去下载字体,文末有链接,下载好后解压,右键字体选择安装,然后在软媒美化大师里面设置即可. 作为UI字体的话可能加粗比较好看,这个嘛...看个人. 4 开始菜单 接下来可以对开始菜单进行设置,设置--&gt;个性化--&gt;开始. 然后可以对磁贴进行修改. 5 透明化任务栏 这是目前的任务栏,呃...反正笔者觉得不太好. 这里推荐三种工具进行美化. 5.1 TranslucentTB 有安装版与绿色版的,这是使用效果. 换一张壁纸看看. 这个有两种模式可以选择:模糊与全透明.右键程序选择即可. 下面是模糊的效果. 5.2 Stardock Start10 这个是专门针对开始菜单进行美化的工具,可以对开始菜单样式进行美化,也可以对徽标美化. 好了,重点来了,要美化的是任务栏,选择Desktop,可以选择模糊与透明度,比TranslucentTB更强: 5.3 TrayS TrayS.exe除了能实现任务栏透明之外,还能把任务栏图标居中: 工具选项如下: 可以选择任务栏透明或者玻璃或者亚克力效果,而且还能显示系统监视. 6 右键菜单 既然桌面什么东西都没有...打开东西会不会很不方便? 当然,有一点,是会有那么一点点不方便,可以利用桌面右键菜单弥补这个不足. 对,就是修改右键菜单. 这个操作涉及到注册表,建议操作前先备份注册表. 6.1 备份 win+r,输入regedit. 先备份一份. 若不小心出了错可以选择import恢复. 6.2 修改 打开HKEY_CLASSES_ROOT\\DesktopBackground\\Shell\\Display.可以看到这里对应着Display与Personalize两个选项. 比如要增加一个微信,可以先在shell下新建一个key,然后在这个key下新建一个string value,取名icon,表示要显示的图标. icon的值为微信exe的位置,然后再WeChat下新建一个叫command的key,里面的值也是微信exe的位置. 然后可以再桌面看一下效果. 6.3 子菜单 如果想要子菜单咋整? 比如view这里. 没问题,类似的,在shell下新建一个key,叫app.接着创建一个叫SubCoommands的string value. 新建一个叫shell的key. shell下新建想要的东西,比如这里是微信. 然后像上面一样,添加一个叫icon的string value与叫command的key,两者的值都是微信exe的位置. 可以测试了. 6.4 隐藏菜单 在上面的基础上,在App中添加一个叫Extended的string value. 这个需要按着shift再点击右键才会显示的. 7 资源合集 Github 码云 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/win10-mei-hua-rang-ni-de-win10-du-yi-wu-er-yu-zhong-bu-tong/"},{"title":"Windows利器使用与配置","content":" 1 概述 2 Listary 2.1 基础配置 2.2 搜索配置 2.2.1 web搜索 2.2.2 目录搜索 2.2.3 命令 2.3 过滤 2.4 外观 2.5 快捷打开 3 WGesture 3.1 基本设置 3.2 全局手势 3.3 触发角和摩擦边 4 cmder 4.1 基本配置 4.2 背景 4.3 标签栏 4.4 确认 4.5 启动 4.6 杂项 4.7 快捷键 5 QtTabBar 5.1 安装 5.2 界面 5.3 基础配置 5.4 标签 5.5 窗口设置 5.6 工具栏 5.7 事件 5.8 拖拽 5.9 文件夹视图 5.10 额外视图 5.11 外观 5.12 组 5.13 应用程序 5.14 快捷键 5.15 预览 5.16 子菜单 1 概述 这篇文章主要讲述了一些windows下的&quot;利器&quot;级别工具的使用以及配置. 2 Listary Listary是一款强大的搜索工具,可以快速搜索过滤各种文件. 点击这里下载 2.1 基础配置 右键进入配置选项,建议开机启动. 2.2 搜索配置 这里可以设置搜索的关键字,包括本地文件搜索,web搜索. 2.2.1 web搜索 比如这里默认自带了百度引擎,关键字为bd,按两次ctrl打开搜索框,输入bd,空格,再加上搜索关键字. 可以按需要修改自己的搜索引擎,比如添加一个Magi引擎,先去magi引擎中随便搜索一个东西. 网址复制下来.到Listary中添加: 把q=后面的改成{query}即可. 2.2.2 目录搜索 这里可以为常用长目录设置一个简单的别名,直接在搜索框里输入即可. 比如这里为D:\\Document设置了一个doc: 2.2.3 命令 可以设置一些执行命令.自带的有reboot,cmd,cmda等. 也是与上面一样,设置关键字,路径等即可. 2.3 过滤 Listary的一个强大功能是它的过滤功能,自带的有过滤文件夹,文件,文档,视频,图片,音频. 例如上面的Picture,关键字是在搜索框中输入的关键字,搜索中可以选定文件表示搜索相应的文件. 这里笔者把关键字改成了一个字母p,然后搜索框中输入p再加一个冒号,会过滤出所有图片. 可以在搜索范围设置相应的文件夹,表示在这个文件夹搜索,不设置默认为所有位置. 2.4 外观 选择即可,还可以点击&quot;编辑&quot;对每一项细致编辑.笔者喜欢深色的. 反正不喜欢亮色. 2.5 快捷打开 &quot;动作&quot;这里,有一些自带的快捷键,比如ctrl+enter是打开文件夹,也可以添加自定义的操作,比如用vscode打开一个文件. 输入文件名,再按快捷键即可. 3 WGesture 这是鼠标党的福音,有了这个可以减少很多的键盘操作.这是一个免费开源的软件. 点击这里下载. 3.1 基本设置 安装后打开设置,选项这里有开启自启,允许的手势键等,没有特别需要默认即可. 3.2 全局手势 这是核心部分.可以修改默认的手势设置与添加自己的手势. 比如添加一个google搜索,画出手势: 然后可以随便选中一些东西进行谷歌搜索. 当然还有其他很多功能比如窗口控制,运行程序等,这些就不一一演示了,根据个人喜好设置. 3.3 触发角和摩擦边 触发角就是鼠标指针放在四个角就会触发相应的操作,摩擦边就是在边上摩擦就会触发相应操作. 下面是触发角的演示,没有点击左键,自动弹出菜单. 这是摩擦边: 可以修改默认行为. 4 cmder 这个是windows下的一个好用的终端,具体有多好用...谁用谁知道. 点击这里下载 以下是初次打开的界面,默认进入用户文件夹. 4.1 基本配置 win+alt+p,打开设置. 按需要调整字体,字体大小,字符集等.下一个的&quot;Size &amp; Pos&quot;可以设置大小与位置,这个没什么好说的就跳过了. 第三个是外观,可以设置标签栏的按钮,搜索框,滚动条的显隐,标题栏的显隐等. 下一个是设置&quot;quake style&quot;,这个是一个下滑效果,非常舒服,设置一下出现与消失延迟与动画时间. 设置了&quot;quake style&quot;后默认为全屏,可以回到&quot;Size &amp; Pos&quot;设置一下大小, 然后去Keys &amp; Macro里设置一个快捷键,搜索quake,默认是ctrl+`. 然后可以按快捷键看一下效果了. 下拉效果非常的不错. 4.2 背景 Background这里,选中&quot;Background image&quot;后,可以设置图片路径,变暗,与放置的位置等.Placement建议选择stretch. 4.3 标签栏 设置是否显示,字体,鼠标双击时的动作等. 4.4 确认 这里可以在操作之前弹出确认的对话框,根据需要设置即可. 4.5 启动 这里可以设置启动的任务类型,可以选择cmder,cmder(admin),powershell,bash等. 选择启动位置,比如这里是D:\\Desktop,直接手动修改: 4.6 杂项 一些很杂的配置,比如光标样式: 主题,这里可以选择主题与配置颜色,需要花一点时间. 透明度,配合背景调暗使用. 状态栏,笔者不需要,隐藏了. 4.7 快捷键 比如这里设置了alt+n切换控制台,而不是默认的ctrl+n. 最后贴一张笔者的图: 5 QtTabBar 这是一个增强windows资源管理器的工具,包括增加标签栏,各种便利的快捷键等.目前最新的版本是1040,在此之前需要先下载1038版本再进行1040版本的升级. 点击这里下载1038 点击这里下载1040升级包 5.1 安装 直接安装1038即可,安装完后注销电脑使qttabbar生效,然后再安装1040即可,重启资源管理器. 5.2 界面 首先安装完后其实与原来的资源管理器没有什么不一样,需要手动开启一些视图,打开视图中的选项: 这是开启Qt Command Bar的: 这是开启Qt Command Bar2的: Qt Command Bar2比Qt Command Bar小巧而且好看很多,建议开启. 这是开启Qt Tab Bar的: 这个强烈建议开启,就像浏览器中的标签栏一样. 这是开启Extra View(Left)的,会在左边多一个视图出来,不过速度会变得稍慢. 这是开启Qt Command Bar(Vertical)的: 就是把上面那个变成了垂直排列,这个功能很多,而且不丑,建议开启. 这是开启Extra View(bottom)的: 在底部多一个视图,右边有预览窗口. 最后一个就是Qt Tab Bar(bottom): 底部的标签栏. 笔者喜欢开这两个,extra view平时用的不多,所以不选择开启. 5.3 基础配置 按下Alt+O可以打开设置. 一开始是语言的一些设置,还可以导出设置文件,设置升级等.默认即可. 下一个是历史记录,可以设置排序方式,何时添加到历史记录,最大存储数目等,一般也默认即可. 5.4 标签 这是一个重要的配置,可以方便地管理资源管理器的标签.Tab选项这里可以设置新标签的位置,关闭当前标签后激活哪一个标签以及标签单行还是多行显示(如果有多个标签)等.建议去掉Rename ambiguous tabs automatically,这个会自动重命名标签名相同的标签,在标签名后加一个@再加所在的位置,有可能会把整个标签所占的位置变得很长. 然后下一个是开启标签动画和当导航失效的时候关闭标签.其他的一些比如显示标签数字(第三个),在标签栏上添加一个+按钮(最后一个)按个人喜好选择. 接下来是关闭按钮等的设置,笔者在这里把显示关闭按钮与标签图标去掉了,关闭的话可以在后面设置一个鼠标的快捷键(比如在标签上双击就是关闭)或一个键盘快捷键关闭.另外还有一些锁住标签的行为,这些笔者不需要就不弄了. 下面是切换器的样式,开启可以选中&quot;Show tab switcher by ctrl+tab&quot;,按ctrl+tab开启. 5.5 窗口设置 窗口可以设置保存透明度与置顶状态,隐藏菜单栏等,一般默认即可,右边有一个捕捉和排除列表设置,需要的可以看一看. 5.6 工具栏 工具栏可以设置导航按钮,位置,自动隐藏等属性. 如上图如果设置了导航按钮,就是这两个东西: 自动隐藏的话看个人吧,可以把左侧的Command Bar与底部/顶部的Qt Tab Bar给隐藏掉. 5.7 事件 这里的事件实际上是为鼠标加上的快捷操作,只要能记住,可以配合ctrl,shift,alt使用,主要的操作是左键单击,左键双击,中键单击,右键单击. 比如笔者的这里把在标签栏上右击的操作设为关闭,有工具栏上的右击设为显示菜单. 当然还有很多,比如文件夹视图,地址栏,子菜单等,也是类似的. 5.8 拖拽 这里可以设置拖拽的设置,比如标签作为拖拽源与标签栏作为拖拽目标时的操作,一般默认即可: 5.9 文件夹视图 主要是一些方便的功能,比如第一个选项是按Backspace可以返回上一层,还有不用获取焦点就可以滚动视图等. 5.10 额外视图 设置默认的额外视图,额外视图的标签栏,地址栏和导航按钮的位置,默认的打开位置等.第一个选项是可以按tab进行切换. 5.11 外观 这里设置的东西可多了,一开始是标签的设置,包括标签的大小,可以选择固定或自动或设置最小宽度,标签的字体,选中的标签的字体,文本对齐,标签图标位置等: 下一个是按钮的设置,可以设置关闭按钮与锁图标的样式: 接下来是工具栏,可以设置工具栏的背景,颜色等. 剩下还有三个是菜单,文件夹视图,导航面板等,都是类似的设置一些颜色,就不详细说了. 5.12 组 组在Command Bar中显示,这个可以设置一些快捷的功能入口,比如快速打开某个控制面版,快速打开某个文件夹等,默认自带了三个组:用户文件夹组,系统文件夹组以及驱动器组,可以选择右侧的Add Place添加自己想要的位置,也可以通过右上侧&quot;上下箭头&quot;调整组的位置. 5.13 应用程序 可以添加快捷的应用程序运行入口,比如这里添加了一个微信: 然后在Command Bar中右键选择添加: 然后就可以看到了: 可以为某个应用程序设置快捷键以便快速打开,在添加的时候最下面有一个&quot;Keyboard shortcut&quot;的选项,选中添加快捷键即可. 5.14 快捷键 一堆快捷键...需要自己慢慢调. 这里建议设置一个标签的激活快捷键,笔者选择的是alt+n. 一些常用的默认快捷键: 快捷键 功能 ctrl+W 关闭当前标签 ctrl+shift+W 关闭除当前标签外的所有标签 ctrl+shift+Z 恢复关闭的标签 ctrl+N 克隆当前标签 ctrl+L 锁定当前标签 ctrl+O 浏览文件且在标签中打开,若已存在该标签则切换到该标签,不存在则在新标签中打开 ctrl+shift+1-8 切换文件视图,比如大图标,中图标,列表视图,有8个可以选择 ctrl+shift+T 新建一个txt 5.15 预览 这个功能是真的舒服啊,可以预览图片,视频等,只需要把鼠标移到文件上面即可,可以设置预览的尺寸,是否按住shift才开启预览等. 时间那里可以设置全屏自动切换的时间,比如想预览一个放有图片的文件夹,打开预览功能(先把鼠标移动到文件出现预览的图片后,按小键盘的小数点即可进入)后,会进入全屏然后自动切换到下一张循环播放. 进入的快捷键可以在快捷键里中的Full screen设置: 5.16 子菜单 这个也是一个厉害的功能,就是安装QtTabBar后,文件夹上带的小箭头: 一般默认即可,这里建议把拖拽到子菜单的显示时间缩短. 好了,设置就这样了,希望你们能用好. ","link":"https://2293736867.github.io/post/windows-li-qi-shi-yong-yu-pei-zhi/"},{"title":"Chrome安装插件提示\"程序包错误\"","content":"1 修改下载crx的后缀 修改为zip或rar,然后解压. 2 修改文件夹 将里面的_metadata改成metadata,即去掉前面的下划线. 3 进入chrome 打开扩展程序,选中开发者模式,选择加载已解压的扩展程序. 4 选择刚才解压的文件夹 完成. ","link":"https://2293736867.github.io/post/chrome-an-zhuang-cha-jian-ti-shi-cheng-xu-bao-cuo-wu/"},{"title":"CentOS8搭建本地Web服务器","content":" 1 概述 2 安装httpd 3 启动服务 4 设置开机启动 5 访问 6 修改默认主页 1 概述 系统centos8,利用httpd搭建本地web服务器. 2 安装httpd sudo yum install -y httpd 3 启动服务 service httpd start 4 设置开机启动 先查看有没有设置开机启动: systemctl list-unit-files | grep httpd 没有的话设置: chkconfig httpd on 再确认一下: systemctl list-unit-files | grep httpd 5 访问 再浏览器输入内网ip地址(内网ip可以通过ifconfig查看).若出现以下页面则表示成功. 6 修改默认主页 默认的网站根目录位于/var/www/html下,可以通过修改/etc/httpd/conf/httpd.conf修改.这里只是修改主页.在/var/www/html创建一个index.html: cd /var/www/html sudo vim index.html 随便输入一点内容,然后刷新在浏览器即可. ","link":"https://2293736867.github.io/post/centos8-da-jian-ben-di-web-fu-wu-qi/"},{"title":"CentOS8搭建FTP服务器","content":" 1 概述 2 安装vsftpd 3 开启服务 4 设置开机启动 5 修改/etc/vsftpd/vsftpd.conf 6 创建测试文件 7 测试 7.1 浏览器测试 7.1.1 匿名测试 7.1.2 用户登录测试 7.2 ftp命令测试 7.2.1 匿名测试 7.2.1.1 上传测试 7.2.1.2 下载测试 7.2.2 用户登录测试 7.2.2.1 上传测试 7.2.2.2 下载测试 7.3 wget测试 7.3.1 匿名测试 7.3.2 用户登录测试 8 总结 1 概述 文章主要讲了CentOS8如何利用vsftpd搭建一个FTP服务器,然后进行简单的匿名上传/下载与用户上传/下载测试,还有使用了wget测试. 2 安装vsftpd yum install -y vsftpd 3 开启服务 service httpd start 4 设置开机启动 可以用 systemctl list-unit-files | grep vsftpd 查看是否开机启动.显示disabled. 通过 chkconfig vsftpd on 开启自启,再次执行systemctl,可以看到变成了enabled. 5 修改/etc/vsftpd/vsftpd.conf sudo vim /etc/vsftpd/vsftpd.conf 首先修改 为YES. 再添加一行anon_upload_enable=YES 第一行的意思是允许匿名登录,第二行的意思是允许匿名上传. 重启服务. service vsftpd restart 6 创建测试文件 cd /var/ftp/pub sudo vim test 7 测试 7.1 浏览器测试 7.1.1 匿名测试 ifconfig获取内网ip,在浏览器中输入ftp://ip. 可以看到有一个pub文件夹,里面有刚才新建的test文件. 右键保存即可下载文件. 下载完成. 去终端看看. 7.1.2 用户登录测试 输入 ftp://username@ip 再输入用户密码. 默认访问的是用户根目录下的文件,这里显示出来了. 下载的话同上,右键选择即可. 7.2 ftp命令测试 首先安装ftp: sudo yum install ftp 7.2.1 匿名测试 ftp ip 这里用户名选择ftp,密码为空,表示匿名登录.ftp为默认的匿名登录用户名,至于密码,可以在/etc/vsftpd/vsftpd.conf中设置一个 no_anon_password=YES 这样匿名用户可以不用密码登录. 7.2.1.1 上传测试 直接使用put命令,后面接上文件,这里的upload.txt是执行ftp之前的所在文件夹下的upload.txt 这里提示不能创建文件,是权限的原因,要确保/var/ftp/pub对&quot;other&quot;用户有写权限. 默认的/var/ftp/pub的权限是644,修改成647. sudo chmod 647 /var/ftp/pub 同时修改上传文件的权限,允许other用户可读. sudo chmod 644 /root/upload.txt 如果不行,使用selinux设置. getsebool -a | grep ftp 把ftpd_full_access开启: setsebool ftpd_full_access on 再进入upload.txt所在的文件夹,执行ftp,再次put. 成功! 7.2.1.2 下载测试 直接get文件即可,由于上面已经设置好了权限,所以不会出现问题. 若出现权限问题可从三方面入手: (1)/var/ftp/pub的对other用户的可读权限:因为是下载,而且匿名,所以只需要对other用户的可读权限 (2)被下载文件的对other用户的可读权限 (3)selinux的问题,设置ftpd_full_access为on 7.2.2 用户登录测试 执行ftp时用对应用户名与密码登录. 默认进入了用户根目录. 7.2.2.1 上传测试 直接put即可. 若出现权限问题参照上面7.2.1.2的那三条方法. 7.2.2.2 下载测试 随便在用户根目录新建一个文件,这里是kr. 直接get即可. 7.3 wget测试 wget用来下载文件,初始下载的目录与ftp登录时的目录一致,比如匿名登录ftp,登录的是/var/ftp目录,则wget会从这个/var/ftp目录下载文件,下载到执行wget命令所在的目录.使用用户&quot;kr&quot;登录ftp,则登录的是/home/kr目录,wget会从/home/kr下载文件. 7.3.1 匿名测试 注意,请确保被下载文件对other用户有可读权限. sudo chmod o+w xxxxxx 然后使用wget wget ftp://ip/pub/xxxx 7.3.2 用户登录测试 使用--ftp-user,--ftp-password指定用户名与密码,其余同上. wget ftp://ip/xxx --ftp-user=xxxx --ftp-password=xxxx 成功. 8 总结 呃....简单来说,就是先安装好ftp与vsftpd,然后修改/etc/vsftpd/vsftpd.conf添加相应权限,对于不能上传与下载的原因,基本上都是权限的问题,主要就是三方面: (1)ftp目录的权限:比如可以是/var/ftp/pub没有对应的写权限导致上传失败,没有对应读权限导致下载失败. (2)被上传文件的权限:比如上传的文件没有读权限导致上传失败. (3)selinux:使用setsebool设置为on. 解决权限问题后,基本就可以通过ftp或wget顺利地使用这个ftp服务器上传/下载文件了. ","link":"https://2293736867.github.io/post/centos8-da-jian-ftp-fu-wu-qi/"},{"title":"Python基础(八)","content":" 1 模块 1.1 模块 1.2 模块存在形式 1.2.1 非内置模块 1.2.2 内置模块 1.3 模块使用 1.3.1 导入整个模块 1.3.2 导入模块中的某个函数 1.4 查看内置模块 2 包 2.1 包 2.2 包管理 2.3 包管理命令 2.3.1 列出已安装的包 2.3.2 更新包 2.3.3 删除包 2.3.4 安装包 1 模块 1.1 模块 模块是一个python文件,其中包含对象定义与语句等.多个模块再加上__init__.py就变成了一个包. 1.2 模块存在形式 模块可以分成两种:非内置模块与内置模块. 1.2.1 非内置模块 非内置模块以.py文件的形式存在,放在对应的包下. 1.2.2 内置模块 内置模块就是内置到解释器中的模块,为了提高性能内置模块采用C语言而不是python编写. 1.3 模块使用 先导入再调用里面的函数,可以一次导入整个模块,或者选择性导入其中的函数. 1.3.1 导入整个模块 import math import cmath as cm 使用as设置模块别名. 1.3.2 导入模块中的某个函数 from math import sin from cmath import sqrt as cs 使用as设置函数别名. 1.4 查看内置模块 import sys sys.builtin_module_names 2 包 2.1 包 包是含有一个特殊的__init__.py文件的文件夹,通常还含有其他.py文件,表示不同的模块. 2.2 包管理 包的下载,安装,更新,删除可通过包管理器进行操作,常用的包管理器为pip与conda.pip设计目的是仅管理Python语言的包,对应的包服务器为PyPI,Conda设计目的是管理多种语言的包,对应的包服务器为Conda. 2.3 包管理命令 2.3.1 列出已安装的包 pip list conda list 2.3.2 更新包 pip install --upgrade package_name conda upgrade package_name 2.3.3 删除包 pip uninstall package_name conda uninstall package_name 2.3.4 安装包 pip install package_name conda install package_name ","link":"https://2293736867.github.io/post/python-ji-chu-ba/"},{"title":"Python基础(七)","content":" 1 模块函数 1.1 模块函数 1.2 导入 1.2.1 import moudle 1.2.2 import module as alias 1.2.3 from module import function 1.2.4 from module import function as alias 2 自定义函数 2.1 定义函数 2.2 设置docstring 2.3 函数调用 2.4 返回值 2.5 形参 2.5.1 形参分类 2.5.2 * 与 ** 2.5.3 命名关键字参数 2.6 实参 2.6.1 位置参数 2.6.2 关键字参数 2.7 变量可见性 2.7.1 局部变量 2.7.2 全局变量 2.7.3 非局部变量 2.8 参数传递规则 2.8.1 值传递 2.8.2 地址传递 2.9 lambda函数 2.9.1 定义 2.9.2 调用 1 模块函数 1.1 模块函数 模块函数指的是模块中的函数,模块函数有三种: 内置模块:又叫标准库. 第三方开源模块:可以通过包管理工具进行安装. 自定义模块. 1.2 导入 导入方法主要有三种: 1.2.1 import moudle import math math.e 1.2.2 import module as alias alias表示别名. 1.2.3 from module import function 从模块导入函数. 1.2.4 from module import function as alias 与上一种类似,加上了别名. 2 自定义函数 2.1 定义函数 使用关键字def定义: def func(): print(1) 2.2 设置docstring docstring就是注释,描述了函数的功能,使用三个单引号或三个双引号,可以用help()获取函数的docstring. def func(): ''' func docstring ''' print(1) help(func) 2.3 函数调用 直接使用函数名即可,需要的话要加上参数. func() func(22) 2.4 返回值 返回值在return里指定,可以返回多个值: def f(): return 1,2,3,4 相当于返回一个元组.若函数没有return,则返回None. 2.5 形参 2.5.1 形参分类 形参就是函数定义时的参数列表里面的参数,可以分为: 可选形参:给出默认值的形参. 必选形参:没有给出默认的形参. def f(x1,x2,x3=3) 其中x1,x2必选形参,x3可选形参. 2.5.2 * 与 ** 带一个 * 的形参表示该形参类型为元组,带两个 * 的形参表示该参数类型为字典. 2.5.3 命名关键字参数 出现在*后的参数. def f(x1,*x2,x3,x4) x3与x4就是命名关键字参数,在调用时必须显式使用参数名. 2.6 实参 python实参可以分为位置实参与关键字实参. 2.6.1 位置参数 位置参数就是没有指定形参名字的实参,每个实参基于顺序关联到一个形参. 2.6.2 关键字参数 关键字参数就是指定了形参名字的实参,用键值对的形式指定,可以不按顺序调用. def f(x1,x2,x3): print(x1,x2,x3) f(1,2,3) f(x3=999,x1=888,x2=999999) 2.7 变量可见性 python变量的可见性有三种:全局变量,局部变量,非局部变量. 2.7.1 局部变量 在函数内的变量为局部变量,因此,以下代码会输出9: x1 = 8 def f(): x1 = 9 print(x1) f() 如果在x1之前输出呢? 直接提示没有定义x1,就是全局变量x1在函数内不可见,但笔者不死心,一定要运行一下. 它说局部变量x1没有被赋值,注意,是局部变量,因此,这也证明了全局变量在函数内不可见. 2.7.2 全局变量 若要使全局变量在函数内可见,使用global: x1 = 8 def f(): global x1 print(x1) x1 = 9 print(x1) f() global x1表示x1是一个全局变量,注意global x1需要单独占一行. 2.7.3 非局部变量 用于嵌套函数中,使用nonlocal声明,表示内层函数的这个变量是外层函数的. x1 = 8 def f(): x1 = 9 print(x1) def f1(): nonlocal x1 print(x1) x1 = 10 print(x1) return f1 f() f()() 第一个与第二个9都是f()中的print()输出的,第三个9是f1()中的print()输出的. 2.8 参数传递规则 当实参传递给形参时,有两种传递规则,一是值传递,而是地址传递. 2.8.1 值传递 当实参为不可变对象时,采用值传递规则,常见的不可变对象类型包括int,float,str,bool,tuple. def f(x): x = 1 print(x) x = 3 print('-------int------') f(x) print(x) print() x = 'string' print('-------str------') f(x) print(x) print() x = (3,4,5) print('-------tuple------') f(x) print(x) print() x = 5.799 print('-------float------') f(x) print(x) print() 2.8.2 地址传递 参数为可变对象时,采用地址传递规则,修改形参的值会同时改变实参的值.常见的可变对象类型包括list,set,dict. def f(x): if type(x) == list: x = x.reverse() elif isinstance(x,set): x.add(8) else: x['0'] = 3 x = [1,2,3] print('-------list------') print(x) f(x) print(x) print() x = {4,5,6} print('-------set------') print(x) f(x) print(x) print() x = {'a':1,'b':2} print('-------dict------') print(x) f(x) print(x) print() 2.9 lambda函数 lambda是一种特殊的自定义函数,使用关键字lambda进行定义,是一种匿名函数,函数体一般很短. 2.9.1 定义 以关键字lambda开头,后面是参数列表,参数列表结束后加一个冒号,后面是返回值. y = lambda x:x*3 z = lambda x,y:x*y 2.9.2 调用 调用可以通过&quot;函数名&quot;调用,或者配合其他函数使用. ","link":"https://2293736867.github.io/post/python-ji-chu-qi/"},{"title":"Python基础(六)","content":" 1 函数 1.1 函数的分类 1.2 函数与方法 1.3 函数也是对象 1.4 注意事项 2 内置函数 2.1 查看帮助 2.2 数学函数 2.2.1 abs 2.2.2 max/min 2.2.3 pow 2.2.4 round 2.3 类型转换函数 2.4 其他函数 2.4.1 type() 2.4.2 isinstance() 2.4.3 dir() 2.4.4 len() 2.4.5 range() 2.4.6 callable() 2.4.7 bin() 2.4.8 oct() 2.4.9 hex() 2.4.10 int() 1 函数 1.1 函数的分类 函数可以分成三种: 内置函数(BIF):解释器中内置的函数,可以直接通过函数名调用,如len(). 模块函数:定义在模块中的函数,通过模块名调用,如math.sin(). 用户自定义函数. 1.2 函数与方法 函数是指在类外定义的,可以独立调用的一组语句集合,另外通过类去调用的语句,也叫函数而不是方法. 方法是指在类内定义的,需要通过对象与点调用的一组语句集合,方法中的self是隐式传递的. 1.3 函数也是对象 在python中,函数也是对象,比如: def xx(): print(4) print(type(xx)) 1.4 注意事项 函数的参数带一个 * 时,表示元组,带两个 * 时,表示字典.函数的返回值可以为迭代器,元组等,如果没有return,默认返回None. 另外就是docstring,docstring其实就是一堆注释,说明函数的作用,建议使用三引号. 2 内置函数 内置函数就是内置在python解释器中的函数,可以直接通过函数名调用,不需要import.查看内置函数可以使用内置函数dir(): dir(__builtins__) 2.1 查看帮助 可以使用help查看函数的帮助. 一般给出简单的帮助信息,详细信息可以去官网查询. 2.2 数学函数 2.2.1 abs 求绝对值. 2.2.2 max/min 求最大/小值,支持元组,列表,集合,字符串等. 2.2.3 pow 求次幂. 2.2.4 round 四舍五入,两个参数,第一个参数是要四舍五入的数,第二个参数是保留的小数位数,第二个参数可以省略,省略的话相当于取整. 若保留的小数位数为2则保留2位,保留的小数位数为1则保留1位,保留的小数位数为0则保留....0...呃...不是,保留1位,保留1位0. 2.3 类型转换函数 就是常用的int(),bool()等函数,这些也是内置函数. 2.4 其他函数 2.4.1 type() type()是查看类型的函数. 2.4.2 isinstance() isinstance()判断一个的类型,与type()类似,但是isinstance()会考虑继承关系,而type()不会考虑. class a: pass class b(a): pass print('type(a()) == a is ',type(a()) == a) print('type(b()) == a is ',type(b()) == a) print('isinstance(a(),a) is ',isinstance(a(),a)) print('isinstance(b(),a) is ',isinstance(b(),a)) 2.4.3 dir() dir()查看搜索的路径. 2.4.4 len() 求长度. 2.4.5 range() 快速生成序列,返回一个迭代器. 2.4.6 callable() 判断对象是否可以被调用,因为函数也是一个对象,所以可以通过callable()判断函数是否可以被调用. 2.4.7 bin() 十进制--&gt;二进制. 2.4.8 oct() 十进制--&gt;八进制. 2.4.9 hex() 十进制--&gt;十六进制. 2.4.10 int() n进制--&gt;十进制. ","link":"https://2293736867.github.io/post/python-ji-chu-liu/"},{"title":"pom.xml详解","content":" 1.pom.xml是什么 2.基本配置 (1)&lt;project&gt; (2)&lt;modelVersion&gt; (3)Maven坐标 A.&lt;groupId&gt; B.&lt;artifactId&gt; C.&lt;version&gt; (4)&lt;packaging&gt; (5)POM 关系 A.依赖 a.&lt;groupId&gt;与&lt;artifactId&gt; b.&lt;version&gt; c.&lt;classifier&gt; d.&lt;type&gt; e.&lt;scope&gt; f.&lt;systemPath&gt; g.&lt;optional&gt; h.&lt;exclusions&gt; B.继承 C.聚合(或多模块) (6)属性 ①env.x ②project.x ③settings.x ④java.x ⑤x 3.构建配置 (1)BaseBuild元素 A.&lt;defaultGoal&gt; B.&lt;directory&gt; C.&lt;finalName&gt; D.&lt;filters&gt; (2)资源 A.&lt;resource&gt; B.&lt;targetPath&gt; C.&lt;flitering&gt; D.&lt;directory&gt; E.&lt;include&gt; F.&lt;excludes&gt; (3)插件 A.&lt;groupId&gt;与&lt;artifactId&gt; B.&lt;version&gt; C.&lt;extensions&gt; D.&lt;inherited&gt; E.&lt;configuration&gt; F.&lt;dependencies&gt; G.&lt;executions&gt; (4)插件管理 (5)目录 A.项目源码目录 B.测试源码目录 C.class目录 D.测试class (6)扩展 (7)报表 A.&lt;excludeDefaults&gt; B.&lt;outputDirectory&gt; C.&lt;plugins&gt; D.&lt;reportSets&gt; 4.项目信息 (1)许可证 A.&lt;name&gt; B.&lt;url&gt; C.&lt;distribution&gt; D.&lt;comments&gt; (2)组织 (3)开发者 A.&lt;id&gt; B.&lt;name&gt; C.&lt;email&gt; D.&lt;url&gt; E.&lt;organization&gt; F.&lt;organizationUrl&gt; G.&lt;roles&gt; H.&lt;timeZone&gt; I.&lt;properties&gt; (4)贡献者 5.环境配置 (1)问题管理 (2)持续集成管理 A.&lt;system&gt; B.&lt;url&gt; C.&lt;notifiers&gt; a.&lt;type&gt; b.&lt;sendOnError&gt; c.&lt;sendOnFailure&gt; d.&lt;sendOnSuccess&gt; e.&lt;sendOnWarning&gt; f.&lt;configuration&gt; (3)邮件列表 A.&lt;name&gt; B.&lt;subscribe&gt; C.&lt;unsubscribe&gt; D.&lt;post&gt; E.&lt;archive&gt; (4)软件配置管理(SCM) A.&lt;connection&gt;与&lt;developConnection&gt; B.&lt;tag&gt; C.&lt;url&gt; (5)前提条件 (6)仓库 A.&lt;releases&gt; B.&lt;snapshots&gt; C.&lt;id&gt; D.&lt;name&gt; E.&lt;url&gt; F.&lt;layout&gt; (7)插件仓库 (8)分发管理 A.仓库 B.站点部署 C.重定位 (9)配置文件 A.&lt;activeByDefault&gt; B.&lt;jdk&gt; C.&lt;os&gt; D.&lt;property&gt; E.&lt;file&gt; 1.pom.xml是什么 pom是Project Object Model(项目对象模型)的缩写,是Maven中的项目文件,可用于管理与配置依赖,组织信息,项目授权,远程仓库等等.一个Maven项目,可以没有任何代码,但不能没有pom.xml. 2.基本配置 (1)&lt;project&gt; &lt;project&gt;是pom.xml的根元素,包含了一些约束信息. &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;/project&gt; (2)&lt;modelVersion&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; pom的版本,这是Maven 2&amp;3唯一支持的pom版本,而且不能忽略. (3)Maven坐标 &lt;groupId&gt;,&lt;artifactId&gt;与&lt;version&gt;标识了仓库中的一个特定位置,叫项目坐标.三个属性告诉了Maven项目中的一个特定版本,让Maven知道如何处理它们以及在生命周期内的哪一阶段需要它们. A.&lt;groupId&gt; &lt;groupId&gt;表示项目所属的组,通常是一个公司或者组织的名称,如org.springframework. B.&lt;artifactId&gt; &lt;artifactId&gt;表示项目的唯一标识. C.&lt;version&gt; &lt;version&gt;表示项目的版本号,通常来说项目的版本号分成三段: 主版本号.次版本号.修订版本号 主版本号:代表架构变动或者不兼容的实现. 次版本号:兼容性修改,功能增强. 修订版本号:bug修复. 版本号的后缀意味着项目的不同阶段: SNAPSHOT:开发中的版本 RELEASE:正式发布版 M1,M2:M指里程碑,表示即将发布 RC:Release Candidate,发布候选 GA:General Availablity,基本可用版本 (4)&lt;packaging&gt; 打包类型,没有提供的话默认值为jar,常见的有jar与war,也可以取值: maven-plugin pom ejb ear rar (5)POM 关系 Maven的一个强大之处是处理项目关系的方式,可以通过一个公共的本地仓库去解决问题. A.依赖 POM的基础就是依赖列表,Maven下载与在编译时链接依赖与其他所需要的目标,而且可以处理传递性依赖,使列表可以专注于项目所需的依赖.依赖放在&lt;dependencies&gt;里面,包含若干个&lt;dependency&gt;. &lt;dependencies&gt; &lt;dependency&gt; .... &lt;/dependency&gt; &lt;dependency&gt; .... &lt;/dependency&gt; &lt;/dependencies&gt; 一个&lt;dependency&gt;通常包含: a.&lt;groupId&gt;与&lt;artifactId&gt; 对应项目坐标 b.&lt;version&gt; 版本 c.&lt;classifier&gt; 可用于配置不同jdk的&lt;depenency&gt;,比如让一个&lt;dependency&gt;同时支持jdk8与jdk11,可以选择使用哪一个&lt;classifier&gt;,方便在不同jdk中使用. d.&lt;type&gt; 对应的依赖类型,默认为jar,通常对应与&lt;packaging&gt;. e.&lt;scope&gt; scope表示类库与项目的关系,可以取以下5个值: compile:默认值,编译依赖使其在所有类路径中可用,而且这些依赖项会传递到其他依赖项目,在编译和打包时都需要此类库. provided:类似compile,但是期望JDK或一个容器会在运行时提供,仅在编译和测试类路径上可用,不可传递. runtime:在运行时与测试类路径中可用,在编译类路径中不可用. test:测试编译与执行阶段可用,不可传递. system:类似于provided,但必须显式提供jar包. f.&lt;systemPath&gt; 当&lt;scope&gt;为system才需要这个,否则(当&lt;scope&gt;不为system时)会构建失败.路径必须为绝对路径. g.&lt;optional&gt; 标记依赖的可选状态. h.&lt;exclusions&gt; 排除不需要的依赖,包含子元素&lt;exclusion&gt;,每个&lt;exclusion&gt;都包含&lt;groupId&gt;与&lt;artifactId&gt;. B.继承 使用&lt;parent&gt;指定需要继承的pom. &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;/parent&gt; 子pom会继承父pom的&lt;groupId&gt;,&lt;version&gt;,&lt;build&gt;等众多属性,具体包括: groupId version description url inceptionYear organization licenses developers contributors mailingLists scm issueManagement ciManagement properties dependencyManagement dependencies repositories pluginRepositories build reporting profiles 但不能继承: artifactId name prerequisites 另外,就像java中所有类都继承于java.lang.Object一样,所有POM都有一个&quot;Super POM&quot;,pom都从它继承而来,下面是Maven3.5.4的&quot;Super pom&quot;: &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;build&gt; &lt;directory&gt;${project.basedir}/target&lt;/directory&gt; &lt;outputDirectory&gt;${project.build.directory}/classes&lt;/outputDirectory&gt; &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt; &lt;testOutputDirectory&gt;${project.build.directory}/test-classes&lt;/testOutputDirectory&gt; &lt;sourceDirectory&gt;${project.basedir}/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;${project.basedir}/src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;${project.basedir}/src/test/java&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;${project.basedir}/src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;reporting&gt; &lt;outputDirectory&gt;${project.build.directory}/site&lt;/outputDirectory&gt; &lt;/reporting&gt; &lt;profiles&gt; &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt; &lt;profile&gt; &lt;id&gt;release-profile&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;/project&gt; C.聚合(或多模块) 模块是pom列出的项目,并作为一个组执行,每个模块通过pom文件或项目的相对路径进行列出. &lt;modules&gt; &lt;module&gt;my-project&lt;/module&gt; &lt;module&gt;another-project&lt;/module&gt; &lt;module&gt;third-project/pom-example.xml&lt;/module&gt; &lt;/modules&gt; 不需要考虑模块间的依赖关系,Maven会对其进行拓扑排序以便在依赖模块之前构建依赖关系. (6)属性 属性是Maven中的值占位符,像Ant一样,可以以 ${x} 这样的形式在pom.xml的任何位置访问一个值,也可以被用作默认值使用. 有5种形式使用值: ①env.x env会使用当前shell的环境变量的值. 例如 ${env.PATH} ②project.x &lt;project&gt;下的x元素的值,如 ${project.version} ③settings.x 使用settings.xml中的元素的值 ${settings.offline} ④java.x java系统属性值,通过java.lang.System.getProperties()获取,如 ${java.home} ⑤x 直接使用x,用的是&lt;properties&gt;下的属性,比如 &lt;properties&gt; &lt;aaa&gt;AAAAA&lt;/aaa&gt; &lt;/properties&gt; ${aaa} 3.构建配置 &lt;build&gt;,声明项目结构,管理插件等. (1)BaseBuild元素 A.&lt;defaultGoal&gt; 目标的默认值,可以取值install,copile B.&lt;directory&gt; 构建产生的文件存放目录 C.&lt;finalName&gt; 构建最终产生的项目名字,但有可能会被更改. D.&lt;filters&gt; 定义一组&lt;filter&gt;,&lt;filter&gt;内是.properties文件,项目中的占位符如xxx.xxx会被.properties中的xxx=xxx的具体值替换掉. (2)资源 &lt;resources&gt;,项目相关的资源文件的位置. A.&lt;resource&gt; 描述每个资源的根元素. B.&lt;targetPath&gt; 构建资源的位置,对于jar包放在META-INF里面. C.&lt;flitering&gt; 取值true或false,表示是否开启过滤 D.&lt;directory&gt; 资源位置. E.&lt;include&gt; 指定要包含的资源,使用*作为通配符. F.&lt;excludes&gt; 与include相反,要排除的资源列表. (3)插件 &lt;plugins&gt;下包含了若干个&lt;plugin&gt;,表示插件,每个&lt;plugin&gt;有以下元素: A.&lt;groupId&gt;与&lt;artifactId&gt; 与上面的&lt;groupId&gt;与&lt;artifactId&gt;一样. B.&lt;version&gt; 与上面的&lt;version&gt;一样. C.&lt;extensions&gt; 取值true或false,表示是否加载扩展,默认为false. D.&lt;inherited&gt; 取值ture或false,是否应用pom的继承关系,默认true. E.&lt;configuration&gt; 插件项的相关配置,可以配置&lt;finalName&gt;,&lt;appendAssemblyld&gt;,&lt;descriptor&gt;等. F.&lt;dependencies&gt; 引入插件的依赖,与前面的&lt;dependencies&gt;类似. G.&lt;executions&gt; 插件可能有多个目标,&lt;executions&gt;配置每一个&lt;execution&gt;作为插件的目标,在&lt;execution&gt;中,用&lt;id&gt;指定执行目标的标识符,用&lt;goals&gt;指定目标,&lt;goals&gt;包含一组&lt;goal&gt;,&lt;phase&gt;用于指定阶段,&lt;inherited&gt;用于指定是否启用继承关系.另外&lt;execution&gt;也可以包含&lt;configuration&gt;,与上面类似,用于配置特定的目标,而不是插件的所有目标. (4)插件管理 &lt;pluginManagement&gt;,包含一组&lt;plugins&gt;,继承于此项目的子项目都可以使用,子项目可以覆盖修改&lt;pluginManagement&gt;. (5)目录 可以为pom设置各种目录,比如 A.项目源码目录 &lt;sourceDirectory&gt;&lt;/sourceDirectory&gt; 构建项目时会编译该目录的源码,是相对于pom.xml的相对路径. B.测试源码目录 &lt;testSourceDirectory&gt;&lt;/testSourceDirectory&gt; 测试时会编译其中的源码,也是相对于pom.xml的相对路径. C.class目录 &lt;outputDirectory&gt;&lt;/outputDirectory&gt; 这里存放被编译过的class文件. D.测试class &lt;testOutputDirectory&gt;&lt;/testOutputDirectory&gt; 存放测试文件编译后的class文件. (6)扩展 &lt;extensions&gt;,将包含在运行中的构建的类路径中,在构建过程中可以激活扩展.比如可以为,例如这是支持ftp的wagon-ftp插件: &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groudId&gt; &lt;artifactId&gt;wagon-ftp&lt;/artifactId&gt; &lt;version&gt;3.3.4&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;/build&gt; (7)报表 &lt;reporting&gt;,描述产生报表的规范等,执行&quot;mvn site&quot;时报表就会运行. A.&lt;excludeDefaults&gt; 是否包含默认报表. B.&lt;outputDirectory&gt; 报表存放位置. C.&lt;plugins&gt; 报表包含的插件以及配置. D.&lt;reportSets&gt; 包含一组&lt;reportSet&gt;,与&lt;execution&gt;类似,配置多个目标,每个&lt;reportSet&gt;包含&lt;id&gt;,&lt;configuration&gt;,&lt;inherited&gt;,以及&lt;reports&gt;,&lt;id&gt;指定报表集合的标识符,&lt;configuration&gt;表示使用的报表配置,&lt;inherited&gt;表示是否继承到子pom,&lt;reports&gt;包含一组&lt;report&gt;,表示使用哪些报表. 4.项目信息 (1)许可证 &lt;licenses&gt;,包含一组&lt;license&gt;,每个&lt;license&gt;包含&lt;name&gt;,&lt;url&gt;,&lt;distribution&gt;,&lt;comments&gt;. A.&lt;name&gt; 名称. B.&lt;url&gt; 官方license页面的url. C.&lt;distribution&gt; 项目分发的方式,可以选择 repo:从Maven仓库下载. manual:手动安装. D.&lt;comments&gt; 一些补充信息. (2)组织 &lt;organazation&gt;,包含&lt;name&gt;,&lt;url&gt;,与&lt;license&gt;的类似. (3)开发者 &lt;developers&gt;,包含一组&lt;developer&gt;,每个&lt;developer&gt;包含: A.&lt;id&gt; 开发者id. B.&lt;name&gt; 姓名. C.&lt;email&gt; 邮箱. D.&lt;url&gt; 主页url. E.&lt;organization&gt; 所属组织. F.&lt;organizationUrl&gt; 所属组织的主页url. G.&lt;roles&gt; 角色,包含一组&lt;role&gt;,一个&lt;role&gt;描述一个角色. H.&lt;timeZone&gt; 时区,可以以America/New_York或Europe/Berlin这样的形式,或者设置一个整数,范围[-11,12]. I.&lt;properties&gt; 开发者属性,如如何处理即时消息等. (4)贡献者 &lt;contributors&gt;,包含一组&lt;contributor&gt;,类似于&lt;developer&gt;,包含&lt;name&gt;,&lt;email&gt;等元素. 5.环境配置 (1)问题管理 &lt;issueManagement&gt;,定义缺陷跟踪系统,如Bugzilla,TestTrack,ClearQuest等,包含&lt;system&gt;与&lt;url&gt;元素,&lt;system&gt;指定系统名字,&lt;url&gt;指定问题管理系统的url. (2)持续集成管理 &lt;ciManagement&gt;,使用了触发器,包含了: A.&lt;system&gt; 持续集成系统的名称. B.&lt;url&gt; 持续集成系统的url. C.&lt;notifiers&gt; 包含一组&lt;notifier&gt;,用来配置触发器,每个&lt;notifier&gt;包含: a.&lt;type&gt; 如何发送通知,比如可以取值mail. b.&lt;sendOnError&gt; 取值true/false,错误时发送. c.&lt;sendOnFailure&gt; 取值true/false,失败时发送. d.&lt;sendOnSuccess&gt; 取值true/false,成功时发送. e.&lt;sendOnWarning&gt; 取值true/false,发生警告时发送. f.&lt;configuration&gt; 相关配置,例如可以添加&lt;address&gt;,发送的地址. (3)邮件列表 &lt;mailingLists&gt;,包含一组&lt;mailingList&gt;,表示邮件信息,包括: A.&lt;name&gt; 邮件名称. B.&lt;subscribe&gt; 订阅邮件地址或链接. C.&lt;unsubscribe&gt; 取消订阅邮件或链接. D.&lt;post&gt; 要发送的邮件地址. E.&lt;archive&gt; 查看旧的邮件的url. (4)软件配置管理(SCM) &lt;scm&gt;,也叫Source Code/Control Management,允许配置代码库供web站点和其他插件使用.包含: A.&lt;connection&gt;与&lt;developConnection&gt; 描述如何通过Maven连接到版本控制系统,其中connection需要读权限,developConnection需要写权限. B.&lt;tag&gt; 代码标签,默认为HEAD. C.&lt;url&gt; 公开的可浏览的仓库,例如ViewVC或Fisheye. (5)前提条件 &lt;prerequisites&gt;,这是Maven2中的元素,只有一个子元素&lt;maven&gt;,指定maven的版本,且规定是2.x版本.Maven3中不需要&lt;prerequisites&gt;了,可以用: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-maven&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;requireMavenVersion&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/requireMavenVersion&gt; &lt;/rules&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 代替. (6)仓库 &lt;repositories&gt;,包含一组&lt;repository&gt;,表示仓库的位置,每个&lt;repository&gt;包含: A.&lt;releases&gt; 如何处理远征仓库的发布版本,包含: &lt;enabled&gt; true/false,是否启用. &lt;updatePolicy&gt; 更新频率,Maven将本地pom的时间戳与远程进行比较,可以选择:always,daily(默认),interval:X(X是一个整数,表示X分钟),never. &lt;checksumPolicy&gt; 校验错误或校验失败时的策略,可以选择ignore,fail或warn. B.&lt;snapshots&gt; 如何处理远程仓库的快照版本,包含的元素与&lt;releases&gt;一样. C.&lt;id&gt; 远程仓库的标识符. D.&lt;name&gt; 远程仓库的名称. E.&lt;url&gt; 远程仓库的url. F.&lt;layout&gt; 仓库布局类型,可以是default或legacy,Maven2.x为仓库提供了默认布局. (7)插件仓库 &lt;pluginRepositories&gt;,插件的远程仓库列表,包含一组&lt;pluginRepository&gt;,与&lt;repositories&gt;中的&lt;repository&gt;类似. (8)分发管理 &lt;distributeManagement&gt;,管理整个构建过程中的分发,可以把网站部署到远程服务器或者把构件部署到远程仓库.包含: A.仓库 &lt;repository&gt;,仓库信息,包含: &lt;uniqueVersion&gt;:唯一版本,取值true/false,表示是否生成一个唯一版本号或是使用部分地址作为版本号. &lt;name&gt;:仓库名字. &lt;id&gt;:仓库id. &lt;url&gt;:指定仓库位置. &lt;layout&gt;:布局,取值default或legacy. 还有一个叫&lt;snapshotRepository&gt;的元素,与&lt;repository&gt;类似,表示快照仓库. B.站点部署 &lt;site&gt;,定义了如何部署项目的站点与文档.包含: &lt;name&gt;:站点名称. &lt;id&gt;:站点id. &lt;url&gt;:站点url. C.重定位 &lt;relocation&gt;,表示项目的新位置.包含: &lt;groupId&gt;:新的&lt;groupId&gt;. &lt;artifactId&gt;:新的&lt;artifactId&gt;. &lt;version&gt;:新版本. &lt;message&gt;:提示信息. (9)配置文件 &lt;profiles&gt;,包含一组&lt;profile&gt;,每个&lt;profile&gt;可以定义不同的配置,包含的元素有: &lt;id&gt;:配置文件的id,比如测试的可以叫test. &lt;build&gt;:相关构建信息. &lt;modules&gt;:模块信息. &lt;repositories&gt;:远程仓库信息. &lt;pluginRepositories&gt;:插件仓库信息. &lt;dependencies&gt;:依赖信息. &lt;reporting&gt;:报表信息. &lt;dependencyManagement&gt;:依赖管理信息. &lt;distributeManagement&gt;:分发管理 &lt;activation&gt;:activation是profile的关键,profile的强大之处是某些情况下才可以修改基本pom,这些情况通过activation指定. &lt;activation&gt;包含以下元素: A.&lt;activeByDefault&gt; 是否默认激活,true或false. B.&lt;jdk&gt; 指定jdk版本. C.&lt;os&gt; &lt;os&gt;可以定义一些特定的操作系统属性,例如&lt;name&gt;,&lt;family&gt;,&lt;arch&gt;,&lt;version&gt;. D.&lt;property&gt; 若Maven检测到该属性就会激活该属性所在的配置文件,可以指定&lt;name&gt;与&lt;value&gt;. E.&lt;file&gt; 有&lt;exists&gt;与&lt;missing&gt;两个子元素,&lt;exists&gt;表示若存在&lt;exists&gt;元素中对应的文件,则激活此配置文件.&lt;miissing&gt;表示若不存在&lt;missing&gt;元素中对应的文件,则激活此配置文件. ","link":"https://2293736867.github.io/post/pomxml-xiang-jie/"},{"title":"Python基础(五)","content":" 1.集合 (1)集合 (2)定义 (3)特点 A.确定性 B.无序性 C.互异性 D.支持集合运算 E.可变对象 2.字典 (1)字典 (2)定义 (3)特点 A.可以通过对应的key访问对应的value B.可变对象 (4)用作函数参数 3.迭代器 (1)迭代器 (2)可迭代对象 (3)可迭代对象转换为迭代器 4.生成器 (1)生成器 (2)特点 (3)使用 1.集合 (1)集合 集合是一种可变的无序的容器. (2)定义 x = {1,2,3} #第一种方法,使用{} x = set([2,4,5]) #第二种方法,使用强制类型转换 (3)特点 A.确定性 类似数学中的集合的确定性,集合描述得很清楚,不存在不能判断一个元素是否在一个集合中,具体来说就是in或not in运算符不会得不到确定的结果. B.无序性 因此不能通过下标访问. subscriptable就是可以通过下标访问的.这里提示&quot;not subscriptable&quot;. C.互异性 没有重复元素. D.支持集合运算 包括==,!=,判断子集,真子集,超集,真超集,交集与并集,差集,对称差分. E.可变对象 可以通过add,remove改变集合本身. 另外有不可变集合frozenset: 2.字典 (1)字典 字典是一种可变的无序容器,每个值都有自己对应的键,是一个映射结构,本质上是一个以键为元素的集合. (2)定义 使用{},键与值用:分隔,键值对用逗号分隔. x = {'aa':1,'bb':2,'cc':3} (3)特点 A.可以通过对应的key访问对应的value B.可变对象 (4)用作函数参数 def func(arg1,**arg2): print(arg1) print(arg2) func('a',a=1,b=2,c=3,d=4) 3.迭代器 (1)迭代器 迭代器可以作为next()的参数被调用,不断返回下一个值. (2)可迭代对象 可以直接作用与循环语句的对象,对于for循环是in后的对象.判断一个对象是否是可迭代对象可以利用isinstance()与Iterable. from collections import Iterable isinstance([1,2,3],Iterable) (3)可迭代对象转换为迭代器 使用iter(): 4.生成器 (1)生成器 生成器是一个函数,不过相比起普通函数,返回的是迭代器. (2)特点 生成器用的不是return,而是yield,另外生成器有惰性计算的特性,调用生成器时不会立即执行它,会在调用每个元素时才进行计算. (3)使用 def gen(): x = range(-1,8) for i in x: yield i+2 for x in gen(): print(x,end = ' ') print() ","link":"https://2293736867.github.io/post/python-ji-chu-wu/"},{"title":"Python基础(四)","content":" 1.字符串 (1)定义 (2)特性 (3)转义 (4)常用操作 A.插入连接 B.去除空白 C.长度 D.unicode编码 2.序列 (1)序列 (2)特点 A.索引 B.切片 C.迭代 D.拆包赋值 E.重复运算 1.字符串 (1)定义 可以使用单引号,双引号,三引号定义字符串. x = '123' x = &quot;123&quot; x = '''123''' x = ''' 123 456 ''' 三引号可以跨行使用. (2)特性 python中的字符串是不可变对象: 字符串也属于序列的一种,支持切片操作: (3)转义 转义一般用于单引号,双引号,斜杠等特殊符号. x = '\\\\123' x = &quot;\\&quot;123\\&quot;&quot; 对于用单引号引起的字符串,若含有单引号,可以把外面的单引号改成双引号,对于双引号字符串也类似. 另一种可以不用转义的方法是在字符串前加一个r: (4)常用操作 A.插入连接 使用x.join(a)表示把x插入到a中的每个字符中间: B.去除空白 strip(),去除左右空白字符,包括空格,换行,制表符. C.长度 计算字符串长度,len(x): D.unicode编码 ord():计算unicode编码. chr():与ord()相反,解码. 注意参数是一个字符. 2.序列 (1)序列 序列是列表,元组,字符串等元素之间具有顺序关系的数据类型的统称,不是一个独立的数据类型. (2)特点 A.索引 可以通过索引来获取元素的值: B.切片 形式为: [start:end:step] start为起始位置,包含.end为结束位置,不包含,step为步长,默认为1,三者都可以省略.三者都可以为负数. C.迭代 序列是支持迭代的,可以放在for循环的in后: x = '123888' for i in x: print(i,end = ' ') print() D.拆包赋值 用逗号分隔等号左边的变量,等号右边为一个序列. E.重复运算 使用*表示重复n次. ","link":"https://2293736867.github.io/post/python-ji-chu-si/"},{"title":"Python基础(三)","content":" 1.list (1)定义方法 (2)下标 (3)切片 (4)反向遍历 A.[::-1] B.使用内置函数reversed() C.使用列表方法.reverse() (5)列表推导式 (6)列表的常用函数 A.extend() B.append() C.insert() D.pop() E.remove() F.len() G.sorted()与sort() H.enumerate() I.zip() 2.元组 (1)定义方法 (2)特点 (3)应用 1.list list是一种可变的有序容器,每个元素都拥有自己的下标.列表使用[]定义. (1)定义方法 x = [1,2,3] #第一种,使用[] y = x #第二种,赋值 y = list({1,2,3}) #第三种,使用强制转换函数 (2)下标 下标从0开始,允许负数作为下标,最后一个元素的下标为-1,第一个元素的下标为-n,第i个元素的下标为(i-1)或-(n-i+1). (3)切片 设x是一个列表,则 x[start:end:step] 为列表的一个切片,start为起始位置,包含,可以省略,end为结束位置,不包含,可以省略,step为步长,可以省略,默认为1. 三者都可以为负数. 三者都省略时为整个列表,反向遍历时可以省略start与end,步长设为-1: (4)反向遍历 反向遍历有三种方法: A.[::-1] 使用切片,像上面一样,步长设为-1 B.使用内置函数reversed() reversed()会返回一个迭代器,想要获取里面的内容可以转换为list(). C.使用列表方法.reverse() 前两种方法不会改变列表,列表方法reverse()改变了列表. (5)列表推导式 列表推导式可用于快速生成有规律性的列表,比如生成包含10个2的列表: [2 for i in range(10)] 有点类似于把for循环的循环体提到前面. (6)列表的常用函数 A.extend() extend()类似于直接使用+,但是+不会改变列表本身,而extend()会改变列表本身. B.append() append()把参数作为一个元素直接追加到列表中. C.insert() insert需要两个参数,分别表示插入的下标与插入的值. D.pop() 根据下标删除元素. E.remove() 根据值删除元素,删除第一个出现的元素,就是说对于重复元素仅删除第一次出现的元素. F.len() 列表长度,注意这个不是列表的方法. G.sorted()与sort() 这两个都是排序的方法,sorted()不是列表的方法,把列表作为函数的参数传递,sort是列表的方法,会改变列表本身. H.enumerate() 逐个显示对应的下标,返回的是一个迭代器.想要显示可以转换为列表. I.zip() 列表的并行计算. 2.元组 元组是不可变的有序容器,用()表示. (1)定义方法 x = (1,2,3,4,5) #第一种,使用() y = x #第二种,使用赋值 x = tuple('kkkrrr') #第三种,使用tuple强制转换 x = 1,2,3,4,5 #第四种,实质上还是第一种,省略了圆括号 (2)特点 用逗号分隔的都是元组,是不可变对象,支持拆包式赋值. (3)应用 交换两个变量: 函数的不定长参数: def fun(arg1,*arg2): print(arg1) if arg2 != (): if len(arg2) == 1: print(arg2[0]) else: print(arg2) fun(1) fun(2,3) fun(4,5,6) ","link":"https://2293736867.github.io/post/python-ji-chu-san/"},{"title":"Maven简介","content":" 1.Maven介绍 2.安装Maven 3.设置Maven 4.Maven常用命令 (1)编译 (2)打包 (3)安装到本地 (4)安装到远程仓库 (5)清理 1.Maven介绍 Maven最初用于代替Ant,用来简化项目的构建,Maven使构建项目变得容易,规定了源码总是放在src/main/java下,测试代码放在/src/test/java中,配置文件放在/src/main/resources中,通过使用pom.xml统一了描述项目的方式,可以自动解决库的依赖问题,只要声明了使用的库,会自动从中央仓库下载,并且可以自动管理冲突. 2.安装Maven 官网这里. 选择下载即可,作者用的是windows,选择zip.下一步是解压放到相应的位置. 然后添加环境变量MAVEN_HOME,是maven的解压位置.需要的话可以再配置一个环境变量M2_HOME,用来作为本地仓库的位置. 最后配置一个PATH,添加 %MAVEN_HOME%/bin 到path中. 在cmd中验证 mvn -version 即表示成功安装. 3.设置Maven 因为中心仓库位于国外,一般下载时会很慢,因此可以设置为国内的镜像,这里选择阿里云的镜像. 打开Maven安装目录下的conf/setting.xml,编辑&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 另外也需要在IDE中设置一下Maven.这里以IDEA为例. 打开settings--&gt;Build,Execution,Deployment--&gt;Build Tools--&gt;Maven,设置maven的位置. 另外也可以设置配置文件的位置与本地仓库的位置,配置文件默认是conf/settings.xml,本地仓库默认用户目录下的.m2文件夹. 4.Maven常用命令 (1)编译 mvn compile 编译Maven工程. (2)打包 mvn package 编译并打包工程,会根据pom.xml中的&lt;packaging&gt;打成jar或war包. (3)安装到本地 mvn install 打包并安装到本地仓库,这样可以通过项目坐标引用. (4)安装到远程仓库 mvn deploy 打包并安装到远程仓库.Maven仓库有两大类: 远程仓库,包括中心仓库与镜像仓库,还有利用nexus搭建的私服. 本地仓库,默认位于用户目录的.m2目录. (5)清理 mvn clean 删除target目录. ","link":"https://2293736867.github.io/post/maven-jian-jie/"},{"title":"Python基础(二)","content":" 1.赋值语句 (1)作用:定义+赋值 (2)复合与链式赋值 (3)特殊类型的赋值 2.注释 3.运算符 (1)算术运算符 (2)关系运算符 (3)赋值运算符 (4)逻辑运算符 (5)位运算符 (6)集合运算符 (7)特殊运算符 in运算符 is运算符 4.if语句 (1)基本语法 (2)单行if (3)配合pass的多行elif 5.for语句 (1)基本语法 (2)range() 6.while语句 (1)基本语法 (2)continue+break 1.赋值语句 (1)作用:定义+赋值 (2)复合与链式赋值 a = b = 2 a *= 2 (3)特殊类型的赋值 序列的赋值: a,b,c = (1,2,3) print(a,b,c) 变量交换: a,b = b,a 不需要额外的temp变量. 2.注释 以#开头的行即为注释. 3.运算符 (1)算术运算符 运算符 含义 + 加 - 减 * 乘 / 除 % 取模 // 整除(不是注释....) ** 幂 (2)关系运算符 运算符 含义 == 等于 != 或 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 (3)赋值运算符 运算符 含义 = 赋值 += x+=3等价于x=x+3 -= x-=3等价于x=x-3 *= x*=3等价于x=x*3 /= x/=3等价于x=x/3 %= x%=3等价于x=x%3 //= x//=3等价于x=x//3 **= x**=3等价于x=x**3 (4)逻辑运算符 运算符 含义 and 和 or 或 not 非 (5)位运算符 运算符 含义 &amp; 按位与 ¦ 按位或 ^ 按位异或 ~ 按位取反 &gt;&gt; 右移 &lt;&lt; 左移 (6)集合运算符 运算符 含义 in ∈\\in∈,属于 not in ∉\\notin∈/​,不属于 == 集合相等 != 集合不相等 &lt; ⊆\\subseteq⊆,真子集 &lt;= ⊂\\subset⊂,子集 &gt; ⊃\\supset⊃,真超集 &gt;= ⊇\\supseteq⊇,超集 &amp; ∩\\cap∩,交集 ¦ ∪\\cup∪,并集 - 差集或相对补集 ^ 对称差分 (7)特殊运算符 in运算符 判断某个变量是否在给定的容器中.可以配合not使用. x = {1,3,4} 1 in x 9 not in x is运算符 检查是否指向同一个引用 x = y = {1,3,4} x is y 注意,若写成 x = {1,3,4} y = {1,3,4} x is y 为False,指向的不是同一个对象. 4.if语句 (1)基本语法 if(xxx): print(a) elif(xxx): print(b) else: print(c) 注意冒号和缩进. (2)单行if 把 if(xxx): A else: B 变为 A if (xxx) else B 本质上是把if内的语句提前,然后写成一行. (3)配合pass的多行elif if(a &lt; 3): print(a) elif(a &gt; 8 and a &lt; 11): pass else: print(a) 注意不能用;代替pass. 5.for语句 (1)基本语法 for xxxx in xxxxx.其中in后面表示的是可迭代对象或迭代器. for x in (1,2,3): print(x) (2)range() 一般for配合range使用,range()返回一个迭代器,参数有三个,前两个为起始值与结束值,第三个可选,表示步长.注意范围是[start,end),就是包含start值,不包含end值. for x in range(1,10): print(x,end=' ') print() 顺序输出1到9, 6.while语句 (1)基本语法 x = 1 while(x&lt;10): print(x,end=' ') x+=1 print() 要注意的一个就是不要使用++......不要用自增运算符,没用的.... (2)continue+break x = 1 while(x &lt; 10): if(x == 3): break print(x,end=' ') x+=1 print() x = 1 while(x &lt; 10): if(x == 3): continue print(x,end=' ') x+=1 print() ","link":"https://2293736867.github.io/post/python-ji-chu-er/"},{"title":"Python基础(一)","content":" 1.基础类型 (1)整数 (2)实数 (3)复数 (4)布尔 (5)字符串 (6)列表 (7)元组 (8)集合 (9)集合常量 (10)字典 2.判断数据类型 3.变量定义 4.引用 5.代码规范 (1)python没有专门的结束符 (2)通常规则是一句一行 (3)可以一行多句或一句多行 (4)缩进 1.基础类型 python的数据类型可以分为两种,一种是内置的,一种是其他包中的,内置的数据类型可以分为10种: (1)整数 用int表示,强制转换函数为int(): x = 10 print(x) int(10.88) 输出都是10. (2)实数 用float表示,强制转换函数为float() x = 10.222 print(x) float(10) 看一个有趣的东西: (3)复数 用complex表示,python默认用j表示虚数单位. x = complex(3,4) y = complex(-9,4.55555) print(x+y) (4)布尔 用bool表示,可以取值Ture/False. x = Ture print(x,False) (5)字符串 用str表示,可以使用单引号或双引号,注意是常量,不可变的.支持序列操作. x = &quot;123&quot; print(x) x = str(5) print(x) (6)列表 用list表示,使用[],支持序列操作.与str相比,list是可变的. x = [1,3,4,4] x[2] = '2342' print(x) (7)元组 用tuple表示,使用(),不可变的,支持序列操作. x = (2,3,4) print(x) (8)集合 用set表示,使用[],可变的,无序的,不支持序列操作. x = {3,4,-4,343,-999} print(x) x.add(123) print(x) (9)集合常量 用frozenset表示,也是使用[],不可变的,不支持序列操作. x = frozenset(range(5)) y = frozenset('9900abc') print('x=',x,'\\ny=',y) (10)字典 用dict表示,使用[]配合键值对,是可变的. x = {'a':1,'b':2,'c':3} print(x['a']) 2.判断数据类型 使用isinstance(),判断一个对象是否是已知的类型,参数是判断的对象与类型: isinstance(10,str) isinstance([3,4],dict) isinstance({7,8,-99999},set} isinstance(8.0,int) 3.变量定义 python中使用赋值语句定义一个变量,用户不需要显示地声明变量的数据类型,python是动态强类型语言,动态是指变量的类型可以动态改变,而强类型是指运算过程中不会自动进行数据类型的转换(除了&quot;数值类&quot;的int,float,bool与complex). 比如,先赋值整数,再赋值列表是可以的,因为是动态类型语言. 可以让int与float相加,但是不能让int与str相加,因为是强类型语言. 4.引用 python中的变量名与c/c++/java的不同,变量名并不是直接表示变量的值,而是表示值的一个引用.因此,这可以解释为什么可以将一个str&quot;赋值&quot;给一个int,变量存放的并不是int或str的具体的值,而是地址. 5.代码规范 (1)python没有专门的结束符 python没有专门的结束符,没有如c,java的分号,python解释器根据其语法完整性判断语句是否结束. (2)通常规则是一句一行 (3)可以一行多句或一句多行 对于一行多句,使用分号分隔不同语句,对于一句多行,使用\\ . (4)缩进 python无固定的缩进单位,PEP8(Python代码编写规范)建议缩进为4个空格,python的缩进很重要,相当于其他语言的{},另外缩进要以:开始. ","link":"https://2293736867.github.io/post/python-ji-chu-yi/"},{"title":"Java实现简单计算器","content":" 1.概述 2.UI (1)文本框 (2)按键 3.鼠标事件 4.键盘事件 5.计算表达式 6.测试 7.源码 1.概述 之前作者写过一篇文章,也是关于计算器的,用的是C++与Qt,链接在这里 这次用java的swing写的(这差距好像有点大,好吧是qt太强了). 先上图: 2.UI 总体布局使用流布局. (1)文本框 文本框就一个JPanel里面加一个JTextField. boxField.setLayout(new FlowLayout()); box.setPreferredSize(new Dimension(300, 25)); boxField.add(box); JTextField设置尺寸需要使用setPreferredSize()而不是setSize(). (2)按键 按键4*4网格布局,逐个添加button即可. buttonsField.setLayout(new GridLayout(4, 4, 20, 20)); buttonsField.setPreferredSize(new Dimension(300, 300)); buttonsField.add(xxx); //add.... 3.鼠标事件 鼠标事件针对button,仔细想一想,单击一个button,然后文本框里面就会有相应的反应,据此添加事件监听. num0.addActionListener(v -&gt; { box.setText(box.getText() + &quot;0&quot;); mainFrame.requestFocus(); }); requestFocus()这一行把焦点还给JFrame,因为鼠标点击button后,button会获取焦点,会影响后面的键盘监听. 4.键盘事件 键盘事件与鼠标事件类似,针对每个键判断即可. 在这里的是把KeyListener注册到JFrame上面,直接在里面重写以下三个KeyListener的方法: public void keyPressed(KeyEvent e); public void keyReleased(KeyEvent e); public void keyTyped(KeyEvent e); 基本上就是通过 if (e.getKeyCode() == KeyEvent.VK_xxxx) 来判断各个键,唯一要注意一下的是+与* 因为作者使用的键盘没有小键盘(尴尬....),+与*需要shift+=或8,尝试过直接 if (e.getKeyCode() == KeyEvent.VK_PLUS) if (e.getKeyCode() == KeyEvent.VK_ADD) if (e.getKeyCode() == KeyEvent.VK_MUTIPLY) 无效. 因此需要在KeyPressed这里判断是否按下了shift,然后到了KeyReleased()的时候,特判一下8与=: else if (e.getKeyCode() == KeyEvent.VK_8) box.setText(box.getText() + (shift ? &quot;*&quot; : &quot;8&quot;)); else if(e.getKeyCode() == KeyEvent.VK_EQUALS) { if(shift) box.setText(box.getText() + &quot;+&quot;); else setResult(); } 5.计算表达式 计算表达式部分这里讲了就不详细说了,代码在后面. 简单来说就是先使用 GetResult.setExpression(); 这个静态方法设置表达式,然后通过 GetResult.valid() 判断是否合法,合法的话通过 GetResult.result() 获取String结果. 6.测试 7.源码 github 码云 ","link":"https://2293736867.github.io/post/java-shi-xian-jian-dan-ji-suan-qi/"},{"title":"Java简单的用户登录界面+MySQL","content":" 1.概述 2.UI (1)主界面 (2)用户信息界面 3.数据库操作 4.完整代码 1.概述 一个简单的swing登录界面,使用了简单的JDBC. 如图: 2.UI (1)主界面 主界面使用了31网格布局+三个JPanel,中间的JPanel使用了22网格布局: import java.awt.FlowLayout; import java.awt.Font; import java.awt.GridLayout; import java.util.Enumeration; import java.awt.Container; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JPasswordField; import javax.swing.JTextField; import javax.swing.UIManager; import javax.swing.plaf.FontUIResource; public class UserManagement { private JFrame mainFrame = new JFrame(&quot;登录&quot;); private Container container = mainFrame.getContentPane(); private JLabel titleLabel = new JLabel(&quot;登录/注册&quot;, JLabel.CENTER); private JPanel inputField = new JPanel(); private JLabel usernameLabel = new JLabel(&quot;用户名:&quot;, JLabel.CENTER); private JTextField username = new JTextField(); private JLabel passwordLabel = new JLabel(&quot;密码:&quot;, JLabel.CENTER); private JPasswordField password = new JPasswordField(); private JPanel buttonField = new JPanel(); private JButton save = new JButton(&quot;登录/注册&quot;); private JButton cancel = new JButton(&quot;取消&quot;); public UserManagement() { init(); setFont(new Font(&quot;微软雅黑&quot;,Font.PLAIN,14)); addEvent(); } private void init() { container.setLayout(new GridLayout(3, 1, 0, 10)); container.add(titleLabel); inputField.setLayout(new GridLayout(2, 2, 5, 5)); inputField.add(usernameLabel); inputField.add(username); inputField.add(passwordLabel); inputField.add(password); container.add(inputField); buttonField.setLayout(new FlowLayout(FlowLayout.CENTER,20,0)); buttonField.add(save); buttonField.add(cancel); container.add(buttonField); mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); mainFrame.setSize(300, 200); mainFrame.setLocationRelativeTo(null); mainFrame.setVisible(true); } private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for(Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if(value instanceof FontUIResource) UIManager.put(key, fontRes); } } private void addEvent() { save.addActionListener( e-&gt; { User user = new User(); user.setName(username.getText()); user.setPassword(new String(password.getPassword())); if(DBUtils.exists(user)) new UserInformation(DBUtils.getByName(user.getName())); else JOptionPane.showConfirmDialog(null, &quot;添加&quot;+(DBUtils.add(user) ? &quot;成功&quot; : &quot;失败&quot;), &quot;&quot;,JOptionPane.CLOSED_OPTION); } ); cancel.addActionListener( e-&gt; { mainFrame.dispose(); } ); } public static void main(String[] args) { new UserManagement(); } } 重点说一下几行代码: mainFrame.setLocationRelativeTo(null); 使整个JFrame处于屏幕水平居中与垂直居中位置. private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for(Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if(value instanceof FontUIResource) UIManager.put(key, fontRes); } } 设置所有组件的字体. cancel.addActionListener( e-&gt; { mainFrame.dispose(); } ); 按钮添加关闭窗口事件. JOptionPane.showConfirmDialog(null,&quot;添加&quot;+(DBUtils.add(user) ? &quot;成功&quot; : &quot;失败&quot;), &quot;&quot;,JOptionPane.CLOSED_OPTION); 提示信息框. (2)用户信息界面 用户信息界面采用了31网格,同样3个JPanel,中间的JPanel布局为32网格. import java.awt.FlowLayout; import java.awt.Font; import java.awt.GridLayout; import java.util.Enumeration; import java.awt.Container; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JPasswordField; import javax.swing.JTextField; import javax.swing.UIManager; import javax.swing.plaf.FontUIResource; public class UserInformation { private JFrame mainFrame = new JFrame(&quot;用户信息&quot;); private Container container = mainFrame.getContentPane(); private JLabel titleLabel = new JLabel(&quot;用户信息&quot;, JLabel.CENTER); private JPanel inputField = new JPanel(); private JLabel idLabel = new JLabel(&quot;Id&quot;,JLabel.CENTER); private JTextField id = new JTextField(); private JLabel usernameLabel = new JLabel(&quot;Username&quot;, JLabel.CENTER); private JTextField username = new JTextField(); private JLabel passwordLabel = new JLabel(&quot;Password&quot;, JLabel.CENTER); private JPasswordField password = new JPasswordField(); private JPanel buttonField = new JPanel(); private JButton update = new JButton(&quot;更新&quot;); private User user; public UserInformation(User user) { if(user == null) mainFrame.dispose(); this.user = user; init(); setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 14)); addEvent(); } private void init() { container.setLayout(new GridLayout(3,1,0,10)); container.add(titleLabel); inputField.setLayout(new GridLayout(3,2,0,3)); inputField.add(idLabel); inputField.add(id); id.setText(user.getId()); id.setEditable(false); inputField.add(usernameLabel); username.setText(user.getName()); inputField.add(username); inputField.add(passwordLabel); password.setText(user.getPassword()); inputField.add(password); container.add(inputField); buttonField.setLayout(new FlowLayout()); buttonField.add(update); container.add(buttonField); mainFrame.setVisible(true); mainFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); mainFrame.setLocationRelativeTo(null); mainFrame.setSize(300,250); } private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for (Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys(); keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if (value instanceof FontUIResource) UIManager.put(key, fontRes); } } private void addEvent() { update.addActionListener( e-&gt; { user.setName(username.getText()); user.setPassword(new String(password.getPassword())); JOptionPane.showConfirmDialog(null, &quot;更新&quot;+(DBUtils.modify(user) ? &quot;成功&quot; : &quot;失败&quot;),&quot;确认&quot;,JOptionPane.CLOSED_OPTION); } ); } } 这个JFrame不能设置EXIT_ON_CLOSE.因为这不是&quot;主窗体&quot;,不然的话点击关闭主窗体也没了. mainFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); 3.数据库操作 import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.UUID; public class DBUtils { private final static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;; private final static String username = &quot;aa&quot;; private final static String password = &quot;123456&quot;; private final static String url = &quot;jdbc:mysql://127.0.0.1/user_test&quot;; private final static String insert = &quot;insert into user(id,username,password) values(?,?,?)&quot;; private final static String update = &quot;update user set username = ?,password = ? where id = ?&quot;; private final static String delete = &quot;delete from user where id = ?&quot;; private final static String select = &quot;select * from user where username = ?&quot;; private static Connection connection; static { try { Class.forName(driver); connection = DriverManager.getConnection(url,username,password); } catch(Exception e) { e.printStackTrace(); connection = null; } } public static boolean exists(User user) { try { PreparedStatement exist = connection.prepareStatement(select); exist.setString(1,user.getName()); ResultSet existResult = exist.executeQuery(); return existResult.next(); } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean add(User user) { try { PreparedStatement add = connection.prepareStatement(insert); user.setId(UUID.randomUUID().toString().substring(0, 8)); add.setString(1, user.getId()); add.setString(2, user.getName()); add.setString(3, user.getPassword()); return add.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean modify(User user) { try { PreparedStatement modify = connection.prepareStatement(update); System.out.println(user.getName()); modify.setString(1, user.getName()); modify.setString(2, user.getPassword()); modify.setString(3, user.getId()); return modify.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean delete(User user) { if(exists(user)) { try { PreparedStatement del = connection.prepareStatement(delete); del.setString(1, user.getId()); return del.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); } } return false; } public static User getByName(String name) { try { PreparedStatement exist = connection.prepareStatement(select); exist.setString(1, name); ResultSet existResult = exist.executeQuery(); if(existResult.next()) { User user = new User(); user.setId(existResult.getString(&quot;id&quot;)); user.setName(existResult.getString(&quot;username&quot;)); user.setPassword(existResult.getString(&quot;password&quot;)); return user; } return null; } catch (SQLException e) { e.printStackTrace(); return null; } } } 注册驱动后,增删查改,就是注意一下mysql版本与驱动名对应. 4.完整代码 github 码云 ","link":"https://2293736867.github.io/post/java-jian-dan-de-yong-hu-deng-lu-jie-mian-mysql/"},{"title":"Gson?So easy.","content":" 1.概述 2.Gson是什么? (1)JSON (2)Gson (3)Gson的好处 3.配置Gson环境 (1)Gradle (2)Maven (3)jar 4.Gson基础 (1)基础类型 (2)嵌套对象 (3)数组 a.普通数组 b.List (4)Map (5)Set (6)null (7)混合 5.Gson注解 (1)@SerializedName a.单独使用value b.同时使用value与alternate (2)@Expose 6.Gson Builder (1)基础 (2)命名规则 a.使用系统命名规则 b.自定义命名规则 (3)null (4)排除 a.属性名排除 b.类型排除 c.修饰符排除 d.@Expose排除 (5)Lenient (6)Floats &amp; Doubles (7)模型版本化 (8)格式化日期 7.Gson进阶 (1)枚举 (2)泛型 (4)自定义序列化 (5)自定义反序列化 (6)默认实例 (7)@JsonAdapter 8.源码 9.参考链接 1.概述 这篇文章主要讲述了Gson的使用.包括从最基础的基本类型的序列化,到对象,数组,集合,再到Gson注解,Gson Builder,再到格式化,自定义序列化与反序列化等内容. 另外文章篇幅较长,建议挑选所需部分查看.所有例子都提供了完整源码,在文章的后面. 2.Gson是什么? (1)JSON JSON全称为JavaScript Object Notation,一种轻量级的数据交换格式. 类似于XML但比XML更小,更易解析. (2)Gson Gson是Google提供的可以使Java对象与JSON互转的类库,可将Java对象转换为JSON,也可将JSON转换成Java对象. (3)Gson的好处 a.容易,高效,强大:Gson是Google管理的标准化库,经过高度优化,同时api简单,比如fromJSON(),toJSON(). b.无依赖性:不需要其他库,当然jdk除外. c.结果简单:转换成的json易于阅读. d.支持泛型,支持内部类. e.开源,免费提供. 3.配置Gson环境 目前最新的是2.8.6版本. (1)Gradle dependencies { implementation 'com.google.code.gson:gson:2.8.6' } (2)Maven &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;/dependency&gt; (3)jar 点击下载. 4.Gson基础 (1)基础类型 int intJSON = 1; long longJSON = 1L; double doubleJSON = 1.0; float floatJSON = 1.0f; byte byteJSON = 1; char charJSON = 'G'; short shortJSON = 1; boolean boooleanJSON = true; System.out.println(gson.toJson(intJSON)); System.out.println(gson.toJson(longJSON)); System.out.println(gson.toJson(doubleJSON)); System.out.println(gson.toJson(floatJSON)); System.out.println(gson.toJson(byteJSON)); System.out.println(gson.toJson(charJSON)); System.out.println(gson.toJson(shortJSON)); System.out.println(gson.toJson(boooleanJSON)); System.out.println(&quot;----------------------------------------&quot;); System.out.println(gson.fromJson(&quot;1&quot;,Integer.class)); System.out.println(gson.fromJson(&quot;1.0&quot;,Double.class)); System.out.println(gson.fromJson(&quot;1&quot;,Long.class)); System.out.println(gson.fromJson(&quot;true&quot;,Boolean.class)); System.out.println(gson.fromJson(&quot;B&quot;,Character.class)); 就是对应输出,没啥好说的. (2)嵌套对象 Gson gson = new Gson(); System.out.println(gson.toJson(new A())); String str = &quot;{'field':'gggg','field2':33,'field3':'G','field4':'true'}&quot;; A a = gson.fromJson(str,A.class); System.out.println(a.getField1()); System.out.println(a.getField2()); System.out.println(a.getField3()); System.out.println(a.getField4()); A类: class A { private String field1 = &quot;123&quot;; private int field2 = 1; private char field3 = 'X'; private Boolean field4 = true; } 序列化出来的对象用{}表示. 反序列化时,注意格式,注意名字对应,用单引号引起来,还有char会自动变为String类型,另外对于布尔类型可以加单引号或不加单引号,都可以正常反序列化. (3)数组 a.普通数组 int [] a = new int []{1,2,3}; double [] b = new double []{1.0,2.0,3.0}; String [] c = new String []{&quot;123&quot;,&quot;456&quot;}; System.out.println(gson.toJson(a)); System.out.println(gson.toJson(b)); System.out.println(gson.toJson(c)); int [] aa = gson.fromJson(&quot;[6,7,8]&quot;,int [].class); double [] bb = gson.fromJson(&quot;[6.0,8.0,9.0]&quot;,double [].class); String [] cc = gson.fromJson(&quot;['123123','5464']&quot;,String [].class); System.out.println(Arrays.toString(aa)); System.out.println(Arrays.toString(bb)); System.out.println(Arrays.toString(cc)); 对普通数组的话,{}变成了[]. 还有就是反序列化时,默认会在逗号后面添一个空格. b.List List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;123&quot;); list.add(&quot;456&quot;); System.out.println(gson.toJson(list)); List&lt;AAAA&gt; list2 = new ArrayList&lt;&gt;(); list2.add(new AAAA()); list2.add(new AAAA(&quot;45345&quot;,8888,false)); System.out.println(gson.toJson(list2)); System.out.println(&quot;---------------------------------&quot;); Type type = new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType(); String strList = &quot;['234234','45457']&quot;; List&lt;String&gt; list3 = gson.fromJson(strList, type); System.out.println(list3); String strList2 = &quot;[&quot; + &quot;{'field1':'9999','field2':666,'field3':'true'}&quot; + &quot;,&quot; + &quot;{'field1':'sdlkfkl','field2':-234234,'field3':'false'}&quot; + &quot;]&quot;; List&lt;AAAA&gt; list4 = gson.fromJson(strList2, new TypeToken&lt;List&lt;AAAA&gt;&gt;(){}.getType()); System.out.println(list4); class AAAA { private String field1 = &quot;123&quot;; private int field2 = 5; private boolean field3 = true; } 序列化没什么问题,直接toJson即可,反序列化时,需要配合java.lang.reflect.Type使用,明确指出所要转换的类型: Type type = new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType(); TypeToken&lt;T&gt;中T为所需要的类型,再把这个Type对象传递给fromJson即可完成转换. List序列化出来的用[]表示. (4)Map Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;123&quot;,88); map.put(&quot;2349&quot;,999); System.out.println(gson.toJson(map)); String str = &quot;{'123':23423423,'9999':-234234}&quot;; Map&lt;String,Integer&gt; map2 = gson.fromJson(str, new TypeToken&lt;Map&lt;String,Integer&gt;&gt;(){}.getType()); System.out.println(map2.get(&quot;123&quot;).toString()); System.out.println(map2.get(&quot;9999&quot;).toString()); Map同样序列化时直接toJson,反序列化时使用java.lang.reflect.Type.Map序列化出来的用{}表示. (5)Set Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;123123&quot;); set.add(&quot;2349594&quot;); set.add(&quot;-234()@#$@#&quot;); System.out.println(gson.toJson(set)); String str = &quot;['38483','@*#$(@#$)','SD&lt;FGDF&gt;G']&quot;; Set&lt;String&gt; set2 = gson.fromJson(str, new TypeToken&lt;Set&lt;String&gt;&gt;(){}.getType()); set2.stream().forEach(System.out::println); set序列化出来的用[]表示. (6)null System.out.println(gson.toJson(new AAA())); String str = &quot;{'field2':333,'field3':null}&quot;; System.out.println(gson.fromJson(str, AAA.class)); class AAA { private String field1 = null; private Integer field2 = null; private Double field3 = 3.0; @Override public String toString() { return &quot;field1:&quot;+field1+&quot;,field2:&quot;+field2+&quot;,field3:&quot;+field3; } } Gson会忽略空值,在序列化时看不到null对应的键值对,反序列化时,直接对应为空. (7)混合 一个对象里面包含了List,Map,Set,null. System.out.println(gson.toJson(new Test())); class Test { private List&lt;String&gt; listField = new ArrayList&lt;&gt;(); private Map&lt;String,Double&gt; mapField = new HashMap&lt;&gt;(); private Set&lt;Integer&gt; setField = new HashSet&lt;&gt;(); private List&lt;User&gt; userListFiled = new ArrayList&lt;&gt;(); private Map&lt;String,User&gt; userMapField = new HashMap&lt;&gt;(); private Set&lt;User&gt; userSetField = new HashSet&lt;&gt;(); private Set&lt;String&gt; nullSetField = null; private Map&lt;String,User&gt; nullMapField = null; private List&lt;User&gt; nullListField = null; private Long longField = 23423423423L; private int intField = 234234; private Double doubleField = 234234.23423; private User userField = new User(); { listField.add(&quot;234234&quot;); mapField.put(&quot;23432&quot;,-234.0); setField.add(-23423); userListFiled.add(new User(&quot;3459&quot;,-23423,new int []{4,5,5})); userListFiled.add(new User()); userMapField.put(&quot;()&quot;,new User()); userMapField.put(&quot;------&quot;, new User(&quot;345345&quot;,3434,new int []{4,44})); userSetField.add(new User()); userSetField.add(new User()); } } class User { private String name = &quot;noName&quot;; private int age = 0; private int [] nums = new int[]{2,3,4}; public User() { } public User(String name,int age,int [] nums) { this.name = name; this.age = age; this.nums = nums; } } 这个就不反序列化了,可以看到对象,Map用{},List,Set用[].与上面的一致. 5.Gson注解 (1)@SerializedName SerializedName注解有两个参数,分别是value与alternate.SerializedName由注解名字可以知道与序列化成的Json名字有关. 默认情况下,json的键名与对象的字段名一致,@SerializedName可以解决序列化/反序列化时json键名与对象字段名不一致的问题,使其将json可以正确映射到对应的字段. a.单独使用value 单独使用一个参数时,即@SerializedName(&quot;xxx&quot;)或@SerializedName(value=&quot;xxx&quot;),序列化时,对象字段会变为@SerializedName中的值,反序列化时,若不是@SerializedName()中的值则不会反序列化: public class SerializedNameValueTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new SerializedNameValueTest().new User())); String str = &quot;{'this is a name':'what????','this is an age':13,'email':'33333@222.com'}&quot;; System.out.println(gson.fromJson(str,User.class)); String str2 = &quot;{'name':'askldfklaslk','age':-222,'email':'234234@23423.com'}&quot;; System.out.println(gson.fromJson(str2, User.class)); } class User { @SerializedName(&quot;this is a name&quot;) private String name = &quot;123&quot;; @SerializedName(&quot;this is an age&quot;) private int age = 0; private String email = &quot;xxx@xxx.com&quot;; private double[] nums = new double[] { 1.0, 2.0 }; @Override public String toString() { return &quot;name:&quot; + name + &quot;,age:&quot; + age + &quot;,eamil:&quot; + email + &quot;,nums:&quot; + Arrays.toString(nums); } } } 最后一个反序列化不成功,因为'name'不对应@SerializedName()中的'this is a name'. b.同时使用value与alternate 同时使用两者可以解决上面的问题,即name字段---&gt;json中的'this is a name'---&gt;name字段: public class SerializedNameValueAndAlternateTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new SerializedNameValueAndAlternateTest().new User())); String str = &quot;{'this is a name':'what????','this is an age':13,'email':'33333@222.com'}&quot;; System.out.println(gson.fromJson(str, User.class)); String str2 = &quot;{'name':'askldfklaslk','age':-222,'email':'234234@23423.com'}&quot;; System.out.println(gson.fromJson(str2, User.class)); } class User { @SerializedName(value = &quot;this is a name&quot;,alternate = &quot;name&quot;) private String name = &quot;123&quot;; @SerializedName(value = &quot;this is an age&quot;,alternate = &quot;age&quot;) private int age = 0; private String email = &quot;xxx@xxx.com&quot;; private double[] nums = new double[] { 1.0, 2.0 }; @Override public String toString() { return &quot;name:&quot; + name + &quot;,age:&quot; + age + &quot;,eamil:&quot; + email + &quot;,nums:&quot; + Arrays.toString(nums); } } } alternate就是为反序列化准备的,若找不到value中对应的值,则寻找alternate对应的值,找不到再设为null. 若同时存在value与alternate: String str3 = &quot;{'name':'altername','this is a name':'value'}&quot;; System.out.println(gson.fromJson(str3, User.class)); String str4 = &quot;{'this is a name':'value','name':'altername'}&quot;; System.out.println(gson.fromJson(str4, User.class)); 则以&quot;最晚&quot;出现的值为标准. (2)@Expose @Expose可以忽略某个字段,有两个参数: serialize deserialize 默认情况下都是true,分别表示序列化与反序列化. System.out.println(gson.toJson(new User())); class User { @Expose(serialize = false) private String name = &quot;123&quot;; @Expose(deserialize = false) private int age = 0; @Expose(serialize = false,deserialize = false) private String email = &quot;xxx@xxx.com&quot;; @Expose(serialize = true,deserialize = true) private double [] nums = new double [] {1.0,2.0}; } name不允许序列化,age不允许反序列化,email不允许序列化与反序列化,nums既允许也允许反序列化.(此时效果等于没加@Expose) 输出: 咦?好像没用的样子? 因为Gson对象会默认忽略@Expose,想要@Expose生效需要使用Gson Builder: GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithoutExposeAnnotation(); Gson gson = gsonBuilder.create(); System.out.println(gson.toJson(new User())); String str = &quot;{'name':'234','age':-3,'email':'23423','nums':[3,4,3]}&quot;; System.out.println(gson.fromJson(str, User.class)); class User { @Expose(serialize = false) private String name = &quot;123&quot;; @Expose(deserialize = false) private int age = 0; @Expose(serialize = false,deserialize = false) private String email = &quot;xxx@xxx.com&quot;; @Expose(serialize = true,deserialize = true) private double [] nums = new double [] {1.0,2.0}; @Override public String toString() { return &quot;name:&quot;+name+&quot;,age:&quot;+age+&quot;,eamil:&quot;+email+&quot;,nums:&quot;+Arrays.toString(nums); } } 不能反序列化age与email,输出的是age与email的默认值. 6.Gson Builder 前面的例子基本上都是通过 Gson gson = new Gson(); 来直接实例化一个Gson来使用Gson的,使用Gson Builder可以设置Gson的某些属性,使用其中的create()返回一个Gson. (1)基础 创建一个简单的Gson,通过create()创建: GsonBuilder gsonBuilder = new GsonBuilder(); Gson gson = gsonBuilder.create(); (2)命名规则 a.使用系统命名规则 使用 gsonBuilder.setFieldNamingPolicy(); 设置json中键的命名规则.6个值可选: IDENTITY:相同,json中的键名与字段名相同. LOWER_CASE_WITH_DASHES:在原来字段的大写字母前加-,并且把大写变成小写 LOWER_CASE_WITH_DOTS:在原来字段的大写字母前加.,并且把大写变成小写 LOWER_CASE_WITH_UNDERSCORES:在原来字段的大写字母前加_,并且把大写变成小写 UPPER_CAMEL_CASE:首字母大写 UPPER_CAMEL_CASE_WITH_SPACES:在原来字段的大写字母前加空格 public class NamingRulesTest { public static void main(String[] args) { NamingRulesTest n = new NamingRulesTest(); GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES); System.out.println(gsonBuilder.create().toJson(n.new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String Name_Name_name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private int _age_age_Age_age = 645; @SuppressWarnings(&quot;unused&quot;) private double numsNumsNums = 34.45; } } 注意,若某个字段有了@SerializedName,则这个字段遵循@SerializedName的策略. b.自定义命名规则 重写FieldNamingStrategy中的translateName(Field field),把自定义的FieldNamingStrategy传递给GsonBuilder的setFieldNamingStrategy(). 比如想要前缀加上某人的名字: public class CustomNamingRulesTest { public static void main(String[] args) { FieldNamingStrategy myNamingStrategy = new FieldNamingStrategy(){ @Override public String translateName(Field field) { return &quot;kr&quot;+field.getName(); } }; GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setFieldNamingStrategy(myNamingStrategy); Gson gson = gsonBuilder.create(); System.out.println(gson.toJson(new CustomNamingRulesTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private int num = 5; } } (3)null 默认情况下,Gson实例不允许序列化null,如果想要序列化null,借助GsonBuilder的serializeNulls()方法: public class NullTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES); System.out.println(gsonBuilder.create().toJson(new NullTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String thisIsANullField; @SuppressWarnings(&quot;unused&quot;) private Integer andThisIsANullFieldToo; } } (4)排除 前面已经接触到了@Expose这样的排除策略,下面看看更加强大的配合GsonBuilder使用的排除策略.主要有四种:属性名排除,类型排除,修饰符排除,@Expose排除. a.属性名排除 public class ExclusionNameTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); ExclusionStrategy exclusionName = new ExclusionStrategy(){ @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().endsWith(&quot;e&quot;); } @Override public boolean shouldSkipClass(Class&lt;?&gt; arg0) { return false; } }; gsonBuilder.setExclusionStrategies(exclusionName); System.out.println(gsonBuilder.create().toJson(new ExclusionNameTest().new User())); } class User { private String name; private int num; } } 排除字段名以e结尾的字段.下面是重点: public boolean shouldSkipField(FieldAttributes f) { return f.getName().endsWith(&quot;e&quot;); } 重写的shouldSkipField从名字可以看出跳过某些字段,返回true表示跳过,即排除这个字段.上面的例子中若名字以e结尾则跳过,因此输出: b.类型排除 public class ExclusionTypeTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); ExclusionStrategy exclusionType = new ExclusionStrategy(){ @Override public boolean shouldSkipField(FieldAttributes arg0) { return false; } @Override public boolean shouldSkipClass(Class&lt;?&gt; cls) { return cls == String.class; } }; gsonBuilder.setExclusionStrategies(exclusionType); System.out.println(gsonBuilder.create().toJson(new ExclusionNameTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name; @SuppressWarnings(&quot;unused&quot;) private int num; } } 重写的shouldSkipClass表示要跳过的类,这里跳过了String,只剩下num. @Override public boolean shouldSkipClass(Class&lt;?&gt; cls) { return cls == String.class; } c.修饰符排除 这个不用重写方法了,直接使用GsonBuilder的excludeFieldsWithModifiers(),参数是java.lang.reflect.Modifier: 这个可选的比较多就不一一列举了,只选了一个final的例子: public class ExclusionModifierTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithModifiers(Modifier.FINAL); System.out.println(gsonBuilder.create().toJson(new User())); } } class User { @SuppressWarnings(&quot;unused&quot;) private final String name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private static int num; } d.@Expose排除 这个准确来说是排除没有被@Expose注解的字段: public class ExclusionExposeTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithoutExposeAnnotation(); System.out.println(gsonBuilder.create().toJson(new ExclusionExposeTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name; @SuppressWarnings(&quot;unused&quot;) private int num; @Expose(serialize = true,deserialize = true) private int age; } } (5)Lenient 这是有关于反序列化时JSON的容错机制的问题,因为通常来说将一个对象通过Gson转换成json没什么大问题,但是将json转换为对象的时候就...就难说了,因为不知道是否符合标准的json格式,因此Gson提供了一定的容错机制,就是Lenient. Lenient翻译过来是&quot;宽容的&quot;的意思,可以通过: GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setLenient(); 开启. Gson内部有一个JsonReader类,默认情况下,JsonReader是严格的且仅接受符合RFC 4627标准的json(RFC 4627标准可以看看这里),设置为lenient后可以&quot;容忍&quot;以下几种错误: a.以 ) ] } ' \\n 开头 b.多个顶层值. c.任何类型的顶层值 d.数字可能是NaNs或infinites e.以行注释//或#结尾 f.以一个换行符结束 g.C风格的注释/**/,可能会嵌套 h.键/字符串没有引号或者单引号 i.数组元素以;分隔 j.不必要的数组分隔符,&quot;默认&quot;null为省略值,比如[1,,2],&quot;默认&quot;第二个元素为null k.键值以=或=&gt;分隔而非使用: l.键值对以;分隔而非使用, 设置setLenient()后,Gson会尽可能解析有错误的json,若实在无能为力,会抛出MalformedJsonException异常. 下面是一个不严格的json的例子: public class LenientTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setLenient(); String str = &quot;{'name'='234';'num'=6}&quot;; System.out.println(gsonBuilder.create().fromJson(str,User.class)); } class User { private String name; private int num; @Override public String toString() { return &quot;name:&quot;+name+&quot;,num:&quot;+num; } } } 下面是一个异常的例子: String errorStr = &quot;{'name'=????,,,,,,}&quot;; System.out.println(gsonBuilder.create().fromJson(errorStr,User.class)); (6)Floats &amp; Doubles 先看一个例子: public class FloatTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new FloatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private float f = Float.POSITIVE_INFINITY; } } 会报错: 它说Infinity在JSON标准是一个非法值.想要重写这个行为需要使用GsonBuilder.serializeSpecialFloatingPointValues(). 因为JSON规范不允许NaN,-Infinity,Infinity,因此会报错.下面使用GsonBuilder: public class FloatTest { public static void main(String[] args) { // Gson gson = new Gson(); // System.out.println(gson.toJson(new FloatTest().new User())); GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeSpecialFloatingPointValues(); System.out.println(gsonBuilder.create().toJson(new FloatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private float f = Float.POSITIVE_INFINITY; } } 直接输出Infinity: double也类似: public class DoubleTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeSpecialFloatingPointValues(); System.out.println(gsonBuilder.create().toJson(new DoubleTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private double ni = Double.NEGATIVE_INFINITY; @SuppressWarnings(&quot;unused&quot;) private double pi = Double.POSITIVE_INFINITY; @SuppressWarnings(&quot;unused&quot;) private double nan = Double.NaN; } } (7)模型版本化 通过@Since与@Until添加版本控制,控制某个版本在序列化与反序列化时忽略或忽略某个字段. @Since表示从某个版本开始这个字段不忽略,@Until表示这个版本后将忽略该字段. 需要配合GsonBuilder的setVersion使用,设定版本号. public class VersionTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); System.out.println(gsonBuilder.setVersion(0.9).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.0).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.4).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.5).create().toJson(new VersionTest().new User())); } class User { @Since(1.0) private String name; @Until(1.4) private int num; } } @Since的范围包含了左区间端点,@Until的范围不包含右区间端点. (8)格式化日期 可以使用setDateForamt()来格式化日期输出: gsonBuilder.setDateFormat(int style); gsonBuilder.setDateFormat(String pattern); gsonBuilder.setDateFormat(int dateStyle,int timeStyle); 第一个函数的参数为DateFormat中的常量值,第二个函数的参数是类似SimpleDateFormat中的String,第三个函数的参数与第一个类似,分开日期与时间设置. 再说以下setPrettyPrinting()这个函数,看名字就知道,美化打印的.会加上空格. public class FormatTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setPrettyPrinting(); System.out.println(gsonBuilder.setDateFormat(DateFormat.SHORT, DateFormat.SHORT).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.SHORT,DateFormat.LONG).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.MEDIUM, DateFormat.MEDIUM).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.LONG, DateFormat.MEDIUM).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.FULL, DateFormat.FULL).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create().toJson(new FormatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private Date date = new Date(); } } 7.Gson进阶 (1)枚举 枚举其实也与普通的字段类似,序列化与反序列化正常操作. public class EnumTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new EnumTest().new User())); String str = &quot;{\\&quot;season\\&quot;:\\&quot;SUMMER\\&quot;,\\&quot;name\\&quot;:\\&quot;8888\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } enum Season { SPRING, SUMMER, AUTUMN, WINTER } class User { private Season season = Season.SPRING; private String name = &quot;123&quot;; @Override public String toString() { return &quot;season:&quot;+season.toString()+&quot;,name:&quot;+name; } } } 主要配合@SerializedName()使用,例如对于月份,可以使用1,2,3来表示: public class EnumTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new EnumTest().new User())); String str = &quot;{\\&quot;season\\&quot;:\\&quot;SUMMER\\&quot;,\\&quot;name\\&quot;:\\&quot;8888\\&quot;,\\&quot;month\\&quot;:\\&quot;2\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } enum Season { SPRING, SUMMER, AUTUMN, WINTER } class User { private Season season = Season.SPRING; private String name = &quot;123&quot;; private Month month = Month.January; @Override public String toString() { return &quot;season:&quot;+season.toString()+&quot;,name:&quot;+name+&quot;,month:&quot;+month.toString(); } } enum Month { @SerializedName(&quot;1&quot;) January, @SerializedName(&quot;2&quot;) February, @SerializedName(&quot;3&quot;) March, @SerializedName(&quot;4&quot;) April, @SerializedName(&quot;5&quot;) May, @SerializedName(&quot;6&quot;) June, @SerializedName(&quot;7&quot;) July, @SerializedName(&quot;8&quot;) August, @SerializedName(&quot;9&quot;) September, @SerializedName(&quot;10&quot;) October, @SerializedName(&quot;11&quot;) November, @SerializedName(&quot;12&quot;) December } } (2)泛型 这里主要说一下反序列化泛型.因为序列化泛型...直接toJson()就好了. 想想这样的情景:有一个待解析的Json String,类型为List,因此想有一个这样的方法: public &lt;T&gt; List&lt;T&gt; fromJSON(String json,Class&lt;T&gt; cls); 好了,怎么写呢,之前用的是TypeToken()实现反序列化: List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); integerList.add(3); integerList.add(-999); gson.toJson(integerList, new TypeToken&lt;List&lt;Integer&gt;&gt;() {}.getType()); 答案就是使用ParameterizedType:重写里面的getActualTypeArguments(),getOwnerTpye()与getRawType(): public class GenericsTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setPrettyPrinting(); Gson gson = gsonBuilder.create(); List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); integerList.add(3); integerList.add(-999); gson.toJson(integerList, new TypeToken&lt;List&lt;Integer&gt;&gt;() {}.getType()); List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(&quot;12321&quot;); stringList.add(&quot;(@)#$@#&quot;); String t1 = gson.toJson(integerList); String t2 = gson.toJson(stringList); new GenericsTest().fromJSON(t1, Integer.class).stream().forEach(System.out::println); new GenericsTest().fromJSON(t2, String.class).stream().forEach(System.out::println); } public &lt;T&gt; List&lt;T&gt; fromJSON(String json,Class&lt;T&gt; cls) { return new Gson().fromJson(json,new ParameterizedTypeImpl(cls)); } class ParameterizedTypeImpl implements ParameterizedType { private Class cls; public ParameterizedTypeImpl(Class cls) { this.cls = cls; } @Override public Type[] getActualTypeArguments() { return new Type[]{cls}; } @Override public Type getRawType() { return List.class; } @Override public Type getOwnerType() { return null; } } } @Override public Type[] getActualTypeArguments() { return new Type[]{cls}; } 返回实际参数类型数组,在这里是String.class与Integer.class. @Override public Type getRawType() { return List.class; } 返回声明这个类型的类或接口,在这里是List.class. @Override public Type getOwnerType() { return null; } 返回其成员之一的类型,就是说如果完全限定类名为A.B,则返回A,在这里没有A,因此为null. 定义好实现ParameterizedTpye接口的类后,把它传递给fromJson()作为第二参数,构造方法的参数为List&lt;T&gt;中的T.class. (4)自定义序列化 自定义序列化一般用于自定义简化json. 比如有一个User类: class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; } 想要不序列化name,可以使用@Expose(serialize = false),但是想要部分序列化nums,比如只是需要第一个nums[0],上面的@Expose,@SerializedName等注解都用不上,这时需要使用JsonSerializer自定义序列化,重写其中的: public JsonElement serialize(T t,Type type,JsonSerializationContext context) 可以返回一个JsonObject,这里的JsonObject可以自定义添加属性(即键值对). 需要配合GsonBuilder使用,创建了自己的JsonSerializer&lt;T&gt;后,把它传递给GsonBuilder的registerTypeAdapter(): public class SerializeCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); JsonSerializer&lt;User&gt; serializer = new JsonSerializer&lt;SerializeCustomTest.User&gt;() { @Override public JsonElement serialize(User u,Type type,JsonSerializationContext context) { JsonObject object = new JsonObject(); object.addProperty(&quot;name&quot;,u.getName()); object.addProperty(&quot;email&quot;,u.getEmail()); object.addProperty(&quot;nums&quot;,u.getNums()[0]); return object; } }; gsonBuilder.registerTypeAdapter(User.class,serializer); System.out.println(gsonBuilder.create().toJson(new SerializeCustomTest().new User())); } class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; public int [] getNums() { return nums; } public String getName() { return name; } public String getEmail() { return email; } } } (5)自定义反序列化 自定义反序列化主要就是针对有多余键值对的json,比如User只需要name字段,但是传来的json包含了诸如age这样的键,因此只需挑选所需的进行反序列化.与序列化类似,首先定义自己的JsonDeserializer&lt;T&gt;,重写其中的: public T deserialize(JsonElement,Type,JsonDeserializationContext); 返回一个自定义的反序列化的对象.最后在GsonBuilder中registerTypeAdapter()即可. public class DeserializedCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); JsonDeserializer&lt;User&gt; deserializer = new JsonDeserializer&lt;DeserializedCustomTest.User&gt;() { @Override public User deserialize(JsonElement json,Type type,JsonDeserializationContext context) { JsonObject object = json.getAsJsonObject(); User user = new DeserializedCustomTest().new User(object.get(&quot;name&quot;).getAsString()); return user; } }; gsonBuilder.registerTypeAdapter(User.class, deserializer); String str = &quot;{\\&quot;aaa\\&quot;:\\&quot;bbbb\\&quot;,\\&quot;name\\&quot;:\\&quot;this is a name\\&quot;,\\&quot;age\\&quot;:\\&quot;444\\&quot;}&quot;; System.out.println(gsonBuilder.create().fromJson(str,User.class)); } class User { private String name; private int age; public User(String name) { this.name = name; } @Override public String toString() { return &quot;name:&quot;+name+&quot;,age:&quot;+age; } } } (6)默认实例 可以设置反序列化时的默认值,通过构造方法实现.比如json中没有所需要的字段的值,默认情况下为null,如果想要不为null,可以设定默认值,对于对象可以设定构造方法. 通过实现InstanceCreator&lt;T&gt;来实现,重写其中的createInstance方法,再配合GsonBuilder的registerTypeAdapter(). public class InstanceCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter( AA.class, new InstanceCustomTest().new AAInstance( new InstanceCustomTest().new BB(&quot;123&quot;,&quot;456&quot;) ) ); String str = &quot;{\\&quot;name\\&quot;:\\&quot;123123\\&quot;}&quot;; System.out.println(gsonBuilder.create().fromJson(str, AA.class)); } class AAInstance implements InstanceCreator&lt;AA&gt; { private BB bb; public AAInstance(BB bb) { this.bb = bb; } @Override public AA createInstance(Type type) { return new AA(bb); } } class AA { private String name = &quot;AA&quot;; private BB bb; public AA(BB bb) { this.bb = bb; } @Override public String toString() { return &quot;name:&quot;+name+&quot;,bb:&quot;+bb.toString(); } } class BB { private String field1; private String field2; public BB(String field1,String field2) { this.field1 = field1; this.field2 = field2; } @Override public String toString() { return &quot;field1:&quot;+field1+&quot;,field2:&quot;+field2; } } } json没有为BB类设定值,采用默认值. (7)@JsonAdapter 这个是自定义序列化/反序列化的注解,可以简化JsonSerializer与JsonDeserializer.另外不用配合GsonBuilder使用,直接使用new Gson().toJson()/fromJson()即可,比直接使用JsonSerializer与JsonDeserializer要简单. 首先使一个类实现JsonSerializer&lt;T&gt;接口,接着把这个类作为要注解的字段的@JsonAdapter的参数: class Serializer implements JsonSerializer&lt;User&gt; class ContainUser { private String userId = &quot;x&quot;; @JsonAdapter(Serializer.class) private User user = new User(); } public class JsonAdapterSerializeTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new JsonAdapterSerializeTest().new ContainUser())); } class Serializer implements JsonSerializer&lt;User&gt; { @Override public JsonElement serialize(User u,Type type,JsonSerializationContext context) { JsonObject object = new JsonObject(); object.addProperty(&quot;name&quot;,u.getName()); object.addProperty(&quot;email&quot;,u.getEmail()); object.addProperty(&quot;nums&quot;,u.getNums()[0]); return object; } } class ContainUser { private String userId = &quot;x&quot;; @JsonAdapter(Serializer.class) private User user = new User(); } class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; public int [] getNums() { return nums; } public String getName() { return name; } public String getEmail() { return email; } } } 反序列化也类似. public class JsonAdapterDeserializeTest { public static void main(String[] args) { Gson gson = new Gson(); String str = &quot;{\\&quot;aaaa\\&quot;:\\&quot;bbbb\\&quot;,\\&quot;name\\&quot;:\\&quot;this is a name\\&quot;,\\&quot;age\\&quot;:\\&quot;444\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } class Deserialize implements JsonDeserializer&lt;User&gt; { @Override public User deserialize(JsonElement json,Type type,JsonDeserializationContext context) { JsonObject object = json.getAsJsonObject(); User user = new JsonAdapterDeserializeTest().new User(object.get(&quot;name&quot;).getAsString()); return user; } } @JsonAdapter(Deserialize.class) class User { private String name = &quot;123&quot;; public User() { } public User(String name) { this.name = name; } @Override public String toString() { return &quot;name:&quot;+name; } } } 实现JsonDeserializer&lt;T&gt;,重写deserialize(),在所需的类上添加注解. 注意@JsonAdapter注解只能添加在类上. 8.源码 所有例子的完整源码. github. 码云. Gson官方github. 9.参考链接 1.Gson Tutorial Series by Future Studio 2.gson完全教程 3.gson教程 4.gson用户指南 5.Gson User guide 6.gson ","link":"https://2293736867.github.io/post/gsonso-easy/"},{"title":"Java实现UDP通信","content":" 1.概述 2.发送端 (1)创建DatagramSocket与DatagramPacket (2)创建DatagramPacket (3)发送 3.接收端 (1)创建DatagramSocket (2)创建DatagramPacket (3)接收 (4)获取数据 4.完整代码 (1)Server.java (2)Client.java 5.测试 1.概述 用DatagramSocket与DatagramPacket实现UDP通信.UDP比TCP相对来说简单一点,不需要等待连接,且处理数据不需要用输出输出流,只需要DatagramPacket.严格来说,UDP没有服务端和客户端之分,只有发送端与接收端之分. 2.发送端 发送端首先建立DatagramSocket与DatagramPacket,设置好DatagramPacket的端口与ip,再通过DatagramSocket发送. (1)创建DatagramSocket与DatagramPacket DatagramSocket socket = new DatagramSocket(55555); 这里的55555端口是指数据通过这个端口发送. (2)创建DatagramPacket InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 12345; String message = &quot;message&quot;; DatagramPacket packet = new DatagramPacket(message.getBytes(),message.getBytes().length,ip,port); 构造方法DatagramPacket()的四个参数分别为 发送的字节数组 字节数组长度 ip 端口 这里端口不能与上面的一致,不然的话会提示端口被占用. (3)发送 socket.send(packet); 3.接收端 接收端只需指定端口进行接收,这里的端口在DatagramSocket中的构造方法中指定,与发送端的发送的packet中设置的端口一致. (1)创建DatagramSocket DatagramSocket socket = new DatagramSocket(12345); (2)创建DatagramPacket 这里创建的DatagramPacket只需要指定存储数据的字节数组与该字节数组的长度. byte [] message = new byte[2048]; DatagramPacket packet = new DatagramPacket(message, message.length); (3)接收 socket.receive(packet); 这个方法会阻塞,直到接收到packet. (4)获取数据 接收到packet后可以使用getData()获取数据,返回字节数组,可以传递给String的构造方法创建String. String str = new String(packet.getData()); 4.完整代码 这里人为地设定了客户端与服务端,可以互相发送数据,服务端输入后发送到服务端,服务端返回固定数据, &quot;客户端&quot;与&quot;服务端&quot;轮流扮演了发送端与接收端的角色.配合了swing使用. (1)Server.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import javax.swing.*; public class Server { public static void main(String[] args) { JFrame frame = new JFrame(&quot;Server&quot;); JTextArea text = new JTextArea(); frame.add(text); frame.setSize(600, 300); frame.setLocationRelativeTo(null); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try { byte [] message = new byte[2048]; DatagramSocket socket = new DatagramSocket(12345); DatagramPacket packet = new DatagramPacket(message, message.length); socket.receive(packet); InetAddress ip = packet.getAddress(); int port = packet.getPort(); text.setText(&quot;ip : &quot;+ip.toString()+&quot;\\n&quot;); text.append(&quot;port : &quot;+port+&quot;\\n&quot;); text.append(&quot;message : &quot;+new String(packet.getData())); String messageFromServer = &quot;Message from server&quot;; packet = new DatagramPacket(messageFromServer.getBytes(),messageFromServer.getBytes().length,ip,port); socket.send(packet); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } (2)Client.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.Socket; import javax.swing.*; import java.awt.GridLayout; public class Client { public static void main(String[] args) { JFrame frame = new JFrame(); JTextArea text = new JTextArea(); JButton send = new JButton(&quot;send&quot;); GridLayout layout = new GridLayout(2,1,1,1); frame.setLayout(layout); frame.setTitle(&quot;Client&quot;); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.setSize(600, 300); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(text); frame.add(send); send.addActionListener( v-&gt; { try { InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 12345; DatagramSocket socket = new DatagramSocket(55555); String message = text.getText(); DatagramPacket packet = new DatagramPacket(message.getBytes(),message.getBytes().length,ip,port); socket.send(packet); byte [] messageFromServer = new byte[2048]; packet = new DatagramPacket(messageFromServer, messageFromServer.length); socket.receive(packet); text.setText(new String(packet.getData())); socket.close(); } catch (IOException e) { e.printStackTrace(); } }); } } 5.测试 ","link":"https://2293736867.github.io/post/java-shi-xian-udp-tong-xin/"},{"title":"Java实现TCP通信","content":" 1.概述 2.服务端 (1)新建ServerSocket (2)接收socket (3)数据处理 (4)完整代码Server.java 3.客户端 (1)新建一个Socket (2)输入输出 (3)完整代码Client.java 4.测试 1.概述 通过ServerSocket与Socket实现的TCP的通信,这个例子配合了swing使用,其实作者之前发过一篇ServerSocker与Socket的通信,在这里,这边文章就是在这个例子上修改而成的. 其实原理很简单的,就是一个服务端一个客户端,服务端这边创建好ServerSocket后,使用accept()堵塞一直等待客户端发送socket. 好吧,不废话了.进正题. 2.服务端 swing的部分就不说了,说一下主要操作. (1)新建ServerSocket ServerSocket serverSocket = null; serverSocket = new ServerSocket(12345);//一个不被占用的端口即可 构造方法的参数是端口,默认使用本地ip. ServerSocket有三个构造方法. ServerSocket(int port); ServerSocket(int port,int backlog); ServerSocker(int poer,int backlog,InetAddress ip); 详情可以看这里 (2)接收socket Socket socket = serverSocket.accept(); 返回一个Socket(),会一直等待,处于阻塞状态. 一般设置一个while(true)循环接收. (3)数据处理 使用DataInputStream与DataOutputStream: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); DataOutputStram outputStream = new DataOutputStream(socket.getOutputStream()); 然后使用read与write方法即可. 注意关闭的时候要等输入输出完成后再一起关闭,就是说,不能这样: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); String data = inputStream.readUTF(); inputStream.close(); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); outputStream.close(); 这样的话getInputStream()没有问题,但是到了getOutputStream()的时候就有问题了,会提示异常: Socket is closed. 所以解决办法就是等输出完之后再一起关闭: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); String data = inputStream.readUTF(); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); inputStream.close();//等输出完成后再关闭 outputStream.close(); (4)完整代码Server.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import javax.swing.*; public class Server { public static void main(String[] args) { JFrame frame = new JFrame(&quot;Server&quot;); JPanel panel = new JPanel(); JTextArea text = new JTextArea(); panel.add(text); frame.setContentPane(panel); frame.setSize(600, 300); frame.setLocationRelativeTo(null); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(12345); while (true) { Socket socket = serverSocket.accept(); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); text.setText(inputStream.readUTF()); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); inputStream.close(); outputStream.close(); socket.close(); } } catch (IOException e) { e.printStackTrace(); } finally { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } 3.客户端 客户端的操作就是开启一个Socket,再通过这个socket获取对应的输入输出流就可以了. (1)新建一个Socket Socket socket = new Socket(&quot;127.0.0.1&quot;,12345);//这个端口与服务端的端口对应 Socket有三个构造方法: Socket(InetAddress ip,int port); Socket(String ip,int port); Socket(InetAddress ip,int port,InetAddress localIp,int localPort); Socket(String ip,int port,InetAddress localIp,int localPort); 详情可以看这里 (2)输入输出 同样使用DataInputStream与DataOutputStream: DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); (3)完整代码Client.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.Socket; import javax.swing.*; import java.awt.GridLayout; public class Client { public static void main(String[] args) { JFrame frame = new JFrame(); JTextArea text = new JTextArea(); JButton send = new JButton(); GridLayout layout = new GridLayout(2, 1, 0, 5); frame.setTitle(&quot;Client&quot;); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.setSize(600, 300); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLayout(layout); frame.add(text); frame.add(send); send.setText(&quot;send&quot;); send.addActionListener(v -&gt; { try { String host = &quot;127.0.0.1&quot;; int port = 12345; Socket socket = new Socket(host, port); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(text.getText()); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); text.setText(inputStream.readUTF()); outputStream.close(); inputStream.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } }); } } 4.测试 先开启服务端,再开启客户端,这里设置了服务端返回给客户端的信息为&quot;ok&quot;. ","link":"https://2293736867.github.io/post/java-shi-xian-tcp-tong-xin/"},{"title":"Java Swing Hello world","content":"1.概述 一个简单的java swing程序hello world,只有一个button 2.源码 import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JButton button = new JButton(&quot;Test button&quot;); jFrame.add(button);//把button添加到JFrame中 jFrame.setSize(300,300);//设置JFrame大小 jFrame.setVisible(true);//设置可见,不然的话看不到 } } 3.第一次修改 有没有觉得有点奇怪,整个button占满了窗口? 没错,少了一个JPanel: import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JPanel jPanel = new JPanel(); JButton button = new JButton(&quot;Test button&quot;); jPanel.add(button); jFrame.setContentPane(jPanel); jFrame.setSize(300,300); jFrame.setVisible(true); } } 添加一个JPanel,把Button添加到JPanel中,然后设置JFrame的contenPane. 效果如下: 4.第二次修改 嗯,有点hello world的样子了,但是你有没有点击过左上角的x按钮? 点了之后,这个东西是&quot;消失&quot;了,但是在后台还在运行着,所以... jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 需要这样设置它的默认关闭操作. 另一个修改就是对它居中显示,要不然的话总是启动的时候在左上角. 很简单,一行就可以了. jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 完整代码: import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JPanel jPanel = new JPanel(); JButton button = new JButton(&quot;Test button&quot;); jPanel.add(button); jFrame.setContentPane(jPanel); jFrame.setSize(300,300); jFrame.setLocationRelativeTo(null); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } ","link":"https://2293736867.github.io/post/java-swing-hello-world/"},{"title":"ssh连接服务器","content":" 1.概述 2.密码认证 3.密钥认证 (1)产生公钥与私钥 (2)复制公钥到服务器 (3)修改本地私钥权限 (4)连接 (5)如果还是需要密码 1.概述 ssh是一种网络通信协议,用于计算机之间的加密登录.一般用ssh连接服务器有两种方式:密码认证与密钥认证. 密码认证就是通过传统的输入密码的方式登录,密钥认证就是把产生的公钥注册到服务器后,用私钥登录,这样就可以不用每次登录输入密码.特别适合作者这种脑残记不住密码的懒人. 2.密码认证 密码认证登录直接在终端使用ssh命令即可: ssh username@xxx.xxx.xxx.xxx username为用户名,后面为ip. 3.密钥认证 (1)产生公钥与私钥 这一步使用ssh-keygen命令生成id_rsa与id_rsa.pub文件: ssh-keygen -t rsa -b 4096 -C &quot;eamil&quot; 其中email为你的邮箱. 然后一直enter就好了(当然你也可以修改参数,比如生成的公钥与私钥的文件名等,后面要对应). (2)复制公钥到服务器 cd ~/.ssh ssh-copy-id -i id_rsa.pub username@xxx.xxx.xxx.xxx 注意复制的是公钥(.pub结尾,不是私钥id_rsa). (3)修改本地私钥权限 若出现以上情况,根据提示说是私钥的权限问题,修改为: chmod 600 id_rsa 在windows上使用wsl的要注意,wsl不能直接修改文件权限,需要修改一下/etc/wsl.conf文件(没有的话就新建). vim /etc/wsl.conf 输入 [automount] enabled = true options = &quot;metadata,umask=22,fmask=11&quot; mountFsTab = false 退出wsl重启. (4)连接 ssh -i ~/.ssh/id_rsa username@xxx.xxx.xxx.xxx 如果上面配置没出现的话就可以连接上了. (5)如果还是需要密码 先用密码认证的方式登录服务器,修改/etc/ssh/sshd_config(注意有一个d,/etc/ssh下有一个叫ssh_config的文件,不要ssh然后按tab....) vim /etc/ssh/sshd_config 找到PasswordAuthentication这一行. 修改为no. 然后重启服务: service ssh restart 或者 /etc/init.d/ssh restart 重启服务后连接: ssh -i ~/.ssh/id_rsa username@xxx.xxx.xxx.xxx ","link":"https://2293736867.github.io/post/ssh-lian-jie-fu-wu-qi/"},{"title":"后端Spring Boot+前端Android交互+MySQL增删查改","content":" 2020.06.23 更新 1 概述 2 开发环境 3 后端 3.1 新建一个Spring Boot项目 3.2 实体类 2.3 持久层 2.4 业务层 2.5 控制层 4 Android端 4.1 增 4.2 删 4.3 查 4.4 改 4.5 UI 4.6 依赖与其他 4.7 网络权限 5 测试 6 源码 2020.06.23 更新 1 概述 使用spring boot作为后端框架与Android端配合mysql进行基本的交互,包含了最基本的增删查改功能. 2 开发环境 Win IDEA 2019.2 Tomcat 9.0.27 MySQL 8.0.17 Spring Boot 2.2.1 JDK 8 3 后端 3.1 新建一个Spring Boot项目 参考这里. 3.2 实体类 新建User类作为实体类: @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 用的其实是3.1链接中的代码,里面有详细的解释. 2.3 持久层 新建UserRepository实现增删查改: @Repository public interface UserRepository extends CrudRepository&lt;User,Integer&gt; { @Query(value = &quot;select * from user where name = ?1&quot;,nativeQuery = true) public List&lt;User&gt; findByName(String name); @Modifying @Query(value = &quot;delete from user where name = ?1&quot;,nativeQuery = true) public int deleteByName(String name); } 由于CrudRepository中已经包含了&quot;增&quot;与&quot;改&quot;,所以按需要实现自己的&quot;查&quot;与&quot;删&quot;即可. CrudRepository的api很简单,官方文档在这里. &quot;增&quot;使用save即可,参数为实体类 &quot;删&quot;使用deleteById,通过主键删除,若不想通过主键删除可以自己编写sql,像上面一样 &quot;查&quot;使用findAll或findById,自定义查找的话需要自己编写SQL &quot;改&quot;也可使用save,注意需要设置主键 @Query用于设置SQL语句,nativeQuery表示使用原生SQL. 2.4 业务层 新建一个MainService.java: @Transactional @Service public class MainService { @Autowired private UserRepository userRepository; public Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } public List&lt;User&gt; findByName(String name) { return userRepository.findByName(name); } public boolean add(String name) { User user = new User(); user.setName(name); userRepository.save(user); return true; } public boolean modify(Integer id,String name) { User user = new User(); user.setName(name); user.setId(id); userRepository.save(user); return true; } public boolean deleteByName(String name) { return userRepository.deleteByName(name) != 0; } } getAllUsers():返回所有行,Iterable&lt;E&gt;类型 findByName():根据name返回所有name相同的行 add直接使用了save,由于save返回的是实体类,原本的代码是这样写的: return userRepository.save(user) != null; 但是文档说了不会为null,所以只能强制返回true了. modify使用了id与name作为参数,新建一个user,将其作为setter的参数,然后交给save deleteByName使用了自定义的删除函数,返回的是int,在UserRepository中这个int代表SQL影响的行数,删除成功则行数不为0,删除失败,或者没有这行数据则行数为0.因此将返回值与0进行比较 2.5 控制层 @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private MainService mainService; @GetMapping(path = &quot;/getAll&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return mainService.getAllUsers(); } @PostMapping(path = &quot;/get&quot;) public @ResponseBody List&lt;User&gt; findByName(String name) { return mainService.findByName(name); } @PostMapping(path = &quot;/add&quot;) public @ResponseBody boolean add(@RequestParam String name) { return mainService.add(name); } @PostMapping(path = &quot;/modify&quot;) public @ResponseBody boolean modify(@RequestParam Integer id,@RequestParam String name) { return mainService.modify(id,name); } @PostMapping(path = &quot;/delete&quot;) public @ResponseBody boolean deleteByName(@RequestParam String name) { return mainService.deleteByName(name); } } Controller主要就是几个注解,除了getAllUsers使用Get外,其他的都是用Post.另外就是路径设置,直接在path中设置即可. 后端的话到这里就基本完成了,剩下的打包部署操作就不说了,需要的可以参考这里. 4 Android端 什么新建工程之类的就不说了. 贴上部分MainActivity,完整代码见文末: public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { register.setOnClickListener(v -&gt;{new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } //... }).start();}); login.setOnClickListener(v -&gt;{new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } //... }).start();}); delete.setOnClickListener(v -&gt;{new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } //... }).start();}); modify.setOnClickListener(v -&gt;{new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } //... }).start();}); } } 下面分别进行CRUD操作. 4.1 增 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 使用OkHttp,通过FormBody设置参数,然后创建Request通过OkHttpClient发送. 由于后端&quot;增&quot;的方法返回的是一个true,因此这里将response.body().string()转换成boolean判断是否操作成功. 稍微提一下, Looper.prepare(); Looper.loop(); 这两行可以在非UI线程中使用Toast. 4.2 删 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 删这部分也是差不多的,就是改一下url,然后....然后没有了....好像很简单的样子?2333333 4.3 查 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 查这里注意一下后端返回的是List,这里借助阿里的fastjson转换成List. List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); 然后判断有没有的话就判断长度是否为0即可. 4.4 改 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 改的话只需一个额外的ID参数,在FormBody中add一个即可,不难. 4.5 UI UI不详细说了,就几个简单的Button,具体可以看代码中的xml文件. 4.6 依赖与其他 注意一下依赖,还有设置java8. compileOptions{ sourceCompatibility=1.8 targetCompatibility=1.8 } dependencies{ implementation 'com.squareup.okhttp3:okhttp:x.x.x' implementation 'com.alibaba:fastjson:x.x.x' } OkHttp最新版本戳这里查看 fastjson最新版本戳这里查看 4.7 网络权限 这个笔者之前的文章有说,主要就是AndroidManifest.xml中的权限设置,请看这里. 5 测试 原始数据库: 注册一个: 看看数据库: 测试登录: 试试登录一个不存在的: 修改: 最后是删除: 删除一个不存在的会删除失败. 6 源码 Github 码云 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/hou-duan-spring-bootqian-duan-android-jiao-hu-mysql-zeng-shan-cha-gai/"},{"title":"SpringBoot+MySQL+Spring Data JPA一个Web的Demo","content":" 2020.06.23 更新 1 概述 2 创建初始spring demo 3 配置数据源 3.1 创建库与用户 3.2 用户授权 3.3 配置application.properties 4 实体类 5 持久层 6 控制层 7 IDE上测试 8 打包发布 9 完整代码 2020.06.23 更新 1 概述 一个简单的web项目配合MySQL+Hibernate+Tomcat的简单示例demo,很容易在此基础上扩展成自己的项目. 2 创建初始spring demo 笔者IDE为IntelliJ IDEA,新建一个工程,选择Spring Initalizer: 下一步的话由于需要部署到服务器上面,选择了war.不需要的话可以选择jar. 选择Spring Web+Spring Data JPA+MySQL Driver. 然后完成即可,首次运行的话配置依赖需要一点时间,请耐心等待. 3 配置数据源 配置数据源分为两部分,一部分是建表与建用户,另一部分是在application.properties中配置的. 3.1 创建库与用户 create database test; 注意这里不用创建表了,因为Hibernate从实体类自动创建一个同名的表. 接着创建用户: create user 'db'@'%' identified by 'xxxxx'; 3.2 用户授权 grant all on test.* to 'db'@'%'; 这里建议授权all,因为后面Hibernate会用到建表权限,不能仅仅授权增删查改. 3.3 配置application.properties 配置四个属性: spring.jpa.hibernate.ddl-auto= spring.datasource.url= spring.datasource.username= spring.datasource.password= 第一个属性是可以取值 none:none是对MySQL的默认值,不会改变数据库结构. update:Hibernate会根据给出的实体类去改变数据库. create:创建数据库但是不会在关闭的时候删除. create-drop:创建数据库,当SessionFactory关闭时删除数据库.这个是H2与其他嵌入式数据库的默认选项. 第一次运行时必须设置为update或create,因为还不知道确切的实体类,第一次运行后,可以设置为update或none. url的话对于MySQL来说是 jdbc:mysql://ip:3306/database 剩下的两个为用户名与密码. 以下是笔者的配置,供参考: 4 实体类 这里创建一个简单的User实体类,需要用到javax中的@Entity,@Id,@GeneratedValue与@GenerationType注解. @Entity用于标识实体类,@Id用于标识主键,@GeneratedValue与@GenerationType用于配置主键. @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 除了主键之外,可以加上自己想要的属性与setter和getter,Hibernate会自动将实体类制作成一个数据表. 5 持久层 创建Repository保存用户记录.需要继承CrudRepository&lt;T,ID&gt;,第一个类型为实体类,第二个类型为主键类型. public interface UserRepository extends CrudRepository&lt;User,Integer&gt; {} 6 控制层 控制层用于控制HTTP请求,在控制器中可以配置不同的路径实现不同的操作. @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private UserRepository userRepository; @PostMapping(path = &quot;/add&quot;) public @ResponseBody String addNewUser(@RequestParam String name) { User user = new User(); user.setName(name); userRepository.save(user); return &quot;Saved.&quot;; } @GetMapping(path = &quot;/all&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } } @RequestMapping中的值表示URL以此值开头 @PostMapping是仅处理POST请求的路径 @ResponseBody表示返回的类型 @RequestParam表示一个从GET或POST中获取的参数 getAllUsers()会返回一个JSON或者xml 7 IDE上测试 首先输入: localhost:8080/demo/all 由于先前已经有一行数据所以有显示. 否则的话应该显示为[]. 接下来可以添加数据: curl localhost:8080/demo/add -d name=123 回应: 接下来可以选择再次查看: 再看看数据库: 8 打包发布 Build-&gt;Build Artifacts. Build即可. 然后会在项目目录的target下有一个WAR文件,就是这个了. 改名字放到Tomcat的webapps下,比如笔者改成了demo.war: 接着可以去访问了,注意路径,这里的路径是WAR的路径加上@RequestMapping的路径再加上@PostMapping或@GetMapping路径: 9 完整代码 Github 码云 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/spring-bootmysqlspring-data-jpa-yi-ge-web-de-demo/"},{"title":"JDBC+C3P0+DBCP 基本使用","content":" 1.概述 2.mysql的处理 (1)新建用户 (2)建立数据表 (3)用户权限 2.JDBC (1)jar包 (2)连接 (3)Statement (4)PreparedStatement (5)事务 3.C3P0 (1)jar包 (2)配置文件 (3)工具类 4.DBCP (1)jar包 (2)配置文件 (3)工具类 5.源码 1.概述 这篇文章主要说了JDBC的基本使用,包括Statement,PreparedStatement,JDBC的连接,Mysql创建用户创建数据表,C3P0的连接与配置,DBCP的连接与配置. 2.mysql的处理 这里的JDBC使用Mysql作为DBMS,请先安装Mysql,未安装的请点击这里下载,安装教程在这里,作者使用的Mysql的8.0.17版本. (1)新建用户 随便新建一个用户,比如这里作者新建的是aa,密码是aa123bb. create user 'aa'@'localhost' identified by 'aa123bb' (2)建立数据表 建立测试用的数据表与数据库. create database db; use db; create table db ( id int PRIMARY key, name char(20) ); (3)用户权限 对刚才新建的用户授权: grant select,update,delete,insert on db.* to 'aa'@'localhost'; 2.JDBC (1)jar包 8.0.17版本在这里 各个版本的在这里下载 (2)连接 首先注册驱动,驱动需要一个url,用户名和密码,用户名和密码是上一步创建好的,url包含ip地址,端口和数据库的名字. private static final boolean mysqlVersionGreaterThen8 = true; private static final String driver = &quot;com.mysql&quot; + (mysqlVersionGreaterThen8 ? &quot;.cj&quot; : &quot;&quot;) + &quot;.jdbc.Driver&quot;; private static final String ip = &quot;127.0.0.1&quot;; private static final String port = &quot;3306&quot;; private static String databaseName = &quot;db&quot;; private static String url; private static String username = &quot;aa&quot;; private static String password = &quot;k041400r&quot;; private static Connection connection = null; public static Connection getConnection() { try { url = &quot;jdbc:mysql://&quot; + ip + &quot;:&quot; + port + &quot;/&quot; + databaseName; Class.forName(driver); return connection = DriverManager.getConnection(url, username, password); } catch (Exception e) { e.printStackTrace(); } return null; } 这里要注意以下旧版本的mysql的驱动叫com.mysql.jdbc.Driver,新版本的叫com.mysql.cj.jdbc.Driver.还有就是url的格式: jdbc:mysql://ip:port/database (3)Statement 获取数据库连接后,使用createStatement方法创建Statement 对于select,使用Statement的executeQuery(sql),返回ResultSet 对于update,delete,insert,使用Statement的executeUpdate(sql) 其中sql是要执行的sql语句,一个String. public void useStatement() { try { useStatementInsert(); useStatementSelect(); useStatementUpdate(); useStatementSelect(); useStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void useStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) { System.out.println(resultSet.getObject(i)); } } } public void useStatementUpdate() throws SQLException { Statement statement = connection.createStatement(); String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; statement.executeUpdate(sql); } 这里对ResultSet使用的getMetaData,可以获取结果集的各种类型信息,包括字段的类型,个数,等等. (4)PreparedStatement PreparedStatement与Statement使用基本一样.调用的时候先使用Connection的prepareStatement(sql)创建,然后 对于select,使用executeQuery(),返回一个ResultSet 对于update,delete,insert使用executeUpdate(). public void usePrepareStatement() { try { usePrepareStatementInsert(); usePrepareStatementSelect(); usePrepareStatementUpdate(); usePrepareStatementSelect(); usePrepareStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void usePrepareStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet resultSet = preparedStatement.executeQuery(); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) System.out.println(resultSet.getObject(i)); } } public void usePrepareStatementUpdate() throws SQLException { String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } (5)事务 Connection有一个setAutoCommit()方法,把它设置成false即可关闭自动提交,所有语句准备好后,一次性使用commit()提交即可. 实现回滚可以配合SavePoint使用. 3.C3P0 (1)jar包 两个: c3p0 mchange-commons (2)配置文件 src下创建一个叫c3p0.properties的文件: c3p0.driverClass=com.mysql.cj.jdbc.Driver c3p0.jdbcUrl=jdbc:mysql://127.0.0.1:3306/db c3p0.user=aa c3p0.password=aa123bb 这里按自己需要更改即可. (3)工具类 import com.mchange.v2.c3p0.ComboPooledDataSource; import java.sql.Connection; public class DbUtil { private static ComboPooledDataSource C3P0dataSource = new ComboPooledDataSource(&quot;c3p0.properties&quot;); public static void releaseConnection(Connection connection) { try { if(connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getC3P0Connection() { try { return C3P0dataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } } 4.DBCP (1)jar包 三个: commons-dbcp commons-logging commons-pool (2)配置文件 src下新建dbcp.properties: driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/db username=aa password=k041400r initialSize=10 maxActive=50 maxIdle=15 minIdle=10 maxWait=60000 connectionProperties=useUnicode=true;characterEncoding=utf8 defaultAutoCommit=true 分别是驱动,url,用户名,密码,初始化连接数,最大连接数,最大空闲连接数,最小空闲连接数,最大等待实际,连接属性(这里设置了编码),自动提交. (3)工具类 import org.apache.commons.dbcp2.BasicDataSourceFactory; import java.io.InputStream; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; public class DbUtil { private static DataSource DBCPdataSource; static { try { InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); DBCPdataSource = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getDBCPConnection() { try { return DBCPdataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void releaseConnection(Connection connection) { try { if (connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 首先加载属性文件,再使用Properties的load方法将其加载到一个Properties对象中,最后交给BasicDataSourceFactory处理. 5.源码 包含了jar包,配置文件,sql文件与测试代码. github 码云 ","link":"https://2293736867.github.io/post/jdbcc3p0dbcp-ji-ben-shi-yong/"},{"title":"从0开始自制计算器!","content":"先看看效果吧: 很炫酷吧? 想不想要? 想要吧. 当然作者知道你们肯定想. 不然也不会点进来对不对. 好.进入正题. 1.概述 2.新建工程 2.界面 (1) 按键 a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 d.复制制作好的button,布好局 e.改内容 f.整体修改大小,同时加上间隔 (2) 输出框 a.添加QLineEdit b.调整好大小,设置好背景颜色 c.设置字体,只读,对齐 (3) 标题栏 a.新建Horizontal Layout b.添加细节 (4)整体处理 a.标题栏 b.调整整体大小,同时添加透明度 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 b.最小化与关闭 B.按键 a.移入与移出事件 b.单击事件 (2)键盘事件 A.添加阴影 B.添加输出 4.整体细节再处理 (1)淡入效果 (2)设置固定尺寸 (3)淡出效果 5.表达式处理 (1)判断 a.去除所有空格 b.分类判断 c.加0 (2)计算 a.calc辅助类 b.计算部分 c.测试 6.整合 (1)设置界面的调用进程,并获取输出结果 (2)修改一些细节地方 a.鼠标键盘修改事件 b.exe中设置数字的格式 c.设置错误提示 d.可以考虑把错误处理整合过来 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 (3) 打包库文件 (4) 生成单个exe (5) 测试 8.源码 9.参考链接 10.最后 1.概述 这个是仿照win10自带的计算器制作的简化版本.是用Qt做的,直接把整个表达式输入然后得出计算结果. 主要分为三部分.界面部分,事件处理部分与表达式处理部分. 界面部分就是看到的计算器,包括标题栏,中间的输出框,还有各个按键. 事件处理就是处理对应的鼠标与键盘事件. 表达式处理部分就是处理整个输入的字符串,返回计算的结果,当然这个还支持错误判断功能. 2.新建工程 选择Widgets Application. 起名字. 一般只需MinGW. 这里默认即可,名字可以随便改 2.界面 (1) 按键 按键的话,基本上按着改就可以了.改布局,改颜色,改字体,主要就是这三个. 首先先打开.ui文件: a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 这里给出作者的参考style: border:1px groove rgb(220,220,220); background-color:rgb(243,243,243); 字体: 这里按个人喜好调整即可. d.复制制作好的button,布好局 e.改内容 这里不仅把里面的字符改变,还要把相应的对象名也改变. 再细调每一个按键,包括大小,字体与颜色,使总体效果更好. 数字要注意有&quot;加粗&quot;效果,符号的话尽量&quot;精细&quot;一点. f.整体修改大小,同时加上间隔 调整好间隔.注意细节. 下面是win10自带的计算器: 看到间隔了没? 作者要的就是这种效果. 可以先运行看看. 两边的间隔的话一会配合widget的大小调整即可. (2) 输出框 输出框很简单,就是一个QLineEdit. a.添加QLineEdit b.调整好大小,设置好背景颜色 作者的qss: border:0px groove rgb(243,243,243); background-color:rgb(245,245,245); c.设置字体,只读,对齐 (3) 标题栏 标题栏其实也很简单,一个QBoxLayout a.新建Horizontal Layout b.添加细节 QLabel输入标题,两个QPushButton表示最小化与关闭,同时加入两个Spacer,让标题与左边空出一些距离. 其实就是模仿win10的标题栏的效果 这里就不做最大化了.因为涉及到按钮的重新排布问题,这个可以自己选择实现. (4)整体处理 a.标题栏 把上一步做的标题栏移到合适的位置,同时删除自带的QMenuBar,QToolBar,QStatusBar. b.调整整体大小,同时添加透明度 调整好后大概就那样,透明度这里选择了0.9. 真是完美啊! 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 首先把本来那个标题栏去掉. setWindowFlags(windowFlags() | Qt::FramelessWindowHint); 再在protected中加入鼠标监听函数: void mousePressEvent(QMouseEvent *); void mouseMoveEvent(QMouseEvent *); 私有成员中加入两个QPoint.分别表示当前窗口坐标与光标的坐标. QPoint mousePoint; QPoint windowPoint; 第一个函数是鼠标按下时触发的,根据event-&gt;button()判断是否是左键,是的话获取mouse坐标,在设置window坐标. 当触发第二个函数时,即先判断是否按住左键不放,使用MainWindow的move方法移动窗口. event-&gt;globalPos()获取坐标后减去原来光标的坐标得到window坐标的变化量,再用原坐标加上这个变化量. void MainWindow::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton) { mousePoint = event-&gt;globalPos(); windowPoint = frameGeometry().topLeft(); } } void MainWindow::mouseMoveEvent(QMouseEvent *event) { if(event-&gt;buttons() &amp; Qt::LeftButton) { move(windowPoint + event-&gt;globalPos() - mousePoint); } } b.最小化与关闭 这里以最小化为例,关闭也一样的,改一下函数调用即可. 在最小化按钮中右键选择Go to slot: 选择clicked() 添加一个最小化函数: 下面是关闭的函数: B.按键 按键的鼠标事件包括两个: 光标移入与移出事件,为按键添加阴影,加深颜色等 单击事件,在输出框中增减对应的字符 a.移入与移出事件 这里的实现方式是通过事件过滤器实现的.增加一个eventFilter()函数 bool eventFilter(QObject *,QEvent *); 首先通过event-&gt;type()判断事件类型,如果是光标悬停,再判断对应的各个对象增加阴影效果. addNumButtonEffet(): void MainWindow::addNumButtonEffect(QPushButton *button,QGraphicsDropShadowEffect *shadow) { shadow-&gt;setEnabled(true); button-&gt;setStyleSheet( &quot;border:1px groove rgb(220,220,220);&quot; &quot;background-color:rgb(193,193,193);&quot; ); } 这里QGraphicsDropShadowEffect *shadow事先初始化好了. 然后在添加事件过滤器: 这里可以对比一下有没有阴影的效果: 没有阴影: 加上阴影: 呃....这里可能是截图工具的问题,看不来多大的效果,但是直接在机器上看是有比较大的区别的,建议还是加上阴影. b.单击事件 单击事件就是单击了某个按键然后用户可以在输出框中看到对应的反应. 依次选择按键,右键Go to slot: 选择clicked() 然后添加处理函数,作者这里自己实现了一个添加文本与清除焦点的函数,添加文本就是对应按键被光标单击后添加到输出框,至于为什么要清除焦点.... 因为... 因为空格. 因为作者的&quot;良好&quot;习惯,习惯在运算符前后加上空格 单击后会把焦点保留在这个按钮上,键盘上敲空格默认会帮你&quot;按一次&quot;这个按钮,因此如果不清除焦点的话,在光标单击了某个按钮,比如7,按空格就会在输出框上输出7,光标单击了8后,按空格就会在输出框上输出8. 这里添加文本时还要注意默认的起提示作用的0. void MainWindow::appendText(const QString &amp;s) { if(ui-&gt;box-&gt;text() == &quot;0&quot;) ui-&gt;box-&gt;setText(s); else ui-&gt;box-&gt;setText(ui-&gt;box-&gt;text()+s); } void MainWindow::appendTextAndClearFocus(QPushButton *button, const QString &amp;s) { appendText(s); button-&gt;clearFocus(); } (2)键盘事件 键盘事件就是主要处理各个按键按下时的阴影与输出框添加输出. 键盘事件通过以下两个函数处理: void keyPressEvent(QKeyEvent *); void keyReleaseEvent(QKeyEvent *); 第一个是按键按下时触发的,第二个是松开按键触发的. A.添加阴影 在按键按下时添加上阴影与颜色加深效果. 通过event-&gt;key()依次判断各个键. 键位可以看这里 然后添加在keyRealeseEvent()中把对应的阴影去掉: void MainWindow::keyReleaseEvent(QKeyEvent *event) { switch (event-&gt;key()) { case Qt::Key_0: case Qt::Key_1: case Qt::Key_2: case Qt::Key_3: case Qt::Key_4: case Qt::Key_5: case Qt::Key_6: case Qt::Key_7: case Qt::Key_8: case Qt::Key_9: case Qt::Key_Plus: case Qt::Key_Minus: case Qt::Key_Asterisk: case Qt::Key_Slash: case Qt::Key_AsciiCircum: case Qt::Key_Percent: case Qt::Key_ParenLeft: case Qt::Key_ParenRight: case Qt::Key_BraceLeft: case Qt::Key_BraceRight: case Qt::Key_BracketLeft: case Qt::Key_BracketRight: case Qt::Key_Backspace: case Qt::Key_Space: case Qt::Key_Period: case Qt::Key_Escape: case Qt::Key_Equal: case Qt::Key_Return: removeNumButtonEffect(ui-&gt;num0,num0_shadow); removeNumButtonEffect(ui-&gt;num1,num1_shadow); removeNumButtonEffect(ui-&gt;num2,num2_shadow); removeNumButtonEffect(ui-&gt;num3,num3_shadow); removeNumButtonEffect(ui-&gt;num4,num4_shadow); removeNumButtonEffect(ui-&gt;num5,num5_shadow); removeNumButtonEffect(ui-&gt;num6,num6_shadow); removeNumButtonEffect(ui-&gt;num7,num7_shadow); removeNumButtonEffect(ui-&gt;num8,num8_shadow); removeNumButtonEffect(ui-&gt;num9,num9_shadow); removeSignButtonEffect(ui-&gt;plus,plus_shadow); removeSignButtonEffect(ui-&gt;minus,minus_shadow); removeSignButtonEffect(ui-&gt;mutiply,mutiply_shadow); removeSignButtonEffect(ui-&gt;divide,divide_shadow); removeSignButtonEffect(ui-&gt;pow,pow_shadow); removeSignButtonEffect(ui-&gt;percent,percent_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;backspace,backspace_shadow); removeSignButtonEffect(ui-&gt;blank,space_shadow); removeSignButtonEffect(ui-&gt;dot,dot_shadow); removeSignButtonEffect(ui-&gt;C,c_shadow); removeSignButtonEffect(ui-&gt;equal,equal_shadow); break; } } 这里之所以没有一个个按键去判断是因为有可能同时多个按键按下,然后同时松开后发现某个按键还存在阴影,因此统一当其中一个按键释放时去除所有按键的阴影. B.添加输出 在输出框中添加输出,调用一个函数即可: 4.整体细节再处理 (1)淡入效果 看看效果: 这里实际使用了Qt的动画,针对透明度改变的动画. void MainWindow::fadeIn(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0); changeOpacity-&gt;setEndValue(0.91); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); } 第一行表示改变的是透明度,第二三行设置起始值与结束值,接下来设置动画时间(单位ms),然后开始动画. (2)设置固定尺寸 这里可以不设置最大尺寸,但一定要设置最小尺寸. 设置这个实际上禁止了拖拽去改变大小. (3)淡出效果 淡出效果与淡入效果类似. 不同的时需要添加计时处理,不能直接在exit(0)前调用fadeOut()函数,因为动画会在另一个线程启动,所以需要在主线程休眠指定秒数,等待淡出效果完成后,主线程再调用exit(0); void MainWindow::fadeOut(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0.9); changeOpacity-&gt;setEndValue(0); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); QTime start = QTime::currentTime().addMSecs(2500); while(QTime::currentTime() &lt; start) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } 其中addMSecs()表示要延迟的秒数,while循环体中表示处理本线程的事件,其中100表示处理事件最多100ms就返回本语句. 这里就不放淡出效果的图片了. 5.表达式处理 由于这是整个字符串作为表达式进行输入,需要先进行判断再计算.所以分为判断与计算两部分. 这里使用了一个新开的控制台工程,后面会把这个整合起来. (1)判断 使用了一个check类判断,由于只有10个数字按键,加减乘除,小数点,求余,求次幂,大中小括号,空格,所以可以分成这几类进行判断. a.去除所有空格 void removeAllBlank(void) { size_t i = 0; while((i = s.find(' ',i)) != string::npos) s.erase(i,1); } 首先把所有空格去除,避免之后的判断. b.分类判断 把表达式中的所有字符分成5类: 数字 小数点 运算符号 + - * / ^ % 左括号类 ( [ { 右括号类 ) ] } 然后就是针对每个类型判断它的下一个字符是否是允许的类型,不是的话返回false. 比如碰上了一个 ( 或 [ 或 { 则它的下一个不能是运算符号或者小数点,当然允许-与+,因为有 (-7) (+234) 这种情况. 然后把这个符号保存下来判断后面是否是对应的右括号. if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } braces.push(s[i]); } 整个判断函数如下: bool valid(void) { if(isSignOrDot(0) || isRightBrace(0)) return false; len = s.size(); stack&lt;char&gt; braces; for(size_t i=0;i&lt;len;++i) { if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } if(isRightBrace(i+1)) return false; braces.push(s[i]); } else if(isRightBrace(i)) { if(isDot(i+1) || isDigit(i+1) || isLeftBrace(i+1)) return false; if(isRightBrace(i+1)) { stack&lt;char&gt; braces_copy(braces); if(braces_copy.empty()) return false; braces_copy.pop(); if(braces_copy.empty()) return false; } if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i] != ')') || (brace == '[' &amp;&amp; s[i] != ']') || (brace == '{' &amp;&amp; s[i] != '}')) return false; braces.pop(); } else if(isSign(i)) { if(isSign(i+1) || isDot(i+1) || isRightBrace(i+1)) return false; } else if(isDot(i)) { if(isSignOrDot(i+1) || isBrace(i+1)) return false; } else if(isDigit(i)) { if(isRightBrace(i+1)) { if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i+1] != ')') || (brace == '[' &amp;&amp; s[i+1] != ']') || (brace == '{' &amp;&amp; s[i+1] != '}')) return false; } } } return braces.empty(); } 特别要注意下的就是碰到右括号的情况,除了要判断是否是单独存在的右括号,还有判断是否与前一个左括号匹配. c.加0 这是针对单目运算符-的情况,比如(-7),然后把它转化为(0-7): string getResult(void) { size_t len = s.size(); for(size_t i = 0;i&lt;len;++i) { if(s[i] == '(' &amp;&amp; (s[i+1] == '-' || s[i+1] == '+')) s.insert(i+1,&quot;0&quot;); } return s; } 在左小括号后判断是否是-或+,是的话对应位置插入0. (2)计算 a.calc辅助类 calc辅助类中使用了两个栈,运算符栈与操作数栈. private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; 其中有两个重要的方法: bool canCalculate(char sign); void calculate(void); 第一个方法将下一个准备进入的符号作为参数,判断是否可以计算操作数栈的前两个数,如果可以的话,使用第二个函数进行计算. calculate()会将出栈两个操作数与一个运算符,得出结果后在将其压回操作数栈. void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } 下面是calc类: class calc { private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; char getSign(void) { return operators.top(); } double getNum(void) { return operands.top(); } void popSign(void) { operators.pop(); } void popNum(void) { operands.pop(); } double popAndGetNum(void) { double num = getNum(); popNum(); return num; } char popAndGetSign(void) { char sign = getSign(); popSign(); return sign; } public: void push(double num) { operands.push(num); } void push(char sign) { operators.push(sign); } char get(void) { return getSign(); } void pop(void) { popSign(); } double result(void) { return getNum(); } void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } bool empty(void) { return operators.empty(); } }; private封装了一些简单的对两个栈进行操作的工具方法,公有的pop()与get()是对运算符栈进行的操作.因为外部不需要对操作数栈进行操作,由calculate()进行操作,公有的push重载了,可以push到操作数栈或运算符栈. b.计算部分 计算部分在这里直接放在了main中: int main(void) { check chk; while(!chk.inputAndCheck()) cout&lt;&lt;&quot;Error!Please input again.\\n&quot;; string s = chk.getResult(); size_t len = s.size(); calc c; for(size_t i=0;i&lt;len;++i) { if(isdigit(s[i])) { double num; size_t i1 = i+1; while(i1 &lt; len &amp;&amp; (isdigit(s[i1]) || s[i1] == '.')) ++i1; istringstream input(s.substr(i,i1)); input&gt;&gt;num; i = i1-1; c.push(num); } else if(s[i] == '}' || s[i] == ']' || s[i] == ')') { char sign; char start = (s[i] == '}' ? '{' : ( s[i] == ']' ? '[' : '(')); while((sign = c.get()) != start) c.calculate(); c.pop(); } else //s[i] is [ ( { + - * / ^ % { while(c.canCalculate(s[i])) c.calculate(); c.push(s[i]); } } while(!c.empty()) c.calculate(); cout&lt;&lt;&quot;result is &quot;&lt;&lt;c.result()&lt;&lt;endl; return 0; } 对表达式的每个字符逐个处理,若是数字,提取出来并压栈. 若是右括号类,不断从运算符栈中提取直到把这段括号内的表达式计算完成. 否则若是左括号或者是运算符,当可以计算的时候一直计算,提取两个操作数运算并压栈,再把新的运算符压栈. 最后使用result()获取结果. c.测试 这里就显示几个很长的例子算了 当然作者测试了很多的例子 6.6/{2.3+34.3*2.22-5%2+22%4*[2+3.4/5-(4.3+3.2*33.3)]+34.3} + 7.8*{2.4-6/6+0-0*[23.4-3.4/6+4*(2.2+3)]}+0 - 0 + 0.0 = 10.8569 3.4 - (+3.34) + 34.3 * (-2) / 3.34 + {[(-3.4)^2/3.4+3.4/3]-3.32+[3*(-3)]} = -28.2656 9^5-34.4^2.3+5%6-34+66%78-78%4 + (-3)*3.4 / {3*(-7)+[3*(-8)+3*(3.4+4.34)/9.3-3.2 + 0.0 - 0]+0.0 - 0}+3.4^4/6.888 = 55683.2 不信的话可以手工计算一下. 6.整合 这部分把界面部分与表达式处理部分整合起来. (1)设置界面的调用进程,并获取输出结果 计算表达式的程序叫MyCalc.exe,注意把它放在对应的工程文件夹下面,然后使用QProcess调用. 使用execute执行,表达式先去除所有的空格,然后作为命令行参数传递给计算程序,然后计算程序把计算结果写入到result.txt文件,Qt读取这个文件,如果读到#表示表达式输入错误,否则,则是正确的计算结果. 对于结果因为在计算程序中设置了fixed格式,因此对于 1+2 也会返回 3.000000 这步把多余的0去掉,还要注意小数点的情况. (2)修改一些细节地方 a.鼠标键盘修改事件 修改setText的内容,把结果传递过去. b.exe中设置数字的格式 设置fixed格式,否则的话显示的是科学计数法,对小数位数有要求的话可以设置setprecision. c.设置错误提示 这里出现错误时,输出&quot;#&quot;,然后主程序读取到就会提示&quot;表达式错误,请重新输入.&quot; 还有除数为0的错误提示,这个要注意一下: d.可以考虑把错误处理整合过来 比如输入了一个点,不能继续输入点,输入了一个乘号或者除号不能再继续输入另一个符号: 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 把Qt文件夹下的如图所示的bin添加到Path环境变量, (3) 打包库文件 使用windeployqt打包,首先把程序调成release模式,运行一次,生成release的exe,然后把exe复制到一个单独的文件夹,再用命令行进入到这个文件夹,运行 windelpoyqt xxx.exe 这个命令把需要的dll复制到当前所在文件夹. (4) 生成单个exe 打开Enigma Virtual Box,选择 第一个选择release的exe,第二个选择打包之后的文件夹,然后选择添加文件,选择递归添加,添加上一步生成的所有文件(夹). 这里选择压缩文件. 然后选择压缩等待完成即可. (5) 测试 点击运行. 大功告成!! 8.源码 1.github(里面包含完整可执行的单个exe) 注:由于使用了lfs上传大文件,所以clone的时候请使用 git lfs clone 2.码云 9.参考链接 1.Qt淡入 2.Qt按键 3.Qt标题栏 4.事件过滤器 5.Qt鼠标事件 6.Qt延时处理 7.Qt文件读写 8.Qt打包成单文件 10.最后 这个简单的计算器有很大的改进空间,比如可以添加各种&quot;数&quot;: 正弦函数,余弦函数,正切函数,反正弦函数,指数函数,对数函数,高阶导数,抽象函数,复合函数.心里没数 等等.另外还可以改进矩形的按钮,可以改成圆角矩形或者椭圆形. 另外,对于阴影的处理可以添加淡入淡出效果. 最后就是磨砂.因为win10的是有磨砂效果的,这个作者还不会.... 最后再上几个图,看看效果(由于动图大小的限制只是简单的表达式...): 希望你们也有一个属于自己的计算器! ","link":"https://2293736867.github.io/post/cong-0-kai-shi-zi-zhi-ji-suan-qi/"},{"title":"Java多种文件复制方式以及效率比较","content":" 1.背景 2.概述 3.jar包 4.遍历 (1)listFiles() (2)list() (3)org.codehaus.plexus.util.FileUtils.getFiles (4)Commons.io工具包 (5)NIO--walkFileTree 5.复制 (1)FileInputStream+FileOutputStream A.read() B.read(b) C.read(b,off,len) (2)BufferedInputStream+BufferedOutputStream A.read(b) B.read(b,off,len) C.readAllBytes() (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)NIO--FileChannel (6)NIO--FileChannel+ByteBuffer (7)FileUtils.copyFile() (8)Files.copy() 6.其他 (1)swing布局 A.网格布局 B.居中 C.组件的添加与删除 (2)进度条 7.测试 (1)1G文件 (2)10G文件 (3)1G目录 (4)10G目录 8.源码 1.背景 java复制文件的方式其实有很多种,可以分为 传统的字节流读写复制FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStream 传统的字符流读写复制FileReader,FileWriter,BufferWriter,BufferedWriter,BufferedReader NIO系列的FileChannel FileChannel+缓冲 java.nio.Files.copy() 第三方包中的FileUtils.copy方法,比如org.apache.commons.io.FileUtils,org.codehaus.plexus.util.FileUtils等等. 所以呢,看看各种方法效率怎么样,主要衡量的标准就是时间,另外的一些标准包括大文件的复制时的内存溢出等问题. 2.概述 由于很多时候复制文件都包括了文件夹下的所有子目录及文件的复制,所以作者采用的遍历+复制方法去复制文件.就是把整个复制过程分为先遍历,遍历的过程中遇到文件夹就创建,遇到文件就调用不同的复制方法. 遍历的5种方法: (1)File.listFiles() (2)File.list() (3)org.codehaus.plexus.util.FileUtils.getFiles() (4)org.apache.commons.io.FileUtils.listFiles() (5)java nio中的java.nio.file.Files.walkFileTree 复制的8种方法: (1)FileInputStream+FileOutputStream (2)BufferedInputStream+BufferedOutputStream (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)FileChannel (6)FileChannel+buffer (7)org.apache.commons.io.FileUtils.copyFile() (8)java.nio.file.Files.copy() 另外作者不太想看控制台.....所以配合了一点swing使用. 3.jar包 1.org.apache.commons 2.org.codehaus.plexus 4.遍历 (1)listFiles() private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 通过srcFile的listFiles()获取所有的子文件与子文件夹,然后判断是否是目录 如果是目录,首先判断有没有这个文件(有时候本来是文件夹但是却存在同名的文件,就先删除),再创建文件夹,然后递归执行函数. 如果不是目录,直接把两个File作为参数进行文件复制,里面用什么方法后面会设置. (2)list() private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } list与第一种listFiles()类似,不过是String[],也是先判断目录,创建目录,不是目录直接复制 (3)org.codehaus.plexus.util.FileUtils.getFiles private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 这是用了别人的工具类进行遍历. org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); 返回的结果的java.util.List (4)Commons.io工具包 private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 使用org.apache.commons.io.FileUtils的listFiles方法，参数为要遍历的目录，一个null和一个false，第二个参数表示过滤器，表示过滤出特定后缀名的文件，类型为String [],第三个布尔参数表示是否递归访问子目录. (5)NIO--walkFileTree 利用FileVisitor这个接口.实际中常用SimpleFileVisitor. private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } FileVisitor接口定义了四个方法，分别为： public interface FileVisitor&lt;T&gt; { FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir前的操作，dir类型一般为java.nio.Path } FileVisitResult postVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir后的操作 } FileVisitResult visitFile(T file,BasicFileAttributes attrs) { //访问file时的操作 } FileVisitResult visitFileFailed(T file,BasicFileAttributes attrs) { //访问file失败时的操作 } } 在上面的例子中只是实现了visitFile，因为只是复制操作，首先判断是否是源目录的路径，不是的话创建文件夹再复制文件. 这里说一下返回值FileVisitResult.FileVisitResult是一个枚举类型，根据返回值判断是否继续遍历. FileVisitResult可取值: CONTINUE:继续 TERMINNATE:结束 SKIP_SIBLINGS:继续，跳过同一目录的节点 SKIP_SUBTREE:继续，跳过子目录，但会访问子文件 5.复制 (1)FileInputStream+FileOutputStream 首先是经典的字节流FileInputStream+FileOutputStream,这个比较简单,使用FileInputStream读取后使用FileOutputStream写入,不过效率嘛.....一般般. private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } 这里说一下三个read方法的区别,FileInputStream有三个read方法: input.read(); input.read(b); input.read(b,off,len); A.read() 逐个字节进行读取,返回int,写入时直接使用write(n); int n = input.read(); output.write(n); 这个可以说是三个read中最慢的....作者试了一个2G左右的文件,用了大概10分钟才复制160M...... B.read(b) 参数是一个byte [],将字节缓冲到其中,返回数组的字节个数,这个比read()快很多. byte [] b = new byte[1024]; while(input.read(b) != -1) output.write(b); C.read(b,off,len) 这个方法其实和read(b)差不多,read(b)相当于省略了参数的read(b,off,len). byte [] b = new byte[1024]; int n; while((n = input.read(b,0,1024))!=-1) output.write(b,0,n); public int read(byte b[], int off, int len) throws IOException { return readBytes(b, off, len); } public int read(byte b[]) throws IOException { return readBytes(b, 0, b.length); } 这两个都是调用一样的readBytes(): private native int readBytes(byte b[], int off, int len) throws IOException; 至于效率...可以看看结果(作者用的是10G内的小文件): 可以看到,没有哪个一定比另外一个更快(不过最后一个误差有点太大了?7G不够的文件.). 采用哪一个建议自己去测试,毕竟这存在很多误差,比如文件,java版本,机器本身等等,仅供参考. (2)BufferedInputStream+BufferedOutputStream 缓冲字节流BufferedInputStream+BufferedOutputStream,相比起FileInputStream,BufferedInputStream读取时会先从缓冲区读取数据,缓冲区无可读数据再从文件读取,所以会比FileInputStream快. private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } 这里也说一下BufferedInputStream的三个read(实际上还有,还有readN,与read(),read()肯定最慢,readN作者很少用,所以就没列出来了) read(b); read(b,off,len); readAllBytes(); A.read(b) 这个其实和FileInputStream的那个没啥区别,把一个字节数组仍进去就好了. B.read(b,off,len) 这个....也和FileInputStream那个没啥区别,不说了 C.readAllBytes() 这个一次可以读取所有的字节.不过用这个虽然省事,可以直接 output.write(input.readAllBytes()); 但是呢,有代价的: 会出现OutOfMemory错误,就是对于大文件还是老老实实分开吧,不要&quot;一口搞定&quot;,&quot;多吃几口&quot;. 看看效率: readAllBytes对于大文件(作者这个是5G内的文件)直接爆内存.... readAllBytes()又爆了.....这个才2G不到的文件...readAllBytes()看来不是很给力啊....不过对于小文件效率还可以接受. (3)FileReader+FileWriter 字符流读写FileReader+FileWriter,相比起字节流的read,基本上把byte[]换成char[]即可,因为是逐个字符读取,而字节流是逐个字节读取因此采用byte[]. 注意这个不能用来读取图片,音乐等文件,不然复制出来的文件打不开. private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (4)BufferedReader+BufferedWriter 缓冲字符流读写BufferedReader+BufferedWriter,BufferedReader相比起FileReader有一个readLine()方法,可以每行读入,会比FileReader快.对应的BufferedWriter提供了write(String)方法,当然也有write(String s,int off,int len).同样这个不能用来读取图片等. private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (5)NIO--FileChannel 通过FileChannel复制,首先通过FileInputStream与FileOutputStream打开流,再用getChannel()方法.最后使用transferTo()或transferFrom()进行复制,一条语句即可,十分方便,而且效率很高. private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } (6)NIO--FileChannel+ByteBuffer 在利用了FileInputStream与FileOutputStream打开了FileChannel的基础上,配合ByteBuffer使用. private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } flip的意思是&quot;翻转&quot;, buffer.flip(); 把Buffer从写模式变为读模式,接着write(buffer),再把buffer清空. 看看这两种方法效率: 另外作者发现transferTo的&quot;上限&quot;为2G,就是对于大于2G的单个文件最多最能复制2个G. 所以...对于大文件没有可比性了. (7)FileUtils.copyFile() 这是工具类,没啥好说的,参数是两个File,分别表示源与目标. private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } (8)Files.copy() 这是官方提供的Files工具类,前两个参数为Path,分别表示源与目标,可以设置第三个参数(或者省略),表示选项.例如可以设置 StandardCopyOption.REPLACE_EXISTING private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } 注意Files.copy会保持文件的隐藏属性,原来是隐藏的文件复制后也是隐藏的.以上7种则不会. 6.其他 (1)swing布局 A.网格布局 主JFrame采用了网格布局 setLayout(new GridLayout(3,1,5,3)); 三行一列，因为只要三个按钮，选择源文件(夹),选择目标文件夹,选择遍历方式. 选择遍历方式/复制方式的JFrame同样适用了网格布局: showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); B.居中 setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); 高400,宽400,利用ToolKit.getDefaultToolKit().getScreenSize()获取屏幕的高度和宽度实现居中. C.组件的添加与删除 由于在主JFrame中只有三个按钮,选择完遍历方式后需要更新这个组件,作者的做法是先删除这个组件在添加组件: traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); 设置它不可见再删除,再添加另一组件,再设置可见. (2)进度条 进度条这个东西把作者搞得很惨啊......其实就是新建一个线程就可以了. 核心代码为: new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); 作者的JProgressBar是直接添加在一个JFrame中的,不用什么太复杂的布局. 获取百分比后调用setValue(),一定要新建一个线程操作,不然不能正常显示进度条. 另外复制的操作建议使用SwingWorker. SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); 7.测试 说了那么多来点实际的. (以下所有的测试都是删除复制的文件后再进行新一次的复制.) (1)1G文件 1G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 20.189s 21.152s 18.249s 20.131s 21.782s BufferedInput/OuputStream 17.761s 23.786s 22.118s 19.646s 16.806s FileReader/Writer 61.334s 58.3s 58.904s 58.679s 55.762s BufferedReader/Writer 63.287s 59.546s 56.664s 58.212s 59.884s FileChannel 20.097s 22.272s 22.751s 22.765s 20.291s FileChannel+ByteBuffer 18.857s 22.489s 23.148s 22.337s 17.213s FileUtils.copyFile 25.398s 21.95s 22.808s 25.325s 22.483s Files.copy 16.272s 14.166s 17.057s 14.987s 10.653s 文件的话其实纵向比较即可,因为基本不用怎么遍历,横向比较可以勉强看作求平均值. 对于非文本文件,FileReader/Writer和BufferedReader/Writer没有太大的参考意义,比如复制视频文件是打不开的,而且复制出来的文件会变大.对于单文件Files.copy的性能非常好,java的nio果然厉害. (2)10G文件 10G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 171.427s 173.146s 172.611s 184.182s 250.251s BufferedInput/OuputStream 203.509s 174.792s 167.727s 177.451s 217.53s FileReader/Writer 187.55s 169.306s 226.571s 168.982s 218.303s BufferedReader/Writer 155.134s 165.883s 166.192s 176.488s 206.306s FileChannel 34.48s 35.445s 43.896s 41.827s 41.755s FileChannel+ByteBuffer 175.632s 167.091s 178.455s 182.977s 183.763s FileUtils.copyFile 203.997s 206.623s 201.01s 213.949s 208.739s Files.copy 209.898s 186.889s 244.355s 222.336s 244.68s 这个10G的文件是文本文件. 现在可以看看FileChannel的这一行,明显所花的时间要比其他要少,为什么呢? 因为文件大于2G.FileChannel的trasferTo方法只能写入最多2G的文件,所以对于大于2G的文件复制出来只有2G,因此FileChannel的这一行没有太大可比性.对于文本文件,BufferedReader/Writer的复制速度是最快的了,其次是FileInput/OutputStream.对于单个大文件,apache的FileUtils与NIO的Files.copy的速度比FileInputStream慢啊... (3)1G目录 1G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 23.549s 99.386s 143.388s 13.451s 10.773s BufferedInput/OuputStream 6.306s 59.458s 20.704s 6.668s 6.616s FileReader/Writer 49.059s 103.257s 51.995s 49.729s 51.509s BufferedReader/Writer 59.932s 127.359s 51.731s 51.418s 50.317s FileChannel 40.082s 71.713s 17.617s 15.782s 19.777s FileChannel+ByteBuffer 33.355s 83.845s 19.68s 10.288s 17.152s FileUtils.copyFile 24.163s 63.979s 8.277s 6.115s 19.513s Files.copy 14.528s 28.215s 6.578s 5.883s 7.502s 对于目录的话可以考虑放弃BufferedReader与FileReader了,除非全部是文本文件,否则推荐使用BufferedInput/OutputStream与Files.copy()进行复制,工具类FileUtils的复制方法表现还是不错的,但相比起java标准的Files.copy效率都差了. 对于FileChannel与配合缓冲使用的FileChannel,1G的话好像不相上下. 遍历方式的话...可以看到plexus的遍历方法表现差距很大,而apache的listFiles或者java nio的walkFileTree比较稳定且速度还可以,推荐使用这两种方式遍历目录. (4)10G目录 10G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 216.822s 228.792s 227.908s 240.042s 191.863s BufferedInput/OuputStream 218.599s 210.941s 207.375s 213.991s 167.614s FileReader/Writer 536.747s 550.755s 550.415s 548.881s 516.684s BufferedReader/Writer 587.612s 552.55s 549.716s 553.484s 498.18s FileChannel 115.126s 117.538s 117.456s 118.207s 97.626s FileChannel+ByteBuffer 225.887s 224.932s 222.077s 223.812s 180.177s FileUtils.copyFile 233.724s 230.199s 232.133s 223.286s 189.737s Files.copy 229.819s 227.562s 226.793s 226.78s 181.071s FileReader与BufferedReader这两行可以忽略了.对于小文件用FileChannel的话还是不错的,对于大文件一定要用FileChannel的话可以配合ByteBuffer使用,不过从数据上看效果比BufferedInput/OutputStream要低. 再看看org.apache.commons.io.FileUtils与java.nio.file.Files的copy,差别不太,效果接近,但在1G的时候差距有点大. 遍历方式的话,java nio的walkFileTrees最快. 当然这些测试仅供参考,具体使用哪一个要看看具体环境,另外这种方式把遍历与复制分开,apache的FileUtils有方法可以直接复制目录的,因此,使用哪个更合适还需要个人具体测试. 8.源码 作者比较偷懒全部仍在一个文件了.七百行. import java.awt.*; import javax.swing.*; import java.nio.*; import java.nio.channels.*; import java.io.*; import java.nio.file.*; import java.nio.file.attribute.*; import java.util.*; import org.apache.commons.io.*; public class Test extends JFrame { public static final long serialVersionUID = 12398129389122L; private JFrame showTraverseMethod = new JFrame(&quot;遍历方式&quot;); private JFrame showCopyMethod = new JFrame(&quot;复制方式&quot;); private JButton traverseMethodButton = new JButton(&quot;请选择遍历方式&quot;); private JButton copyMethodButton = new JButton(&quot;请选择复制方式&quot;); private JButton copyButton = new JButton(&quot;开始复制&quot;); private JButton traverseByListFiles = new JButton(&quot;File.listFiles()&quot;); private JButton traverseByList = new JButton(&quot;File.list()&quot;); private JButton traverseByGetFiles = new JButton(&quot;(plexus)getFiles()&quot;); private JButton traverseByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton traverseByNIO2 = new JButton(&quot;NIO2&quot;); private JButton copyByFileStream = new JButton(&quot;File stream&quot;); private JButton copyByBufferStream = new JButton(&quot;Buffer stream&quot;); private JButton copyByFileReader = new JButton(&quot;File reader&quot;); private JButton copyByBufferReader = new JButton(&quot;Buffer reader&quot;); private JButton copyByFileChannel = new JButton(&quot;File channel&quot;); private JButton copyByFileChannelWithBuffer = new JButton(&quot;File channel with buffer&quot;); private JButton copyByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton copyByFiles = new JButton(&quot;Files.copy&quot;); public Test() { JButton src = new JButton(&quot;选择源文件(夹)&quot;); src.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new Label(), &quot;选择文件(夹)&quot;); FilesCopy.setSrc(fileChooser.getSelectedFile()); } ); JButton des = new JButton(&quot;选择目标文件夹&quot;); des.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new JLabel(),&quot;选择文件夹&quot;); FilesCopy.setDes(fileChooser.getSelectedFile()); } ); traverseMethodButton.addActionListener( event -&gt; { traverseByListFiles.addActionListener( e-&gt; { FilesCopy.setTraverseByListFiles(); showTraverseMethod.dispose(); } ); traverseByList.addActionListener( e -&gt; { FilesCopy.setTraverseByList(); showTraverseMethod.dispose(); } ); traverseByGetFiles.addActionListener( e -&gt; { FilesCopy.setTraverseByGetfiles(); showTraverseMethod.dispose(); } ); traverseByCommonsIO.addActionListener( e -&gt; { FilesCopy.setTraverseByCommonsIO(); showTraverseMethod.dispose(); } ); traverseByNIO2.addActionListener( e -&gt; { FilesCopy.setTraverseByNIO2(); showTraverseMethod.dispose(); } ); showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showTraverseMethod.setTitle(&quot;遍历方式&quot;); showTraverseMethod.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showTraverseMethod.setVisible(true); showTraverseMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showTraverseMethod.add(traverseByListFiles); showTraverseMethod.add(traverseByList); showTraverseMethod.add(traverseByGetFiles); showTraverseMethod.add(traverseByCommonsIO); showTraverseMethod.add(traverseByNIO2); traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); } ); copyMethodButton.addActionListener( event -&gt; { copyByFileStream.addActionListener( e -&gt; { FilesCopy.setCopyByFileStream(); showCopyMethod.dispose(); } ); copyByBufferStream.addActionListener( e -&gt; { FilesCopy.setCopyByBufferStream(); showCopyMethod.dispose(); } ); copyByFileReader.addActionListener( e -&gt; { FilesCopy.setCopyByFileReader(); showCopyMethod.dispose(); } ); copyByBufferReader.addActionListener( e -&gt; { FilesCopy.setCopyByBufferReader(); showCopyMethod.dispose(); } ); copyByFileChannel.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannel(); showCopyMethod.dispose(); } ); copyByFileChannelWithBuffer.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannelWithBuffer(); showCopyMethod.dispose(); } ); copyByCommonsIO.addActionListener( e -&gt; { FilesCopy.setCopyByCommonsIO(); showCopyMethod.dispose(); } ); copyByFiles.addActionListener( e -&gt; { FilesCopy.setCopyByFiles(); showCopyMethod.dispose(); } ); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); showCopyMethod.setTitle(&quot;复制方式&quot;); showCopyMethod.setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showCopyMethod.setVisible(true); showCopyMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showCopyMethod.add(copyByFileStream); showCopyMethod.add(copyByBufferStream); showCopyMethod.add(copyByFileReader); showCopyMethod.add(copyByBufferReader); showCopyMethod.add(copyByFileChannel); showCopyMethod.add(copyByFileChannelWithBuffer); showCopyMethod.add(copyByCommonsIO); showCopyMethod.add(copyByFiles); copyMethodButton.setVisible(false); remove(copyMethodButton); add(copyButton); copyButton.setVisible(true); } ); copyButton.addActionListener( event -&gt; { if(FilesCopy.haveSelectedSrcAndDes()) { FilesCopy.copy(); copyButton.setVisible(false); remove(copyButton); add(traverseMethodButton); traverseMethodButton.setVisible(true); } else JOptionPane.showMessageDialog(null,&quot;请先选择源文件(夹)与目标文件夹!&quot;); } ); setLayout(new GridLayout(3,1,5,3)); setTitle(&quot;复制文件&quot;); setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); add(src); add(des); add(traverseMethodButton); } public static void main(String[] args) { new Test(); } } class FilesCopy { private static File src = null; private static File des = null; private static long desSize = 0; private static long srcSize = 0; private static boolean [] traverseMethod = {false,false,false,false,false,false}; private static boolean[] copyMethod = { false, false, false, false, false, false ,false,false}; private static JFrame showProgressBar = new JFrame(); private static JProgressBar copyProgressBar = new JProgressBar(); private static JTextField textField = new JTextField(); private static int index = 0; private static int getCopyPercent() { return (int)(desSize * 100.0 / srcSize); } private static void addCopySize() { desSize += 1024L; } public static void setTraverseByListFiles() { traverseMethod[0] = true; } private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByList() { traverseMethod[1] = true; } private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByGetfiles() { traverseMethod[2] = true; } private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByCommonsIO() { traverseMethod[3] = true; } private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByNIO2() { traverseMethod[4] = true; } private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } public static void setCopyByFileStream() { copyMethod[0] = true; } private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } public static void setCopyByBufferStream() { copyMethod[1] = true; } private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } public static void setCopyByFileReader() { copyMethod[2] = true; } private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByBufferReader() { copyMethod[3] = true; } private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByFileChannel() { copyMethod[4] = true; } private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } public static void setCopyByFileChannelWithBuffer() { copyMethod[5] = true; } private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } public static void setCopyByCommonsIO() { copyMethod[6] = true; } private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } public static void setCopyByFiles() { copyMethod[7] = true; } private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } public static void setSrc(File srcFile) { src = srcFile; if(srcFile.isDirectory()) srcSize = org.apache.commons.io.FileUtils.sizeOfDirectory(srcFile); else srcSize = src.length(); } public static void setDes(File desFile) { des = desFile; desSize = 0; } public static void setSrc(Path srcPath) { setSrc(srcPath.toFile()); } public static void setDes(Path desPath) { setDes(desPath.toFile()); } private static void copyFile(File srcFile,File desFile) throws IOException { if (copyMethod[0]) copyByFileStream(srcFile,desFile); else if (copyMethod[1]) copyByBufferStream(srcFile, desFile); else if (copyMethod[2]) copyByFileReader(srcFile, desFile); else if (copyMethod[3]) copyByBufferReader(srcFile, desFile); else if (copyMethod[4]) copyByFileChannel(srcFile, desFile); else if (copyMethod[5]) copyByFileChannelWithBuffer(srcFile, desFile); else if (copyMethod[6]) copyByCommonsIO(srcFile, desFile); else if (copyMethod[7]) copyByFiles(srcFile, desFile); else showMessage(&quot;复制失败,找不到复制方法.&quot;); } private static void showMessage(String message) { JOptionPane.showMessageDialog(null, message); } public static boolean haveSelectedSrcAndDes() { return src != null &amp;&amp; des != null; } public static void copy() { long start = System.currentTimeMillis(); if(haveSelectedSrcAndDes()) { if(src.isFile()) { des = new File(des.getAbsolutePath()+File.separator+src.getName()); } SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); if (!copyMethod[4] &amp;&amp; !copyMethod[6] &amp;&amp; !copyMethod[7]) { copyProgressBar.setMinimum(0); copyProgressBar.setMaximum(100); copyProgressBar.setValue(0); copyProgressBar.setVisible(true); copyProgressBar.setStringPainted(true); showProgressBar.add(copyProgressBar); showProgressBar.setTitle(&quot;复制进度&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 150, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 50, 300, 100); showProgressBar.setVisible(true); new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); } else { final String [] text = {&quot;.&quot;,&quot;..&quot;,&quot;...&quot;,&quot;....&quot;,&quot;.....&quot;,&quot;.......&quot;,&quot;......&quot;,&quot;.....&quot;,&quot;....&quot;,&quot;...&quot;,&quot;..&quot;,&quot;.&quot;}; textField.setVisible(true); textField.setHorizontalAlignment(JTextField.CENTER); textField.setEditable(false); showProgressBar.add(textField); showProgressBar.setTitle(&quot;复制中&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 120, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 40, 240, 80); showProgressBar.setVisible(true); new Thread( () -&gt; { while (getCopyPercent() &lt; 100) { try { Thread.sleep(400); } catch(InterruptedException e) { e.printStackTrace(); } if(index &lt; text.length) textField.setText(&quot;复制中&quot;+text[index++]); else index = 0; } } ).start(); } } } private static void finish(long start) { long end = System.currentTimeMillis(); showProgressBar.dispose(); showMessage(&quot;复制成功,用时:&quot; + (end - start) / 1000.0 + &quot;s&quot;); copyProgressBar.setVisible(false); showProgressBar.remove(copyProgressBar); textField.setVisible(false); showProgressBar.remove(textField); Arrays.fill(traverseMethod, false); Arrays.fill(copyMethod, false); des = src = null; desSize = srcSize; } } ","link":"https://2293736867.github.io/post/java-duo-chong-wen-jian-fu-zhi-fang-shi-yi-ji-xiao-lu-bi-jiao/"},{"title":"聊聊Java中final那点事","content":" 1.final是什么 2.final有什么用 3.final修饰成员变量 (1)修饰静态变量 (2)修饰普通成员变量 4.final修饰局部变量 (1)修饰形参 (2)修饰局部变量 (3)final修饰引用变量 5.final修饰方法 6.final修饰类 1.final是什么 final是一个java关键字,一个修饰符,可用于修饰变量,方法,修饰类. 2.final有什么用 final可以修饰变量时,可以使其值不能改变 final修饰方法时使其不能被重写 final修饰类时,使其不能被继承. 3.final修饰成员变量 fianl最常见的用法时用来修饰成员变量,成员变量分为静态变量与普通变量. 对于final修饰的变量,不是不能被赋值,是其值不能被改变,可以理解成只能赋一次值.可以在定义时赋值,也可以在定义后在另外赋值,但无论何种方式只能被赋值一次. (1)修饰静态变量 修饰静态变量时,可以选择以下两种方式赋值: 在定义时赋值 静态初始化块内赋值 final static int a = 6; final static int b; static { b = 6; } (2)修饰普通成员变量 修饰普通成员变量时,可以选择以下三种方式赋值: 定义时赋值 初始化块内赋值 构造方法赋值 public class test { int c = 1; int d; int e; { d = 2; } public test() { e = 3; } } 根据&quot;静态&quot;不能访问&quot;非静态&quot;规则,就是说静态的方法不能访问非静态成员,static初始化块不能初始化非静态成员,普通初始化块也不能初始化静态变量. 但是,有一个&quot;bug&quot;就是java允许通过方法访问final成员,因此...有趣的事情发生了. public class test { final int a; { System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } 以上这段代码会报错,因为java不允许final成员未初始化前访问. 把上面那一行出错的代码注释后...居然通过了编译?! public class test { final int a; { //System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } printA()中只是用方法包装了一下输出函数,居然就通过了编译...有没有兴趣看一下结果? emmmmmm....final&quot;默认值&quot;为0.....总之就不要想这些歪门邪道去在final初始化之前访问final变量了 ,在使用final变量前初始化,初始化,初始化,重要的事情说三遍. 4.final修饰局部变量 final修饰局部变量其实也分两种,一种是修饰形参,一种是修饰方法内部的局部变量 (1)修饰形参 没什么好说的...就是形参的值不能改变. public void f(final int a) { a = 3;//报错. } (2)修饰局部变量 修饰局部变量时可以定义时赋值,也可以在定义后在赋值(仅一次). public void f() { final int a = 3; final int b; b = 2; } (3)final修饰引用变量 嗯.....这个是一个特别一点的例子,Talk is cheap.上代码. import java.util.Arrays; public class test { public static void main(String[] args) { final int[] arr = {1,2,3}; arr[1] = 5; Arrays.stream(arr).forEach(System.out::print); System.out.println(); final A a = new A(); a.setA(9); System.out.println(a.getA()); } } class A { private int a = 3; public void setA(int a) { this.a = a; } public int getA() { return a; } } 为什么final数组可以赋值???fianl对象的值被改变了???看看结果: final数组居然被改变了??final对象的值也被改变了?? 其实呢,因为数组是引用类型,final修饰引用类型时,只能保证这个变量永远&quot;指向&quot;那一段内存空间,保存的仅仅是一个引用,但是那段内存空间的值是可以改变的.修饰对象时也是一样的道理. 5.final修饰方法 final修饰的方法不能被重写,当然,不能&quot;配合&quot;private&quot;使用&quot;,因为private把方法变成了私有,相当于对子类不可见,子类都不知道父类&quot;还有这玩意&quot;,就可以进行所谓的&quot;重写&quot;了. class A { private final void f(){} } class B extends A { public final void f(){}//没毛病 } 因为B类的f()是属于B类的,不是从A类继承过来的. 6.final修饰类 final修饰类时表示该类不能被继承. final class A{} class B extends A{}//出错 ","link":"https://2293736867.github.io/post/liao-liao-java-zhong-final-na-dian-shi/"},{"title":"Java自定义的getInstance()返回泛型","content":"1.背景 实际中经常使用getInstance()方法返回一个对象,对于工厂模式,传入对应的参数返回与之相对应的对象.但是,问题来了,返回的对象需要被强制转换,很麻烦. import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(&quot;test1&quot;); test2 t2 = factory.getInstance(&quot;test2&quot;); } } class factory { public static Object getInstance(String className) { try { return Class.forName(className).getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } 编译不通过,说类型不兼容. 因此加上强制类型转换,编译通过了. test1 t1 = (test1)factory.getInstance(&quot;test1&quot;); test2 t2 = (test2)factory.getInstance(&quot;test2&quot;); 2.如何处理 例子只有两个类,手动强制转换还可以,但如果多个类咋办啊?而且作者是那种非常懒的人,也不想手动去转换,因此,用大招-----泛型! 3.使用泛型 使用Class&lt;T&gt; 泛型可以避免强制转换从而更有效地偷懒 ,需要把返回类型改成&lt;T&gt; T,同时由于使用了T,必须修改传进来的参数. public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(test1.class); test2 t2 = factory.getInstance(test2.class); } } class factory { public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) { try { return t.getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } ","link":"https://2293736867.github.io/post/java-zi-ding-yi-de-getinstancefan-hui-fan-xing/"},{"title":"Java反射Array的使用","content":" 1.什么是Array 2.Array有什么用 3.Array使用示例 (1)创建 (2)赋值 (3)获取值 (4)强制类型转换 4.完整代码 5.运行结果 1.什么是Array Array是一个类的简写,全限定类名是java.lang.reflect.Array. 2.Array有什么用 Array可以代表所有的数组,可以通过Array动态创建与修改里面的元素. 3.Array使用示例 (1)创建 使用静态方法newInstance()构造Object对象.方法如下: public static Object newInstance(Class&lt;?&gt; element, int ... length); 第一个参数是代表元素的类,剩下的参数表示维数,一个参数表示一维数组,两个参数表示二维数组(数组的数组),参数的值代表维数的长度. Object intArray = Array.newInstance(int.class,3); //int [3] Object stringArray = Array.newInstance(String.class,2,3); //String [2][3] (2)赋值 赋值使用静态方法set即可,参数为Array返回的Object对象,下标与对应的值. public static void set(Object array,int index,Object value); public static void setBoolean(Object array,int index,boolean b); public static void setXxxx(Object array,int index,xxx); 其中最后一个表示对应的基本类型,第二个为boolean类型的示例. Array.set(intArray,2,3); Array.set(stringArray,1,new String[]{&quot;123&quot;,&quot;456&quot;}); (3)获取值 使用静态方法get,参数为Array返回的Object对象与下标. public static Object get(Object array,int index); public static boolean getBoolean(Object array,int index); public static xxx getXxx(Object array,int index); 最后一个表示对应的基本类型,第二个为boolean类型的示例 System.out.println(Array.get(intArray,2)); System.out.println(Array.get(Array.get(stringArray,1),1)); (4)强制类型转换 可以通过强制类型转换使Array返回的Object对象转换为对应的数组. var castIntArray = (int [])intArray; var castStringArray = (String [][])stringArray; 这样可以当作一个普通数组使用. 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { var intArray = Array.newInstance(int.class, 3); var stringArray = Array.newInstance(String.class, 2,3); Array.set(intArray, 2, 3); Array.set(stringArray, 1, new String[] { &quot;123&quot;, &quot;456&quot; }); System.out.println(Array.get(intArray, 2)); System.out.println(Array.get(Array.get(stringArray,1),1)); System.out.println(&quot;-------cast-------&quot;); System.out.println(((int[]) intArray)[2]); System.out.println(((String [][])stringArray)[1][1]); } } 5.运行结果 ","link":"https://2293736867.github.io/post/java-fan-she-array-de-shi-yong/"},{"title":"Log4j2入门hello world","content":" 1.什么是log4j2 (1)log4j (2)log4j2 3.VScode下使用log4j2(不用Maven) (1)准备jar包 (2)准备插件 (3)创建项目 (4)设置jar包路径 (5)新建测试文件 (6)运行 (7)创建配置文件使其输出更多信息 (8)再次运行 4.VScode下使用log4j2(带Maven) (1)创建maven项目 (2)在pom.xml配置依赖 (3)创建log4j2.xml (4)修改测试类 (5)测试 5.IDEA下使用log4j2(不用Maven) (1)创建项目 (2)添加jar包 (3)新建测试类 (4)新建log4j2.xml (5)测试 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 (2)配置依赖 (3)创建log4j2.xml (4)创建测试类 (5)测试 1.什么是log4j2 (1)log4j log4j是apache的一个开源项目,表示log for java.是一个日志工具,可以将日志信息输出到文件,控制台等其他地方 ,还可以定义日志的输出格式,另外还有日志级别的区分,可通过配置文件去配置输出格式,输出目的地等信息. (2)log4j2 log4j2从名字就知道了,是log4j的升级版本,性能有了很大提升,增加了很多新特性(如自定义级别,lambda表达式)与新的API,直接与tomcat等服务器集成. 3.VScode下使用log4j2(不用Maven) (1)准备jar包 点击这里下载 作者用的是win10,下载zip. (2)准备插件 搜索安装:Eclipse New Java Project (3)创建项目 ctrl+shift+p调出命令面板,输入new java project 项目名 JavaSE版本 创建完毕. (4)设置jar包路径 在项目根路径下新建lib文件夹,把下载的 这两个jar包放进去. 下一步设置.classpath. 添加 &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-api-2.12.1.jar&quot; /&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-core-2.12.1.jar&quot; /&gt; (5)新建测试文件 src下直接建立test.java test.java: import org.apache.logging.log4j.*; public class test { private final static Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (6)运行 点击main上的Run 结果: 输出了fatel与error信息. 另外还提示了没有找到log4j2配置文件,使用默认的配置文件,默认输出到控制台. (7)创建配置文件使其输出更多信息 src下创建log4j2.xml配置文件. log4j2的配置文件只能是.xml或.json或.jsn文件,默认会在classpath下寻找(在这里classpath相当于图中的src). 默认情况下系统选择配置文件的优先级如下: 1.classpath下名为 log4j-test.json 或者log4j-test.jsn文件 2.classpath下名为 log4j2-test.xml 3.classpath下名为 log4j.json 或者log4j.jsn文件 4.classpath下名为 log4j2.xml 这里使用log4j2. xml.log4j2.xml如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Logger三个主要的组件为 logger(记录器) appender(输出目的地) layout(布局,定义日志的格式) &lt;appenders&gt;了输出目的地,&lt;Console&gt;表示控制台,&lt;PatternLayout&gt;定义了布局,里面的布局表示时间格式(%d,HH:mm:ss.SSS),接着是日志线程名(%t),%-5表示最小长度为5左对齐,level表示输出日志级别. %logger表示输出logger名称. %m是%msg与%message的缩写,表示输出应用提供的与记录事件有关的信息. %n表示换行. &lt;loggers&gt;定义的logger与logger使用的appender.root为log默认的输出形式,如果一个类的没有明确loggers中的输出格式就会采用root的格式. (8)再次运行 没有之前的&quot;没有配置文件&quot;的提示了. 4.VScode下使用log4j2(带Maven) (1)创建maven项目 使用插件maven for java创建,命令面板(ctrl+shift+p)输入. 选择quickstart. 选择版本. 最后选择项目路径即可. 在控制台中vscode会下载相关文件,然后会提示以交互模式创建: 这里等一会就好了. 然后会提示输入一些值. ok. (2)在pom.xml配置依赖 在&lt;dependencies&gt;中添加如下代码: &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; 以下是完整的pom.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;/project&gt; 右键选择Update project configuration. (3)创建log4j2.xml 在java目录下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.App&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)修改测试类 修改默认的App.java. package com.example; import org.apache.logging.log4j.*; public class App { private static final Logger logger = LogManager.getLogger(App.class.getName()); public static void main( String[] args ) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 run即可. 5.IDEA下使用log4j2(不用Maven) (1)创建项目 什么也不用选,直接next. 勾选从模板创建项目. 选好路径与填好项目名即可. (2)添加jar包 选择刚才的lib目录,或者自己手动改成两个jar包(log4j-api-版本.jar,log4j-core-版本.jar). (3)新建测试类 项目结构如下: Main.java package com.test; import org.apache.logging.log4j.*; public class Main { private static final Logger logger = LogManager.getLogger(Main.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (4)新建log4j2.xml 在src下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.test.Main&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (5)测试 直接点击run按钮. 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 这里作者偷懒就直接在上面项目的基础上新建模块不新建项目了. 都不用选直接next. 填好GroupId与ArtifactId之后next. 最后选好位置. (2)配置依赖 pom.xml中加入: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下是完整的pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 右键选择同步pom.xml. 选择右下角弹出的提示中的Import Changes. (3)创建log4j2.xml 在target下的classes下创建log4j2.xml. log4j2.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)创建测试类 创建包与test.java. test.java package com.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class test { private static final Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 新建配置Application. 输入Main class与名字. run. 参考: 1.log4j2(1) 2.log4j2(2) 3.log4j2(3) 4.log4j2(4) 5.log4j2(5) ","link":"https://2293736867.github.io/post/log4j2-ru-men-hello-world/"},{"title":"Java通过ServerSocket与Socket实现通信","content":" 1.ServerSocket (1) (2) (3) 2.Socket (1) (2) (3) (4) 3.服务器端 4.客户端 5.运行结果 6.Socket设置超时 首先说一下ServerSocket与Socket. 1.ServerSocket ServerSocket是用来监听客户端Socket连接的类,如果没有连接会一直处于等待状态. ServetSocket有三个构造方法: (1) ServerSocket(int port); 这个使用指定的端口去创建ServerSocket,IP地址使用默认的本地IP地址. (2) ServetSocket(int port,int backlog); 除了端口外,还有一个用来改变队列长度参数的backlog,指定当服务器繁忙时,可以与之保持连接请求的客户端数量,默认为50. (3) ServetSocket(int port,int backlog,InetAddress ip); 这个使用指定的端口,backlog,ip地址去创建ServerSocket. (这里简单提一下InetAddress,InetAddress没有构造方法,只有两个静态方法获取InetAddress对象,分别是 getByName(String hostName); getByAddress(byte[] address); ) 2.Socket Socket一般用来连接到服务器,程序通过Socket发出网络请求或应答网络请求. Socket有三个构造方法: (1) Socket(InetAddress address,int port); 使用指定IP与指定端口构造Socket,对于本地地址,默认使用本地ip,对于本地端口则动态分配. (2) Socket(String address,int port); 与(1)一样,使用String表示远程ip. (3) Socket(InetAddress address,int port,InetAddress localAddr,int localPort); 创建指定了远程ip,远程端口,本地ip,本地端口的Socket. (4) Socket(String address,int port,InetAddress localAddr,int localPort) 与(2)类似,使用String表示远程ip,用InetAddress表示本地ip. 了解了ServerSocket与Socket后可以编写实现简单的通信了. 3.服务器端 import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(12345);//这个端口自己随意,建议1024以上未使用的端口. while(true) { Socket socket = serverSocket.accept();//一直等待来自客户端的请求. PrintStream printStream = new PrintStream(socket.getOutputStream());//创建输出流 printStream.println(&quot;Server message.&quot;); printStream.close(); socket.close(); } } } 说一下ServetSocket的accept()方法: Socket accept(); 没有参数,返回一个Socket,如果接收到客户端的一个Socket,则返回,否则一直处于等待状态,线程也被阻塞. 4.客户端 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetAddress; import java.net.Socket; public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(&quot;This message comes from server:&quot;+bufferedReader.readLine()); bufferedReader.close(); socket.close(); } } Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); 表示创建一个本地地址,端口为12345的Socket,创建好了后服务器的.accept()方法就会接收到这个Socket,并创建输出流输出相应信息,然后客户端从Socket获取输入流进行读取,读取到了来自服务器的信息. 5.运行结果 (由于作者的漂亮终端不知道什么原因坏了....只能让用VScode的默认终端了....) 先运行服务器端的代码: 服务器端这边因为accept()方法会一直阻塞直到客户端发送请求. 客户端这边一运行就收到了来自服务器端的信息. 6.Socket设置超时 可以为Socket设置超时设置,当Socket超过这个时间没有连接上时系统会认为连接失败. Socket socket = new Socket(&quot;127.0.0.1&quot;,12345); socket.setToTimeout(10000);//单位:ms,在这里是10s 但是未连接上之前无法创建Socket对象,并且Socket没有提供指定超时的构造方法,因此常见的做法是先创建一个无连接的Socket,再调用connect()方法连接. Socket socket = new Socket(); socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,12345),12345); connect()方法其实有两个重载方法,分别是 void connect(SocketAddress endpoint); void connect(SocketAddress endpoint,int timeout); 对于第一个connect()官方文档没有提及超时之类的,就是直接连接. 对于第二个connect,timeout指定的超时时间,单位为ms,设置为0则为无限期等待. 参考链接 1.socket ","link":"https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/"},{"title":"Java7与Java9中的try-finally关闭资源","content":"1.java7中的try 在java7之前,对于一些需要使用finally关闭资源的操作,会显得很臃肿. try { // } catch(Exception e) { // } finally { if(xxxx != null) { xxxx.close(); } } 在java7中引入了可以在try中直接声明需要关闭的资源的功能,在try后的圆括号直接定义一个或多个资源即可. try( var xxx = new xxx(); var xxx = new xxx(); ) { // } 但是这些类都需要实现了Closeable或AutoCloseable接口,实现其中的close(). 2.Closeable接口 Closeable接口是AutoCloseable的子接口,其中的close()抛出了IOException异常,实现接口时要注意抛出的异常需是IOException异常或IOException子类异常. 3.AutoCloseable接口 AutoCloseable接口中的close()抛出的异常是Exception,实现接口时可以抛出任何类型的异常. java7几乎把所有的&quot;资源类&quot;(包括文件IO的各种类,JDBC编程的Connection,Statement等接口)进行了改写,改写后的资源都实现了AutoCloseable或Closeable接口.(引自&lt;&lt;疯狂Java讲义&gt;&gt;(第5版) P381) 4.java9中的try java9不像java7一样在try中定义资源,只需要自动关闭的资源有final修饰即可.也就是说,可以不在try中声明,在try前声明且使用final修饰即可. final var xxx = new xxx(); final var xxx = new xxx(); try(xxx;xxx) { // } ","link":"https://2293736867.github.io/post/java7-yu-java9-zhong-de-try-finally-guan-bi-zi-yuan/"},{"title":"一文带你理解脏读,幻读,不可重复读与mysql的锁,事务隔离机制","content":" 1 ACID (1) A:原子性(Atomicity) (2) C:一致性(Consistency) (3) I:隔离性(Isolation) (4) D:持久性(Durability) 2 Mysql的锁 (1) S锁与X锁 Ⅰ.S锁 Ⅱ.X锁 (2) 乐观锁与悲观锁 Ⅰ.乐观锁 Ⅱ.悲观锁 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 (2) 幻读 (3) 不可重复读 (4) 第一类丢失更新 (5) 第二类丢失更新 5 封锁协议与隔离级别 (1) 一级封锁协议 a.引发脏读 b.引发幻读 c.引发不可重复读 (2) 二级封锁协议 Ⅰ.Read committed a.避免脏读 b.引发幻读 c.引发不可重复读 Ⅱ.Repeatable read a.避免脏读 b.避免不可重复读 c.引发幻读 (3) 三级封锁协议 a.避免脏读 b.避免幻读 c.避免不可重复读 6 两段锁协议 (1) 加锁 (2) 解锁 首先说一下数据库事务的四大特性 1 ACID 事务的四大特性是ACID(不是&quot;酸&quot;....) (1) A:原子性(Atomicity) 原子性指的是事务要么完全执行,要么完全不执行. (2) C:一致性(Consistency) 事务完成时,数据必须处于一致的状态.若事务执行途中出错,会回滚到之前的事务没有执行前的状态,这样数据就处于一致的状态.若事务出错后没有回滚,部分修改的内容写入到了数据库中,这时数据就是不一致的状态. (3) I:隔离性(Isolation) 同时处理多个事务时,一个事务的执行不能被另一个事务所干扰,事务的内部操作与其他并发事务隔离. (4) D:持久性(Durability) 事务提交后,对数据的修改是永久性的. 2 Mysql的锁 Mysql的锁其实可以按很多种形式分类: 按加锁机制分,可分为乐观锁与悲观锁. 按兼容性来分,可分为X锁与S锁. 按锁粒度分,可分为表锁,行锁,页锁. 按锁模式分,可分为记录锁,gap锁,next-key锁,意向锁,插入意向锁. 这里主要讨论S锁,X锁,乐观锁与悲观锁. (1) S锁与X锁 S锁与X锁是InnoDB引擎实现的两种标准行锁机制.查看默认引擎可使用 show variables like '%storage_engine%'; 作者的mysql版本为8.0.17,结果如下: 先建好测试库与测试表,很简单,表就两个字段. create database test; use test; create table a ( id int primary key auto_increment, money int ); Ⅰ.S锁 S锁也叫共享锁,读锁,数据只能被读取不能被修改. 玩一下,上锁! lock table a read; 然后..... 只能读不能改,删,也不能增. Ⅱ.X锁 X锁也叫排他锁,写锁,一个事务对表加锁后,其他事务就不能对其进行加锁与增删查改操作. 设置手动提交,开启事务,上X锁. set autocmmmit=0; start transaction; lock table a write; 在开启另一个事务,使用select语句. set autocommit=0; start transaction; select * from a; 这里是阻塞select操作,因为一直都没释放X锁. 同样也不能再加锁,也是阻塞中. 回到原来那个加锁的事务,嗯,什么事也没有,正常读写. 释放锁后: unlock table; 在另一个事务中可以看到中断时间. (2) 乐观锁与悲观锁 Ⅰ.乐观锁 乐观锁就是总是假设是最好的情况,每次去操作的时候都不会上锁,但在更新时会判断有没有其他操作去更新这个数据,是一种宽松的加锁机制. mysql本身没有提供乐观锁的支持,需要自己来实现,常用的方法有版本控制和时间戳控制两种. 版本控制 版本控制就是为表增加一个version字段,读取数据时连同这个version字段一起读出来,之后进行更新操作,版本号加1,再将提交的数据的版本号与数据库中的版本号进行比较,若提交的数据的版本号大于数据库中的版本号才会进行更新. 举个例子,假设此时version=1,A进行操作,更新数据后version=2,与此同时B也进行操作,更新数据后version=2,A先完成操作,率先将数据库中的version设置为2,此时B提交,B的version与数据库中的version一样,不接受B的提交. 时间戳控制 时间戳控制与版本控制差不多,把version字段改为timestamp字段 还有一种实现方法叫CAS算法,这个作者不怎么了解,有兴趣可以自行搜索. Ⅱ.悲观锁 悲观锁就是总是假设最坏的情况,在整个数据处理状态中数据处于锁定状态,悲观锁的实现往往依靠数据库的锁机制.每次在拿到数据前都会上锁. mysql在调用一些语句时会上悲观锁,如(先关闭自动提交,开启事务): set autocommit=0; start transaction; 两个事务都这样操作,然后其中一个事务输入: select * from a where xxx for update; 在另一事务也这样输入: 这时语句会被阻塞,直到上锁的那个事务commit(解开悲观锁). 在另一事务中可以看到这个事务被阻塞了2.81s. *** lock in share mode. 也会加上悲观锁. 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 脏读是指一个事务读取到了另一事务未提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据,但没有提交,此时事务B却读取了,这时事务B就形成了脏读,一般事务A的后续操作是回滚,事务B读取到了临时数值. 事务A 事务B 开始事务 开始事务 更新X,旧值X=1,新值X=2 读取X,X=2(脏读) 回滚X=1 结束事务(X=1) 结束事务 (2) 幻读 幻读是指并不是指同一个事务执行两次相同的select语句得到的结果不同, 而是指select时不存在某记录,但准备插入时发现此记录已存在,无法插入,这就产生了幻读. 事务A 事务B 开始事务 开始事务 select某个数据为空,准备插入一个新数据 插入一个新数据 提交,结束事务 插入数据,发现插入失败,由于事务B已插入相同数据 结束事务 (3) 不可重复读 不可重复读指一个事务读取到了另一事务已提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据并且提交了,此时事务B却读取了,这时事务B就形成了不可重复读. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交,结束事务 读取X=2 结束事务 (4) 第一类丢失更新 第一类丢失更新就是两个事务同时更新一个数据,一个事务更新完毕并提交后,另一个事务回滚,造成提交的更新丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 修改X=2 修改X=3 提交,结束事务 回滚 结束事务(X=1) X=1,X本应为提交的3 (5) 第二类丢失更新 第二类丢失更新就是两个事务同时更新一个数据,先更新的事务提交的数据会被后更新的事务提交的数据覆盖,即先更新的事务提交的数据丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交事务,X=2,结束 更新X=3 提交事务,X=3,事务A的更新丢失,结束 5 封锁协议与隔离级别 封锁协议就是在用X锁或S锁时制定的一些规则,比如锁的持续时间,锁的加锁时间等.不同的封锁协议对应不同的隔离级别.事务的隔离级别一共有4种,由低到高分别是Read uncommitted,Read committed,Repeatable read,Serializable,分别对应的相应的封锁协议等级. (1) 一级封锁协议 一级封锁协议对应的是Read uncommitted隔离级别,Read uncommitted,读未提交,一个事务可以读取另一个事务未提交的数据,这是最低的级别.一级封锁协议本质上是在事务修改数据之前加上X锁,直到事务结束后才释放,事务结束包括正常结束(commit)与非正常结束(rollback). 一级封锁协议不会造成更新丢失,但可能引发脏读,幻读,不可重复读. 设置手动提交与事务隔离等级为read uncommited,并开启事务(注意要先设置事务等级再开启事务). set autocommit=0; set session transaction isolation level read uncommitted; start transaction; (中间有一行打多了一个t可以忽略.....) a.引发脏读 在一个事务中修改表中的值,不提交,另一个事务可以select到未提交的值. 出现了脏读. b.引发幻读 在一个事务中插入一条数据,提交. 另一事务中select时没有,准备insert,但是insert时却提示已经存在.引发幻读. c.引发不可重复读 未操作提交前: 另一事务修改并提交: 再次读: 引发不可重复读. (2) 二级封锁协议 二级封锁协议本质上在一级协议的基础上(在修改数据时加X锁),在读数据时加上S锁,读完后立即释放S锁,可以避免脏读.但有可能出现不可重复读与幻读.二级封锁协议对应的是Read committed与Repeatable Read隔离级别. 先设置隔离等级 set session transaction isolation level read committed; Ⅰ.Read committed Read committed,读提交,读提交可以避免脏读,但可能出现幻读与不可重复读. a.避免脏读 开启一个事务并更新值,在这个事务中money=100(更新后) 另一事务中money为未更新前的值,这就避免了脏读. 注意,事实上脏读在read committed隔离级别下是不被允许的,但是mysql不会阻塞查询,而是返回未修改之前数据的备份,这种机制叫MVCC机制(多版本并发控制). b.引发幻读 在一个事务中插入数据并提交. 另一事务中不能插入&quot;不存在&quot;的数据,出现幻读. c.引发不可重复读 事务修改并提交前: 事务修改并提交: 出现不可重复读. Ⅱ.Repeatable read Repeatable read比Read committed严格一点,是Mysql的默认级别,读取过程更多地受到MVCC影响,可防止不可重复读与脏读,但仍有可能出现幻读. a.避免脏读 在一个事务中修改数据,不提交. 另一事务中两次select的结果都不变,没有出现脏读. b.避免不可重复读 一个事务修改数据并提交. 另一事务中select的结果没有发生改变,即没有出现不可重复读. c.引发幻读 同理,一个事务插入一条数据并提交. 另一个事务插入时出现幻读. (3) 三级封锁协议 三级封锁协议,在一级封锁协议的基础上(修改时加X锁),读数据时加上S锁(与二级类似),但是直到事务结束后才释放S锁,可以避免幻读,脏读与不可重复读.三级封锁协议对应的隔离级别是Serializable. 先设置Serializable隔离级别 set session transaction isolation level serializable a.避免脏读 设置事务隔离等级后开启事务并update,发现堵塞.从而避免了脏读. b.避免幻读 插入时直接阻塞,避免了幻读. c.避免不可重复读 在脏读的例子中可以知道,update会被堵塞,都不能提交事务,因此也避免了不可重复读. 6 两段锁协议 事务必须分为两个阶段对数据进行加锁与解锁,两端锁协议叫2PL(不是2PC),所有的加锁都在解锁之前进行. (1) 加锁 加锁会在更新或者 select *** for update *** lock in share mode 时进行 (2) 解锁 解锁在事务结束时进行,事务结束包括rollback与commit. 参考链接 1:ACID1 2:ACID2 3:mysql的锁1 4:乐观锁与悲观锁1 5:乐观锁与悲观锁2 6:乐观锁与悲观锁3 7:mysql修改事务隔离等级 8:mysql三级封锁与二段锁 9:数据库封锁协议 10:mysql事务隔离机制1 11:mysql事务隔离机制2 12:mysql幻读 13:mysql脏读,不可重复读与幻读 14:mysql两段锁1 15:mysql两段锁2 ","link":"https://2293736867.github.io/post/yi-wen-dai-ni-li-jie-zang-du-huan-du-bu-ke-chong-fu-du-yu-mysql-de-suo-shi-wu-ge-chi-ji-zhi/"},{"title":"Android通过Web与后台数据库交互","content":" 2020.06.23 更新 1 背景 2 开发环境 3 准备环境 3.1 安装MySQL 3.1.1 下载并安装mysql 3.1.2 启动服务并查看初始化密码 3.1.3 修改密码 3.1.4 允许外部访问 3.1.5 配置防火墙(可选) 3.2 安装Tomcat 3.2.1 下载并上传到服务器 3.2.2 解压 3.2.3 修改默认端口(可选) 3.2.4 启动 3.2.5 测试 3.2.6 开机启动(可选) 4 建库建表 4.1 创建user.sql 4.2 导入到数据库 5 后端部分 5.1 创建项目 5.2 添加依赖库 5.3 创建包与类 5.4 DBUtils 5.5 User 5.6 UserDao 5.7 SignIn与SignUp 5.8 添加servlet到web.xml 5.9 Hello.html测试文件 6 打包发布 6.1 Project Structure-&gt;Artifacts-&gt;Web Application:Archive 6.2 创建目录并添加模块 6.3 添加依赖库与其他文件 6.4 打包 6.5 上传测试 7 Android端 7.1 新建工程 7.2 MainActivity.java 7.3 UserService.java 7.4 activity_main.xml 8 测试 8.1 注册测试 8.2 登录测试 9 注意事项 9.1 数据库用户名与密码 9.2 网络权限问题 9.3 防火墙问题 9.4 HTTP注意事项 9.5 线程问题 9.6 AVD问题 10 源码与JAR包 10.1 JAR包 10.2 源码 11 最后 12 参考网站 2020.06.23 更新 1 背景 开发一个app与后台数据库交互,基于MySQL+原生JDBC+Tomcat,没有使用DBUtils或JDBC框架,纯粹底层jdbc实现. 以后逐步改用Spring框架,优化MySQL,进一步部署Tomcat等等,现在项目刚刚起步,还有很多不懂的东西,得慢慢来...... 这几天踩了很多坑,说得夸张点真是踩到笔者没有知觉,希望能帮助别人少踩坑... 2 开发环境 本地Win 服务器CentOS 7 Android Studio 3.5.1 IntelliJ IDEA 2019.02 MySQL 8.0.17 Tomcat 9.0.26 3 准备环境 说一下MySQL与Tomcat的安装. 3.1 安装MySQL 这个是目前比较新的MySQL版本. 服务器系统是CentOS. 其他系统安装看这里: Win10 Ubuntu Fedroa ReaHat CentOS使用yum命令安装: 3.1.1 下载并安装mysql sudo yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm sudo yum install mysql-community-server 3.1.2 启动服务并查看初始化密码 sudo service mysqld start sudo grep 'temporary password' /var/log/mysqld.log 3.1.3 修改密码 首先使用root登录: mysql -u root -p 输入上一步看到的密码,接着使用alter修改密码: alter mysql.user 'root'@'localhost' identified by 'password'; 注意新版本的MySQL不能使用太弱的密码. 如果出现如下提示: 则说明密码太弱了,请使用一个更高强度的密码. 3.1.4 允许外部访问 use mysql; update user set host='%' where user='root'; 这个可以根据自己的需要去修改,host='%'表明允许所有的ip登录,也可以设置特定的ip,若使用host='%'的话建议新建一个用户配置相应的权限. 3.1.5 配置防火墙(可选) 一般来说需要在对应的云厂商的防火墙配置中开启响应端口,如图: 其中授权对象可以根据自己的需要更改,0.0.0.0/0表示允许所有的ip. 3.2 安装Tomcat 3.2.1 下载并上传到服务器 先去官网下载,下载后上传文件到服务器: 笔者使用的是scp命令,使用不熟练的可以戳这里看看 scp apache-tomcat-xxxx.tar.gz username@xx.xx.xx.xx:/ 改成自己的用户名和ip. 3.2.2 解压 ssh连接到服务器,接着移动到/usr/local并解压: mkdir /usr/local/tomcat mv apache-tomcat-xxxx.tar.gz /usr/local/tomcat tar -xzvf apache-tomcat-xxx.tar.gz 3.2.3 修改默认端口(可选) 修改conf/server.xml文件,一般只需修改 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 中的8080端口,修改这个端口即可. 需要的话自行更改. 笔者这么懒的是不会更改的. 3.2.4 启动 运行bin目录下的startup.sh: cd bin ./startup.sh 3.2.5 测试 浏览器输入: 服务器IP:端口 若出现: 则表示成功. 3.2.6 开机启动(可选) 建议配置开机启动,修改/etc/rc.local文件,添加: sh /usr/local/tomcat/bin/startup.sh 这个根据自己的Tomcat安装路径修改,指定bin下的startup.sh即可. 4 建库建表 创建用户表,这里简化操作(好吧笔者就是喜欢偷懒)就不创建新用户不授权了. 这是一个在本地用root登录的示例,请根据实际情况创建并授权用户. 4.1 创建user.sql CREATE DATABASE userinfo; USE userinfo; CREATE TABLE user ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NULL, password CHAR(30) NULL ); 4.2 导入到数据库 mysql -u root -p &lt; user.sql 5 后端部分 5.1 创建项目 选择Web Application: 5.2 添加依赖库 创建一个叫lib的目录: 添加两个jar包(jar包在文末提供下载链接): mysql-connector-java-8.0.17.jar javax.servlet-api-4.0.1.jar 打开Project Structure: Modules --&gt; + --&gt; JARs or directories: 选择刚才新建的lib下的两个jar包: 打勾,apply: 5.3 创建包与类 总共4个包 com.servlet:用于处理来自前端的请求,包含SignUp.java,SignIn.java com.util:主要功能是数据库连接,包含DBUtils.java com.entity:实体类,包含User.java com.dao:操作用户类的类,包含UserDao.java 5.4 DBUtils 连接数据库的类,纯粹的底层jdbc实现,注意驱动版本. public class DBUtils { private static Connection connection = null; public static Connection getConnection() { try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; connection = DriverManager.getConnection(url,usename,password); } catch (Exception e) { e.printStackTrace(); return null; } return connection; } public static void closeConnection() { if(connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 主要就是获取连接与关闭连接两个函数. String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; 这几行根据自己的用户名,密码,服务器ip和库名修改. 注意,MySQL 8.0以上使用的注册驱动的语句是: Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 旧版的是: Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 5.5 User User类比较简单,就是就三个字段与getter,setter: public class User { private int id; private String name; private String password; //三个getter与三个setter //... } 5.6 UserDao public class UserDao { public boolean query(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;select * from user where name = ? and password = ?&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); ResultSet resultSet = preparedStatement.executeQuery(); return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } public boolean add(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;insert into user(name,password) values(?,?)&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } } 主要就是查询与添加操作,查询操作中存在该用户就返回true,否则返回false 添加操作中使用executeUpdate()与getUpdateCount() != 0.注意不能直接使用 return preparedStatement.execute(); 去代替 preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; 咋一看好像没有什么问题,那天晚上笔者测试的时候问题可大了,android那边显示注册失败,但是数据库这边的却insert进去了.........这..... 好吧说多了都是泪,还是函数用得不够熟练. 一般来说select使用executeQuery(),executeQuery()返回ResultSet,表示结果集,保存了select语句的执行结果,配合next()使用 delete,insert,update使用executeUpdate(),executeUpdate()返回的是一个整数,表示受影响的行数,即delete,insert,update修改的行数,对于drop,create操作返回0 create,drop使用execute(),execute()的返回值是这样的: 如果第一个结果是ResultSet对象,则返回true 如果第一个结果是更新计数或者没有结果则返回false 所以在这个例子中 return preparedStatement.execute(); 肯定返回false,所以才会数据库这边insert进去,但前端显示注册失败(这个bug笔者找了是真的久......) 5.7 SignIn与SignUp servlet包的SingIn类用于处理登录,调用JDBC查看数据库是否有对应的用户. SignUp类用于处理注册,把User添加到数据库中. 目前使用的是HTTP连接,后期会考虑添加HTTPS支持. SignIn.java如下: @WebServlet(&quot;/SignIn&quot;) public class SingIn extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException, ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.query(user))//若查询失败 { httpServletResponse.sendError(204,&quot;query failed.&quot;);//设置204错误码与出错信息 } } } @WebServlet(&quot;/SignIn&quot;) 首先是@WebServlet注解,表示这是一个名字叫SignIn的servlet,可用于实现servlet与url的映射,如果不在这里添加这个注解,则需要在WEB-INF目录下的web.xml添加一个&lt;servlet-mapping&gt;,也就是叫servlet的映射. 接着设置响应类型与编码: httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 HttpServletRequest.getParameter(String name)方法表示根据name获取相应的参数: String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); 下面是SignUp.java: @WebServlet(&quot;/SignUp&quot;) public class SignUp extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//设定编码防止中文乱码 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;);//根据name获取参数 String password = httpServletRequest.getParameter(&quot;password&quot;);//根据password获取参数 UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.add(user)) //若添加失败 { httpServletResponse.sendError(204,&quot;add failed.&quot;);//设置204错误码与出错信息 } } } 5.8 添加servlet到web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SingIn&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignUp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SignUp&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;/web-app&gt; 要把刚才创建的Servlet添加进web.xml,在&lt;servlet&gt;中添加子元素&lt;servlet-name&gt;与&lt;servlet-class&gt;: &lt;servlet-name&gt;是Servlet的名字,最好与类名一致 &lt;servlet-class&gt;是Servlet类的位置 如果在Servlet类中没有添加@WebServlet(&quot;/xxxx&quot;)注解,则需要在web.xml中添加: &lt;servlet-mapping&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;url-pattern&gt;/SignIn&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中&lt;servlet-name&gt;与&lt;servlet&gt;中的子元素&lt;servlet-name&gt;中的值一致,&lt;url-pattern&gt;是访问的路径. 5.9 Hello.html测试文件 最后添加一个叫Hello.html的HTML测试文件. &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello web. &lt;/body&gt; &lt;/html&gt; 6 打包发布 笔者用的IDEA,Eclipse的打包请看这里. 6.1 Project Structure-&gt;Artifacts-&gt;Web Application:Archive 6.2 创建目录并添加模块 修改名字,并创建WEB-INF目录与子目录classes: 选中classes,添加Module Output,选择自己的web项目: 6.3 添加依赖库与其他文件 添加JAR包,选中lib目录后添加JAR包文件: (lib文件夹被挡住了不要在意细节哈...) 接着添加Hello.html与web.xml,web.xml需要在WEB-INF目录里,Hello.html在WEB-INF外面: 6.4 打包 Build-&gt;Build Artifacts: 6.5 上传测试 打包好的.war文件上传到服务器的Tomcat的webapps目录下: scp ***.war username@xxx.xxx.xxx.xxx:/usr/local/tomcat/webapps 注意改成自己的webapps目录. Tomcat启动后,在浏览器输入 服务器IP:端口/项目/Hello.html 笔者为了方便就在本地测试了: 7 Android端 7.1 新建工程 7.2 MainActivity.java public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button signin = (Button) findViewById(R.id.signin); signin.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signIn(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); Button signup = (Button) findViewById(R.id.signup); signup.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signUp(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); } } 没什么好说的,就为两个Button绑定事件,然后设置两个Toast提示信息. 7.3 UserService.java public class UserService { public static boolean signIn(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机内网IP:8080/cx/SignIn&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } public static boolean signUp(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机内网IP:8080/cx/SignUp&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } } class MyThread extends Thread { private String path; private String name; private String password; private boolean result = false; public MyThread(String path,String name,String password) { this.path = path; this.name = name; this.password = password; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000);//设置连接超时时间 httpURLConnection.setReadTimeout(8000);//设置读取超时时间 httpURLConnection.setRequestMethod(&quot;POST&quot;);//设置请求方法,post String data = &quot;name=&quot; + URLEncoder.encode(name, &quot;utf-8&quot;) + &quot;&amp;password=&quot; + URLEncoder.encode(password, &quot;utf-8&quot;);//设置数据 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//设置响应类型 httpURLConnection.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;);//设置内容长度 httpURLConnection.setDoOutput(true);//允许输出 OutputStream outputStream = httpURLConnection.getOutputStream(); outputStream.write(data.getBytes(&quot;utf-8&quot;));//写入数据 result = (httpURLConnection.getResponseCode() == 200); } catch (Exception e) { e.printStackTrace(); } } public boolean getResult() { return result; } } MyThread myThread = new MyThread(&quot;http://内网IP:8080/cx/SignUp&quot;,name,password); MyThread myThread = new MyThread(&quot;http://内网IP:8080/cx/SignIn&quot;,name,password); 这两行换成自己的ip,内网ip的话可以用ipconfig或ifconfig查看,修改了默认端口的话也把端口一起改了. 路径的话就是: 端口/web项目名/Servlet名 web项目名是再打成war包时设置的,Servlet名在web.xml中的&lt;servlet&gt;的子元素&lt;servlet-name&gt;设置,与源码中的@WebServlet()注解一致. 另外一个要注意的就是线程问题,需要新开一个线程进行http的连接. 7.4 activity_main.xml 前端页面部分很简单,就两个button,用于验证功能. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;用户名&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etname&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;密码&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etpassword&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;注册&quot; android:id=&quot;@+id/signup&quot; /&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;登录&quot; android:id=&quot;@+id/signin&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 8 测试 8.1 注册测试 随便输入用户名与密码 查看数据库: 8.2 登录测试 9 注意事项 9.1 数据库用户名与密码 数据库的用户名和密码一定要设置正确,要不然会像下图一样抛出异常: 在加载驱动错误时也可能会出现这个错误,因此要确保打成WAR包时lib目录正确且JAR包版本正确. 还有就是由于这个是JDBC的底层实现,注意手写的SQL语句不能错. 千万千万别像笔者这样: 9.2 网络权限问题 需要在AndroidManifest.xml添加网络权限: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 9.3 防火墙问题 服务器的话一般会有相应的相应的网页界面配置,当然也可以手动配置iptables. 修改/etc/sysconfig/iptables vim /etc/sysconfig/iptables 添加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启iptables: service iptables restart 9.4 HTTP注意事项 由于从Android P开始,google默认要求使用加密连接,即要使用HTTPS,所以会禁止使用HTTP连接. 使用HTTP连接时会出现以下异常: W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 两种建议: 使用HTTPS 修改默认的AndroidManifest.xml使其允许HTTP连接 在res下新建一个文件夹xml,创建一个叫network_security_config.xml的文件,文件内容如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt; &lt;/network-security-config&gt; 然后在AndroidMainfest.xml中加入: &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; /&gt; 即可 另一种办法是在AndroidManifest.xml直接加入一句 &lt;application android:usesCleartextTraffic=&quot;true&quot; /&gt; 9.5 线程问题 从android4.0开始,联网不能再主线程操作,万一网络不好就会卡死,所以有关联网的操作都需要新开一个线程,不能在主线程操作. 9.6 AVD问题 这个bug笔者找了很久,HTTP连接没问题,服务器没问题,数据库没问题,前端代码没问题,然后去了StackOverflow,发现是AVD的问题.... 简单来说就是卸载了APP再重启AVD,居然成功了..... 10 源码与JAR包 10.1 JAR包 MySQL 8.0.17驱动(注意这个要与自己的mysql版本对应) java-servlet-api-4.0.1 其他版本可以来这里搜索下载. 10.2 源码 Github 码云 11 最后 笔者小白一枚,有什么不对的地方请大家指正,评论笔者会好好回复的. 12 参考网站 1.Android 通过Web服务器与Mysql数据库交互 2.Android高版本联网失败 3.IDEA 部署Web项目 4.PreparedStatement的executeQuery、executeUpdate和execute 5.preparedstatement execute()操作成功！但是返回false 6.HttpServletResponse(一) 7.HttpServletResponse(二) 8.HttpServletRequest 9.HttpUrlConnection 10.java.net.socketexception 如果觉得文章好看，欢迎点赞。 同时欢迎关注微信公众号：氷泠之路。 ","link":"https://2293736867.github.io/post/android-tong-guo-web-yu-hou-tai-shu-ju-ku-jiao-hu/"},{"title":"强大的工具（一）：Capslock+ 2.x版本","content":" 2020.07.09 更新 1 Capslock+简介 2 基础功能 2.1 光标移动 2.2 光标选择 2.3 插入符号 2.4 其他修改操作 2.5 剪贴板 2.6 翻译 2.7 临时改变鼠标速度 2.8 切换窗口 2.9 快速打开/关闭窗口 2.10 切换标签 2.11 模拟光标滚动 2.12 F1-F6的功能 3 高级功能 3.1 [Global]全局设置 3.2 capslock+Tab 3.2.1 补全 3.2.2 计算 3.3 JS自定义函数 3.4 翻译的高级设置 3.5 窗口绑定 3.5.1 直接绑定 3.5.2 绑定多个窗口到同一按键 3.5.3 把当前窗口所属程序的所有窗口绑定 3.6 Qbar 3.6.1 QRun 3.6.2 QSearch 3.6.3 QWeb 3.6.4 QStyle 3.7 自定义某些按键 4 最后 2020.07.09 更新 由于原作者只发布了Windows与Mac版，笔者在Linux上工作，因此自行开发了Linux版，目前还在开发中，详情戳这里。 另外作者更新了3.x版本，因此更新了3.x版本的博客，可以戳这里。 本篇文章介绍的是2.x版本。 1 Capslock+简介 Capslock+利用了键盘少用的Capslock键，实现了很多强大的操作。Capslock+是开源的，源码在Github上，点击这里查看，不强制收费。 官网：Capslock+官网。 2 基础功能 2.1 光标移动 按键 效果 capslock+e 光标向上 capslock+d 光标向下 capslock+s 光标向左 capslock+f 光标向右 按键 效果 capslock+a 光标向左跳过一个词 capslock+g 光标向右跳过一个词 capslock+y 光标向上5行 capslock+b 光标向下5行 注意使用a和g时汉字可能会整句跳过。 按键 效果 capslock+= 光标向下移动一页 capslock+- 光标向上移动一页 capslock+p 光标到行首 capslock+; 光标向行尾 2.2 光标选择 按键 效果 capslock+i 光标向上选中 capslock+k 光标向下选中 capslock+j 光标向左选中 capslock+l(小写L) 光标向右选中 capslock+h 光标向左选中一个词 capslock+n 光标向右选中一个词 与a、g一样，h和n对于汉字可能会选择整句。 按键 效果 capslock+0 光标向上选中5行 capslock+m 光标向下选中5行 capslock+u 光标向行首选中 capslock+o 光标向行尾选中 2.3 插入符号 按键 效果 capslock+9 插入() capslock+[ 插入{} capslock+' 插入&quot;&quot; capslock+, 插入&lt;&gt; 以上4项在选中文本时插入到文本两侧。 2.4 其他修改操作 按键 效果 capslock+w 等于Backspace capslock+r 等于delete capslock+Backspace 删除光标所在的一行 capslock+z 撤销 连续按下capslock+z会交替撤销与重做。 按键 效果 capslock+space 等于Enter capslock+Enter 不论光标是否在行尾，直接换行 2.5 剪贴板 capslock+自带两套剪贴板，分别是： capslock+x/c/v capslock+LAlt+x/c/v（LAlt是键盘左边的alt） 都与ctrl+x/c/v独立的一套剪切板。 当选中文字时，对所选的文字操作 不选中文字时，对光标所在行的文字进行操作 capslock+F12可关闭独立剪切板的功能，关闭后capslock+x/c/v与capslock+LAlt+x/c/v失效，capslock+F12可重新开启。 2.6 翻译 capslock+t 翻译，默认使用有道API翻译，可以选中或不选中翻译。 选中即直接翻译选中的词或句子 不选中的话，若光标在整个句子或整个单词的右侧，或者光标在句子或单词的中间时，可以翻译光标所在的句子或单词 光标在句子或单词的左侧时，会翻译上一个句子或单词 建议英文不选中翻译，中文选中翻译 注意： 1、翻译的面板可以修改，重新输入后按Enter可继续翻译 2、获取单词发送通过ctrl+c实现，请确保按下capslock+t的时候ctrl+c不会有额外操作 3、翻译功能通过有道API实现，请求频率限制为每小时1000次，也就是所有使用该翻译功能的人一小时内翻译次数不能超过1000次，突破限制的方法在下面介绍 2.7 临时改变鼠标速度 按住capslock+LAlt可临时改变鼠标的速度，按住capslock+LAlt再配合滚轮上下滚动可以增加或减慢速度，一般是先配合滚轮设定速度，松开LAlt与capslock后再一起按从而临时改变速度。 2.8 切换窗口 按键 作用 capslock+LAlt+e 切换当前窗口上面的窗口 capslock+LAlt+d 切换当前窗口下面的窗口 capslock+LAlt+s 切换当前窗口左边的窗口 capslock+LAlt+f 切换当前窗口右边的窗口 capslock+LAlt+a 切换当前窗口最左侧的窗口 capslock+LAlt+g 切换当前窗口最右侧的窗口 对窗口位置的判定是以当前窗口的横竖中线为依据。 2.9 快速打开/关闭窗口 按键 作用 capslock+LAlt+j 把当前窗口最小化且记录当前窗口为capslock+LAlt+l即将打开的窗口 capslock+LAlt+k 把当前窗口最小化且记录当前窗口为capslock+LAlt+l最后一个打开的窗口 capslock+LAlt+l 打开队列中的第一个窗口，并将其移出队列 capslock+LAlt+h 清楚窗口队列的记录 这与队列类似，capslock+LAlt+j把窗口放进队首，capslock+LAlt+k把窗口放进队尾。 2.10 切换标签 按键 作用 capslock+LAlt+w 等价于ctrl+shift+tab capslock+LAlt+r 等价于ctrl+tab 2.11 模拟光标滚动 按键 作用 capslock+LAlt+y 页面向上移动5行，光标不动 capslock+LAlt+b 页面向下移动5行，光标不动 capslock+LAlt+- 光标移动到页首 capslock+LAlt+= 光标移动到页尾 2.12 F1-F6的功能 按键 作用 capslock+F1 打开帮助文档网页 capslock+F2 弹出计算面板 在计算面版被激活的情况下，若切换为大写，主键盘一部分被替换成小键盘，对应关系如下： 按键 对应字符 m 1 , 2 . 3 j 4 k 5 l 6 u 7 i 8 o 9 p * [ / ; + ' - space 0 RAlt . shift+Enter会将计算结果输出到下一行，ctrl+Enter或capslock+space为换行。 按键 作用 capslock+F3 下一首歌 capslock+F4 短按时将窗口变为半透明 长按时配合滚轮改变透明度。 若当前窗口的透明度，不是完全不透明，也不是半透明，则先将窗口变为完全不透明。 按键 作用 capslock+F5 重载capslock+ capslock+F6 置顶/解除置顶一个窗口，即若该窗口不是处于置顶的状态，则将该窗口置顶，若窗口处于置顶的状态，则解除窗口的置顶状态 3 高级功能 3.1 [Global]全局设置 CapsLock+settings.ini中的[Global]是全局设置，其中： loadScript：要加载的JS文件(要放在loadScript文件夹里)，用逗号分隔 allowClipboard：是否允许使用独立剪切板，1为是，0为否，默认1 mouseSpeed：按下capslock+LAlt时鼠标的速度，范围1-20，默认3 autostart：是否开机启动，1为是，0为否，默认0 loadingAnimation：是否开启程序加载动画，1为是，0为否，默认1 3.2 capslock+Tab capslock+Tab可以实现补全与计算的功能。 3.2.1 补全 这个补全其实是将某一字符串替换成你自定义的字符串，需要在CapsLock+settings.ini中进行设置。 CapsLock+settings.ini中有三个字段有字符串替换功能，分别是[TabHotString]、[QRun]与[QWeb]，优先级是[TabHotString]&gt;[QRun]&gt;[QWeb]，也就是如果三个字段下都有相同的键名，会按优先级顺序替换，但最好不要重复键名，替换的最好都在[TabHotString]中设置。 格式为： 键名 = 要替换的字符串 例如： 3.2.2 计算 计算其实是运行相应的JavaScript代码，处理的是光标左边的字符，直到遇到第一个空格或行首，之间的字符串会被认为是表达式： 当表达式不带=时，会替换掉原来的表达式 当表达式带=时，将结果输出到=右侧，计算不出结果时返回? 若表达式带有空格，则要先选中表达式或在表达式头部加上反引号` 若表达式跨越多行，只能选中 （对于比较严格的计算，如金钱计算，慎用！！！） 3.3 JS自定义函数 首先要编写自己的.js文件，把它放到capslock+文件夹下的loadScript文件夹，然后在CapsLock+settings.ini中的[Global]中，在loadScript=scriptDemo.js后面加上,在加上自己的js文件名，保存，capslock+F5重载capslock+，然后就可以使用了 scriptDemo.js中有一些定义好的函数和事例，可以参照一下： 比如说笔者写的my.js： 接着调用即可： 如果直接打函数名字的话会出现函数的源代码。 还可以对多行字符串使用字符串函数，但要先选中： 3.4 翻译的高级设置 由于有道API每小时只能翻译1000次，想要更多请前往有道智云申请一个独立的Key， 申请到后把key写进CapsLock+settings.ini下的[TTranslate]段。 免费版的填： apiType=0 apiKey=xxxx(你申请的key) KeyFrom=xxxx 收费版的填 apiType=1 apiKey=xxxx(你申请的key) 3.5 窗口绑定 窗口绑定有三种模式： 直接绑定 绑定多个窗口到同一按键 统一程序窗口绑定到统一按键 3.5.1 直接绑定 capslock+LAlt+1-8，把当前的窗口绑定到相应按键，接着capslock+1-8，会激活绑定到相应按键的窗口。 若当前窗口不是绑定的窗口则先切换到按键绑定的窗口，若当前窗口是按键绑定的窗口，则会最小化该窗口，或从最小化复原。 另外，capslock+LAlt+反单引号也可绑定窗口，激活时capslock+反单引号。 3.5.2 绑定多个窗口到同一按键 绑定多个窗口到同一按键很简单，按住capslock+LAlt后，按两次被绑定的按键就行。 比如先选中某一个窗口，capslock+LAlt+1绑定（按两次1），选中另一个窗口后，再capslock+LAlt+两次1，然后capslock+1会按绑定次序打开窗口，多次按下时类似用Alt+tab切换绑定的窗口，会优先打开最常使用的窗口： 3.5.3 把当前窗口所属程序的所有窗口绑定 这种情况针对同一个程序打开了多个不同窗口的情况，比如打开理论多个word文档，此时便派上了用场。 按住capslock+LAlt后，按三次被绑定的按键就行。 比如打开了3个txt，切换到三个txt之一后，按capslock+LAlt+1（按三次1），然后三个txt都被绑定到capslock+1上，然后按capslock+1会在这三个txt之间切换，类似于Alt+tab，也会优先打开最常用的窗口： 3.6 Qbar Qbar是按capslock+q弹出的框，可以方便地浏览文件、打开文件、与打开网页或是用引擎搜索，Esc可关闭，重新按capslock+q可获得焦点，选中字符后按capslock+q会自动填入，选中文件会将路径填入。 输入cl set可以设置CapsLock+settings.ini文件。 Qbar还能使用通配符，?表示单个，*表示多个，如a?b匹配aab，abb，acb，adb等， 而a*b匹配abb，abbb，accb等(不区分大小写) 浏览文件目录时可以按/或\\或tab进入下一层文件夹，按capslock+,返回上一层： 3.6.1 QRun 可以使用Qbar快速启动应用程序，在CapsLock+settings.ini中的[QRun]下添加想要快速运行的程序，接着只需在Qbar中键入相应名字即可启动，也可直接在Qbar中使用-&gt;run来设定，格式为： xxx -&gt; xxx 或 xxx -&gt;run xxx 注意第一种-&gt;两旁有空格，第二种-&gt;前面有空格，后面紧接run，run后面有空格。 QRun也可设定用来打开文件的程序，比如在[QRun]下有： aa = &quot;xxxx/xxx.exe&quot; bb = &quot;xxx/xxxx&quot; 则在Qbar中输入aa bb就会使用aa打开bb。 3.6.2 QSearch 这个可以用搜索引擎快速搜索，内置了bd(百度)，wk（维基），g（谷歌），m（MDN），tb（淘宝），默认为百度。 当然可以自定义，例如改变默认搜索引擎，在CapsLock+settings.ini中的[QSearch]添加default=xxxxx，也可以直接在Qbar中default -&gt; xxxx，这需要通过网址定位到搜索的关键词，并将关键词修改成{q}。 添加自己的搜索引擎类似，CapsLock+settings.ini中的[QSearch]中添加，或在Qbar中使用-&gt;search添加： 3.6.3 QWeb 打开网站，直接输入网址即可，可以在Qbar中使用-&gt;web定义，也可在CapsLock+settings.ini中的[QWeb]下定义，xxx = xxxx。 ctrl+Enter可在前面加www.，后面加.com，如输入taobao，ctrl+Enter会打开www.taobao.com，对于含有.net，.com，.org，www.，http://，https://的网站可以直接当作网址打开而不是用默认引擎去搜索，一些特定的网站可以加上web xxxx打开。 3.6.4 QStyle 在CapsLock+settings.ini中的[QStyle]下自定义Qbar的样式。 颜色可以是指定16种HTML基础颜色之一或6位的RGB颜色值(0x前缀可以省略)。例如：red、ffffaa、FFFFAA、0xFFFFAA。下面的颜色设置也一样： 属性 取值 borderBackgroundColor 背景颜色，默认red borderRadius 边框四角圆角程度，默认9 textBackgroundColor 文字输入框的背景颜色，默认green textColor 输入文字的颜色，默认ffffff，白色 editFontName 输入文字的字体，默认Hiragino Sans GB W6 editFontSize 输入文字大小，默认12 listFontName 提示列表字体，默认consoals listFontSize 提示列表字体大小，默认10 listBackgroundColor 提示列表背景颜色，默认blue listColor 提示列表文字颜色，默认0x000000 listCount 提示列表行数，默认5 lineHeight 提示列表每行高度，默认19 progressColor 进度条颜色，默认0x00cc99 比如这是笔者的Qbar（好丑，对不对，好像比默认的还。。。）: 3.7 自定义某些按键 在CapsLock+settings.ini中的[Keys]下可以改变一些capslock+按键的功能，也可以增加一些按键，capslock+支持的按键有： Capslock + (LALt + ) F1~F12 Capslock + (LALt + ) 0~9 Capslock + (LALt + ) a~z Capslock + (LALt + ) -=[]\\;',./ Capslock + (LALt + ) Backspace, Tab, Enter, Space, RAlt 键位以caps_开头，字母用小写表示，F1-F12用f1-f12表示，LALt用lalt表示。 键位功能以keyFunc_开头，比如： keyFunc_volumeMute 静音 keyFunc_volumeDown 音量增大 keyFunc_volumeUp 音量减少 keyFunc_mediaPrev 上一首 keyFunc_mediaPlayPause 播放/暂停 如caps_j=keyFunc_selectLeft，具体的键位功能可用capslock+q输入cl set并在CapsLock+settingsDemo.ini中查看。 又比如在CapsLock+settings.ini中的[Keys]下添加了caps_lalt_9=keyFunc_volumeMut，则按capslock+LAlt+9可以静音。 4 最后 这基本上就是capslock+的所有功能了，作者最近才更新了，目前最新的版本是3.1.0，2020年4月更新的。 不过有一个问题就是其实capslock+e/d/s/f并不能完全代替上下左右的方向键，比如Alt+←是后退，但Alt+capslcok+s没有任何反应，当上下左右和其他键联合使用capslock还不能代替。 希望作者以后可以考虑出个Linux版。 ","link":"https://2293736867.github.io/post/qiang-da-de-gong-ju-yi-capslock/"}]}