{"posts":[{"title":"java通过ServerSocket与Socket实现通信","content":" 1.ServerSocket (1) (2) (3) 2.Socket (1) (2) (3) (4) 3.服务器端 4.客户端 5.运行结果 6.Socket设置超时 首先说一下ServerSocket与Socket. 1.ServerSocket ServerSocket是用来监听客户端Socket连接的类,如果没有连接会一直处于等待状态. ServetSocket有三个构造方法: (1) ServerSocket(int port); 这个使用指定的端口去创建ServerSocket,IP地址使用默认的本地IP地址. (2) ServetSocket(int port,int backlog); 除了端口外,还有一个用来改变队列长度参数的backlog,指定当服务器繁忙时,可以与之保持连接请求的客户端数量,默认为50. (3) ServetSocket(int port,int backlog,InetAddress ip); 这个使用指定的端口,backlog,ip地址去创建ServerSocket. (这里简单提一下InetAddress,InetAddress没有构造方法,只有两个静态方法获取InetAddress对象,分别是 getByName(String hostName); getByAddress(byte[] address); ) 2.Socket Socket一般用来连接到服务器,程序通过Socket发出网络请求或应答网络请求. Socket有三个构造方法: (1) Socket(InetAddress address,int port); 使用指定IP与指定端口构造Socket,对于本地地址,默认使用本地ip,对于本地端口则动态分配. (2) Socket(String address,int port); 与(1)一样,使用String表示远程ip. (3) Socket(InetAddress address,int port,InetAddress localAddr,int localPort); 创建指定了远程ip,远程端口,本地ip,本地端口的Socket. (4) Socket(String address,int port,InetAddress localAddr,int localPort) 与(2)类似,使用String表示远程ip,用InetAddress表示本地ip. 了解了ServerSocket与Socket后可以编写实现简单的通信了. 3.服务器端 import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(12345);//这个端口自己随意,建议1024以上未使用的端口. while(true) { Socket socket = serverSocket.accept();//一直等待来自客户端的请求. PrintStream printStream = new PrintStream(socket.getOutputStream());//创建输出流 printStream.println(&quot;Server message.&quot;); printStream.close(); socket.close(); } } } 说一下ServetSocket的accept()方法: Socket accept(); 没有参数,返回一个Socket,如果接收到客户端的一个Socket,则返回,否则一直处于等待状态,线程也被阻塞. 4.客户端 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetAddress; import java.net.Socket; public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(&quot;This message comes from server:&quot;+bufferedReader.readLine()); bufferedReader.close(); socket.close(); } } Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); 表示创建一个本地地址,端口为12345的Socket,创建好了后服务器的.accept()方法就会接收到这个Socket,并创建输出流输出相应信息,然后客户端从Socket获取输入流进行读取,读取到了来自服务器的信息. 5.运行结果 (由于作者的漂亮终端不知道什么原因坏了....只能让用VScode的默认终端了....) 先运行服务器端的代码: 服务器端这边因为accept()方法会一直阻塞直到客户端发送请求. 客户端这边一运行就收到了来自服务器端的信息. 6.Socket设置超时 可以为Socket设置超时设置,当Socket超过这个时间没有连接上时系统会认为连接失败. Socket socket = new Socket(&quot;127.0.0.1&quot;,12345); socket.setToTimeout(10000);//单位:ms,在这里是10s 但是未连接上之前无法创建Socket对象,并且Socket没有提供指定超时的构造方法,因此常见的做法是先创建一个无连接的Socket,再调用connect()方法连接. Socket socket = new Socket(); socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,12345),12345); connect()方法其实有两个重载方法,分别是 void connect(SocketAddress endpoint); void connect(SocketAddress endpoint,int timeout); 对于第一个connect()官方文档没有提及超时之类的,就是直接连接. 对于第二个connect,timeout指定的超时时间,单位为ms,设置为0则为无限期等待. 参考链接 1.socket ","link":"https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/"},{"title":"java7与java9中的try-finally关闭资源","content":"1.java7中的try 在java7之前,对于一些需要使用finally关闭资源的操作,会显得很臃肿. try { // } catch(Exception e) { // } finally { if(xxxx != null) { xxxx.close(); } } 在java7中引入了可以在try中直接声明需要关闭的资源的功能,在try后的圆括号直接定义一个或多个资源即可. try( var xxx = new xxx(); var xxx = new xxx(); ) { // } 但是这些类都需要实现了Closeable或AutoCloseable接口,实现其中的close(). 2.Closeable接口 Closeable接口是AutoCloseable的子接口,其中的close()抛出了IOException异常,实现接口时要注意抛出的异常需是IOException异常或IOException子类异常. 3.AutoCloseable接口 AutoCloseable接口中的close()抛出的异常是Exception,实现接口时可以抛出任何类型的异常. java7几乎把所有的&quot;资源类&quot;(包括文件IO的各种类,JDBC编程的Connection,Statement等接口)进行了改写,改写后的资源都实现了AutoCloseable或Closeable接口.(引自&lt;&lt;疯狂Java讲义&gt;&gt;(第5版) P381) 4.java9中的try java9不像java7一样在try中定义资源,只需要自动关闭的资源有final修饰即可.也就是说,可以不在try中声明,在try前声明且使用final修饰即可. final var xxx = new xxx(); final var xxx = new xxx(); try(xxx;xxx) { // } ","link":"https://2293736867.github.io/post/java7-yu-java9-zhong-de-try-finally-guan-bi-zi-yuan/"},{"title":"一文带你理解脏读,幻读,不可重复读与mysql的锁,事务隔离机制","content":" 1 ACID (1) A:原子性(Atomicity) (2) C:一致性(Consistency) (3) I:隔离性(Isolation) (4) D:持久性(Durability) 2 Mysql的锁 (1) S锁与X锁 Ⅰ.S锁 Ⅱ.X锁 (2) 乐观锁与悲观锁 Ⅰ.乐观锁 Ⅱ.悲观锁 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 (2) 幻读 (3) 不可重复读 (4) 第一类丢失更新 (5) 第二类丢失更新 5 封锁协议与隔离级别 (1) 一级封锁协议 a.引发脏读 b.引发幻读 c.引发不可重复读 (2) 二级封锁协议 Ⅰ.Read committed a.避免脏读 b.引发幻读 c.引发不可重复读 Ⅱ.Repeatable read a.避免脏读 b.避免不可重复读 c.引发幻读 (3) 三级封锁协议 a.避免脏读 b.避免幻读 c.避免不可重复读 6 两段锁协议 (1) 加锁 (2) 解锁 首先说一下数据库事务的四大特性 1 ACID 事务的四大特性是ACID(不是&quot;酸&quot;....) (1) A:原子性(Atomicity) 原子性指的是事务要么完全执行,要么完全不执行. (2) C:一致性(Consistency) 事务完成时,数据必须处于一致的状态.若事务执行途中出错,会回滚到之前的事务没有执行前的状态,这样数据就处于一致的状态.若事务出错后没有回滚,部分修改的内容写入到了数据库中,这时数据就是不一致的状态. (3) I:隔离性(Isolation) 同时处理多个事务时,一个事务的执行不能被另一个事务所干扰,事务的内部操作与其他并发事务隔离. (4) D:持久性(Durability) 事务提交后,对数据的修改是永久性的. 2 Mysql的锁 Mysql的锁其实可以按很多种形式分类: 按加锁机制分,可分为乐观锁与悲观锁. 按兼容性来分,可分为X锁与S锁. 按锁粒度分,可分为表锁,行锁,页锁. 按锁模式分,可分为记录锁,gap锁,next-key锁,意向锁,插入意向锁. 这里主要讨论S锁,X锁,乐观锁与悲观锁. (1) S锁与X锁 S锁与X锁是InnoDB引擎实现的两种标准行锁机制.查看默认引擎可使用 show variables like '%storage_engine%'; 作者的mysql版本为8.0.17,结果如下: 先建好测试库与测试表,很简单,表就两个字段. create database test; use test; create table a ( id int primary key auto_increment, money int ); Ⅰ.S锁 S锁也叫共享锁,读锁,数据只能被读取不能被修改. 玩一下,上锁! lock table a read; 然后..... 只能读不能改,删,也不能增. Ⅱ.X锁 X锁也叫排他锁,写锁,一个事务对表加锁后,其他事务就不能对其进行加锁与增删查改操作. 设置手动提交,开启事务,上X锁. set autocmmmit=0; start transaction; lock table a write; 在开启另一个事务,使用select语句. set autocommit=0; start transaction; select * from a; 这里是阻塞select操作,因为一直都没释放X锁. 同样也不能再加锁,也是阻塞中. 回到原来那个加锁的事务,嗯,什么事也没有,正常读写. 释放锁后: unlock table; 在另一个事务中可以看到中断时间. (2) 乐观锁与悲观锁 Ⅰ.乐观锁 乐观锁就是总是假设是最好的情况,每次去操作的时候都不会上锁,但在更新时会判断有没有其他操作去更新这个数据,是一种宽松的加锁机制. mysql本身没有提供乐观锁的支持,需要自己来实现,常用的方法有版本控制和时间戳控制两种. 版本控制 版本控制就是为表增加一个version字段,读取数据时连同这个version字段一起读出来,之后进行更新操作,版本号加1,再将提交的数据的版本号与数据库中的版本号进行比较,若提交的数据的版本号大于数据库中的版本号才会进行更新. 举个例子,假设此时version=1,A进行操作,更新数据后version=2,与此同时B也进行操作,更新数据后version=2,A先完成操作,率先将数据库中的version设置为2,此时B提交,B的version与数据库中的version一样,不接受B的提交. 时间戳控制 时间戳控制与版本控制差不多,把version字段改为timestamp字段 还有一种实现方法叫CAS算法,这个作者不怎么了解,有兴趣可以自行搜索. Ⅱ.悲观锁 悲观锁就是总是假设最坏的情况,在整个数据处理状态中数据处于锁定状态,悲观锁的实现往往依靠数据库的锁机制.每次在拿到数据前都会上锁. mysql在调用一些语句时会上悲观锁,如(先关闭自动提交,开启事务): set autocommit=0; start transaction; 两个事务都这样操作,然后其中一个事务输入: select * from a where xxx for update; 在另一事务也这样输入: 这时语句会被阻塞,直到上锁的那个事务commit(解开悲观锁). 在另一事务中可以看到这个事务被阻塞了2.81s. *** lock in share mode. 也会加上悲观锁. 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 脏读是指一个事务读取到了另一事务未提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据,但没有提交,此时事务B却读取了,这时事务B就形成了脏读,一般事务A的后续操作是回滚,事务B读取到了临时数值. 事务A 事务B 开始事务 开始事务 更新X,旧值X=1,新值X=2 读取X,X=2(脏读) 回滚X=1 结束事务(X=1) 结束事务 (2) 幻读 幻读是指并不是指同一个事务执行两次相同的select语句得到的结果不同, 而是指select时不存在某记录,但准备插入时发现此记录已存在,无法插入,这就产生了幻读. 事务A 事务B 开始事务 开始事务 select某个数据为空,准备插入一个新数据 插入一个新数据 提交,结束事务 插入数据,发现插入失败,由于事务B已插入相同数据 结束事务 (3) 不可重复读 不可重复读指一个事务读取到了另一事务已提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据并且提交了,此时事务B却读取了,这时事务B就形成了不可重复读. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交,结束事务 读取X=2 结束事务 (4) 第一类丢失更新 第一类丢失更新就是两个事务同时更新一个数据,一个事务更新完毕并提交后,另一个事务回滚,造成提交的更新丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 修改X=2 修改X=3 提交,结束事务 回滚 结束事务(X=1) X=1,X本应为提交的3 (5) 第二类丢失更新 第二类丢失更新就是两个事务同时更新一个数据,先更新的事务提交的数据会被后更新的事务提交的数据覆盖,即先更新的事务提交的数据丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交事务,X=2,结束 更新X=3 提交事务,X=3,事务A的更新丢失,结束 5 封锁协议与隔离级别 封锁协议就是在用X锁或S锁时制定的一些规则,比如锁的持续时间,锁的加锁时间等.不同的封锁协议对应不同的隔离级别.事务的隔离级别一共有4种,由低到高分别是Read uncommitted,Read committed,Repeatable read,Serializable,分别对应的相应的封锁协议等级. (1) 一级封锁协议 一级封锁协议对应的是Read uncommitted隔离级别,Read uncommitted,读未提交,一个事务可以读取另一个事务未提交的数据,这是最低的级别.一级封锁协议本质上是在事务修改数据之前加上X锁,直到事务结束后才释放,事务结束包括正常结束(commit)与非正常结束(rollback). 一级封锁协议不会造成更新丢失,但可能引发脏读,幻读,不可重复读. 设置手动提交与事务隔离等级为read uncommited,并开启事务(注意要先设置事务等级再开启事务). set autocommit=0; set session transaction isolation level read uncommitted; start transaction; (中间有一行打多了一个t可以忽略.....) a.引发脏读 在一个事务中修改表中的值,不提交,另一个事务可以select到未提交的值. 出现了脏读. b.引发幻读 在一个事务中插入一条数据,提交. 另一事务中select时没有,准备insert,但是insert时却提示已经存在.引发幻读. c.引发不可重复读 未操作提交前: 另一事务修改并提交: 再次读: 引发不可重复读. (2) 二级封锁协议 二级封锁协议本质上在一级协议的基础上(在修改数据时加X锁),在读数据时加上S锁,读完后立即释放S锁,可以避免脏读.但有可能出现不可重复读与幻读.二级封锁协议对应的是Read committed与Repeatable Read隔离级别. 先设置隔离等级 set session transaction isolation level read committed; Ⅰ.Read committed Read committed,读提交,读提交可以避免脏读,但可能出现幻读与不可重复读. a.避免脏读 开启一个事务并更新值,在这个事务中money=100(更新后) 另一事务中money为未更新前的值,这就避免了脏读. 注意,事实上脏读在read committed隔离级别下是不被允许的,但是mysql不会阻塞查询,而是返回未修改之前数据的备份,这种机制叫MVCC机制(多版本并发控制). b.引发幻读 在一个事务中插入数据并提交. 另一事务中不能插入&quot;不存在&quot;的数据,出现幻读. c.引发不可重复读 事务修改并提交前: 事务修改并提交: 出现不可重复读. Ⅱ.Repeatable read Repeatable read比Read committed严格一点,是Mysql的默认级别,读取过程更多地受到MVCC影响,可防止不可重复读与脏读,但仍有可能出现幻读. a.避免脏读 在一个事务中修改数据,不提交. 另一事务中两次select的结果都不变,没有出现脏读. b.避免不可重复读 一个事务修改数据并提交. 另一事务中select的结果没有发生改变,即没有出现不可重复读. c.引发幻读 同理,一个事务插入一条数据并提交. 另一个事务插入时出现幻读. (3) 三级封锁协议 三级封锁协议,在一级封锁协议的基础上(修改时加X锁),读数据时加上S锁(与二级类似),但是直到事务结束后才释放S锁,可以避免幻读,脏读与不可重复读.三级封锁协议对应的隔离级别是Serializable. 先设置Serializable隔离级别 set session transaction isolation level serializable a.避免脏读 设置事务隔离等级后开启事务并update,发现堵塞.从而避免了脏读. b.避免幻读 插入时直接阻塞,避免了幻读. c.避免不可重复读 在脏读的例子中可以知道,update会被堵塞,都不能提交事务,因此也避免了不可重复读. 6 两段锁协议 事务必须分为两个阶段对数据进行加锁与解锁,两端锁协议叫2PL(不是2PC),所有的加锁都在解锁之前进行. (1) 加锁 加锁会在更新或者 select *** for update *** lock in share mode 时进行 (2) 解锁 解锁在事务结束时进行,事务结束包括rollback与commit. 参考链接 1:ACID1 2:ACID2 3:mysql的锁1 4:乐观锁与悲观锁1 5:乐观锁与悲观锁2 6:乐观锁与悲观锁3 7:mysql修改事务隔离等级 8:mysql三级封锁与二段锁 9:数据库封锁协议 10:mysql事务隔离机制1 11:mysql事务隔离机制2 12:mysql幻读 13:mysql脏读,不可重复读与幻读 14:mysql两段锁1 15:mysql两段锁2 ","link":"https://2293736867.github.io/post/yi-wen-dai-ni-li-jie-zang-du-huan-du-bu-ke-chong-fu-du-yu-mysql-de-suo-shi-wu-ge-chi-ji-zhi/"},{"title":"android通过web与后台数据库交互","content":" 1.背景 2.开发环境 3.相关资源 4.配置开发环境 一. 安装Mysql8.0.17 (1) 下载mysql (2) 安装mysql (3) 启动服务 (4) 查看初始化密码,用于下一步设置自己的root密码 (5) 本地使用root登录 (6) 更改密码 (7) 允许外部访问 (8) 配置防火墙(可选) 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 (2) 连接到服务器,解压压缩包 (3) 修改tomcat默认端口(可选) (4) 启动tomcat (5) 测试 (6)开机启动 5.建库建表 (1) 创建user.sql (2) 导入到数据库 6.后端部分 (1) 创建项目 (2) 添加jar包 (3) 创建包与类 (4) 先来处理DBUtils类 (5) 接下来处理User类 (6) 接下来是UserDao (7) servlet包的SignIn与SignUp类 (8) 添加servlet到web.xml (9) 最后添加一个叫Hello.html的html文件用于测试. 7.打包发布 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (6) 添加Hello.html与web.xml (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 (9) 测试 8.前端页面部分 (1) 新建工程 (2) MainActivity.java (3) UserService.java (4) activity_main.xml 9.测试 (1) 注册测试 (2) 登录测试 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 (2) 网络权限问题 (3) 防火墙问题 (4) 使用HTTP注意事项 * * * 1 使用HTTPS * 2 修改默认的AndroidManifest.xml使其允许HTTP连接 (5) 线程问题 (6) AVD问题 11 最后 1.背景 开发一个app与后台数据库交互,基于mysql+jdbc+tomcat,没有使用DBUtils或jdbc框架,纯粹底层jdbc实现. 以后逐步改用Spring框架,优化mysql,进一步部署tomcat等等,现在项目刚刚起步,还有很多不懂的东西,得慢慢来...... 这几天踩了很多坑,说得夸张点真是踩到我没有知觉,希望能帮助别人少踩坑... 2.开发环境 系统 : win10 IDE : Android Studio 3.5.1,IntelliJ IDEA 2019.02 DBMS : Mysql 8.0.17 web服务器: tomcat9 3.相关资源 1.相关jar包: mysqlV8.0.17驱动(注意这个要与自己的mysql版本对应) java-servlet-api-V4.0.1 其他版本可以来这里搜索下载 Maven仓库 2.github 这是源码地址,包括前后端与建表等所有代码. (欢迎star) 3.码云 这也是源码地址 4.配置开发环境 IDE就不说了,重点说一下mysql与tomcat9的安装 一. 安装Mysql8.0.17 这个是目前比较新的mysql版本. 服务器系统是centos 其他系统安装看这里 win10 ubuntu fedroa reahat centos使用yum命令安装(参考链接) (1) 下载mysql sudo yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm (2) 安装mysql sudo yum install mysql-community-server (3) 启动服务 sudo service mysqld start (4) 查看初始化密码,用于下一步设置自己的root密码 sudo grep 'temporary password' /var/log/mysqld.log (5) 本地使用root登录 mysql -u root -p 输入上一步看到的密码 (6) 更改密码 alter mysql.user 'root'@'localhost' identified by 'password'; 注意新版本的mysql不能使用太弱的密码 如果出现如下提示 则说明密码太弱了,请使用一个更高强度的密码 (7) 允许外部访问 use mysql; update user set host='%' where user='root'; 这个可以根据自己的需要去修改,host='%'表明允许所有的ip登录,也可以设置特定的ip,若使用host='%'的话建议新建一个用户配置相应的权限. (8) 配置防火墙(可选) 由于作者使用的是阿里云的服务器,没配置防火墙的话远程连接不上,因此需要手动配置,如图 其中授权对象可以根据自己的需要更改,0.0.0.0/0表示允许所有的ip. 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 作者使用的是scp命令,不会的可以看这里 scp apache-tomcat-xxxx.tar.gz username@xx.xx.xx.xx:/ 改成自己的用户名和ip (2) 连接到服务器,解压压缩包 mkdir /usr/local/tomcat mv apache-tomcat-xxxx.tar.gz /usr/local/tomcat tar -xzvf apache-tomcat-xxx.tar.gz (3) 修改tomcat默认端口(可选) 修改conf/server.xml文件,一般只需修改 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 中的8080端口,修改这个端口即可 这个懒的话(比如作者)可以不改 (4) 启动tomcat 运行bin目录下的startup.sh cd bin ./startup.sh (5) 测试 浏览器输入 服务器IP:端口 若出现 则表示成功. (6)开机启动 建议配置开机启动,修改/etc/rc.local文件 vim /etc/rc.local 添加 sh /usr/local/tomcat/bin/startup.sh 这个根据自己的tomcat安装路径修改,指定bin下的startup.sh即可 5.建库建表 创建用户表,这里简化操作(好吧我喜欢偷懒)就不创建新用户不授权了 这是一个在本地用root登录的示例,请根据实际情况创建并授权用户. (1) 创建user.sql CREATE DATABASE userinfo; USE userinfo; CREATE TABLE user ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NULL, password CHAR(30) NULL ); (2) 导入到数据库 mysql -u root -p &lt; user.sql 6.后端部分 (1) 创建项目 选择web application 选好路径,改好名字后finish (2) 添加jar包 创建一个叫lib的目录 添加两个jar包: mysql-connector-java-8.0.17.jar javax.servlet-api-4.0.1.jar 打开Project Structure Modules--&gt; + --&gt; JARs or directories 选择刚才新建的lib下的两个jar包 打勾,apply (3) 创建包与类 总共4个包 com.servlet 用于处理来自前端的请求,包含SignUp.java,SignIn.java com.util 主要功能是数据库连接,包含DBUtils.java com.entity 用户类,包含User.java com.dao 操作用户类的类,包含UserDao.java (4) 先来处理DBUtils类 这个是连接数据库的类,纯粹的底层jdbc实现,注意驱动版本. package com.util; import java.sql.*; public class DBUtils { private static Connection connection = null; public static Connection getConnection() { try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; connection = DriverManager.getConnection(url,usename,password); } catch (Exception e) { e.printStackTrace(); return null; } return connection; } public static void closeConnection() { if(connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 主要就是获取连接与关闭连接两个函数. String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; 这几行根据自己的用户名,密码,服务器ip和库名修改 注意,mysql8.0以上使用的注册驱动的语句是 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 旧版的是 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 注意对应. (5) 接下来处理User类 User类比较简单,就是就三个字段与getter,setter package com.entity; public class User { private int id; private String name; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } (6) 接下来是UserDao package com.dao; import com.entity.User; import com.util.DBUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class UserDao { public boolean query(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;select * from user where name = ? and password = ?&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); ResultSet resultSet = preparedStatement.executeQuery(); return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } public boolean add(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;insert into user(name,password) values(?,?)&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } } 主要就是查询与添加操作,查询操作中存在该用户就返回true,否则返回false 添加操作中使用executeUpdate()与getUpdateCount() != 0.注意不能直接使用 return preparedStatement.execute(); 去代替 preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; 咋一看好像没有什么问题,那天晚上我测试的时候问题可大了,android那边显示注册失败,但是数据库这边的却insert进去了.........我...... 好吧说多了都是泪,还是函数用得不够熟练. 一般来说select使用executeQuery() executeQuery()返回ResultSet,表示结果集,保存了select语句的执行结果,配合next()使用 delete,insert,update使用executeUpdate() executeUpdate()返回的是一个整数,表示受影响的行数,即delete,insert,update修改的行数,对于drop,create操作返回0 create,drop使用execute() execute()的返回值是这样的: 如果第一个结果是ResultSet对象,则返回true 如果第一个结果是更新计数或者没有结果则返回false 所以在这个例子中 return preparedStatement.execute(); 肯定返回false,所以才会数据库这边insert进去,但前端显示注册失败(这个bug作者找了很久......) (7) servlet包的SignIn与SignUp类 SingIn类用于处理登录,调用jdbc查看数据库是否有对应的用户 SignUp类用于处理注册,把user添加到数据库中 这两个使用的是http连接,后期作者会采用https加密连接. SignIn.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/SignIn&quot;) public class SingIn extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException, ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.query(user))//若查询失败 { httpServletResponse.sendError(204,&quot;query failed.&quot;);//设置204错误码与出错信息 } } } @WebServlet(&quot;/SignIn&quot;) 这行代码表示这是一个名字叫SignIn的servlet,可用于实现servlet与url的映射,如果不在这里添加这个注解,则需要在WEB-INF目录下的web.xml添加一个 &lt;servlet-mapping&gt; 叫servlet的映射 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 这行代码设置响应类型与编码 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); HttpServletRequest.getParameter(String name)方法表示根据name获取相应的参数 下面是SignUp.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.annotation.*; import javax.servlet.http.*; import javax.servlet.*; import java.io.IOException; @WebServlet(&quot;/SignUp&quot;) public class SignUp extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//设定编码防止中文乱码 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;);//根据name获取参数 String password = httpServletRequest.getParameter(&quot;password&quot;);//根据password获取参数 UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.add(user)) //若添加失败 { httpServletResponse.sendError(204,&quot;add failed.&quot;);//设置204错误码与出错信息 } } } (8) 添加servlet到web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SingIn&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignUp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SignUp&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;/web-app&gt; 要把刚才创建的Servlet添加进web.xml,在&lt;servlet&gt;中添加子元素&lt;servlet-name&gt;与&lt;servlet-class&gt; &lt;servlet-name&gt;是Servlet的名字,最好与类名一致. &lt;servlet-class&gt;是Servlet类的位置. 如果在Servlet类中没有添加 @WebServlet(&quot;/xxxx&quot;) 这个注解,则需要在web.xml中添加 &lt;servlet-mapping&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;url-pattern&gt;/SignIn&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中&lt;servlet-name&gt;与&lt;servlet&gt;中的子元素&lt;servlet-name&gt;中的值一致 &lt;url-pattern&gt;是访问的路径 (9) 最后添加一个叫Hello.html的html文件用于测试. &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello web. &lt;/body&gt; &lt;/html&gt; 7.打包发布 作者用的是IDEA,Eclipse的打包请看这里 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (那个lib文件夹被挡住了.....) (6) 添加Hello.html与web.xml web.xml这个需要在WEB-INF目录里,Hello.html在WEB-INF外面 (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 把打包好的.war文件上传到服务器的tomcat的/webapps目录下的 scp ***.war username@xxx.xxx.xxx.xxx:/usr/local/tomcat/webapps 注意改成自己的webapps目录. (9) 测试 在浏览器输入 服务器IP:端口/项目/Hello.html 作者是在本地上开了tomcat后测试的 8.前端页面部分 (1) 新建工程 (2) MainActivity.java package com.cx; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button signin = (Button) findViewById(R.id.signin); signin.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signIn(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); Button signup = (Button) findViewById(R.id.signup); signup.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signUp(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); } } 没什么好说的,就为两个Button绑定事件,然后设置两个Toast提示信息. (3) UserService.java package com.cx; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; public class UserService { public static boolean signIn(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } public static boolean signUp(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } } class MyThread extends Thread { private String path; private String name; private String password; private boolean result = false; public MyThread(String path,String name,String password) { this.path = path; this.name = name; this.password = password; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000);//设置连接超时时间 httpURLConnection.setReadTimeout(8000);//设置读取超时时间 httpURLConnection.setRequestMethod(&quot;POST&quot;);//设置请求方法,post String data = &quot;name=&quot; + URLEncoder.encode(name, &quot;utf-8&quot;) + &quot;&amp;password=&quot; + URLEncoder.encode(password, &quot;utf-8&quot;);//设置数据 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//设置响应类型 httpURLConnection.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;);//设置内容长度 httpURLConnection.setDoOutput(true);//允许输出 OutputStream outputStream = httpURLConnection.getOutputStream(); outputStream.write(data.getBytes(&quot;utf-8&quot;));//写入数据 result = (httpURLConnection.getResponseCode() == 200); } catch (Exception e) { e.printStackTrace(); } } public boolean getResult() { return result; } } MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); 这两行换成自己的ip,本地ip的话可以用ipconfig或ifconfig查看,修改了默认端口的话也把端口一起改了. 路径的话就是 端口/web项目名/Servlet名 web项目名是再打成war包时设置的,Servlet名在web.xml中的&lt;servlet&gt;的子元素&lt;servlet-name&gt;设置,与java源码中的@WebServlet()注解中的一致 另外一个要注意的就是线程问题,需要新开一个线程进行http的连接 (4) activity_main.xml 前端页面部分很简单,就两个button,用于验证功能. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;用户名&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etname&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;密码&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etpassword&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;注册&quot; android:id=&quot;@+id/signup&quot; /&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;登录&quot; android:id=&quot;@+id/signin&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 9.测试 (1) 注册测试 随便输入用户名与密码 查看数据库 这里没有加密保存,后期会添加加密保存 (2) 登录测试 perfect! 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 这个错误在加载驱动错误时也可能会出现这个错误,因此要确保打成war包时lib目录正确且jar包版本正确. 还有就是由于这个是jdbc的底层实现,注意手写的sql语句不能错 千万千万别像我这样: (2) 网络权限问题 这个需要在AndroidManifest.xml添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; (3) 防火墙问题 服务器的话一般会有相应的相应的网页界面配置,比如作者的是阿里云服务器,当然也可以手动配置iptables 修改/etc/sysconfig/iptables vim /etc/sysconfig/iptables 添加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启iptables service iptables restart (4) 使用HTTP注意事项 由于从Android P开始,google默认要求使用加密连接,即要使用HTTPS,所以会禁止使用HTTP连接 使用HTTP连接时会出现以下异常 W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 两种建议: 1 使用HTTPS 2 修改默认的AndroidManifest.xml使其允许HTTP连接 在res下新建一个文件夹xml,创建一个叫network_security_config.xml的文件,文件内容如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt; &lt;/network-security-config&gt; 然后在AndroidMainfest.xml中加入 &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; /&gt; 即可 另一种办法是直接加入一句 android:usesCleartextTraffic=&quot;true&quot; &lt;application android:usesCleartextTraffic=&quot;true&quot; /&gt; (5) 线程问题 从android4.0开始,联网不能再主线程操作,万一网络不好就会卡死,所以有关联网的操作都需要新开一个线程,不能在主线程操作. (6) AVD问题 这个bug作者找了很久,http连接没问题,服务器没问题,数据库没问题,前端代码没问题,然后去了stackoverflow,发现是AVD的问题,我....... 简单来说就是卸载了再重启AVD,居然成功了..... 11 最后 作者小白一枚,有什么不对的地方请大家指正,评论作者会好好回复的.最后分享一首歌希望你们喜欢. 薛之谦-暧昧 参考网站 1.Android 通过Web服务器与Mysql数据库交互 2.Android高版本联网失败 3.IDEA 部署Web项目 4.PreparedStatement的executeQuery、executeUpdate和execute 5.preparedstatement execute()操作成功！但是返回false 6.HttpServletResponse(一) 7.HttpServletResponse(二) 8.HttpServletRequest 9.HttpUrlConnection 10.java.net.socketexception ","link":"https://2293736867.github.io/post/android-tong-guo-web-yu-hou-tai-shu-ju-ku-jiao-hu/"},{"title":"强大的工具(一):Capslock+","content":" 基本功能 高级功能 Capslock+利用了键盘少用的Capslock键,实现了很多强大的操作。 Capslock+是开源的，源码在Github上，点击这里查看，不强制收费。 官网:Capslock+官网 基本功能 光标移动 capslock+e 光标向上 capslock+d 光标向下 capslock+s 光标向左 capslock+f 光标向右 capslock+a 光标向左跳过一个词 capslock+g 光标向右跳过一个词 使用a和g时汉字可能会整句跳过 capslock+y 光标向上5行 capslock+b 光标向下5行 capslock+= 光标向下移动一页 capslock+- 光标向上移动一页 capslock+p 光标到行首 capslock+; 光标向行尾 光标选择 capslock+i 光标向上选中 capslock+k 光标向下选中 capslock+j 光标向左选中 capslock+l(是字母L的小写) 光标向右选中 capslock+h 光标向左选中一个词 capslock+n 光标向右选中一个词 与a、g一样，h和n对于汉字可能会选择整句 capslock+0 光标向上选中5行 capslock+m 光标向下选中5行 capslock+u 光标向行首选中 capslock+o 光标向行尾选中 插入符号 capslock+9 插入() capslock+[ 插入{} capslock+' 插入&quot;&quot; capslock+, 插入&lt;&gt; 以上4项在选中文本时插入到文本两侧 其他修改操作 capslock+w 等于Backspace capslock+r 等于delete capslock+Backspace 删除光标所在的一行 capslock+z 撤销 连续按下capslock+z会交替撤销与重做 capslock+space 等于Enter capslock+Enter 不论光标是否在行尾，直接换行 capslock+c capslock+x capslock+v 与ctrl+c独立的一套剪切板 当选中文字时，对所选的文字操作 不选中文字时，对光标所在行的文字进行操作 翻译 capslock+t 翻译，默认使用有道翻译，可以选中或不选中翻译 不选中的话，若光标在整个句子或整个单词的右侧，或者光标在句子或单词的中间时，可以翻译光标所在的句子或单词 光标在句子或单词的左侧时，会翻译上一个句子或单词 建议英文不选中翻译，中文选中翻译 注意 1.翻译的面板可以修改，重新输入后按Enter可继续翻译 2.获取单词发送通过ctrl+c实现，请确保按下capslock+t的时候ctrl+c不会有额外操作 3.翻译功能通过有道API实现，请求频率限制为每小时1000次，也就是所有使用该翻译功能的人一小时内翻译次数不能超过1000次，突破限制的方法在下面介绍 与LAlt(左边的Alt键)结合 临时改变鼠标速度 按住capslock+LAlt可临时改变鼠标的速度，按住capslock+LAlt再配合滚轮上下滚动可以增加或减慢速度，一般是先配合滚轮设定速度，松开LAlt与capslock后再一起按从而临时改变速度 切换不同窗口 capslock+LAlt+e 切换当前窗口上面的窗口 capslock+LAlt+d 切换当前窗口下面的窗口 capslock+LAlt+s 切换当前窗口左边的窗口 capslock+LAlt+f 切换当前窗口右边的窗口 capslock+LAlt+a 切换当前窗口最左侧的窗口 capslock+LAlt+g 切换当前窗口最右侧的窗口 对窗口位置的判定是以当前窗口的横竖中线为依据 快速打开/关闭窗口 capslock+LAlt+j 把当前窗口最小化且记录当前窗口为capslock+LAlt+l(小写L)即将打开的窗口 capslock+LAlt+k 把当前窗口最小化且记录当前窗口为capslock+LAlt+l最后一个打开的窗口 这与队列差不多，capslock+LAlt+j把窗口放进队首，capslock+LAlt+k把窗口放进队尾 capslock+LAlt+l 打开队列中的第一个窗口，并将其移出队列 capslock+LAlt+h 清楚窗口队列的记录 切换标签 capslock+LAlt+w 等于ctrl+shift+tab capslock+LAlt+r 等于ctrl+tab 模拟光标滚动 capslock+LAlt+y 页面向上移动5行，光标不动 capslock+LAlt+b 页面向下移动5行，光标不动 capslock+LAlt+- 光标移动到页首 capslock+LAlt+= 光标移动到页尾 第三套剪切板 ctrl+x/c/v为第一套，capslock+x/c/v为第二套，capslock+LAlt+x/c/v为第三套 当选中文字时复制文字，不选中文字时复制光标所在行的文字 capslock+F12可关闭独立剪切板的功能，关闭后capslock+x/c/v与capslock+LAlt+x/c/v失效，capslock+F12可重新开启 F1-F6的功能 capslock+F1 打开帮助文档网页 capslock+F2 弹出计算面板 在计算面版被激活的情况下，若切换为大写，主键盘一部分被替换成小键盘，对应关系如下 u-----------8 i-----------9 o----------0 p-----------* [---------------/ j------------4 k----------5 l----------6 ;------------+ '---------------(减号) m----------1 ,-----------2 .-----------3 space----0 RAlt----------. shift+Enter会将计算结果输出到下一行，ctrl+Enter或capslock+space为换行 capslock+F3 下一首歌 capslock+F4 短按时将窗口变为半透明 长按时配合滚轮改变透明度 若当前窗口的透明度，不是完全不透明，或不是半透明，则先将窗口变为完全不透明 capslock+F5 重载capslock+ capslock+F6 置顶/解除置顶一个窗口，即若该窗口不是处于置顶的状态，则将该窗口置顶，若窗口处于置顶的状态，则解除窗口的置顶状态 高级功能 CapsLock+settings.ini中的[Global]全局设置 loadScript:要加载的JS文件(要放在loadScript文件夹里)，用逗号分隔 allowClipboard:是否允许使用独立剪切板，1为是，0为否，默认1 mouseSpeed:按下capslock+LAlt时鼠标的速度，范围1-20，默认3 autostart:是否开机启动，1为是，0为否，默认0 loadingAnimation:是否开启程序加载动画，1为是，0为否，默认1 capslock+Tab:补全+计算 1.补全 这个补全其实是将某一字符串替换成你自定义的字符串，需要在capslock+的位置下的CapsLock+settings.ini中进行设置 CapsLock+settings.ini中有三个字段有字符串替换功能，分别是[TabHotString]、[QRun]与[QWeb]，优先级是[TabHotString]&gt;[QRun]&gt;[QWeb]，也就是如果三个字段下都有相同的键名，会按优先级顺序替换，但最好不要重复键名，替换的最好都在[TabHotString]中设置 格式为:键名 = 要替换的字符串 2.计算(对于比较严格的计算，如金钱计算，慎用) 计算其实是运行相应的JavaScript代码，处理的是光标左边的字符，直到遇到第一个空格或行首，之间的字符串会被认为是表达式 当表达式不带=时，会替换掉原来的表达式，当表达式带=时，将结果输出到=右侧，计算不出结果时返回? 若表达式带有空格，则要先选中表达式或在表达式头部加上`，若表达式在跨越多行只能选中 用JS自定义函数 首先要编写自己的.js文件，把它放到capslock+文件夹下的loadScript文件夹，然后在CapsLock+settings.ini中的[Global]中，在loadScript=scriptDemo.js后面加上,在加上自己的js文件名，保存，capslock+F5重载capslock+，然后就可以使用了 scriptDemo.js中有一些定义好的函数和事例，可以参照一下 比如说我自己写的my.js中包含了如下两个函数(我不太会JS...以下只是模仿别人写的) 然后... 如果直接打函数名字的话会出现函数的源代码 还可以对多行字符串使用字符串函数，但要先选中 翻译的高级设置 由于有道API每小时只能翻译1000次，想要更多请前往有道智云申请一个独立的Key， 申请到后把key写进capslock+安装目录下的CapsLock+settings.ini下的[TTranslate]段 免费版的填apiType=0 apiKey=xxxx(你申请的key) KeyFrom=xxxx 收费版的填apiType=1 apiKey=xxxx(你申请的key) 窗口绑定 窗口绑定有三种模式： 第一种：直接绑定 capslock+LAlt+1-8,把当前的窗口绑定到相应按键 然后capslock+1-8，会激活绑定到相应按键的窗口 （1-8，capslock+9是插入括号，capslock+0是向上选中5行） 若当前窗口不是绑定的窗口则先切换到按键绑定的窗口，若当前窗口是按键绑定的窗口，则会最小化该窗口，或从最小化复原 另外，capslock+LAlt+反单引号(`，主键盘区数字1左边)也可绑定窗口，激活时capslock+反单引号 第二种：绑定多个窗口到同一按键（按两次） 先选中某一个窗口，capslock+LAlt+1绑定（按两次1），在选中另一个窗口后，再capslock+LAlt+两次1，然后capslock+1会按绑定次序打开窗口，多次按下时类似用Alt+tab切换绑定的窗口，会优先打开最常使用的窗口 第三种：把当前窗口所属程序的所有窗口绑定（按三次） 比如你打开了3个txt，切换到三个txt之一后，按capslock+LAlt+1（按三次1），然后三个txt都被绑定到capslock+1上，然后按capslock+1会在这三个txt之间切换，类似于Alt+tab，也会优先打开最常用的窗口 模式三类似于模式二，模式二可对不同程序的窗口绑定到同一按键，要分别绑定，模式三对同一程序的所有窗口绑定，只需绑定一次 Qbar Qbar是按capslock+q弹出的框，可以方便地浏览文件、打开文件、与打开网页或是用引擎搜索，Esc可关闭，重新按capslock+q可获得焦点，选中字符后按capslock+q会自动填入，选中文件会将路径填入。 输入cl set可以设置CapsLock+settings.ini文件 Qbar还能使用通配符，?表示单个，表示多个，如a?b匹配aab，abb，acb，adb等 ab匹配abb,abbb,accb等(不区分大小写) 可以按/或\\或tab进入下一层文件夹，按capslock+,返回上一层 Qbar中的QRun 可以在CapsLock+settings.ini中的[QRun]下添加想要快速运行的程序，只需在Qbar中键入相应名字即可，也可直接在Qbar中使用&quot; -&gt;run &quot;来设定，格式为： xxx -&gt; xxx 或 xxx -&gt;run xxx 注意第一种-&gt;两旁有空格，第二种-&gt;前面有空格，后面紧接run，run后面有空格 QRun也可设定用来打开文件的程序，比如在[QRun]下有aa = &quot;xxxx/xxx.exe&quot;，bb = &quot;xxx/xxxx&quot;，就会用aa打开bb Qbar中的QSearch 这个可以用搜索引擎快速搜索，内置了bd(百度)，wk（维基），g（谷歌），m（MDN），tb（淘宝），默认为百度 当然可以自定义... 例如改变默认搜索引擎，在CapsLock+settings.ini中的[QSearch]添加default=xxxxx) 也可以直接在Qbar中default -&gt; xxxx 这需要通过网址定位到搜索的关键词，并将关键词修改成{q} 添加自己的搜索引擎类似，CapsLock+settings.ini中的[QSearch]中添加，或在Qbar中使用 -&gt;search 添加 Qbar中的QWeb 打开网站，直接输入网址即可，可以在Qbar中使用-&gt;web 定义，也可在CapsLock+settings.ini中的[QWeb]下定义，xxx = xxxx ctrl+Enter可在前面加www.，后面加.com，如输入taobao，ctrl+Enter会打开www.taobao.com，对于含有.net，.com，.org，www.，http://，https://可以直接当作网址打开而不是用默认引擎去搜索，一些特定的网站可以加上web xxxx打开 自定义Qbar的样式 在CapsLock+settings.ini中的[QStyle]下设置 颜色可以是指定16种HTML基础颜色之一或6位的RGB颜色值(0x前缀可以省略)。例如：red、ffffaa、FFFFAA、0xFFFFAA。下面的颜色设置也一样。 borderBackgroundColor-----背景颜色，默认red borderRadius-------------------边框四角圆角程度，默认9 textBackgroundColor---------文字输入框的背景颜色，默认green textColor-------------------------输入文字的颜色，默认ffffff，白色 editFontName------------------输入文字的字体，默认Hiragino Sans GB W6 editFontSize--------------------输入文字大小，默认12 listFontName-------------------提示列表字体，默认consoals listFontSize---------------------提示列表字体大小，默认10 listBackgroundColor----------提示列表背景颜色，默认blue listColor--------------------------提示列表文字颜色，默认0x000000 listCount-------------------------提示列表行数，默认5 lineHeight-----------------------提示列表每行高度，默认19 progressColor------------------进度条颜色，默认0x00cc99 比如这是我的Qbar（好丑，对不对，好像比默认的还。。。） 自定义某些按键 在CapsLock+settings.ini中的[Keys]下可以改变一些capslock+按键的功能，也可以增加一些按键，capslock+支持的按键有: Capslock + (LALt + ) F1~F12 Capslock + (LALt + ) 0~9 Capslock + (LALt + ) a~z Capslock + (LALt + ) -=[];',./ Capslock + (LALt + ) Backspace, Tab, Enter, Space, RAlt keyFunc_volumeMute 静音 keyFunc_volumeDown 音量增大 keyFunc_volumeUp 音量减少 keyFunc_mediaPrev 上一首 keyFunc_mediaPlayPause 播放/暂停 以caps_开头，字母用小写表示，F1-F12用f1-f12表示，LALt用lalt表示，键位以keyFunc_开头，如caps_j=keyFunc_selectLeft，具体可用capslock+q输入cl CapsLock+settingsDemo.ini中查看 比如在CapsLock+settings.ini中的[Keys]下添加了caps_lalt_9=keyFunc_volumeMut，则按capslock+LAlt+9可以静音 ------------------------------------------------没有了---------------------------------------------------------- 这基本上就是capslock+的所有功能了，作者好像不怎么更新了，最新的版本是16年的 有一个问题就是其实capslock+e/d/s/f并不能完全代替上下左右的方向键，比如Alt+←是后退，但Alt+capslcok+s没有任何反应，当上下左右和其他键联合使用capslock还不能代替 ","link":"https://2293736867.github.io/post/qiang-da-de-gong-ju-yi-capslock/"}]}