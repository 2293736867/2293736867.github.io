{"posts":[{"title":"ssh+scp基本使用","content":"1 ssh ssh一般用于连接服务器，可以使用密码认证与密钥认证的方式。 1.1 密码认证 直接使用ssh即可： ssh username@xxx.xxx.xxx.xxx username为用户名，后面为公网ip. 若需要使用特定端口登录，加上p参数，比如使用12345端口： ssh -p 12345 username@xxx.xxx.xxx.xxx 1.2 密钥认证 密钥认证需要先生成密钥，然后把公钥使用scp上传到服务器，接着修改服务器的ssh配置文件。 1.2.1 生成密钥 ssh-keygen -t rsa -b 4096 -C &quot;email&quot; -f /xxx/id_rsa t表示加密算法，b指定位数，C表示注释，识别这个密钥，一般用邮箱即可。f表示生成的私钥文件位置（需要加上文件名），公钥会放在同一文件夹下。 1.2.2 上传公钥 使用scp上传公钥到服务器，注意是公钥，ssh-keygen会生成一个公钥与私钥，pub结尾的文件就是公钥，默认叫id_rsa.pub . scp /xxxx/id_rsa.pub username@xxx.xxx.xxx.xxx:/root/ 这里就直接放到服务器上的/root下。 1.2.3 修改ssh配置文件 先使用ssh密码认证的方式登录服务器，然后修改/etc/ssh/sshd_config： cd /etc/ssh cp sshd_config sshd_config.bak vim sshd_config 找到PubKeyAuthentication这一行，修改如下： 如果需要修改端口的，搜索Port，直接修改： 接着重启sshd服务： systemctl restart sshd 1.2.4 测试连接 ssh -i /xxx/id_rsa -p port username@xxx.xxx.xxx.xxx 其中i后为私钥的位置，p参数如果修改了默认的端口（22）则需要加上自定义端口。 如果在windows上生成的私钥，可能会有如下问题： 这里提示私钥的权限是755，也就是其他用户可读，需要修改为600： chmod 600 /xxx/id_rsa 如果用的是wsl可能会修改失败，需要加上wsl的配置，修改/etc/wsl.conf（如果没有就新建） vim /etc/wsl.conf 输入： [automount] enabled = true options = &quot;metadata,umask=22,fmask=11&quot; mountFsTab = false 退出wsl重启，然后再修改权限，应该就没问题了。 2 scp scp是secure copy的缩写，一般用于从服务器下载文件或上传文件到服务器，与ssh类似，可以使用密码认证或密钥认证或指定端口。 2.1 上传文件（夹）到服务器 scp localFile username@xxx.xxx.xxx.xxx:/xxxx scp -r localDir username@xxx.xxx.xxx.xxx:/xxx 上面是密码认证的方式，密钥认证请加上i参数，指定私钥位置： scp localFile username@xxx.xxx.xxx.xxx:/xxx scp -i /xxx/id_rsa -r localDir username@xxx.xxx.xxx.xxx:/xxxx 需要特定端口请加上P参数（注意是大写，不是ssh的小写p端口参数） scp -i /xxx/id_rsa -P xx localFile username@xxx.xxx.xxx.xxx 2.2 从服务器下载文件（夹） scp username@xxx.xxx.xxx.xxx:/xxx /localDir scp -r username@xxx.xxx.xxx:/xxx /localDir 第一个是下载文件，第二个是下载文件夹，需要加上r参数。 同理，密钥认证加i参数，端口加P参数： scp -i /xxx/id_rsa -P xx username@xxx.xxx.xxx.xxx:/xxx /localDir scp -i /xxx/id_rsa -P xx -r username@xxx.xxx.xxx.xxx:/xxx /localDir ","link":"https://2293736867.github.io/post/sshscp-ji-ben-shi-yong/"},{"title":"Nginx/Apache + acme.sh 实现https访问","content":" 1 概述 2 准备工作 2.1 域名与服务器 2.2 域名解析 2.2 端口 3 Nginx 3.1 编译安装的Nginx(1.17.9) 3.1.1 安装Nginx 3.1.2 证书处理 3.1.3 Nginx配置 3.1.4 测试 3.2 从仓库安装Nginx(1.16.1) 3.2.1 安装Nginx 3.2.2 证书处理 3.2.3 Nginx配置 3.2.4 测试 4 Apache 4.1 编译安装的Apache(2.4.41) 4.1.1 安装Apache 4.1.2 证书处理 4.1.3 Apache配置 4.1.4 测试 4.2 从仓库安装的Apache(2.4.6) 4.2.1 安装Apache 4.2.2 证书处理 4.2.3 Apache配置 4.2.4 测试 5 总结 1 概述 acme.sh实现了acme协议，可以从Let‘s Encrypt生成免费的ssl证书用于实现https，本文介绍了常见的两种服务器Apache与Nginx上利用acme.sh配置https服务。 约定: APACHE_INSTALL_DIR --- Apache安装目录 NGINX_INSTALL_DIR --- Nginx安装目录 www.test.com --- 测试域名,请按需要换成自己的域名 2 准备工作 一个域名 一台云服务器 2.1 域名与服务器 域名与服务器直接买就好了，笔者的都是在阿里云上买的。 2.2 域名解析 需要确保域名可以解析到对应的ip上面，一般的域名购买商会提供解析服务，按图形界面操作即可，以阿里云为例，选择域名进行解析： 主机记录填www，记录值填服务器公网ip. 间隔十分钟左右可以ping一下自己的域名，如果显示服务器ip则解析成功。 2.2 端口 服务器要开启80与443端口，80用于HTTP测试，443用于HTTPS访问。以阿里云为例: 3 Nginx Nginx有两种安装方式，一种是仓库形式安装，另一种是从源码编译安装。 3.1 编译安装的Nginx(1.17.9) 3.1.1 安装Nginx 先去下载源码，上传到服务器，解压： tar -zxvf nginx-1.17.9.tar.gz cd nginx-1.17.9 可以先使用 ./configure --help 查看选项帮助，这里要注意一下pcre与openssl，是源码目录，不是安装目录，安装之后删了源码的，重新来这里下载pcre与这里下载openssl，注意一定需要http_ssl_module这个模块，不要漏了。 ./configure --prefix=/xxxxx --with-pcre=/xxxxx --with-openssl=/xxxx --with-http_ssl_module make sudo make install 好了之后进入安装目录下的sbin，启动服务。 cd NGINX_INSTALL_DIR/sin ./nginx 然后可以在浏览器输入服务器公网ip测试一下： 3.1.2 证书处理 首先安装acme.sh curl https://get.acme.sh | sh . ~/.bashrc 生成证书 acme.sh --issue -d www.test.com --webroot NGINX_INSTALL_DIR/html webroot的话就直接使用Nginx的默认文档根目录。好了之后会看到这样的提示： 接着安装证书： acme.sh --installcert \\ -d www.test.com \\ --keypath /xxxx/xxx.key \\ --fullchainpath /xxx/xxx.pem 路径与名字随便，后缀不能变。 3.1.3 Nginx配置 修改Nginx配置文件： cd NGINX_INSTALL_DIR/conf cp nginx.conf nginx.conf.bak vim nginx.conf 找到HTTPS server这一行，这里是96行，把从server开始到最后一个花括号的代码全部去掉注释。 然后修改这三行，server_name填域名，ssl_certificate填刚才的pem文件路径，ssl_certificate_key填刚才的key文件路径。路径建议绝对路径，可以不加双引号。 记得记得要加上一行ssl协议： 3.1.4 测试 可以先使用-t测试语法错误： cd NGINX_INSTALL_DIR/sbin ./nginx -t ok的话，重启服务并输入域名测试： cd NGINX_INSTALL_DIR/sbin ./nginx -s stop ./nginx 成功！ 3.2 从仓库安装Nginx(1.16.1) 3.2.1 安装Nginx 从仓库安装就简单多了，一行就可以了，系统Centos，其他自行搜索： yum install nginx 可以先测试一下，直接用 nginx 开启服务，然后浏览器输入公网ip： （笔者有点怀疑是不是装了个假的Nginx，两个的主页居然不一样。。。。） 3.2.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot /usr/share/nginx/html 安装证书： acme.sh --installcert \\ -d www.test.com \\ --keypath /xxxx/xxx.key \\ --fullchainpath /xxx/xxx.pem 3.2.3 Nginx配置 同样先备份： cd /etc/nginx cp nginx.conf nginx.conf.bak vim nginx.conf 这里的配置比编译安装的又多了不少，一样从server（61行）开始去掉注释： 然后修改三行： server_name填域名，ssl_certificate填pem文件，ssl_certificate_key填key文件。 最后增加一行ssl协议： 3.2.4 测试 可以先用-t测试语法错误： nginx -t ok的话重启服务： nginx -s stop nginx 浏览器输入域名访问： 4 Apache Apache也有两种安装方式，从源码编译安装与从仓库安装。 4.1 编译安装的Apache(2.4.41) 4.1.1 安装Apache 编译安装Apache比较麻烦，需要安装pcre，apr，apr-util，生成Makefile时需要指定以下几个选项： --with-apr \\ --with-apr-util \\ --with-pcre \\ --enable-ssl \\ --with-ssl 具体可以看这里。 安装好了之后需要先确定ssl模块是否存在： cd APACHE_INSTALL_DIR/modules ls | grep ssl 如果没有显示mod_ssl.so，则需要重新安装，确定生成Makefile时没有漏掉 --enable-ssl 与 --with-ssl 如果有ssl模块，直接修改配置文件测试一下。 cd APACHE_INSTALL_DIR/conf vim httpd.conf 修改ServerName为 localhost:80 启动服务输入localhost测试： cd APACHE_INSTALL_DIR/bin ./apachectl 页面只有一行It works!： （话说这和仓库安装的Apache首页差距这么大。。。） 4.1.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot APACHE_INSTALL_DIR/htdocs 这里webroot为Apache默认的文档根目录. 安装证书： acme.sh --installcert -d www.test.com \\ --key-file /xxxx/xxx.key \\ --cert-file /xxxx/xxxx.crt \\ --fullchain-file /xxx/xxxfullchain.crt 路径与名字随便，后缀名不能变。 4.1.3 Apache配置 首先修改conf/httpd.conf： cd APACHE_INSTALL_DIR/conf cp httpd.conf httpd.conf.bak vim httpd.conf 找到这三行，去掉注释。 然后修改httpd-ssl.conf: cd extra cp http-ssl.conf http-ssl.conf.bak vim httpd-ssl.conf DocumentRoot可以默认，ServerName改成 www.test.com:443 然后修改这三行，把证书的文件相应填入。 4.1.4 测试 语法检查： cd APACHE_INSTALL_DIR/bin ./apachectl -t 没有错误之后重启服务： ./apachectl stop ./apachectl 浏览器输入域名访问： 4.2 从仓库安装的Apache(2.4.6) 4.2.1 安装Apache yum install httpd 修改配置文件并进行测试： cd /etc/httpd/conf cp httpd.conf httpd.conf.bak vim httpd.conf 找到ServerName改成 localhost:80 开启服务后输入localhost:80. systemctl start httpd 另外要确保ssl模块存在： cd /etc/httpd/modules ls | grep ssl 如果没有输出的话，证明没有ssl模块，需要安装： yum install mod_ssl 再一次grep： ls | grep ssl 4.2.2 证书处理 没安装acme.sh的先安装： curl https://get.acme.sh | sh . ~/.bashrc 申请证书： acme.sh --issue -d www.test.com --webroot /var/www/html 其中/var/www/html为Apache默认文档根目录。 安装证书： acme.sh --installcert -d www.test.com \\ --key-file /xxxx/xxx.key \\ --cert-file /xxxx/xxxx.crt \\ --fullchain-file /xxx/xxxfullchain.crt 4.2.3 Apache配置 修改ssl.conf: cd /etc/httpd/conf.d cp ssl.conf ssl.conf.bak vim ssl.conf 修改ServerName与DocumentRoot，ServerName填域名，DocumentRoot直接去掉注释。接着修改以下三行，根据刚才生成的三个文件对应填入即可。 4.2.4 测试 apachectl -t 没有语法错误就重启服务： systemctl stop httpd systemctl start httpd 浏览器输入访问： 5 总结 其实这里采用了比较麻烦的方式手动安装证书，acme.sh其实还有更简单的不需要webroot的命令： acme.sh --issue -d www.test.com --apache acme.sh --issue -d www.test.com --nginx 另外还可以通过手动dns的方式： acme.sh --issue -d www.test.com --dns dns_xxx 这种方式可以利用域名解析商提供的api自动添加记录完成认证，可以参考这里。 另外文章没有说到证书过期更新的问题，可以看官方中文说明，这里。 除此之外还可以利用openssl使安全性的评分更高，测试网站这里，修改配置这里。 还有最后一个,现有云服务器厂商提供了免费的证书购买，如阿里云，可以直接购买免费证书然后利用文档安装到服务器上。 祝你们早日有一个属于自己的https的网站。 ","link":"https://2293736867.github.io/post/nginxapache-acmesh-shi-xian-https-fang-wen/"},{"title":"Github Pages+Gridea搭建个人博客","content":"1 概述 Github Pages可以用来托管个人网站，静态的，便于用来实现博客，可以在一个仓库的settings中开启： Gridea是一个静态博客写作客户端，所有文件都在本地，没有数据库，实现简单，支持Markdown。 好了不多说开始动手。 2 准备工作 一个Gthub账号 一个Github Pages的仓库 一个Gridea客户端（支持Mac，Windows，Linux） （可选）一个域名 3 Github Pages 仓库名是: 用户名.github.io 需要公开仓库与一个REDAME文件,然后创建. 进入设置开启Github Pages: 下拉找到Github Pages: 默认使用master分支,可以选择主题. 然后在浏览器输入刚才创建的仓库名就可以访问了. 4 Gridea 理论上来说这样就完成了,但是如果想更好看和更方便管理一些,就要用Gridea. 先去下载,官网这里. 下载之后直接打开,进入设置: 域名与仓库名一样,分支填master,email自己填,这里说一下Token.打开设置中的开发者设置: 新建一个Token: 只需要勾选仓库相关的权限,名字可以随便. 复制填入. 然后可以测试一下连接: 若失败请返回前几步看看哪里出错. 设置好了之后可以设置主题等,自定义美化. 设置好了之后可以先预览再同步. 同步完成后就可以在浏览器输入 用户名.github.io 进行访问了. 5 绑定域名(可选) 如果购买了域名的话,可以绑定到自己的域名上面,笔者的域名是阿里云上购买的,因此这里以阿里云的为例,进入域名的解析页面,添加两个记录: 第一个记录类型是CNAME,主机记录是www,记录值为仓库的名字. 第二个记录类型是A,主机记录是@,记录值为ping仓库名字得到的ip. 若成功的话会这样显示: 添加之后在Gridea的客户端中设置的CNAME添加域名: 使用左下角的按钮测试一下,测试通过之后就可以通过域名访问了. 如果想通过https访问,直接在Github Pages中设置Enforce HTTPS即可(解析域名之后需要一定时间才可以勾选). 之后就可以通过https访问了. ","link":"https://2293736867.github.io/post/github-pagesgridea-da-jian-ge-ren-bo-ke/"},{"title":"编译安装Apache遇到的缺少expat.h与undefined reference to `XML_GetErrorCode'错误","content":"1 缺少expat.h 编译安装Apache需要apr-util，而在编译安装apr-util时提示说缺少expat.h，此时直接安装expat库即可（centos）： yum install expat-devel 2 undefined reference to `XML_GetErrorCode' 首先安装libxml2-devel包： yum install libxml2-devel 接着删除apr-util安装目录并重新编译安装： sudo rm -rf /usr/local/apr-util cd apr-util make clean ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr make make install 目录的话根据需要修改，最后重新编译安装apache： cd httpd-xxxxx make clean ./configure \\ --prefix=/usr/local/apache \\ --with-apr=/usr/local/apr \\ --with-apr-util=/usr/local/apr-util \\ --with-pcre=/usr/local/pcre 同样目录按需修改。 ","link":"https://2293736867.github.io/post/bian-yi-an-zhuang-apache-yu-dao-de-que-shao-expath-yu-undefined-reference-to-xml_geterrorcodecuo-wu/"},{"title":"Android Activity间跳转与传递数据","content":" 1 概述 2 Activity间跳转 2.1 直接跳转 2.2 回调 3 Activity间传递数据 3.1 传递普通数据 3.2 传递一组数据 3.3 传递对象 4 源码 1 概述 Activity之间的跳转主要使用 startActivity(Intent intent); startActivityForResult(Intent intent,int requestCode); 这两个函数,传递数据的话利用Intent进行传递,负责数据需要配合Bundle使用.这篇文章讲述了如何利用这两个函数在Activity之间的跳转以及传递数据. 2 Activity间跳转 2.1 直接跳转 这里有两个Activity:FirstActivity与SecondActivity,从FirstActivity中跳转到SecondActivity中只需要一个startActivity()即可: startActivity(new Intent(this,SecondActivity.class)); 一般需要在SecondActivity中加上finish()函数,表示这个Activity结束,比如这里直接在SecondActivity的按钮事件里面加上了finish(): 2.2 回调 很多情况下需要在FirstActivity跳转到SecondActivity后,在SecondActivity进行相应的操作,如更新数据之类,然后返回FirstActivity,通知FirstActivity执行某些操作,这时候就需要使用startActivityForResult(). startActivityForResult有两个参数,一个是Intent,表示将要跳转的Activity,一个是requestCode(int类型),表示请求码,用于调用Activity的onActivityResult()函数. 如FirstActivity中: startActivityForResult(new Intent(this,SecondActivity.class),11); 这里11就是请求码,然后在SecondActivity中,使用setResult()函数: setResult(22,new Intent().putExtra(&quot;str&quot;,&quot;from second activity&quot;)); setResult()接受两个参数,第一个参数表示resultCode,从这个SecondActivity返回的结果码,另一个Intent,表示要返回给FirstActivity的数据. 最后在FirstActivity中重载onActivityResult(): onActivityResult中判断请求码与结果码后进行相应操作. 3 Activity间传递数据 3.1 传递普通数据 传递普通类型的数据直接使用Intent的putExtra()即可,putExtra接受两个参数,第一个是一个String,表示键,第二个是值,类型可以是byte,char,short,long等基本类型与这些基本类型组成的数组,当然String也可以. 比如在FirstActivity中,传递数据给SecondActivity: 然后在SecondActivity中使用getIntent()获取Intent后,再从里面获取数据: 如果想从SecondActivity中返回数据给FirstActivity,也就是从被调用的Activity中返回数据,可以使用前面介绍过的setResult()方法. 其中第二个参数是一个用于存储数据的Intent,把数据put进去即可. 最后记得在onActivityResult做相应的判断处理: 3.2 传递一组数据 当数据的种类变多时,比如混合了int,String,byte,char等,可以对逐个类型使用putExtra(),但更好的方法是使用Bundle. Bundle的使用与Intent类似,也是对于不同的类型采用键值对的添加方法,直接putXXX: 数据添加完毕之后,在intent中使用putExtras(bundle): 然后就可以在SecondActivity中接收数据了. 首先需要使用getIntent().getExtras()获取Bundle,再获取里面的数据. 注意一下获取到的Bundle有可能为null,取数据前需要判断一下. 3.3 传递对象 如果想要传递的数据是一个对象怎么办?难道对每一个属性都使用getter再放进去吗? 并不是,Bundle提供了一个处理序列化对象的方法: 只要对象实现了Serializable,就可以被Bundle处理,比如这里有一个测试类Student: 然后在FirstActivity中直接new一个,并使用Bundle的putSerializable即可. 接着再SecondActivity中通过Intent取出Bundle后,使用其中的getSerializable()取出对象,最后使用强制类型转换: 4 源码 github 码云 ","link":"https://2293736867.github.io/post/android-activity-jian-tiao-zhuan-yu-chuan-di-shu-ju/"},{"title":"一文吃透jQuery选择器!","content":" 1 jQuery选择器 2 基本选择器 2.1 id选择器 2.2 元素选择器 2.3 类选择器 2.4 通配符选择器 2.5 组合选择器 3 层级选择器 3.1 后代选择器 3.2 子代选择器 3.3 相邻选择器 3.4 兄弟选择器 4 过滤选择器 4.1 基本过滤器 4.1.1 两端类 4.1.2 范围索引类 4.1.3 奇偶类 4.1.4 其他 4.2 内容过滤器 4.3 可见性过滤器 4.4 属性过滤器 4.5 子元素过滤器 4.5.1 索引过滤器 4.5.1.1 first-child与last-child 4.5.1.2 nth-child与nth-last-child(1.9+) 4.5.2 类型过滤器(1.9+) 4.5.3 唯一过滤器 4.6 表单对象属性过滤器 5 表单选择器 5.1 文本框类 5.2 选择框类 5.3 按钮类 5.4 其他 5.5 例子 1 jQuery选择器 jQuery选择器用于选择DOM元素进行相应操作,允许通过多种方式选择,包括标签名,属性名,类名,id等对元素进行选择,基于CSS选择器.jQuery中所有的选择器都以$符号开头,后面加一对括号. jQuery选择器可以分为基本选择器,层次选择器,过滤选择器与表单选择器. 2 基本选择器 基本选择器可以分成五个: id选择器 元素选择器 类选择器 通配符选择器 组合选择器 2.1 id选择器 id选择器根据给定的id匹配一个元素,以 # 开头,如有: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 则选择器 $(&quot;#div1&quot;) 会选择 如果id中含有特殊字符,比如点: &lt;div id=&quot;div1.1.1&quot;&gt;&lt;/div&gt; 则需要使用双反斜杠转义: $(&quot;#div1\\\\.1\\\\.1&quot;) 2.2 元素选择器 根据元素的标签名查找所有符合的元素.假设有: &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; 选择器 $(&quot;div&quot;) 会选择所有div元素. 2.3 类选择器 根据给定的css类名匹配元素,以 . 开头.如有: &lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; &lt;p class=&quot;class1&quot;&gt;&lt;/p&gt; &lt;div class=&quot;class2&quot;&gt;&lt;/div&gt; 选择器 $(&quot;.class1&quot;) 会选择: 选择器 $(&quot;.class2&quot;) 会选择: 2.4 通配符选择器 选择所有的元素. &lt;div&gt;div&lt;/div&gt; &lt;p&gt;p&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; $(&quot;*&quot;) 会显示 也就是说整个&lt;html&gt;都在选择范围内,不仅仅是&lt;body&gt;. 若要选择&lt;body&gt;内的元素,可用 $(&quot;body *&quot;) 2.5 组合选择器 组合选择器就是多个选择器的组合,用 , 分隔每一个选择器,如有: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;class2&quot;&gt;&lt;/div&gt; $(&quot;#div1,p,.class2&quot;) 会选择 3 层级选择器 层级选择器共有四种:后代选择器,子代选择器,相邻选择器,兄弟选择器. 3.1 后代选择器 根据祖先元素选择所有的后代元素,使用空格分隔,如有 &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; $(&quot;#div1 div&quot;) 会选择 3.2 子代选择器 选择给定父元素下的所有子元素,使用 &gt; 分隔,同样上面的例子: $(&quot;#div1&gt;div&quot;) 会选择 两者的区别在于后代选择器会选择所有的后代,不管里面有多少后代(层),而子选择器只会选择直接后代,也就是只选择&quot;一代&quot;后代(层). 3.3 相邻选择器 选择紧接在指定元素后面的元素,用 + 分隔,如有 &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; $(&quot;#div1+p&quot;) 会选择 可用 .next() 代替,如上面的例子可以变为 $(&quot;#div1&quot;).next() 3.4 兄弟选择器 选择之后的所有兄弟元素,用 ~ 分隔,如有 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; 则 $(&quot;div~p&quot;) 会选择 可用 .nextAll() 代替,如上面的例子可以表示为: $(&quot;div&quot;).nextAll(&quot;p&quot;) 如果没有加上p选择器: $(&quot;div&quot;).nextAll() 会选择 等价于 $(&quot;div~*&quot;) 与相邻选择器的区别:兄弟选择器会选择后面所有的兄弟,而相邻选择器只选择第一个兄弟. 4 过滤选择器 过滤选择器种类最多,可以分为: 基本过滤器 内容过滤器 可见性过滤器 属性过滤器 子元素过滤器 表单对象属性过滤器 下面一个个进行说明. 4.1 基本过滤器 根据某类过滤规则进行选择,以 : 开头. 4.1.1 两端类 过滤器 作用 :first 选择第一个元素 :last 选择最后一个元素 html: &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div&gt;p:first&quot;) $(&quot;div&gt;p:last&quot;) 4.1.2 范围索引类 过滤器 作用 :eq(index) 选择指定索引值元素 :gt(index) 选择大于给定索引值元素 :lt(index) 选择小于给定索引值元素 注意索引从0开始,要与下面的:nth-child/:nth-last-child/:nth-of-type/:n-last-of-type区分. html: &lt;div&gt; &lt;p id=&quot;index0&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;index5&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div&gt;p:eq(3)&quot;) $(&quot;div&gt;p:lt(2)&quot;) $(&quot;div&gt;p:gt(4)&quot;) 4.1.3 奇偶类 选择索引值为奇/偶的元素,从0开始计数. 过滤器 作用 :odd 选择索引值为奇数的元素 :even 选择索引值为偶数的元素 html: &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div&gt;p:odd&quot;) $(&quot;div&gt;p:even&quot;) odd为什么是246?even为什么是135? 难道结果错了? 并不是,下标从0开始计数,下标为0的&lt;p&gt;的id为p1,算进去偶数里了. 4.1.4 其他 过滤器 作用 :header 选择标题元素,如&lt;h1&gt;,&lt;h2&gt; :animated 选择正在执行动画效果的元素 :focus(1.6+) 选择当前获取焦点的元素 :root(1.9+) 选择根元素,也就是&lt;html&gt; :target(1.9+) 这个比较特殊,与URI有关,选择ID和特定标识符相匹配的元素比如给定了URI http://xxx.com#ttt , $(&quot;p:ttt&quot;)会选择&lt;p id=&quot;ttt&quot;&gt; :lang(language)(1.9+) 选择指定语言的所有元素 :not(selector) 反选器 挑取一些简单演示,html: &lt;div lang=&quot;en&quot;&gt; &lt;h1 id=&quot;h1&quot;&gt;&lt;/h1&gt; &lt;h2 id=&quot;h2&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div lang=&quot;zh-CN&quot;&gt;&lt;/div&gt; &lt;div lang=&quot;en&quot;&gt;&lt;/div&gt; 选择器: $(&quot;:header&quot;) $(&quot;:root div&quot;) $(&quot;div:not(:lang(zh-CN))&quot;) 4.2 内容过滤器 四种: 过滤器 作用 :contains(text) 选择包含给定文本的元素 :has(selector) 选择含有过滤器所匹配的元素的元素 :empty 选择不包含子元素或文本为空的元素 :parent 选择含有子元素或文本为的元素 html: &lt;div id=&quot;div1&quot;&gt;123&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;123&lt;/div&gt; &lt;div id=&quot;div5&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; 选择器: $(&quot;body *:contains(123)&quot;) $(&quot;body *:has(#div3)&quot;) $(&quot;body *:empty&quot;) $(&quot;div:parent&quot;) 4.3 可见性过滤器 过滤器 作用 :visible 选择可见元素 :hidden 选择不可见元素 html: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; 选择器: $(&quot;body *:hidden&quot;); $(&quot;body *:visible&quot;); 4.4 属性过滤器 属性过滤器针对元素的属性进行过滤,包括有没有该属性,该属性的值,以某些值开头/结尾,包含某些值等,使用 [] 表示属性过滤器. 过滤器 作用 [attr] 选择包含attr属性的元素,常见的是[id],选择包含id属性的元素. [attr=value] 选择attr属性为value的元素,如[name=123],[id=div1] [attr!=value] 选择不含有attr属性,或含有attr属性,但是值不为value的元素.等价于:not([attr=vale])如果想要选择包含特定属性但是属性值不为value的元素请使用[attr]:not([attr=value]) [attr^=value] 选择attr属性值是以value开始的元素 [attr$=value] 选择attr属性值是以value结尾的元素 [attr*=value] 选择attr属性值是包含value的元素 html: &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot; name=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot; name=&quot;div3&quot;&gt;&lt;/div&gt; 选择器: $(&quot;[id]&quot;) $(&quot;[id$=3]&quot;) $(&quot;body *[name!=div2]&quot;) $(&quot;body *[name*=div]&quot;) 4.5 子元素过滤器 可以按照索引顺序(即第一个,倒数第几个等)或者按照类型或者按照唯一性对子元素进行过滤. 4.5.1 索引过滤器 过滤器 作用 :first-child 选择第一个子元素,等价于:nth-child(1) :last-child 选择最后一个子元素 :nth-child 选择第n个子元素 :nth-last-child 选择倒数第n个子元素 4.5.1.1 first-child与last-child 先来看看first-child与last-child: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:first-child&quot;) $(&quot;div p:last-child&quot;) 注意与:first/:last的区别,:first/:last只会选择整个父级元素的第一个/最后一个元素,但是:first-child/:last-child会选择每个父级元素的第一个/最后一个元素. :first/:last把所有符合的元素看作一个整体,即使其中有并列的父级元素,而:first-child/:last-child把每个父级元素单独看待,选择每个父级元素的第一个/最后一个元素. 4.5.1.2 nth-child与nth-last-child(1.9+) nth-child选择父元素下第n个元素,注意,从1开始计数. &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:nth-child(3)&quot;) 注意与:eq的区别,有点类似:first/:first-child的区别,:eq会把所有符合条件的元素看作一个整体,而且不要忘记:eq是从0开始计数. 另一方面,nth-child支持奇偶与代数表达式,比如: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p7&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p8&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p9&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p10&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p11&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;div p:nth-child(odd)&quot;) $(&quot;div p:nth-child(even)&quot;) $(&quot;div p:nth-child(3n+1)&quot;) $(&quot;div p:nth-child(4n-3)&quot;) 计数也是从1开始. nth-last-child与nth-child类似,需要1.9以上的版本,看名字就知道,是选择倒数第n个的,同样支持奇偶与代数表达式. $(&quot;div p:nth-last-child(2)&quot;) $(&quot;div p:nth-last-child(odd)&quot;) $(&quot;div p:nth-last-child(even)&quot;) $(&quot;div p:nth-last-child(3n+1)&quot;) 对于nth-last-child的odd/even/代数表达式来说,从最后一个符合条件的开始选择,但是按原来的顺序排列. 4.5.2 类型过滤器(1.9+) 有四种: :first-of-type :last-of-type :nth-of-type :nth-last-of-type first-of-type会选择符合条件的元素的父元素的第一个该类型的子元素. 例如, &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器: $(&quot;p:first-of-type&quot;) 若使用id选择器: $(&quot;#p2:first-of-type&quot;) 则结果为空. 为什么? 因为此时选择的是id为p2的元素,但是这个 &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; 的前面有一个 &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; 也就是说 &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; 不是第一个孩子,因此选择为空,此时若把第一个孩子注释: &lt;div id=&quot;div1&quot;&gt; &lt;!-- &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; --&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 则 $(&quot;#p2:first-of-type&quot;) 会选择 多个父级元素也是一样的道理: &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p class=&quot;a&quot; id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;p class=&quot;a&quot; id=&quot;p5&quot;&gt;&lt;/p&gt; &lt;/div&gt; $(&quot;.a:first-of-type&quot;) last-of-type/nth-of-child/nth-last-of-type类似,要注意的是nth-of-child/nth-last-of-type都支持奇偶与代数表达式,计数从1开始. 4.5.3 唯一过滤器 两种: only-child only-of-type(1.9+) 如果某个元素是它父元素的唯一子元素,则only-child会选择该(子)元素. &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; 选择器 $(&quot;div p:only-child&quot;) 会选择 注意文本并不会影响选择的结果,也就是说,改成 &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; 456 &lt;p id=&quot;p3&quot;&gt;123&lt;/p&gt; 456 &lt;/div&gt; 后,选择器不变,选择的结果只是p里面多了文字: 而如果某个元素的父元素只有唯一一个该元素类型的子元素,则only-of-type会选择该元素,注意是类型,不是数量. 上面的only-child指的是数量,也就是只有一个孩子,这里only-of-type指的是类型,只有一个这种类型的孩子,而不管孩子数量. &lt;div&gt; &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; $(&quot;div p:only-of-type&quot;) 会选择 而如果选择器换成only-child: $(&quot;div p:only-child&quot;) 则会选择 4.6 表单对象属性过滤器 选择以下三种状态的元素: 可用 不可用 选中 过滤器 作用 :enabled 选择可用元素 :disabled 选择不可用元素 :checked 选择所有被选中的元素 :selected 选择所有被选中的option元素(针对&lt;select&gt;) &lt;input type=&quot;checkbox&quot; checked/&gt; &lt;input type=&quot;radio&quot; checked&gt; &lt;input type=&quot;radio&quot; id=&quot;disabled&quot; disabled/&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;select&gt; &lt;option value=&quot;1&quot;&gt;&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;&lt;/option&gt; &lt;/select&gt; $(&quot;body *:enabled&quot;) $(&quot;:disabled&quot;) $(&quot;:selected&quot;) $(&quot;:checked&quot;) 5 表单选择器 5.1 文本框类 过滤器 作用 :text 选择所有文本框 :password 选择所有密码框 5.2 选择框类 过滤器 作用 :radio 选择所有单选框 :checkbox 选择所有多选框 5.3 按钮类 过滤器 作用 :submit 选择所有提交按钮 :reset 选择所有重置按钮 :button 选择所有按钮 5.4 其他 过滤器 作用 :image 选择所有图像域 :file 选择所有文件域 5.5 例子 &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;password&quot; /&gt; &lt;input type=&quot;radio&quot; /&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;input type=&quot;button&quot; /&gt; &lt;input type=&quot;image&quot; /&gt; &lt;input type=&quot;file&quot; /&gt; $(&quot;:text&quot;) $(&quot;:password&quot;) $(&quot;:radio&quot;) $(&quot;:checkbox&quot;) $(&quot;:submit&quot;) $(&quot;:reset&quot;) $(&quot;:button&quot;) $(&quot;:image&quot;) $(&quot;:file&quot;) ","link":"https://2293736867.github.io/post/yi-wen-chi-tou-jquery-xuan-ze-qi/"},{"title":"android studio sync失败","content":"1 原因 sync失败或gradle同步慢的原因基本上就是网络的问题,这里采用的办法是在Maven的设置文件添加国内镜像. 2 添加镜像 Maven的settings.xml中,在&lt;mirrors&gt;中添加: &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 这样android studio同步的速度就会很快了. ","link":"https://2293736867.github.io/post/android-studio-sync-shi-bai/"},{"title":"jquery hello world","content":"1 jQuery jQuery是一个js库,一个js文件,极大地简化了编程,官网链接在这里,有compressed,uncompressed版本,使用时一样. 2 hello world &lt;html&gt; &lt;head&gt; &lt;title&gt;jquery hello world&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;p&quot;).html(&quot;hello world&quot;); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; jQuery使用时直接从官网引入文件即可,这里用的是3.4.1版本. $(function()) 是 $(document).ready(function(){}) 的缩写,这个函数会在DOM加载完成后执行. $(&quot;p&quot;) 表示选择页面的所有&lt;p&gt;元素,html()可以设置元素的内容. ","link":"https://2293736867.github.io/post/jquery-hello-world/"},{"title":"MySQL数据类型全解析","content":"1 概述 本文主要介绍了MySQL的各种数据类型,版本为8.x, MySQL的数据类型可以分为六类:数值类型,日期时间类型,字符串类型,二进制类型,JSON类型与空间数据类型. 2 数值类型 数值类型是最基本的类型,可以分为整数类型与浮点数类型. 2.1 整型 类型 字节数 无符号范围 有符号范围 TINYINT 1 [0,255] [-128,127] SMALLINT 2 [0,65535] [-32768,32767] MEDIUMINT 3 0-1677w +-838w INT/INTEGER 4 0-42e +-21e BIGINT 8 0-18446744e +-9223372e 没写出的具体的精确值无符号的范围计算公式如下: 有符号的计算公式如下: 所有整形如果允许NULL的话默认为NULL,不允许为NULL的需要手动设置默认值. 如果插入或修改的数据范围不符合会提示操作失败,如上图提示列c_mediumint的数据超出范围. 2.2 浮点型 可以用两种方式来表示小数,分别是浮点数类型与定点数类型. 浮点数用于不需要太精确的小数场合,类型包括FLOAT与DOUBLE,定点数类型就是DECIMAL. 类型 字节数 范围 FLOAT 4 +- 1.17e-38 - 3.4e+38 和 0 DOUBLE 8 +- 2.22e-308 - 1.79e+308 和 0 DEC(M,D)/DECIMAL(M,D) 取决于M与D 取决于M与D 下面是测试的待插入的数据: 插入之后再查询: 可以看到,float的精度最高为6位,后面的进行四舍五入,DOUBLE的最高精度为15位. 下面来说一下DECIMAL. 2.3 DECIMAL DECIMAL也可用DEC来表示,用于计算精确的小数值,DECIMAL通常如下表示: DECIMAL(M,D) 类型 含义 取值范围 默认值 M 十进制有效数字总个数 1-65 10 D 小数点后十进制数字个数 0-30(D&lt;=M) 0 如果要计算所占用的字节数,需要分为整数与小数两部分,分开计算再相加,每部分又按照9位数字去拆分,计算规则如下: 位数 占用字节数 1-2 1 3-4 2 5-6 3 7-9 4 也就是说对于 DECIMAL(24,8) 整数部分24-8=16位,小数部分8位,小数部分的8位根据规则所占用的字节数为4个,整数部分按每9位进行拆分,16=9+7,9位的部分占4个字节,7位的部分按照规则也占4个字节,所以整数部分占8个字节,加上小数部分的4个字节,总共占12个字节. 至于NUMERIC,在MySQL中,NUMERIC被实现为DECIMAL: 3 日期与时间类型 总共有五类:YEAR,TIME,DATE,DATETIME,TIMESTAMP. 3.1 日期 日期有两种类型:YEAR与DATE,YEAR表示年,DATE表示日期. 类型 字节数 取值范围 YEAR 1 [1901,2155] DATE 3 [1000-01-01,9999-12-31] DATE中的年月日插入时可以不分隔或者用各种符号进行分隔,比如 ! @ # $ % ^ &amp; * ( ) - / \\ [ ] { } : ; ' &quot; | , . &lt; &gt; ? 上图中的date都是合法的,插入之后MySQL都会统一用横杠代替: YEAR的话MySQL其实允许两位数的YEAR,其中00-69表示2000-2069,70-99表示1970-1999. 其他插入方式的话可以用CURRENT_DATE,CURRENT_DATE(),CURDATE(),NOW(),CURTIME(),CURRENT_TIME,CURRENT_TIME(): 3.2 时间 时间就一种类型:TIME. TIME所占的字节数为3个字节,取值范围为: [-838:59:59,838:59:59] 插入时时分秒可以不分隔或者必须以冒号分隔. 插入后统一变为冒号分隔: 可以使用CURRENT_TIME或CURRENT_TIME(),CURTIME()或NOW()插入: 甚至也可以使用CURDATE(),不过此时插入的是零值: 3.3 日期+时间 TIMESTAMP与DATETIME: 类型 字节数 取值范围 DATETIME 8 [1000-01-01 00:00:00,9999-12-31 23:59:59] TIMESTAMP 4 [19700101080001,20380119111407] DATETIME就是DATE与TIME的结合,先DATE再TIME,空格分隔. TIMESTAMP表示时间戳,表示当前时间到1970年1月1日0时0分0秒经过的秒数,中的写法是年月日时分秒,比如 19700101080001 表示 1970年1月1日8时0分01秒 这里之所以使用080001是因为中国的时区. 19700101000000 会报错,范围不允许. 19700101080000 也不行. 在插入时可以指定默认值,使用now()或CURRENT_TIMESTAMP: 插入后DATETIME与TIMESTAMP存储的形式一致,横杠分隔日期,冒号分隔时间,时间与日期用空格隔开. 也可以使用CURTIME()或CURDATE()插入,对于CURTIME(),日期采用当前日期,对于CURDATE(),时间采用 00:00:00 4 字符串类型 4.1 CHAR/VARCHAR 类型 最大长度 特点 CHAR 255个字符 长度固定,CHAR(M)表明CHAR的长度为M个字符,所占用的字节数为字符个数*每个字符所占用字节数,也就是说与字符集有关,定长的效率较高,一般用于存储固定位数的数据或经常需要更新的数据,如电话号码,身份证,MD5值等.保存CHAR时,会在末尾填充空格用于对齐,查询时自动把空格删除 VARCHAR 65535字节,字符个数为(最大行大小-NULL标识-长度标识)/字符集单字符最大字节数,可以看这里 长度不固定,实际占用的空间为字符串实际长度+1/2,也就是说需要额外的1或2个字节记录字符串的长度.相对来说VARCHAR比CHAR更节省空间,但是在UPDATE时可能会使行变得更长,需要做额外的工作.VARCHAR适合存储字段更新少,字符串平均长度不稳定的情况 无论是CHAR还是VARCHAR,超过了创建时指定的长度便插入失败: 4.2 TEXT TEXT是一种专用于存储长文本的变长数据类型,包括TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT: 类型 允许长度(字节) 存储空间 TINYTEXT [0,255] 长度+2字节 TEXT [0,65535] 长度+2字节 MEDIUMTEXT 0-1677w 长度+3字节 LONGTEXT 0-42e 长度+4字节 TEXT在插入时超过最大允许长度会插入失败. 4.3 ENUM 枚举类型,在创建表时enum的取值范围以列表的形式指定: ENUM('value1','value2',...,'valuen') ENUM占用1或2个字节,列表中最多能有65535个值,每个值末尾的空格都会被删除,列表中的每个值独有一个顺序排列的编号,MySQL会存入这个编号而不是对应的值. 等价于 即取值列表的编号从1开始. 4.4 SET SET占用1或2或3或4或8个字节,取决于里面元素的数量,最大数量为64.SET可以是一个或多个元素的组合,值后面多余的空格会被删除,取多个元素时,不同元素用逗号隔开. 如: 插入前: 插入后: 5 二进制类型 5.1 BIT BIT在创建时指定最大长度: BIT(M) M表示最大二进制数的位数,M取值1-64,默认1,插入数据时,如果数据在BIT允许的范围则插入成功,否则插入失败. 插入时需要加上b前缀,后面跟的字符串由0与1组成: 查询之后就变成了十进制: 5.2 BLOB BLOB是特殊的二进制数据类型,用来保存数据量很大的二进制数据,如图片等,BLOB包括TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOG,与TEXT类似: 类型 允许长度(字节) 存储空间 TINYBLOB [0,255] 长度+2字节 BLOB [0,65535] 长度+2字节 MEDIUMBLOB 0-1677w 长度+3字节 LONGBLOB 0-42e 长度+4字节 5.3 BINARY/VARBINARY BINARY(M)/VARBINARY(M)中的M指的是字节长度,由于BINARY/VARBINARY存储的是二进制字符串,因此没有字符集的概念. 类型 最大长度 特点 BINARY 255字节 定长,允许长度0-M的二进制字符串,不足最大长度的空间由0x00补全,查询时不会截断后面的0x00,比较时所有字节都有效 VARBINARY 65535字节 变长,不会在后面填充0x00. 下面的例子演示了插入时填充0x00: 这里的BINARY为3个字节,插入了a,等价是插入了 a\\0\\0 两个\\0填充后面两个字节,因此,前面两个比较的结果都为0. 比较时按照二进制值进行比较,这与CHAR/VARCHAR有很大不同. CHAR/VARCHAR比较的是字符值,忽略后面的空格,因此比较结果为1,但是BINARY比较的是二进制值,'a'的二进制值化为十六进制为61,'a '的二进制值化为十六进制为6120,因此比较结果为0. 6 JSON类型 JSON存储的数据不能是NULL,只能是JSON格式的数据,否则会报错, 创建很简单,直接为JSON类型: 插入时可以使用一个JSON对象或JSON数组,数组用方括号,一个对象用花括号: MySQL同时提供了一组操作JSON的函数,具体看这里. 这里演示了json_object函数,用来创建一个JSON对象: 插入后: 7 空间数据类型 Spatial数据,又叫空间或几何数据,包含的数据类型有 GEOMETRY POINT LINESTRING POLYGON 其中GEOMETRY可用于存储任意几何类型.其他集合类型的空间数据类型如下: MULTIPOINT MULTILINESTRING MULTIPOLYGON GEOMETRYCOLLECTION 其中GEOMETRYCOLLECTION可以存储任意类型的集合. 下面仅对POINT的使用作简单介绍. 插入数据使用st_geomfromtext()函数,参数是一个point(),里面的参数标识x,y坐标,空格分隔. 查询时直接 SELECT * FROM 会返回BLOB数据,需要使用st_astext(),参数为列名. 增加几行数据后,继续查询: 使用了st_x()与st_y()两个函数,分别取得point的x,y坐标. ","link":"https://2293736867.github.io/post/mysql-shu-ju-lei-xing-quan-jie-xi/"},{"title":"Chrome/Chromium的实验性功能+扩展推荐，让你的Chrome/Chromium起飞!","content":" 1 实验性功能 1.1 平滑滚动 1.2 悬停标签 1.4 并行下载 1.5 强制黑暗模式 1.6 阅读模式 1.7 扩展菜单栏 1.8 渲染级别数据优化 2 扩展推荐 2.1 AdGuard/uBlock 2.2 better-onetab 2.3 Dark Reader 2.4 Extensions Manager 2.5 Imagus 2.6 Infinity Pro 2.7 Minimal Scrollbar 2.8 Similar Sites 2.9 Tampermonkey 2.10 Vimuim 3 最后 1 实验性功能 Chrome/Chromium内置了一些很酷的实验性功能,打开 chrome://flags 即可访问.打开这些实验性功能后,浏览器的使用体验会更好,这里Chrome的版本为80.0.3987.132, Chromium的版本为82.0.4080.0,不同的版本中有不同的实验性功能,具体每一项请打开上面的访问地址进行查看. 1.1 平滑滚动 1.2 悬停标签 鼠标悬停标签显示网址与网页缩略图. 1.4 并行下载 1.5 强制黑暗模式 对所有内容使用黑暗模式. 1.6 阅读模式 开启之后会在某些页面的地址栏的在最右边的收藏五角星符号旁边多一个阅读视图的符号。 1.7 扩展菜单栏 这样就不用每次都打开&quot;更多工具&quot;了. 1.8 渲染级别数据优化 2 扩展推荐 先来一张图，这是笔者自用的扩展： 扩展不在多而在精，原本是有20多个的，然后不断精简，优化，替换，就剩下了13个扩展。 2.1 AdGuard/uBlock 去广告的扩展，原本用的是什么广告终结者，AdBlock，后来就改成了这两个。 2.2 better-onetab 原本用的是onetab，onetab其实做的不错了，只是UI确实比better-onetab差。。。 这个扩展是用于标签管理的，最常见的功能是，需要关闭浏览器，但是目前开了很多个标签，想在下一次打开浏览器时恢复这些标签，但是又不想一个一个加进收藏夹，因为完全没必要而且大部分都是一次性使用，此时better-onetab便派上了用场，单击扩展存储全部标签即可。 由于这个可能经常使用，建议打开 chrome://extensions/shortcuts 增加快捷键。 笔者这里加了两个，一个是显示扩展页面的，一个是存储所有标签的。 2.3 Dark Reader 这个嘛，看名字就知道了，黑暗模式，支持一键切换，支持不同站点，也支持亮度，对比度等的调节，非常实用，也建议加上快捷键。 比如这里加的快捷键为alt+q，然后按一下就可以切换黑暗/正常模式了。 2.4 Extensions Manager 扩展管理器，可以管理所有的扩展，一键开启/关闭，同时也支持不同环境下的快速切换扩展，常见的场景是一般浏览使用默认配置，然后开发环境使用另一套扩展，切换非常的简单，首先在设置里添加。 然后单击该扩展就可以进行切换了： 2.5 Imagus 这个扩展主要用于预览图片，鼠标悬停可以放大预览图片，还可以对临时的预览图片进行缩放，旋转等功能。 可以打开设置修改默认的快捷键，默认q垂直翻转，w水平翻转，e逆时针旋转，r顺时针旋转，剩下的就不说了，按需要自定义。 2.6 Infinity Pro 一个非常漂亮的新标签页扩展，建议注册一个账号去开启Pro功能，开启Pro后可以支持文件夹的创建，还可以把数据备份到云端，然后切换浏览器可以一键恢复数据。 可以自定义的设置非常丰富，包括布局行列数，行宽，列宽，图标大小，阴影，圆角，透明度，字体大小，阴影，颜色，自定义/随机壁纸，搜索栏显隐等，自行体会。 2.7 Minimal Scrollbar 最小化滚动条，这个没啥好说的，自己对比一下安装扩展后的变化就好了。 2.8 Similar Sites 可以发现类似的网站，比如，打开csdn时，显示了github，stackoverflow，博客园等网站。 2.9 Tampermonkey 这个很出名啊，油猴，有一个类似的，叫暴力猴。油猴这个扩展主要是用来管理脚本的，也就是说，单单安装这个扩展啥用也没有，需要安装脚本，这里推荐这个网站：Greasy Fork. 具体就不多说了，有些奥秘需要自己去探个究竟。 2.10 Vimuim 这个压轴登场的扩展，是vim与chromium的结合体，换句话说，在浏览器中集成vim的操作。 比如hjkl是最常见的vim操作，对应页面的滚动，分别是左/下/上/右滚，f是页面跳转功能，比如一个页面按f前： 按了f后： 可以看到多了很多字母对吧，如果此时再输入对应的字母，便会在当前页面跳转到目标页面，比如此时再输入le，便会跳转到“这份Android Studio快捷键大全....”这个页面，大写F实现的功能类似，不过是在新标签页打开。 另一个非常实用的功能是搜索框，按下o/O即可出现： 这个框可以直接输入链接跳转，或者输入字符进去搜索，可以在vimuim的设置里设置默认的搜索引擎： 这里默认的搜索引擎是百度，下面的设置可以自定义搜索引擎，比如第一行为 g : https://www...... 冒号前面的g表示关键字，后面的搜索关键字用 %s 代替，然后在搜索框中输入关键字+空格+字符就可以用该关键字对应的搜索引擎进去搜索了。 这里演示一下添加搜索引擎的方法，以github为例，打开github随便搜索123： 复制这个地址，加上关键字与替换123： 别忘了底部的保存按钮。 然后输入关键字+空格+搜索字符进行搜索即可。 再说一下书签功能，输入b/B可以直接访问书签（强大吧），比如笔者这里的书签有四个文件夹： 输入的标签以斜杠符号开始，后面加对应的文件夹以及对应的网站，这里不用担心输错，因为有自动显示的功能，输错的话下面没有书签显示： 还有很多功能就不逐一介绍了，可以输入?查看帮助： 3 最后 现在主流的Chrome已经很强大了，加上这些实验性功能与推荐的扩展，希望你们能有一个更舒服的上网冲浪的环境。 ","link":"https://2293736867.github.io/post/chromechromium-de-shi-yan-xing-gong-neng-kuo-zhan-tui-jian-rang-ni-de-chromechromium-qi-fei/"},{"title":"linux下php7安装与Apache配置","content":"1 php 1.1 准备工作 需要先安装Apache，已安装的可以跳过，没安装的可以看这里。 1.2 下载 官网 1.3 解压 tar -zxvf php-7.4.3.tar.gz cd php-7.4.3 1.4 编译安装 ./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache/bin/apxs prefix为安装位置，后面的选项为apache安装目录bin下的apxs。好了之后： make sudo make install 1.5 配置文件 需要复制一份php.ini文件： sudo cp php.ini-development /usr/local/lib/php.ini 2 Apache 在conf/httpd.conf最后加上： LoadModule php7_module modules/libphp7.so &lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 若是php5请修改为： LoadModule php5_module modules/libphp5.so 最后重启apache服务： /usr/local/apache/bin/apachectl restart 3 测试 在apache目录下的htdocs下新建一个test.php： &lt;?php phpinfo() 浏览器输入apache配置文件中的ServerName加上文件名，笔者的是localhost:80。 localhost:80/test.php 显示以上信息即成功。 ","link":"https://2293736867.github.io/post/linux-xia-php7-an-zhuang-yu-apache-pei-zhi/"},{"title":"linux编译安装Apache","content":"1 前言 编译安装Apache HTTP Server，目前最新的版本为2.4.41，做好apr，apr-util，pcre的安装后编译安装即可。 2 准备工作 三个：apr，apr-util，pcre，已安装的可以跳过。 2.1 apr 下载：链接 tar -zxvf apr-1.7.0.tar.gz cd apr-1.7.0 ./configure --prefix=/usr/local/apr/apr make sudo make install 安装位置自定义。 2.2 apr-util 下载：链接 tar -zxvf apr-util-1.6.1.tar.gz cd apr-util-1.6.1 ./configure --prefix=/usr/local/apr/util --with-apr=/usr/local/apr/apr 安装位置自定义，如果另外如果在上一步更改了apr的默认安装位置需要使用 --with-apr 指定自定义的apr的安装位置。 然后编译安装： make sudo make install 2.3 pcre 下载：链接 tar -zxvf pcre-8.44.tar.gz cd pcre-8.44 ./configure --prefix=/usr/local/pcre make sudo make install 3 Apache 3.1 下载 官网 3.2 解压 tar -zxvf httpd-2.4.41.tar.bz2 cd httpd-2.4.41 3.3 安装 ./configure --prefix=/usr/local/httpd 由于修改了apr的默认安装位置，这里提示找不到apr，因此使用 ./configure --help 查看一下选项帮助。 选项挺多的不过需要的有关apr的选项： ./configure --help | grep -i “apr” 因此加上选项： ./configure --prefix=/usr/local/httpd \\ --with-apr=/usr/local/apr/apr \\ --with-apr-util=/usr/local/apr/util 若出现pcre找不到再加上： --with-pcre=/usr/local/pcre 3.4 编译并安装 make sudo make install 3.5 修改默认配置 vim PREFIX/conf/httpd.conf 其中PREFIX为安装位置。根据需要修改服务器名，端口等。 搜索ServerName，初始的配置可以修改为： ServerName localhost:80 3.6 启动服务 PREFIX/bin/apachectl -k start PREFIX为安装位置，权限拒绝请加sudo. 3.7 测试 浏览器输入刚才的自定义的ServerName： 成功，这里显示的是安装目录下htdocs/index.html. ","link":"https://2293736867.github.io/post/linux-bian-yi-an-zhuang-apache/"},{"title":"linux下Mysql  8.0.19 编译安装","content":" 1 前言 2 准备工作 2.1 gcc 2.2 boost 2.3 cmake 2.4 其他 2.4.1 Red Hat系 2.4.2 ubuntu系 3 下载与解压 3.1 下载 3.2 解压 3.3 创建临时bld文件夹 4 编译与安装 4.1 cmake 4.2 编译 4.3 安装 4.4 测试 5 配置MySQL 5.1 新建用户组与用户 5.2 修改数据目录所有者与权限 5.3 my.cnf 5.4 初始化 5.5 支持ssl与rsa（可选） 5.6 开启服务 5.7 修改root密码 5.8 测试 6 后续处理 6.1 删除文件 6.2 别名 1 前言 linux下安装MySQL的方式有很多种，包括以仓库的方式安装(yum,apt,zypper)，以包的方式安装(rpm,deb)，以docker方式安装，从压缩包解压安装，从源码编译安装，这里使用的是最后一种，从源码编译安装。 编译安装需要大量的耐心与时间，而且还会遇到非常多奇奇怪怪的问题，因此，需要极大的毅力，很有可能一万次失败也换不来一次的成功，请做好心理准备。 2 准备工作 下面是安装要求，已安装的可以跳过。 cmake boost gcc ncurses openssl bison doxygen 2.1 gcc gcc的话一般linux都配备，最低要求版本为5.3，需要更新的话可以看笔者的另一篇博客。 2.2 boost boost不需要手动安装，后面运行cmake脚本的时候会自动下载安装，当然也可以手动安装，官网的文档说是需要特定版本，这里的MySQL Server 8.0.19需要的是1.70.0，目前最新的boost库为1.72.0。 2.3 cmake 看笔者的另一篇博客。 2.4 其他 其他一般使用仓库安装即可，当然也可以每一个都去折腾从源码安装，你喜欢就好。 2.4.1 Red Hat系 7.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen 8.x： sudo yum install -y bison bzip2 git hostname ncurses-devel openssl openssl-devel pkgconfig tar wget zlib-devel doxygen diffutils rpcgen make libtirpc-devel 2.4.2 ubuntu系 sudo apt-get update sudo apt-get install -y bison git hostname libncurses-dev libssl-dev make openssl pkg-config doxygen 3 下载与解压 3.1 下载 MySQL Server下载 这里不知道带boost与不带boost的有什么区别，后面使用cmake的时候都需要手动下载boost，所以就随便选一个吧。有知道的大神可以留言，小弟感激不尽。 3.2 解压 tar -zxvf mysql-boost-8.0.19.tar.gz cd mysql-8.0.19 3.3 创建临时bld文件夹 mkdir bld cd bld 4 编译与安装 4.1 cmake cmake .. \\ -DDOWNLOAD_BOOST=1 \\ -DWITH_BOOST=. \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DENABLED_LOCAL_INFILE=ON \\ -DWITH_SSL=system \\ -DCMAKE_INSTALL_PREFIX=/usr/local/mysql/server \\ -DMYSQL_DATADIR=/usr/local/mysql/data \\ -DMYSQL_TCP_PORT=3306 \\ 安装了boost的可以不需要： -DDOWNLOAD_BOOST=1 -DWITH_BOOST 安装位置与数据位置根据需要自定义： -DCMAKE_INSTALL_PREFIX= -DMYSQL_DATADIR= 4.2 编译 make -j n n为cpu核心数，若失败请直接使用 make 这里编译需要比较长的时间，有进度提示。 4.3 安装 sudo make install 这里笔者遇到了libstdc++.so.6这个库的问题，MySQL Server 8.0.19安装需要GLIBCXX_3.4.25. 可以看看自己的libstdc++.so.6的路径： sudo find / -name lidstdc++.so.6 找到路径之后： strings /xxx/libstdc++.so.6 | grep GLIBCXX 笔者这里只有GLIBCXX_3.4.22，由于之前手动更新了gcc，在gcc的lib目录中： 因此只需要根据sudo make install的提示把这个libstdc++.so.6复制到/lib/： sudo cp libstdc++.so.6 /lib/x86_64-linux-gnu/ 另一种解决办法是（针对Ubuntu系），添加ppa源，然后update： sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade 其他的也类似，更新gcc，手动指定lib的位置。 安装成功。 4.4 测试 make test 测试通过。 5 配置MySQL 安装完成后还需要进行MySQL的配置。 5.1 新建用户组与用户 sudo groupadd mysql sudo useradd -r -g mysql -s /bin/false mysql 5.2 修改数据目录所有者与权限 数据目录根据需要修改。 sudo chown mysql:mysql /usr/local/mysql/data sudo chmod 777 /usr/local/mysql/data 这里官网的文档写的是750权限，但是后面会出现不可写错误，755也不行，所以直接改成了777。 5.3 my.cnf my.cnf在/etc或/etc/mysql下，笔者这里安装后默认有一个my.cnf在/etc/mysql下： /etc/mysql/my.cnf是全局配置，~/.my.cnf是用户特定的配置，这里直接修改/etc/mysql/my.cnf： [mysqld] port=3306 basedir=/usr/local/mysql/server datadir=/usr/local/mysql/data character-set-server=utf8mb4 [mysql] default-character-set=utf8 [client] port=3306 default-character-set=utf8 参数根据需要可以后期添加，这里如果使用utf8： [mysqld] character-set-server=utf8 会有警告，因为MySQL5.5.3之后增加了utf8mb4，mb4是most bytes 4的意思，专门用来兼容四字节的unicode，utf8指的是utf8mb3，支持的utf8编码最大字符长度为3字节，警告提示改成utf8mb4: [mysqld] character-set-server=utf8mb4 （额外阅读：utf8与utf8mb4） 5.4 初始化 进入到MySQL Server的安装目录下的bin： mysqld --initialize-insecure --user=mysql 这里使用-insecure是因为后面不用输入随机密码。当然也可以去掉insecure，这样就会有一个随机密码，要记住。 mysqld --initialize --user=mysql 5.5 支持ssl与rsa（可选） mysql_ssl_rsa_setup 这个一般服务器需要。 5.6 开启服务 mysqld_safe --user=mysql &amp; 5.7 修改root密码 先用root登录 mysql -u root --skip-password 如果是使用initialize初始化的，输入 mysql -u root -p 输入刚才的临时密码。 进去之后，使用alter修改root密码： alter 'root'@'localhost' identified by 'xxxxx' 5.8 测试 使用自带的mysqlshow与mysqladmin: mysqladmin -u root -p version mysqlshow -u root -p 完成，至此MySQL Server8.0.19安装完毕。 6 后续处理 6.1 删除文件 可以先把安装文件给删去： sudo rm -rf mysql-8.0.19* 另外，根据刚才cmake的时候的boost目录可以把boost库给删去： sudo rm -rf boost_1_70_0* 因为文档说只是需要boost去build，不需要使用。 6.2 别名 加个别名只是为了方便使用，这里笔者的做法其实很偷懒，默认root登录，修改~/.bash_aliases： alias mysqld=&quot;/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;&quot; alias mysql=&quot;/usr/local/mysql/bin/mysql -u root -p&quot; 使用MySQL之前使用mysqld启动服务挂后台，然后使用mysql登录，默认root用户。 当然更偷懒的做法是 alias mysql=&quot;/usr/local/mysql/bin/mysql -u root --password=xxxx&quot; 这样密码都不用输了。 ","link":"https://2293736867.github.io/post/linux-xia-mysql-8019-bian-yi-an-zhuang/"},{"title":"linux安装cmake","content":"1 概述 linux下安装cmake，目前最新的版本为3.17.0-rc2，安装的方式一共有三种：通过软件包仓库安装，通过编译好的版本进行安装，从源码手动编译安装。 2 仓库安装 笔者的是deepin，可以直接apt安装： sudo apt install cmake 安装是没问题了，但是版本有点旧，3.7的，不满意，所以就卸了： sudo apt autoremove cmake 其他的请自行搜索。 3 通过编译好的版本安装 先去官网下载： 解压并进入目录： tar -zxvf cmake-3.17.0-rc2-Linux-x86_64.tar.gz cd cmake-3.17.0-rc2-Linux-x86_64/bin 这样就可以了，直接 cmake -version 可以查看版本。 一般需要加个软链： sudo ln -s cmake /usr/bin/cmake 4 手动编译安装 手动编译安装其实也不难，官网的文档是三步： 4.1 下载 这里 4.2 解压 tar -zxvf cmake-3.17.0-rc2.tar.gz cd cmake-3.17.0-rc2 4.3 配置 ./bootstrap --prefix=/usr/local/cmake 加个安装位置即可。 出现上图说明成功，如果失败，请根据错误信息自行判断，笔者这里遇到的问题是gcc与g++的版本不匹配，因为是先更新gcc到了9.2.0，g++的软链忘记改，导致了g++是6.3.0的版本，而gcc是9.2.0的版本。 4.4 编译 make -j 6 笔者的为6核，-j可以为并行优化，默认为1。 安装时有进度提示，笔者在这里没有问题，出现其他问题自行搜索。 4.5 安装 make install 成功之后，在bash_aliases加个别名： vim ~/.bash_aliases 加上 alias cmake=/usr/local/xxxxx/cmake/bin/cmake :wq后： source ~/.bash_aliases 或 . ~/.bash_aliases 使用 cmake -version 测试 成功。 ","link":"https://2293736867.github.io/post/linux-an-zhuang-cmake/"},{"title":"linux 更新python3.8","content":"1 下载源码 地址 选版本下载即可，目前最新为3.8.2版本。 2 解压 tar -zxvf Python-3.8.2.tgz cd Python-3.8.2 3 新建安装目录 安装目录在/usr/local/python38: sudo mkdir /usr/local/python38 4 安装 ./configure --prefix=/usr/local/python38 &amp;&amp; make &amp;&amp; make install 笔者这里安装遇到的是安装目录的权限问题，直接改为775，776都不行，改为777： sudo chmod 777 /usr/local/python38 5 链接 可以先把以前的备份一下： sudo cp /usr/bin/python /usr/bin/python2.bak 链上python3： sudo ln -s /usr/local/python38/bin/python3.8 /usr/bin/python 6 测试 成功。 7 删除 可以把安装文件删除了。 rm -rf Python3.8.2* ","link":"https://2293736867.github.io/post/linux-geng-xin-python38/"},{"title":"linux下更新gcc","content":"1 下载源码 链接 目前最新为9.2版本。 2 解压 tar -zxvf gcc-9.2.0.tar.gz cd gcc-9.2.0 3 download_prerequisites脚本 运行这个脚本: ./contrib/download_prerequisites 4 临时目录 建立临时目录，用于放置中间文件。 mkdir gcc_9_2_0_build cd gcc_9_2_0_build 5 生成makefile文件 ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib 不对，是这张： 下面说一下几个选项： -enable-checking / -disable-checking 表示编译器在编译过程中是否做额外检查。 -enable-languages 表示支持的语言，可以支持 ada c c++ d fortran go jit lto objc obj-c++ -disable-multilib 关闭多架构支持，可以支持arm，m68，mips，msp430，powerpc架构。 6 编译 sudo make -j6 -jn 选项表示为多核处理器优化，n为核心数，笔者的为6核。 此操作极为耗时，建议准备充足时间，如果出现错误一般一两分钟左右停止，不成功请直接使用 sudo make 7 安装 sudo make install 8 验证 gcc -v 如果还是旧版本，请重启再试一次。 下面是成功截图： 9 删除 可以把安装文件以及压缩包删了。 rm -rf gcc* 注意所在的目录... ","link":"https://2293736867.github.io/post/linux-xia-geng-xin-gcc/"},{"title":"PyCharm安装与配置","content":"1 下载 官网 2 安装 选位置即可. 接下来是几个选项:快捷方式,环境变量PATH,右键菜单添加&quot;Open Folder as Project&quot;,文件关联,按需要选择. 3 初始配置 首次运行不需要导入设置. 选主题. 下一个是选插件,分别是vim,markdown支持,R支持,AWS工具箱. 4 配置 进入settings: 可以先把主题与界面字体大小改一下. 主题可以在插件处搜索安装. 显示行号,方法分隔符,空白字符: 字体,笔者用的是Fira Code. 编码,统一utf8: ","link":"https://2293736867.github.io/post/pycharm-an-zhuang-yu-pei-zhi/"},{"title":"php环境搭建+Hello World","content":" 1 概述 2 安装php 2.1 下载 2.2 安装 2.3 测试 3 IDE 3.1 下载 3.2 安装 3.3 配置 4 安装MySql 4.1 安装介绍 4.2 下载 4.3 配置文件 4.4 环境变量 4.5 初始化 4.6 改密码 5 安装Apache HTTP Server 5.1 下载 5.2 安装 5.3 测试 6 Hello world 1 概述 基础教程,搭建php入门基本环境.环境win10. 2 安装php 2.1 下载 官网点击这里 2.2 安装 其实只需要添加环境变量即可.win+Pause,高级系统设置: Path这里新建一个,刚才的php目录. 2.3 测试 打开cmd,输入php -v: 这样就安装成功了. 3 IDE 这里用的IDE是Php Storm. 3.1 下载 官网点击这里 直接下载就行. 3.2 安装 挑个位置. 下面这些根据个人需要勾选即可,分别是快捷方式,添加运行目录到环境变量,右键菜单添加&quot;作为一个工程打开&quot;,文件关联. 安装后以后直接run. 3.3 配置 其他配置按需要,这里主要说一下php: 改个名字后选择刚才安装php的路径: 然后如果该目录内没有php.ini的话会提示配置文件php.ini不存在: 点击How To Fix后提示: 它说创建php.ini文件在这个目录,在这个目录内可以找到两套模板:php.ini-development与php.ini-production,前者是默认设置,后者是推荐设置,那既然后面那个是推荐设置那就把它复制一下改名字: 然后就不会有警告了: 4 安装MySql 4.1 安装介绍 MySql有以下版本: Enterprise Edition,企业版,可免费试用30天. Standard Edition,标准版,收费. Classic Edition,经典版,只可作为一个嵌入式数据库用于ISVs(独立软件开发商),OEMs(原始设备制造商),VARs(增值经销商)的授权. Cluster CGE,高级集群版,收费. Embedded,嵌入式版,相比起经典版,ISV/OEM用户可以有更多选择. Community Server,社区版,开源免费. 一般用社区版即可,下面介绍社区版的安装流程. MySql有三种安装包,分别是安装器,压缩包与Docker镜像. 一般选择安装器安装或压缩包解压.这里使用的是压缩包,压缩包包含了完整的MySQL Server,解压之后需要额外的手动配置. 4.2 下载 官网这里,直接下载即可. 4.3 配置文件 解压之后,在解压目录新建一个叫my.ini的配置文件,输入以下内容: [mysqld] port=3306 basedir=E:\\Mysql datadir=E:\\Mysql\\data max_connections=200 max_connect_errors=12 character-set-server=utf8 default-storage-engine=INNODB [mysql] default-character-set=utf8 [client] port=3306 default-character-set=utf8 basedir与datadir是安装目录与数据存放目录,按需要修改即可. 4.4 环境变量 添加安装目录/bin到环境变量Path.不截图了. 4.5 初始化 打开cmd,执行: mysqld --initialize --consle 若出现以下问题: 可以看一下这个链接. 此时会出现root的初始密码,需要记住. 然后输入 mysqld --install 这里笔者之前安装过了,所以显示已存在. 4.6 改密码 好了之后输入 net start mysql 启动服务之后,输入: mysql -u root -p 输入刚才的随机密码. 然后修改root密码: alter user 'root'@'localhost' identified by 'xxxx'; 修改root密码后就可以用新密码登录了. 5 安装Apache HTTP Server 5.1 下载 官网 官网说只提供源码,需要自己编译,这里推荐了几个编译好的网站,去下载即可. 如果需要自己编译,看了一下文档,四个步骤,先下载源码,还有apr,apr-util,apr-iconv,把它们放到对应文件夹,然后运行perl命令. 笔者没有安装perl,也不懂perl,所以就弱弱地用别人编译好的了,点第一个即可: 64位,点击下载即可. 5.2 安装 解压之后移动到想要的目录,首先去修改conf下的httpd.conf第40行SRVROOT这里: 修改成安装目录即可. 然后打开cmd进入该目录下的bin,输入: httpd -k install 然后打开服务去开启服务: 5.3 测试 浏览器输入 localhost:80 会出现以下主页. 6 Hello world 打开IDE,新建一个空项目,创建一个php文件: 输入echo: 然后移动到右上角的那个小方块: ok! ","link":"https://2293736867.github.io/post/php-huan-jing-da-jian-hello-world/"},{"title":"熵权可拓物元模型","content":" 1 概述 2 概念 2.1 物元 2.2 可拓 2.3 相容与不相容问题 2.4 物元分析 2.5 物元可拓分析 2.6 熵权法 3 步骤 3.1 确定物元 3.2 确定经典域 3.3 确定节域 3.4 确定待评物元 3.5 确定关联函数 3.6 确定关联度 3.7 确定权重 3.7.1 确定初始矩阵 3.7.2 指标归一 3.7.3 计算熵值 3.7.4 计算熵权 3.8 确定综合关联度 4 源码 5 参考 1 概述 物元分析方法是中国学者蔡文于20世纪80年代提出的用于解决矛盾问题的技术方法,是研究物元及其变化规律,解决现实世界中不相容问题的有效方法,可应用于生态环境,水资源承载力,农用地分级和土地生态水平等综合评价研究中. 本文主要介绍了熵权可拓物元模型的相关概念与该模型的建立过程. 2 概念 2.1 物元 物元分析法的主要思想是把事物用&quot;事物,特征,量值&quot;(分别用N,C,V表示)3个要素以有序三元组的形式来描述,这个三元组就叫物元. 2.2 可拓 可拓学是以蔡文,杨春燕研究员等为首的中国学者创立的新学科. 可拓学是研究事物拓展的可能性和开拓创新的规律与方法,并用以解决矛盾问题,是一门交叉学科,基本理论是可拓论,特有的方法是可拓方法,逻辑基础是可拓逻辑,与各领域的交叉融合形成可拓工程.可拓论,可拓方法(也叫可拓创新方法),可拓工程构成了可拓学. (图源) 可拓评价法是综合评价法的重要分支,通过借助可拓学的基本理论,从定性和定量两个角度将矛盾问题转化为多个特性的择近原则问题,从而得出事物之间的内部规律. 2.3 相容与不相容问题 当所给的条件能达到要实现的目标时,称为相容问题,当所给的条件不能达到要实现的目标时,则为不相容问题.不相容问题在一定条件下不能用常规办法解决,用数学公式表示,就是: W = R × r 其中W表示问题,R表示目标,r表示条件,在条件处于r的情况下,通过一般常规方法,不能实现目标R,这时问题W就是不相容问题.不相容问题具有时效性,因为一些不相容问题,虽然只能用非常规办法解决,但随着时代发展,又可以用常规方法加以解决. 2.4 物元分析 物元分析是研究物元,探讨如何求解不相容问题的一种方法,以研究促进事物转化,解决不相容问题为核心内容,是研究求解不相容问题时出点子,想办法的规律与方法的理论.物元分析的突出特点是创立了物元这一新概念,并建立了物元变换理论.求解不相容问题,必须同时考虑质和量,才可以使问题得到解决. 2.5 物元可拓分析 物元可拓分析是利用物元模型与可拓集合把系统研究中的实际问题转化为形式化的问题模型以及描述问题解决过程的模型,从而有效地解决矛盾,为决策提供数据,将不相容问题转化为相容问题,使问题得到合理解决. 2.6 熵权法 传统的AHP法等确定评价指标权重的方法往往比较主观,容易造成评价结果由于人的主观因素而形成偏差.熵权法根据评价指标变异程度的大小来确定指标权重,指标变异程度越大,信息熵越小,该指标权重值越大,反之则越少.熵权法的主要目的是减少主观性,使对评价对象进行的评价更加客观化. 3 步骤 3.1 确定物元 将要评价的事物记作N,其特征记为c,特征量值记为v,假设N有多个特征: 这n个特征对应的量值为: 则可表示为: R为n维物元,简记为: c表示要评价的物元的n个特征: v表示n个特征的量值: 3.2 确定经典域 经典域是根据将要评价的物元的特征及其量值所在的区间确定的,假设将评价等级分为m级,用 表示第j个等级,用 表示第i个评价指标,用 表示在等级j下第i个评价指标的取值范围,这个取值范围用区间 表示,则N,c,v以有序三元组的形式结合起来即为经典域物元Rj: 3.3 确定节域 节域用Rp表示,vpi为节域物元关于特征ci的量值范围: 其中 就是 第i个指标的所有范围的并集. 节域物元Rp可表示为: 3.4 确定待评物元 设有y个待评事物,把待评对象Nx的物元表示为Rx: 3.5 确定关联函数 令有界区间X 的模定义为: 某一点x到区间X的距离为: 则关联函数的k定义为: 3.6 确定关联度 关联函数表达式为: 其中kxj(vi)表示第x个待评物元,第j个等级,第i个指标的关联度,vxi为第x个待评价物元的第i个量值,vji为第j个经典域物元第i个指标的量值范围,|vji|为3.5中定义的区间的模,vpi为节域物元第i个指标的量值范围. 为3.5中的公式,表示第x个待评物元第i个量值vi与对应经典域量值范围vji的有限区间的距离. 通过该式子会计算出y × n × m个关联度(y为待评物元个数,n为指标的个数,m为划分的等级的个数): 3.7 确定权重 需要计算n个指标对应的n个权重: 四个步骤:确定初始矩阵,归一处理,计算熵值,计算熵权. 3.7.1 确定初始矩阵 初始矩阵即为要评价的y个物元中的n个指标的量值构成的矩阵,用X表示: 3.7.2 指标归一 将初始矩阵归一化处理,得到归一化矩阵B: 其中: min(xi)/max(xi)为矩阵X第i行的最小/最大值. 另一种计算方式为: 3.7.3 计算熵值 需要计算n个熵值: m为划分的等级的个数. fij为: 分子为bij,分母为矩阵B第i行之和. 一般为了使对数有意义,需要对上式进行修正,分子分母都&quot;加1&quot;: 因此修正后的熵值Hi为: 3.7.4 计算熵权 计算n个指标对应的n个熵权: n个熵权,满足和等于1: 3.8 确定综合关联度 需要计算y*m个综合关联度,用K表示: 其中 Nx表示第x个评价事物,wi为第i个指标的熵权,kj(vi)为第j个等级第i个指标的关联度. (注:x其实不一定从1开始,如评价的事物与年份有关,则x从年份开始,如x=2000,y=2010). 4 源码 java版： github 码云 5 参考 参考相关论文以及网站合集 ","link":"https://2293736867.github.io/post/shang-quan-ke-tuo-wu-yuan-mo-xing/"},{"title":"每天AC系列(十三):两数相除","content":"1 题目 LeetCode第29题,计算两数相除的商，不允许使用乘法，除法，求模运算符。 2 减法 首先判断结果是否需要加上负号，将商置为0后，被除数不断减去除数，同时商自增。最后根据是否有负号返回相应的商。 boolean negative = true; if((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) negative = false; dividend = dividend &gt; 0 ? dividend : -dividend; divisor = divisor &gt; 0 ? divisor : -divisor; int result = 0; while(dividend &gt;= divisor) { dividend -= divisor; ++result; } return negative ? -result : result; 3 思考 3.1 溢出 -2147483648与2147483647这两个数，是4字节的int的最小值与最大值，在java中，它们可用Integer.MIN_VALUE与Integer.MAX_VALUE表示，当一个int为Integer.MIN_VALUE时，取反也是这个数： 最简单最粗暴的解决方案就是使用long，long可以放下-Integer.MIN_VALUE，因此，直接将被除数与除数的类型改成long，返回值转为long即可。 但是提交了一下，超时： 所以对除数1与-1进行特判一下： if(divisor == 1) return dividend; if(divisor == -1) { if(dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE; return -dividend; } 若除数是1直接返回被除数，这时不需要考虑溢出，若是除数是-1，需要特判一下被除数是否为int的最小值，因为-Intger.MIN_VALUE也是Intger.MIN_VALUE，题目也说了返回int的最大值。 然后信心十足地提交了： 惨淡。 3.2 负数 溢出的原因，就算因为负数的存储范围比正数多1，就算因为那两个可恶的-2147483648与2147483647. 上面的做法是判断结果的负号，然后将被除数与除数都转为正数来计算，可以换一种思路，将被除数与除数都转为负数来计算： dividend = dividend &gt; 0 ? -dividend : dividend; divisor = divisor &gt; 0 ? -divisor : divisor; int result = 0; while(dividend &lt;= divisor) { dividend -= divisor; ++result; } if(negative) { if(-result == Integer.MIN_VALUE) return Integer.MIN_VALUE; return -result; } else { if(result == Integer.MIN_VALUE) return Integer.MAX_VALUE; return result; } 结果从0开始自增，while循环的条件改成被除数小于等于除数而不是之前的被除数大于等于除数，然后对得出的商判断正负与边界，如果是负数，判断商的相反数是否是int的最小值，若是的话，表示真正的商为2147483648，负溢出，返回int的最小值，若不是负数，判断商是否为int的最小值，若是的话，表示真正的商为2147483648，正溢出，返回int的最大值。 快了600ms，还是有效果的。 3.3 翻倍与移位 速度慢的原因，是因为减法。因此需要改进减法，使被除数更快地逼近除数。 对于被除数为2147483647，除数为1的情况，需要减2147483647次，才能得出结果，所以，使用翻倍，第一次减1，第二次减2，第三次减4，以此类推。 但是怎么翻倍怎么操作呢? a *= 2 ? 题目说不能用乘法运算符。 作为一个现代的程序员，总不能这样翻倍吧？ a += a; 这时就轮到位移运算符登场了，左移一位，相当于乘2，右移一位相当与除2： a &lt;&lt;= 1; // a *= 2 a &gt;&gt;= 1; // a /= 2 总体思路是设置一个tempResult与一个tempDivisor，不断将tempResult与tempDivisor翻倍，直到被除数大于等于tempDivisor或tempDivisor溢出，然后把tempResult增加到result上面。 while(dividend &lt;= divisor) { int tempDivisor = divisor; int tempResult = 1; while(dividend &lt; (tempDivisor&lt;&lt;1) &amp;&amp; tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1)) { tempDivisor &lt;&lt;= 1; tempResult &lt;&lt;= 1; } dividend -= tempDivisor; result += tempResult; } 其中： tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1) 这个while中的判断很重要，如果tempDivisor大于int的最小值的一半，则tempDivisor左移1位后会小于Integer.MIN_VALUE，也就是小于int的最小值，会溢出，跳出循环后会导致被除数减去一个正数而不是一个负数，这样相当于增大了被除数导致计算的结果错误。 4 递归 递归可以减少设置一个result变量，直接在返回值里加上即可： public int div(int dividend,int divisor) { if(dividend &lt;= divisor) { int tempDivisor = divisor; int tempResult = 1; while(dividend &lt; (tempDivisor&lt;&lt;1) &amp;&amp; tempDivisor &gt; (Integer.MIN_VALUE &gt;&gt; 1)) { tempDivisor &lt;&lt;= 1; tempResult &lt;&lt;= 1; } return tempResult + div(dividend-tempDivisor,divisor); } return 0; } 代码与迭代基本相同，结束条件为被除数大于除数，在进入递归前需要对被除数与除数处理正负： public int divide(int dividend,int divisor) { boolean negative = (dividend &gt; 0) ^ (divisor &gt; 0); int result = div(dividend &gt; 0 ? -dividend : dividend,divisor &gt; 0 ? -divisor : divisor); if(negative) return -result; return result == Integer.MIN_VALUE ? Integer.MAX_VALUE : result; } 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-san-liang-shu-xiang-chu/"},{"title":"每天AC系列(十二):K个一组翻转链表","content":"1 题目 LeetCode第25题,每K个节点一组进行翻转,剩下不足K个的保留原状. 2 直接翻转 将链表分成三部分，已翻转，待翻转，未翻转三部分： 首先，用一个指针t表示要插入的位置的前驱，一边把head移动k遍，一边插入在t后面（下图假设k=3）： int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { temp = head.next; head.next = t.next; t.next = head; head = temp; } 直接插在t的后面，一轮循环之后，移动t与head. t的新位置为未插入head之前的head的位置，因此在插入之前把head的位置保存下来，直接使t移动到该位置，head的位置为自然移动到的位置，不需改变。 ListNode nextTPosition = head; ListNode temp; int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { temp = head.next; head.next = t.next; t.next = head; head = temp; } if(i == k) t = nextTPosition; 接着再翻转，到达7后，7不需要翻转，因为剩下的节点数不足： 这时就需要i发挥作用了，i表示已翻转的节点的值，因为只是一次遍历，每遍历k次便翻转k次，若i小于k，由于已经翻转了剩下的i个节点，因此需要再将这剩下的i个节点翻转一次： if(i == k) t = nextTPosition; else { for(head = t.next,t.next=null;head!=null;) { temp = head.next; head.next = t.next; t.next = head; head = temp; } break; } 对剩下的i个节点再次翻转时，不需要修改t的位置，使head指向t.next，再把t.next置为null，因为此时t为 4-&gt;7 若不把t.next置为null，在 head.next = t.next 这一步会使head.next指向错误的t.next，导致会在最后一个节点不断循环。 翻转最后的i个节点后，跳出循环，返回结果。 3 递归 递归的话思路也类似，遍历k次，翻转k个，若还有需要翻转的节点，递归翻转，若没有，翻转剩下的i个节点。 if(i == k) t.next = reverse(head,k); 大部分代码与循环相同就不贴了，最大的不同是这里，这里的t为原来未遍历前的head，因为改成递归后，不需要使用t作为移动的指针指示插入的位置，t.next就相当于翻转后的最后一个节点，把递归的结果插入到这个节点的后面。 4 使用额外空间--栈 因为题目规定只能使用常数的额外空间，因此应该只有这两种方法了，但是，如果允许使用额外的空间，可以使用栈优化直接翻转的算法。 因为出栈的次序正是翻转的顺序，每遍历k个节点就压栈k个节点，若剩余不足k个节点，把head连上dummy，若还有多余的节点或者刚好遍历完，把出栈的节点依次连上主链。 while(true) { Stack&lt;ListNode&gt; s = new Stack&lt;&gt;(); ListNode temp = head; int i=0; for(;i&lt;k &amp;&amp; head != null;++i) { s.add(new ListNode(head.val)); head = head.next; } if(i == k) { for(i=0;i&lt;k;++i) { t.next = s.pop(); t = t.next; } } else if(head == null) { t.next = temp; break; } } 其中for循环为遍历压栈，i==k判断是否翻转链表。 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-er-k-ge-yi-zu-fan-zhuan-lian-biao/"},{"title":"每天AC系列(十一):删除排序数组中的重复项","content":"1 题目 LeetCode第26题,给出一个非降序的数组,删除重复的元素. 2 覆盖移动 题目明确要求不能使用额外的数组空间,一开始,没想到什么好的算法. 但是,它又有提示,不需要考虑数组中超出新长度后面的元素,所有,就想到了覆盖移动这样的方法. 思想很简单,就是使用两个下标,一个下标表示要返回的下一个要被替换的数,同时这个下标加1代表要返回的长度,一个下标为遍历数组的下标. 首先,遍历数组,若遇到大于nums[index]的数,首先判断当前下标是否为index的下一个,如果是下一个的话覆盖相当于重复了,把自己赋给自己,若i与index的距离大于1,则在自增index的同时,把i处的值覆盖到index处,这样就不用移动后面的数了,而且可以保证这样的数有序,最后返回index+1,表示不重复的元素的个数,即新数组的长度. int index = 0; for(int i=1;i&lt;nums.length;++i) { if(nums[i] &gt; nums[index]) { if(i &gt; ++index) nums[index] = nums[i]; } } return index+1; 嗯,一次就AC,舒服. 其他解法?不清楚,看了别人的题解差不多都是这样的,不过叫法不一样,叫双指针,快慢指针,本质都是一样. 4 再来一题 实在没想到上一题这么不堪一击,然后下一题是LeetCode的27题,与上一题有点类似,给定一个数组,删除数值等于指定值的所有元素. 5 解法 int index = -1; for (int i = 0; i &lt; nums.length; ++i) { if(nums[i] != val) { if (i &gt; ++index) nums[index] = nums[i]; } } return index + 1; 还是一样的解法啊,覆盖移动,快慢指针,这是上次的代码改了if的判断条件,然后就: 不想说什么了. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-yi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"},{"title":"每天AC系列(十):两两交换链表中的节点","content":"1 题目 LeetCode第24题,交换链表的相邻节点. 2 直接交换 直接交换的思想很简单,遍历一次链表,进行两两交换. ListNode newHead = new ListNode(0); newHead.next = head; ListNode before = newHead; ListNode first = head; ListNode second = head.next; ListNode move; while(true) { move = second.next; first.next = second.next; second.next = first; before.next = second; before = first; first = move; if(move != null &amp;&amp; move.next != null) { second = move.next; move = move.next.next; } else break; } return newHead.next; 虽然思想简单,但是,并不好实现,有点绕,首先增加一个头节点,first,second当前要交换的两个节点,before为first的前一个节点,用来连上first,move是为了更新first与second节点的节点,进入while循环后,首先把first与second交换,接着用before连上first同时更新before,然后利用move更新first与second. 3 递归交换 递归交换就是每次只交换头两个节点,然后把第三个节点作为下一次递归交换的头结点继续递归交换. if(head != null &amp;&amp; head.next != null) { ListNode t = head.next; head.next = swapPairs(t.next); t.next = head; return t; } return head; 要注意交换的顺序,先赋值head.next,head.next为剩下的节点,然后把t连上head. 4 插入法 新建一个链表,采用尾插法,依次插入交换的节点. 对于原链表设置两个指针a与b,令a指向首个节点,b指向第二个节点,然后对于新链表,先插入b,再插入a,最后更新a,b,使a,b都指向后继的后继,这样依次插入b与a就会得到所需的链表. if(head == null || head.next == null) return head; ListNode a = head; ListNode b = head.next; ListNode newHead = new ListNode(0); ListNode t = newHead; while(a != null &amp;&amp; b != null) { t.next = new ListNode(b.val); t = t.next; t.next = new ListNode(a.val); t = t.next; if(b.next != null) b = b.next.next; a = a.next.next; } if(a != null) t.next = new ListNode(a.val); return newHead.next; 在更新a,b时,对于a不需要判断a.next是否为空,因为a.next肯定为b,肯定不为空,但是对于b,当到达最后一个节点时,b.next为空,因此需要加上判断.当a,b其中一个为空后跳出循环,最后的判断a是否为空表示节点个数为奇数,此时a指向最后一个节点,直接插入a. 5 插入法改进 对于上面的插入法,由于ab是连在一起的,因此可以只使用其中一个,再优化判空与插入操作. ListNode newHead = new ListNode(0); ListNode t = newHead; while(head != null) { if(head.next != null) { t.next = new ListNode(head.next.val); t = t.next; } t.next = new ListNode(head.val); t = t.next; if(head.next == null) break; head = head.next.next; } return newHead.next; 要注意while中的判空条件,因为节点的个数有可能是奇数,在插入后一个节点前需要先判断是否为空,再插入前一个节点. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-shi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/"},{"title":"每天AC系列(九):合并K个排序链表","content":"1 题目 LeetCode第23题,合并k个有序的链表. 2 暴力法 直接遍历所有链表,取出所有节点的值,用数组存储,非降序排序,然后创建一个新链表用头插法依次插入节点. List&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(ListNode x:lists) { while(x != null) { s.add(x.val); x = x.next; } } s.sort((a,b) -&gt; {return a.compareTo(b);}); ListNode result = new ListNode(0); ListNode t = result; for(Integer x:s) { t.next = new ListNode(x); t = t.next; } return result.next; 这里要注意一下,sort那里不能写成: s.sort((a,b)-&gt;{return a&gt;b ? 1 : -1;}); 没有考虑到等于的情况,所以用compareTo代替: s.sort((a,b)-&gt;{return a.compareTo(b);}); 3 直接合并法 每次遍历所有链表,取出首节点的值,各个比较然后得出最小值,将最小值插入新链表,然后移动最小值所在的链表的指针,直到所有链表为空. ListNode result = new ListNode(0); ListNode t = result; int len = lists.length; int nullNodeNums = 0; for(boolean [] b = new boolean[len];nullNodeNums&lt;len;) { int min = Integer.MAX_VALUE; int minIndex = -1; for(int index = 0;index&lt;len;++index) { ListNode x = lists[index]; if(x == null) { if(!b[index]) { b[index] = true; ++nullNodeNums; } } else if(x.val &lt; min) { min = x.val; minIndex = index; } } if(minIndex != -1) { t.next = new ListNode(min); t = t.next; lists[minIndex] = lists[minIndex].next; } } return result.next; 这里使用了一个布尔数组判断是否某个节点已经移动到尾部,即表示是否为空,为空的话跳过这个节点,不为空的话取其值,计算是否为最小值.得到最小值后,添加到结果节点中,并移动最小值所在链表的指针. 这个方法看起来慢得很啊. 4 优先队列 优先队列是上两个方法的结合,遍历所有节点,取值并根据其值确定优先级添加到优先队列中,然后依次出队,将出队的值直接插入到新链表中. PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(ListNode x:lists) { while(x != null) { queue.add(x.val); x = x.next; } } ListNode s = new ListNode(0); ListNode t = s; while(!queue.isEmpty()) { t.next = new ListNode(queue.poll()); t = t.next; } return s.next; java的优先队列可以直接add即可,按照默认出队序列(对于整数是小的先出)使用尾插法插入到新链表中. 嗯,好像还可以的样子,但是还是不够快. 5 两两合并法 合并k个链表,相当于合并2个链表k-1次,利用递归的思想,每次合并两个链表,将合并后的链表后返回作为下一个要合并的链表继续合并. public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) return null; ListNode t = lists[0]; for(int i=1;i&lt;lists.length;++i) t = merge(t, lists[i]); return t; } //public ListNode merge(ListNode a,ListNode b) merge为直接合并两个链表的操作,不难,就不贴代码了,首先赋值t为第一个链表,然后依次合并t与剩下的n-1个链表. 好慢啊. 6 分治法 分治法是两两合并法的改进,两两合并每次合并两个链表,分治法每次合并一半数量的链表,总体思想是这样的:想要得到最终有序的链表,若左半部分的链表与右半部分的链表都有序,则相当于合并两个有序链表,为了得到左半部分的有序链表,需要继续对左半部分进行一半的分割,再次分成左半部分与右半部分,然后再分,直到某部分只有一个链表,然后返回,以合并两个普通有序链表的方式合并两个返回的链表. public ListNode f(int start,int end) { int len = end - start; if(len &lt;= 1) return lists[start]; ListNode l = f(start,start+len/2); ListNode r = f(start+len/2,end); return merge(l, r); } 代码非常简洁,一开始为判断递归的条件,区间长度小于等于1直接返回[start]的节点,然后递归合并左半部分与右半部分的节点. 一个字,舒服. 真快. 7 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-jiu-he-bing-k-ge-pai-xu-lian-biao/"},{"title":"每天AC系列(八):括号生成","content":"1 题目 LeetCode第22题,根据一个整数生成所有的有效的括号组合,这个整数表示括号的对数. 2 暴力法 对于n对括号,总共2n个字符,每个字符可以为左括号或右括号,所以总共2^(2n)中组合,暴力法就是枚举各个组合,然后判断它们是否为有效的组合: public void f(char c[],int pos,List&lt;String&gt; result) { if(pos == c.length) { if(valid(c)) result.add(Arrays.toString(c).replaceAll(&quot;(\\\\[)|(\\\\])| |,&quot;,&quot;&quot;)); } else { c[pos] = '('; f(c,pos+1,result); c[pos] = ')'; f(c,pos+1,result); } } public boolean valid(char [] f) { int len = 0; for(char c:f) { if(c == '(' ) { if(++len &gt; f.length/2) return false; } else if(len-- &lt;=0) return false; } return len == 0; } 首先加上左括号,进入下一轮递归,同时把加括号的位置加1,然后到达2n长度后,判断是否有效,有效的话加入结果数组,然后回到上一层的递归,把当前位置的括号换成右括号,接着再次进入下一轮递归,一样直到2n长度,继续判断是否有效,这样不断递归就会枚举了所有的组合. 看来不太理想啊. 3 深搜 深搜的话是暴力的改进,暴力的话不管序列是什么状态都直接添加括号,而深搜的话,当序列有效时才添加括号. 添加左括号的条件:当前的左括号数量小于n. 添加右括号的条件:当前左括号的数量小于右括号的数量. public void f(String c,int n,int l,int r,List&lt;String&gt; result) { if(l == n &amp;&amp; r == n) result.add(c); else { if(l &lt; r) return ; if(l &lt; n) f(c+&quot;(&quot;,n,l+1,r,result); if(r &lt; n) f(c+&quot;)&quot;,n,l,r+1,result); } } c为上一次递归的结果,l,r分别表示左括号与右括号的数量,递归的结束条件是左右括号的数量均为n,继续递归的条件是左右括号的数量小于n. 4 动态规划 设f(n)表示n对括号的所有有效序列,则有 具体来说: f(3) = ( + f(0) + ) + f(2) f(3) = ( + f(1) + ) + f(1) f(3) = ( + f(2) + ) + f(0) 这三个都是三对括号的有效序列,因此f(3)最后的结果是这三个有效序列组成的数组. 因为f(n)不一定为一个有效序列,因此返回值为一个数组,剩下的只需要遍历这个数组,把它们添加到最终结果数组中去: public List&lt;String&gt; f(int n) { List&lt;String&gt; s = new ArrayList&lt;&gt;(); if(n == 0) s.add(&quot;&quot;); for(int i=0;i&lt;n;++i) { List&lt;String&gt; l = f(i); List&lt;String&gt; r = f(n-i-1); for(String ll:l) { for(String rr:r) { s.add(&quot;(&quot;+ll+&quot;)&quot;+rr); } } } return s; } 若n为0,添加一个空序列然后返回,若n不为0,l表示i对括号的所有有效序列,r表示n-i-1对括号的所有有效序列,然后只需要遍历这两个序列,在两边加上左括号与右括号即可. 这个...好像没有深搜快. 5 动规优化 上面的递归的动规没有保存之前计算过的结果,比如计算n=3的时候, f(3) = ( + f(0) + ) + f(2) f(3) = ( + f(1) + ) + f(1) f(3) = ( + f(2) + ) + f(0) f(2): f(2) = ( + f(1) + ) + f(0) f(2) = ( + f(0) + ) + f(1) f(1) f(1) = ( + f(0) + ) + f(0) 只是计算f(3),计算了 f(2):2次 f(1):2+2*2=6次 f(0):2+2*2+6*2=18次 当n增大时,计算的重复度会变得更大,因此可以考虑用一个数组存储之前计算的结果,需要时直接取出来即可. public List&lt;String&gt; generateParenthesis(int n) { List&lt;List&lt;String&gt;&gt; s = new ArrayList&lt;&gt;(); s.add(Arrays.asList(&quot;&quot;)); s.add(Arrays.asList(&quot;()&quot;)); for(int n1 = 2;n1&lt;=n;++n1) { List&lt;String&gt; t = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n1;++i) { List&lt;String&gt; l = s.get(i); List&lt;String&gt; r = s.get(n1-i-1); for(String ll:l) { for(String rr:r) { t.add(&quot;(&quot;+ll+&quot;)&quot;+rr); } } } s.add(t); } return s.get(n); } 可以先看最后的return,因为s保存了0到n的所有结果,所以,直接get即可. 然后设置一个临时的n1,表示当前要计算的n1对括号的序列,当n1增加时,表示已经完成了计算n1对括号的序列,t为结果,添加到s中去.直到n1与n相等,计算完最后一个n1后,直接返回s的最后一个序列. 嗯,快了1ms,看来优化还是有效果的. 6 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-ba-gua-hao-sheng-cheng/"},{"title":"正则表达式匹配方括号","content":"Java代码: String s = &quot;[1,2,3]+[4,5,6]&quot;; System.out.println(s.replaceAll(&quot;(\\\\[)&quot;,&quot;&quot;)); //匹配左方括号 System.out.println(s.replaceAll(&quot;(\\\\])&quot;,&quot;&quot;)); //匹配右方括号 System.out.println(s.replaceAll(&quot;(\\\\[)|(\\\\])&quot;,&quot;&quot;)); //匹配左右方括号 结果: 需要使用replaceAll而不是replace. ","link":"https://2293736867.github.io/post/zheng-ze-biao-da-shi-pi-pei-fang-gua-hao/"},{"title":"每天AC系列(七):合并两个有序链表","content":"1 题目 LeetCode第21题,合并两个有序链表. 2 直接合并 因为已经有序了,类似归并排序中的合并一样,操作不难,直接上代码了. ListNode t = new ListNode(0); ListNode head = t; while(l1 != null &amp;&amp; l2 != null) { if(l1.val &lt; l2.val) { t.next = l1; l1 = l1.next; } else { t.next = l2; l2 = l2.next; } t = t.next; } while(l1 != null) { t.next = l1; l1 = l1.next; t = t.next; } while(l2 != null) { t.next = l2; l2 = l2.next; t = t.next; } return head.next; 3 递归合并 这个可以采用递归优化,而且不用额外设置一个移动的临时结点t.首先对两个指针进行判空操作,其中一个为空的话返回另一个,然后进行递归合并,首先创建一个head结点,进行赋值后递归合并next结点,将返回值赋给head.next,最后返回head. if(l1 == null) return l2; if(l2 == null) return l1; ListNode head = null; if(l1.val &lt; l2.val) { head = l1; head.next = mergeTwoLists(l1.next, l2); } else { head = l2; head.next = mergeTwoLists(l1, l2.next); } return head; 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-qi-he-bing-liang-ge-you-xu-lian-biao/"},{"title":"每天AC系列(六):有效的括号","content":"1 题目 LeetCode第20题,这题比较简单,匹配括号. 2 栈 这是栈的典型应用,括号匹配,当然不需要直接使用栈,使用一个StringBuilder即可: if(s.isEmpty()) return true; char a = s.charAt(0); if (a != '(' &amp;&amp; a != '[' &amp;&amp; a != '{') return false; StringBuilder t = new StringBuilder(); int len = -1; for(char c:s.toCharArray()) { if(c == '(' || c == '[' || c == '{') { t.append(c); ++len; } else { if(len == -1) return false; char cc = t.charAt(len); if( (c == ')' &amp;&amp; cc != '(') || (c == ']' &amp;&amp; cc != '[') || (c == '}' &amp;&amp; cc != '{') ) return false; t.deleteCharAt(len--); } } return len == -1; 首先判断是否为空,再判断第一个字符,然后进入逐个循环判断,若表示左边的括号则append,若表示右边的括号首先判断len,然后取出len处字符进行判断是否匹配,不匹配直接返回false,匹配的话则删除这个字符.最后根据len是否为-1返回最终结果. 3 优化 其实就是简化一下代码,直接开辟一个大的空间,不需要进行append与delete,只需移动栈顶指针.栈顶指针从1开始,若从0开始的话对于&quot;]&quot;这种情况会报下标越界错误,压栈就是++p,压入字符,出栈直接- - p,然后判断是否匹配即可. char[] t = new char[s.length() + 1]; int p = 1; for (char c : s.toCharArray()) { if (c == '(' || c == '[' || c == '{') t[p++] = c; else { --p; if ((c == ')' &amp;&amp; t[p] != '(') || (c == ']' &amp;&amp; t[p] != '[') || (c == '}' &amp;&amp; t[p] != '{')) return false; } } return p == 1; 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-liu-you-xiao-de-gua-hao/"},{"title":"每天AC系列(五):删除链表的倒数第N个节点","content":"1 题目 LeetCode第19题,删除链表倒数的第n个结点. 2 两趟扫描 两趟扫描的思想很简单,第一趟扫描确定长度,第二趟扫描定位到目标结点并进行删除操作. public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null || head.next == null) return null; ListNode head_copy = head; int length = 0; while(head != null) { head = head.next; ++length; } head = head_copy; ListNode before = head; int i = 0; for(;i&lt;length-n;++i) { before = head; head = head.next; } if(i == 0) return head.next; else before.next = before.next.next; return head_copy; } 3 一趟扫描 当然,来刷题的话不能就这样就算了,肯定得把它弄成一趟扫描,对吧? 两趟扫描的目的是获取长度再进行定位,因此,为了能一次定位,可以使用两个头指针,对于给定的n,先让第一个头指针访问n次,第二个头指针不动,当第一个头指针访问n次后,第一个头指针继续访问直到最后一个,第二个头指针与第一个头指针并行访问,这样,当第一个头指针访问到最后一个时,第二个头指针就指向倒数第N个节点. public ListNode removeNthFromEnd(ListNode head, int n) { ListNode a = head; ListNode b = head; ListNode t = head; for(int i=0;i&lt;n;++i) a = a.next; if(a == null) return head.next; while(a != null) { t = b; a = a.next; b = b.next; } t.next = t.next.next; return head; } 总的来说这个只需要一趟扫描即可,针对只有两个结点或者一个结点的要判断一下. 4 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-wu-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/"},{"title":"android+spring boot 选择,上传,下载文件","content":" 1 概述 2 环境 3 android 3.1 准备工作 3.1.1 新建工程 3.1.2 AndroidManifest.xml 3.1.3 build.gradle 3.1.4 上传文件 3.1.5 布局 3.2 选择文件 3.2.1 申请权限 3.2.2 Intent选择文件 3.3 上传文件 3.4 下载文件 4 Spring Boot 4.1 准备工作 4.1.1 新建工程 4.1.2 application.properties 4.1.3 pom.xml 4.2 处理上传文件 4.3 处理下载文件 5 测试 5.1 postman测试 5.1.1 上传测试 5.1.2 下载测试 5.2 android端测试 5.2.1 上传测试 5.2.2 下载测试 6 部署到服务器 6.1 部署 6.1.1 改变打包方式 6.1.2 去除tomcat依赖 6.1.3 修改Main 6.1.4 修改路径 6.1.5 设置打包名字 6.1.6 打包 6.1.7 上传到服务器 6.1.8 运行 6.2 测试 6.2.1 postman测试 6.2.2 android端测试 7 最最最喜欢的 坑 7.1 权限 7.2 路径 7.3 有关http的问题 7.3.1 okhttp的stream关闭 7.3.2 http 7.3.3 线程 7.3.4 AVD 7.4 ip 7.5 判空处理 8 源码 1 概述 前端android,上传与下载文件,使用OkHttp处理请求,后端使用spring boot+MVC,处理android发送来的上传与下载请求.这个其实不难,就是特别多奇奇怪怪的坑,因此,希望看到的,不要像笔者这样踩的那么痛苦了... 2 环境 win10 Spring Boot 2.2.2 RELEASE IDEA 2019.3.1 Android Studio 3.6RC1 Tomcat 9.0.30 3 android 3.1 准备工作 3.1.1 新建工程 这次用一个全新的例子写博客,因此从新建工程开始: 3.1.2 AndroidManifest.xml 加入 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;application android:usesCleartextTraffic=&quot;true&quot;&gt; 网络权限,读写SD卡权限,当然还有允许http请求的权限. 3.1.3 build.gradle 加入 compileOptions { sourceCompatibility = 1.8 targetCompatibility = 1.8 } 这个是支持JDK8的. 还有这两个okhttp与conscrypt,最新版本okhttp可以在这里查看,最新版本conscrypt在这里: implementation 'com.squareup.okhttp3:okhttp:4.3.1' implementation 'org.conscrypt:conscrypt-android:2.2.1' 3.1.4 上传文件 手动上传一些文件到AVD设备,为下一步选择与上传文件做准备,先把这个窗口工具栏打开: 打开后,打开在右侧栏中的Device File Explorer: 然后选择sdcard文件夹上传文件即可,其他文件夹一般没有权限. 3.1.5 布局 添加三个button(上传/下载/选择文件),一个EditText(上传文件名与下载文件名),一个ImageView(显示下载的图片). 直接拖放改一下id. 3.2 选择文件 3.2.1 申请权限 首先申请动态读写文件权限(其实选择文件只需要读权限,因为后面的下载需要写权限所以这里就一起申请了): 使用checkSelfPermission检查权限,参数为一个Context与String,String表示相应的权限,如果有了这个权限就会返回 PackageManager.PERMISSION_GRANTED 没有就会返回 PackageManager.PERMISSION_DENIED 没有就利用requestPermissions()申请,参数为Content,String[],int,String[]表示要申请的所有权限,int是一个requestCode. 3.2.2 Intent选择文件 新建一个Intent后,设置选择类型,然后就重写onActivityResult: 这是简化了的处理,因为选择的是图片,选择其他文件的话可以参照这里. 其中path是选择的文件的路径,可能你会问: String path = dir.toString().substring(0,dir.toString().indexOf(&quot;0&quot;)+2) + DocumentsContract.getDocumentId(uri).split(&quot;:&quot;)[1]; 这个是怎么来的,其实是拼凑过来的,因为这是图片,是这个的简化版: (博客在这里) 3.3 上传文件 参数为文件路径与文件名,然后使用OkHttpClient,因为是文件,用的body是MultipartBody,增加一个叫file的FormDataPart与一个叫filename的FormDataPart.然后使用execute()发送请求,body()获取响应内容,这里假设了后端响应一个布尔,表示上传成功或失败,url的话使用了本地的路径,注意不能是localhost,使用内网ip,然后还要与后端对应. 3.4 下载文件 参数为一个文件名,根据这个文件名返回对应的文件,返回一个File,这里请求体可以选择FormBody或MultipartBody,因为这是一个文件名参数,这里笔者为了统一就选择了MultipartBody,使用FormBody的话,只需要将RequestBody的那一行改为: RequestBody body = new FormBody.Builder().add(&quot;filename&quot;,filename).build(); 有了请求体后发送请求获取响应体,进而获取输入流,然后首先需要判断是否为空,但不能直接这样判断: inputStream == null 因为后端是这样的: 从响应体获取的inputStream肯定不为null,需要先进行一次读取(也就是判断里面的文件是否为null),若为null的话删除这个文件,不为null的话继续读取并写入文件. 4 Spring Boot 4.1 准备工作 用的是IDEA,其他IDE请自行搜索如何新建一个SpringBoot工程. 4.1.1 新建工程 打包的话可以jar或war,不用部署的话jar即可,要部署的话后期也可以改成war. 两个,一个Spring Web,用于MVC等,一个模板引擎,用于显示视图,如果不需要显示可以不选. 4.1.2 application.properties 作为一个示例demo,属性就直接在application.properties中配置了,实际情况请在相应的配置文件中配置相应属性. 需要配置上传文件的大小限制与上传文件夹的路径. 4.1.3 pom.xml 这里其实不需要干什么,只是如果下载依赖慢的话,可以这样设置settings.xml文件,在&lt;mirrors&gt;中加上: &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; windows用户的话这个文件在 C:\\Users\\{username}\\.m2\\settings.xml linux的话在 ~/.m2/settings.xml 4.2 处理上传文件 首先对应的post映射路径为/upload,与android端的路径对应,然后需要一个表示文件的MultipartFile与一个表示文件名的String,判断这两个是否为空后,如果上传的文件夹不存在则先创建,存在的话直接进行复制,然后根据复制成功或失败返回布尔值.复制使用了Files.copy(),第一个InputStream为上传文件的输入流,第二个Path为存储文件的路径,resolve(filename)相当于在上传目录下的filename文件.输出的话建议使用日志代替. 4.3 处理下载文件 下载的话可以选择使用get或post请求,这里选择了post请求,因为android端是post请求,需要对应.get请求的话可以从浏览器发起. 首先根据文件名获取对应文件,判断文件是否存在后返回一个ResponseEntity,需要设定content-type与body,content-type根据需要设置即可,这里是图片,默认.jpg或.png,body的话使用FileSystemResource,直接new一个放进body即可. 如果不存在相应的文件则返回null,这里需要注意一下前端的判断,不能直接判断ResponseBody是否为null. 5 测试 5.1 postman测试 postman只能测试与后端的连接,上传等是否有问题,可以用来定位后端的问题. 5.1.1 上传测试 再Headers中设置了Content-Type为multipart/form-data后: 在body添加一个叫file的文件与一个叫filename的字符串表示文件名: 发送,返回true. 服务器端有输出提示: 查看文件夹: 5.1.2 下载测试 把file参数关掉,保留filename,修改路径. 然后发送,postman可以直接显示图片: 5.2 android端测试 5.2.1 上传测试 后端提示: 查看文件夹: 5.2.2 下载测试 输入文件名后直接下载: 默认的话是放在这里,按需要更改位置即可,注意加上写权限: 若看不到文件选择synchronize即可. 6 部署到服务器 服务器用的是tomcat,需要修改一些Spring Boot的部分. 6.1 部署 6.1.1 改变打包方式 pom.xml中jar改成war. 6.1.2 去除tomcat依赖 pom.xml加入: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 6.1.3 修改Main 修改Main类,让其继承SpringBootServletInitializer,重载configure(),同时main()保持不变. 修改前: 修改后: 6.1.4 修改路径 这个按需要修改即可,在这里不需要,注意就是@PostMapping,@GetMapping等都是相对于 tomcat/webapps/项目/ 目录下的. 6.1.5 设置打包名字 build加上&lt;finalName&gt;. 6.1.6 打包 6.1.7 上传到服务器 打包后的文件放在target下,使用scp上传即可,这里是本地的tomcat,就这接移动war了. 6.1.8 运行 开启tomcat,双击startup.bat即可. linux的话: cd xxxx/tomcat/bin ./startup.sh 6.2 测试 在测试前需要确保没有占用相应端口,默认8080,也就是说,如果不改端口的话,需要关闭IDEA运行中的SpringBoot应用. 6.2.1 postman测试 上传测试,注意需要改路径,加上打包项目名,ip的话可以使用localhost或者内网ip. 服务器这边收到了,因为上传路径只是直接写名字,因此会与startup.bat同一路径. 下载测试: 服务器的输出: 6.2.2 android端测试 android端需要修改路径即可,加上war打包的名字. 这里打包的名字是kr,直接加上即可. 上传那里也是要加上,然后: 服务器的输出: 查看文件: 7 最最最喜欢的 坑 7.1 权限 android需要读权限才能读取文件并上传,需要写权限才能保存从服务器返回的文件,在AndroidManifest.xml中加入: &lt;manifest&gt;... &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;application&gt;...&lt;/application&gt; 这是外部设备的读写权限.当然,加入这个还不能访问,因为,android6.0以后还需要动态申请权限,所以: String [] permission = new String[]{ &quot;android.permission.READ_EXTERNAL_STORAGE&quot;, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; }; if( ActivityCompat.checkSelfPermission(this,permission[0]) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this,permission[1]) != PackageManager.PERMISSION_DENIED ) { ActivityCompat.requestPermissions(this,permission,1); } 7.2 路径 需要保证下面几个路径正确,还有可读,可写等: url路径不能错. 前端上传文件的路径. 后端接收前端上传文件的路径. 后端发送前端需要下载的文件的路径. 前端接收下载文件的路径. 7.3 有关http的问题 7.3.1 okhttp的stream关闭 若前端是这样写的,在工具类中返回了之后Response已经关闭,因此需要读取输入流之类的需要先读取再返回,而不是返回一个ResponseBody或InputStream进行读取,否则会提示&quot;closed&quot;. 7.3.2 http Android P开始默认禁用http,因此可以使用https或者在AndroidManifest.xml中允许http连接: &lt;application android:usesCleartextTraffic=&quot;true&quot;&gt; 7.3.3 线程 网络请求不能在主线程中,新开一个线程即可. 7.3.4 AVD 若检查过了服务器与android端没问题,那么有可能是AVD的问题,解决方法很简单,卸载,重启AVD,注意一定要卸载再重启. 7.4 ip 在本地测试的话后端可以直接localhost,在android端不能直接localhost,可以使用ipconfig或ifconfig查看内网ip,输入内网ip即可. 若在服务器上测试直接使用服务器ip. 7.5 判空处理 对于前端,应该判断存储路径是否为空,是否为null等,再传给后端,对于后端,要判断文件是否存在等,不存在就返回null,这时又需要前端进行判断返回的null,在下载文件时,虽然对不存在的文件后端返回null,但是,前端收到的是一个InputStream,不能直接判断是否为null,需要先读取一次,再进行剩下的读取: 8 源码 github 码云 ","link":"https://2293736867.github.io/post/androidspring-boot-xuan-ze-shang-chuan-xia-zai-wen-jian/"},{"title":"每天AC系列(四):四数之和","content":"1 题目 Leetcode第18题,给定一个数组与一个target,找出数组中的四个数之和为target的不重复的所有四个数. 2 暴力 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length == 4 &amp;&amp; nums[0] + nums[1] + nums[2] + nums[3] == target) result.add(Arrays.asList(nums[0], nums[1], nums[2],nums[3])); else if (nums.length &gt; 4) { Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resultSet = new HashSet&lt;&gt;(); for(int i=0;i&lt;nums.length-3;++i) { for(int j=i+1;j&lt;nums.length-2;++j) { for(int k=j+1;k&lt;nums.length-1;++k) { for(int m=k+1;m&lt;nums.length;++m) { if(nums[i]+nums[j]+nums[k]+nums[m] == target) resultSet.add(Arrays.asList(nums[i],nums[j],nums[k],nums[m])); } } } } result.addAll(resultSet); Collections.sort(result,(t1,t2)-&gt; { if(t1.get(0) &gt; t2.get(0)) return 1; if (t1.get(0) &lt; t2.get(0)) return -1; if (t1.get(1) &gt; t2.get(1)) return 1; if (t1.get(1) &lt; t2.get(1)) return -1; if (t1.get(2) &gt; t2.get(2)) return 1; if (t1.get(2) &lt; t2.get(2)) return -1; if (t1.get(3) &gt; t2.get(3)) return 1; if (t1.get(3) &lt; t2.get(3)) return -1; return 0; }); } return result; 判断长度,然后排序,直接上四个for,然后... 好! 惨败. 3 优化 3.1 去掉结果排序 首先最后的排序是不必要的,也就是后面的 Collections.sort(result,(t1,t2)-&gt; { if(t1.get(0) &gt; t2.get(0)) return 1; if (t1.get(0) &lt; t2.get(0)) return -1; if (t1.get(1) &gt; t2.get(1)) return 1; if (t1.get(1) &lt; t2.get(1)) return -1; if (t1.get(2) &gt; t2.get(2)) return 1; if (t1.get(2) &lt; t2.get(2)) return -1; if (t1.get(3) &gt; t2.get(3)) return 1; if (t1.get(3) &lt; t2.get(3)) return -1; return 0; }); 对结果进行排序不必要,虽然会在测试时与答案有差别,但是提交的话不需要排序. 3.2 stream去重 之前的操作用的是HashSet进行去重,有一个符合的四元组就直接添加进集合中,现在采用了stream+distinct去重: return result.stream().distinct().collect(Collectors.toList()); 3.3 双指针+最大最小剪枝 可以利用类似三数之和的思想,固定一个数,双指针分别指向两端的两个数,这里的话,四个数,选择固定两个数,计算它们的和并把它们看作一个数,即可利用双指针. for(int i=0;i&lt;nums.length-3;++i) { for(int j=i+1;j&lt;nums.length-2;++j) { int m = nums[i] + nums[j]; int left = j+1; int right = nums.length-1; while(left &lt; right) { int temp = m + nums[left] + nums[right]; if(temp == target) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); --right; ++left; } else if(temp &gt; target) --right; else ++left; } } } m为固定的数,left与right就是双指针,根据&quot;三数&quot;之和判断与目标值的大小移动双指针. 最小剪枝就是首先计算&quot;三数&quot;的最小值,若大于目标值就可以跳过,最大剪枝就是计算&quot;三数&quot;的最大值,若小于目标值则跳过,进入下一个循环: int m = nums[i] + nums[j]; int left = j+1; int right = nums.length-1; if(m + nums[left] + nums[left+1] &gt; target) continue; if (m + nums[right-1] + nums[right] &lt; target) continue; 3.4 提交 呃...好了那么一点点吧. 4 来来来再快一点 4.1 初始判断 首先,初始的判断可以再简单一点,如果数组为空或长度小于4,直接返回. List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums == null &amp;&amp; nums.length &lt; 4) return result; 4.2 一次不够,就再剪几次 上面的算法中,只是在两层for里面进行了一次最大最小剪枝,可以在没进入for之前剪一次: Arrays.sort(nums); int len = nums.length; if( nums[0] + nums[1] + nums[2] + nums[3] &gt; target || nums[len-4] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target ) return result; for(int i=0;i&lt;len-3;++i) 注意要先排序,然后直接判断整个数组的最大最小值并与target判断. 然后在进入第一层for之后再剪一次: for(int i=0;i&lt;len-3;++i) { if(nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target) break; if(nums[i] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target) continue; for(int j=i+1;j&lt;len-2;++j) } 因为数组是升序排序的,因此,&quot;最左边&quot;四个数肯定是最小值,若这个最小值大于target,可以直接break了,但是,最右边三个数与nums[i]相加不一定为最大值,因此判断之后若小于target只能continue. 4.3 去重 4.3.1 双指针去重 首先,在双指针的循环中,若发现了有四个数符合条件,可以尝试多次移动指针: result.add(Arrays.asList(nums[i], nums[j], nums[left++], nums[right--])); while(left &lt; right &amp;&amp; nums[left] == nums[left-1]) ++left; while(left &lt; right &amp;&amp; nums[right] == nums[right+1]) --right; 因为值一样的可以一次性移动指针,不需要再次进行和的判断. 呃,可以尝试提交了. 咦,不对啊,做了这么多,没快多少啊... 为啥呢... ... 4.3.2 外循环去重 找了很久,发现是这里的原因: return result.stream().distinct().collect(Collectors.toList()); 这里去重的话,用是用的很舒服,一个stream(),一个distinct()就好了,问题是...还是很慢啊!!! 所以呢,需要手动去重,出现重复的原因就是数组中有重复的数,比如: [1,1,1,1,2,2,2,2],target=6 顺序判断时,会好几个 [1,1,2,2] 因此,对于重复的数,进行跳过处理,在第一层for中,对重复过的进行跳过: for(int i=0;i&lt;len-2;++i) if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue; 其次,在第二层for中,也对重复过的进行跳过: for(int j=i+1;j&lt;len-2;++j) if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue; 这样的话,例如对于上面的(不同的1用字母区分) [1(a),1(b),1(c),1(d),2,2,2,2] 一开始是a处的1与b处的1,然后到了第二层循环,因为此时j=i+1,指向b处的1,因此不会跳过1,会进入双指针循环,第二次j指向c处的1,出现重复,j不断跳过直到j指向2.然后2结束后,到了i这层循环,因为1出现过,i不断跳过直到i指向2. 没错,说了这么多,去重不需要什么HashSet,不需要什么stream,只需两行: if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue; if(j&gt;i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; 4.4 提交 尽力了. 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-si-si-shu-zhi-he/"},{"title":"@Scheduled注解","content":" 1 概述 2 cron 2.1 cron通配符 2.2 cron示例 3 fixedRate 3.1 fixedRate 3.2 fixedRateString 4 fixedDelay 4.1 fixedDelay 4.2 fixedDelayString 5 initialDelay 5.1 initialDelay 5.2 initialDelayString 1 概述 @Scheduled注解是spring boot提供的用于定时任务控制的注解,主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意需要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay. 2 cron cron是@Scheduled的一个参数,是一个字符串,以5个空格隔开,只允许6个域(注意不是7个,7个直接会报错),分别表示秒,分,时,日,月,周. 单位 允许值 允许通配符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * / ? L W 月 1-12 或 JAN-DEC(大小写均可) , - * / ? 周 1-7 或 SUN-SAT(大小写均可) , - * / ? L # 2.1 cron通配符 符号 含义 * 所有值.在秒字段上表示每秒执行,在月字段上表示每月执行 ? 不指定值,不需要关系当前指定的字段的值,比如每天都执行但不需要关心周几,就可以把周的字段设为? - 区间,如秒的0-2,表示0秒,1秒,2秒都会触发 , 多个值,比如在0秒,20秒,25秒触发,可以把秒的字段设为0,20,25 / 递增触发,比如秒的字段上设0/3,从第0秒开始,每隔3秒触发 L 最后,只允许在日字段或周字段上,在日字段上使用L表示当月最后一天,在周字段上使用3L表示该月最后一个周四 W 只允许用在日字段上,表示距离最近的该日的工作日.工作日指的是周一至周五 # 只允许在周字段上,表示每月的第几个周几,如2#3,每月的第3个周二 2.2 cron示例 @Scheduled(cron = &quot;0 * * * 1 SAT&quot;) //每年的1月的所有周六的所有0秒时间执行 @Scheduled(cron = &quot;0 0 0 1 Jan ?&quot;) //每年的1月的1日的0时0分0秒执行 cron支持占位符,若在配置文件中有 cron = 2 2 2 2 2 ? 则 @Scheduled(cron = &quot;${cron}&quot;) 表示每年的二月二号的两时两分两秒执行. 3 fixedRate 3.1 fixedRate fixedRate表示自上一次执行时间之后多长时间执行,以ms为单位. 如 @Scheduled(fixedRate = 1000 * 5) 自上次执行之后5秒再执行. 3.2 fixedRateString 有一个类似的参数叫fixedRateString,是字符串的形式,支持占位符. 如 @Scheduled(fixedRateString = &quot;1000&quot;) 自上次执行1秒再执行. 若在配置文件中有相应的属性,可以用占位符获取属性,如在application.properties中有 interval=2000 可以使用 @Scheduled(fixedRateStirng=&quot;${interval}&quot;) 表示2秒间隔. 4 fixedDelay 4.1 fixedDelay fixedDelay与fixedRate有点类似,不过fixedRate是上一次开始之后计时,fixedDelay是上一次结束之后计时,也就是说,fixedDelay表示上一次执行完毕之后多长时间执行,单位也是ms. @Scheduled(fixedDelay = 1000 * 3600 * 12) //上一次执行完毕后半天后再次执行 4.2 fixedDelayString 与fixedRateString类似,也是支持占位符 @Scheduled(fixedDelayString = &quot;${fixedDelay}&quot;) 5 initialDelay 5.1 initialDelay initialDelay表示首次延迟多长时间后执行,单位ms,之后按照cron/fixedRate/fixedRateString/fixedDelay/fixedDelayString指定的规则执行,需要指定其中一个规则. @Scheduled(initialDelay=1000,fixedRate=1000) //首次运行延迟1s 5.2 initialDelayString 与initialDelay类似,不过是字符串,支持占位符. @Scheduled(initialDelayString = &quot;${initialDelay}&quot;,cron = &quot;0 0 0 14 4 ?&quot;) //按照配置文件initialDelay指定的时间首次延迟,并于每年4月14日0时0分0秒执行 ","link":"https://2293736867.github.io/post/scheduled-zhu-jie/"},{"title":"每天AC系列(三):电话号码的字母组合","content":"1 题目 Leetcode第17题。 数字2-9映射字母，给出一个包含字符串的数字，列出字母的所有组合。 2 递归 拿到这样的题目想到了递归实现，创建一个Map映射对应的字母，然后把它传给递归函数，同时创建一个临时变量temp，保存每一次添加字母的结果，递归的结束条件是数字串的长度为0. public void one(String digits,List&lt;String&gt; result,HashMap&lt;Integer,String&gt; ss,String temp) { if(digits.length() &gt; 0) { String s = ss.get((int)(digits.charAt(0))-48); for(int i=0;i&lt;s.length();++i) one(digits.substring(1),result,ss,temp+s.charAt(i)); } else result.add(temp); } 3 提交 直接一次AC. 4 优化 其实可以不需要Map的，可以直接使用一个字符串数组，因为是数字到字符串的映射，对于数字可以用下标代替。其次，为了更快的速度可以使用StringBuilder代替String. 还有就是用下标代替了截断digits，对于digits其实没必要使用截断，只需要一个下标表示范围即可，对于StringBuilder，因为没有像String这样的+，因此需要在使用append后对其进行删除处理。 public void one(String digits,int index,StringBuilder temp) { if(index &lt; digits.length()) { String d = s[digits.charAt(index)-'0']; for(int i=0;i&lt;d.length();++i) { one(digits,index+1,temp.append(d.charAt(i))); temp.deleteCharAt(index); } } else result.add(temp.toString()); } 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-san-dian-hua-hao-ma-de-zi-mu-zu-he/"},{"title":"每天AC系列(二):最接近的三数之和","content":"1 题目 leetcode第16题，给定一个数组与一个目标数，找出数组中其中的三个数，这三个数的和要与目标数最接近。 2 暴力 按惯例先来一次O(n3)的暴力： int temp = nums[0]+nums[1]+nums[2]; for(int i=0;i&lt;nums.length;++i) for(int j=i+1;j&lt;nums.length;++j) for(int k=j+1;k&lt;nums.length;++k) { int temp1 = nums[i]+nums[j]+nums[k]; if(Math.abs(temp-target) &gt; Math.abs(temp1-target)) { temp = temp1; if(temp == target) return target; } } return temp; 然后。。。。 受宠若惊啊，直接暴力居然给过了。。。 3 O(n2) 算了，这种暴力笔者自己也看不下去，搞点正经事，暴力的话直接三个循环，每一次都加三个数并判断与target的距离，如果是target直接返回，如果不是则继续，但是...O(n3)啊... 其实这也可以用笔者上一篇文章中提到的双指针法，先对数组排序，然后固定一个数，再用两个指针指向起始端与末端，然后不断向中间逼近。 Arrays.sort(nums); int t1 = nums[0]+nums[1]+nums[2]; for(int i=0;i&lt;nums.length-2;++i) { int left = i+1; int right = nums.length-1; while(left &lt; right) { int t2 = nums[i]+nums[left]+nums[right]; if(t2 == target) return target; else if(t2 &gt; target) --right; else ++left; if(abs(t1-target) &gt; abs(t2-target)) { t1 = t2; } } } return t1; 首先将数组排序，nums[i]为固定的数，left和right为两个两个指针，根据计算的t2=nums[i]+nums[left]+nums[right]判断与target关系，大于的话向左移动右指针，小于的话向右移动左指针，直到两指针相遇。排序需要O(n log n)，两个循环需要O(n2)，总的时间复杂度为O(n2). 4 冲击2ms 去看了一下第一的那个解答，2ms，确实是快，主要是手写了快排，然后在for里面的循环中用了最大最小剪枝。 4.1 手写快排 去查了一下Arrays.sort()的算法，它是几种算法的组合： （图片来源） 只有当数组的长度小于286大于等于47时，才会调用快速排序，因此这里直接手写了一个快排，无论长度多少都直接使用快排。 （原理就不多说了，手写快排还是稍微有那么一点难度的...） public void qs(int [] nums,int l,int r) { if(l &lt; r-1) { int t = l; int ll = l+1; int rr = r-1; int temp; while(true) { while(t &lt; rr &amp;&amp; nums[t] &lt; nums[rr]) --rr; if(t &lt; rr) { temp = nums[rr]; nums[rr] = nums[t]; nums[t] = temp; t = rr--; } else break; while(ll &lt; t &amp;&amp; nums[ll] &lt; nums[t]) ++ll; if(ll &lt; t) { temp = nums[ll]; nums[ll] = nums[t]; nums[t] = temp; t = ll++; } else break; } qs(nums,l,t); qs(nums,t+1,r); } } 原本两个while循环中的条件是 while(ll &lt; rr &amp;&amp; ...) 后来出了bug，调了一下，发现范围不对，改成了两个while： while(t &lt; rr &amp;&amp; ...) while(ll &lt; t &amp;&amp; ...) 4.2 最大最小剪枝 最小剪枝就是计算固定的那个数，还有两个最小的数之和，判断与目标值的大小，如果这个最小值大于目标值，那么，结果有可能是这个最小值，但是，不可能是其他值，因为这个值最小了，而且大于目标值，再与其他值相加的话只会离目标值更远，因此判断是最小值后可以直接break. 最大剪枝也类似，计算最大的两个数与固定的那个数之和，判断与目标值的大小，如果小于目标值，则结果有可能是这个最大值，不可能是其他值，判断完后也是直接break. int left = i+1; int right = nums.length-1; if(left &lt; right) { int min = nums[i] + nums[left] + nums[left+1]; if(min &gt; target) { if(abs(min - target) &lt; abs(t1 - target)) t1 = min; continue; } } int max = nums[i] + nums[right] + nums[right-1]; if(max &lt; target) { if(abs(max - target) &lt; abs(t1 - target)) t1 = max; continue; } 4.3 噢... 一个字，开心。 5 源码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-er-zui-jie-jin-de-san-shu-zhi-he/"},{"title":"自定义grub主题","content":" 1 概述 2 下载主题 3 解压 4 安装 5 效果 6 改进 6.1 progress_bar 6.2 boot_menu 6.3 image 6.4 /etc/default/grub 6.5 /boot/grub/grub.cfg 6.6 背景 7 最终效果 8 配置文件 1 概述 自定义grub引导菜单的主题，笔者的linux是deepin，感觉默认的grub主题不太好看，嗯，没办法，就是想改了。 这篇文章主要是修改/boot/grub/grub.cfg以及/boot/grub/themes/.../theme.txt这两个文件，修改之前要备份，不要问为什么。 2 下载主题 到这里下载自己喜欢的主题。这是笔者下载的主题。 3 解压 tar -zxvf xxxx.tar.gz 4 安装 直接在解压后的文件夹运行： sudo ./install.sh 输入y： 5 效果 6 改进 还不满意，嗯。。。 6.1 progress_bar 这个是进度条的设置，如果觉得进度条不满意可以直接去修改/boot/grub/themes/主题名/theme.txt下的progress_bar设置： 可以修改（距离左边和顶部的）位置，宽度，高度，是否显示文本，设置文本等，还可以设置前景颜色（fg_color）与背景颜色（bg_color），还有进度条的风格，就是显示哪一些图片等。 6.2 boot_menu 这个是启动项菜单的设置，可以调整启动项的位置，字体大小，启动项高度，各个启动项之间的间隔，启动项前的图标大小等。 6.3 image 笔者的这个theme.txt有一个image,用来显示KDElogo的，这个可以选择直接不要，删除全部即可，如果想更换成自己喜欢的图片，可以直接修改文件位置，或者再新建一个image: 如果是自己的文件需要把图片放到与theme.txt同一个文件夹，其他宽度，高度之类的，设置合适就好了。 6.4 /etc/default/grub 一些系统相关的基本上不用改，经常改的是默认项，timeout这几个。 GRUB_DEFAULT：设置默认启动项，按menuentry排序（menuentry顺序可以通过/boot/grub/grub.cfg查看），从0开始计数，从0开始计数，从0开始计数，重要的事再说一遍不是从1开始计数，若设为“saved”的话表示保存上次项，需要配合GRUB_SAVEDEFULT使用。 GRUB_SAVEDEFAULT：当GRUB_DEFAULT设置为“saved”时这个选项才生效，默认为false，设为true的话默认的启动项是上次启动项。 GRUB_TIMEOUT：进入默认项的等待时间，单位秒，有其他键被按下这个时间会取消，默认为5，设为0表示立即启动，不会显示启动项菜单，设为-1的话表示无限等待。 GRUB_TIMEOUT_STYLE：默认为&quot;menu&quot;（不设置这个值与设为“menu”等价），表示显示启动项菜单，如果设为&quot;countdown&quot;，不会显示启动项菜单，会显示一行倒计时文字，若设为“hidden”，效果与“countdown”类似，不过不会显示倒计时文字，等待GRUB_TIMEOUT结束后启动默认启动项。若设为&quot;countdown&quot;或&quot;hidden&quot;，想要显示启动项菜单按Esc即可。 不过这里其实有一个坑，就是只需要按Esc一次即可显示启动项菜单，一次即可，两次就会进入grub中的shell，这个要把握好时机，按快了的话没效果或者会进入grub，按慢了就直接启动默认启动项了，当然这个如果GRUB_TIMEOUT稍微大一点就无所谓，笔者说这个因为经历过把GRUB_TIMEOUT设为1，然后GRUB_TIMEOUT_STYLE设为了“hidden”这样的情形，然后就悲剧了。。。想进去启动菜单要重启好几次。。。。因此，GRUB_TIMEOUT_STYLE不太建议设为“countdown”或“hidden”，笔者“血的教训”。。。 /etc/default/grub还有其他设置，不过一般不怎么用，需要的话可以来这里看一下。 6.5 /boot/grub/grub.cfg 执行update-grub后会更新这个文件，手动修改这个文件是因为想修改启动项的文字，因为太长了，感觉没必要。 注意，如果手动修改过/etc/default/grub，也就是需要执行update-grub后使其生效后，需要重新修改/boot/grub/grub.cfg. sudo vim /boot/grub/grub.cfg 笔者只是想改文字，因此这里搜索找到menuentry直接修改： 改短一点就好了，submenu同理： 6.6 背景 这个比较简单，这接把想要的背景复制到/boot/grub/themes/主题名/下，重命名叫background.png即可，或者可以在theme.txt中修改： 7 最终效果 这是笔者的最终效果，主要就是加了一个头像，换个背景啥的。(手机问题。。。) 8 配置文件 这是需要的配置文件以及主题。 github ","link":"https://2293736867.github.io/post/zi-ding-yi-grub-zhu-ti/"},{"title":"每天AC系列(一):三数之和","content":"1 题目 LeetCode第15题,难度中等,题目描述: 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 2 解法 什么也不管先来个O(n3): for(int i=0;i&lt;nums.length;++i) { for(int j=i+1;j&lt;nums.length;++j) { for(int k=j+1;k&lt;nums.length;++k) { if(nums[i]+nums[j]+nums[k] == 0) { ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(nums[i]); arrayList.add(nums[j]); arrayList.add(nums[k]); result.add(arrayList); } } } } well. 3 优化 上面暴力算法的思想就是单纯三个循环,优化的方法可以考虑降低一个循环,使用&quot;双指针&quot;的思想,首先对数组进行排序,然后一开始固定一个数,然后让两个指针一个指向这个数的右区间的起点,一个指向终点,不断计算这三个值的和,根据得出的和移动左指针或者右指针,一共三种情况: 和等于0,同时移动左右指针,两者向中间方向移动. 和大于0,说明取值过大,需要把右指针向左移动. 和小于0,说明取值过小,需要把左指针向右移动. 基于以上的三种情况,写出了如下代码: List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums.length == 3 &amp;&amp; nums[0] + nums[1] + nums[2] == 0) result.add(Arrays.asList(nums[0], nums[1], nums[2])); else if (nums.length &gt; 3) { Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resultSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2 &amp;&amp; nums[i] &lt;= 0; ++i) { int left = i + 1; int right = nums.length - 1; while (left &lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { if (!resultSet.contains(Arrays.asList(nums[i], nums[left], nums[right]))) resultSet.add(Arrays.asList(nums[i], nums[left], nums[right])); --right; ++left; } else if (sum &gt; 0) --right; else ++left; } } result.addAll(resultSet); } 首先判断数组的长度是否大于等于3,小于3的话直接返回一个空List,等于3判断是否这三个数之和为0,大于3的话,首先排序,接着需要确保被确定的相对不移动的数为负数,这样的话剩下两个数的和才有可能为正数,否则的话会造成全部都是正数还要进行判断的局面.接着计算left指针与right指针的值,一直判断直到两指针相遇. 4 提交 AC! 5 完整代码 github 码云 ","link":"https://2293736867.github.io/post/mei-tian-ac-xi-lie-yi-san-shu-zhi-he/"},{"title":"Java备份MySQL","content":" 1 概述 2 创建备份路径 3 执行命令 4 执行 5 其他问题 1 概述 使用java备份mysql数据库,主要是使用mysqldump与Runtime().getRuntime().exec(). 2 创建备份路径 如果没有备份的存储路径首先创建路径. Path path = Paths.get(xxxx); try { Files.createDirectories(path); } catch(IOException e) { //xxxx } 3 执行命令 如果是直接用shell执行的话: mysqldump -u user_name -p database_name &gt; xxxx\\database_name.sql 使用-u与-p分别指定用户与密码,最后重定向到文件. 但是,要注意再java中用exec()时,千万千万不能使用-p选项,-p是交互式输入密码的,使用了-p的话导出的文件是0KB的,需要使用 --password 代替. String command = &quot;mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 要注意一下路径问题,另外,在windows下,需要使用cmd: String command = &quot;cmd /c mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 这需要把 %MYSQL_HOME%/bin 加入到环境变量,如果没有加入的话输入绝对路径: String command = &quot;cmd /c C:\\\\Program Files\\\\mysql\\\\bin\\\\mysqldump -u user --password=xxxx &gt; xxxx\\\\xxxx.sql&quot; 4 执行 try { Runtime.getRuntime().exec(command); } catch(IOException e) { //xxxx } 5 其他问题 如果没有导出文件或者导出的文件为0KB,可能原因是: 语法错误:命令的空格使用不当,路径设置错误,使用了错误的参数等. 环境问题:如在windows下没有添加到环境变量,没有加上&quot;cmd /c&quot;. 用户名/密码错误:这个.... 权限问题:用户没有相应权限,要登陆到mysql中授权. ","link":"https://2293736867.github.io/post/java-bei-fen-mysql/"},{"title":"Python生成词云","content":" 1 概述 2 准备工作 2.1 安装anaconda 2.2 安装cython 2.3 安装wordcloud 3 使用 3.1 打开Jupyter 3.2 创建文字库 3.3 生成词云 3.4 注意事项 1 概述 利用Python生成简单的词云,需要的工具是cython,wordcloud与anaconda. 2 准备工作 包括安装cython,wordcloud与anaconda. 2.1 安装anaconda 下载官网 选择对应的版本下载即可. 2.2 安装cython cython是为了安装wordcloud准备的. pip -m pip install --upgrade cython 2.3 安装wordcloud 安装wordcloud前需要先安装Microsoft Visuall C++ 14.0. 这里下载 安装好了以后重启,输入 python -m easy_install wordcloud 3 使用 3.1 打开Jupyter 打开Jupyter Notebook. 然后会在浏览器打开这个页面,新建一个notebook. 先把需要的库导入: from wordcloud import WordCloud import matplotlib.pyplot as plt 3.2 创建文字库 简单的文字库可以直接选择一个txt文件,复杂的话可以选择创建一个excel,导出为csv文件,然后利用pandas库的read_csv()读入文件.这里创建一个txt,空格分隔单词即可. 然后上传到Jupyter中: 3.3 生成词云 首先读入文件: text = open('1.txt').read() 然后使用WordCloud().generate(text),在里面设置各种属性. wc=WordCloud( width=800, repeat=True, height=800).generate(text) 这里设置了高度与宽度,允许重复. plt.imshow(wc,interpolation=&quot;bilinear&quot;) plt.axis(&quot;off&quot;) plt.show() 显示词云, interpolation='bilinear' 会使显示平滑更加平滑,axis(&quot;off&quot;)表示不显示坐标轴. 下面是效果: 3.4 注意事项 如果含有汉字,首先在读取时设置编码: text = open('1.txt',encoding='utf-8') 然后再生成词云时设置字体: wc = WordCloud(font_path=r'C:\\Windows\\Fonts\\simfang.ttf') 测试: text=open('1.txt',encoding='utf-8').read() wc=WordCloud( width=1300, repeat=True, font_path=r'C:\\Windows\\Fonts\\simfang.ttf', height=1300).generate(text) plt.imshow(wc,interpolation=&quot;bilinear&quot;) plt.axis(&quot;off&quot;) plt.savefig('aaaa.jpg') ","link":"https://2293736867.github.io/post/python-sheng-cheng-ci-yun/"},{"title":"git push时出现Permission denied(publickey)的解决","content":"1 问题描述 push的时候出现上述错误,它说请确保有足够的权限和这个仓库存在,仓库不存在...这个估计不是,所以是权限的问题,准确来说是sshkey的问题. 2 重新生成ssh key ssh-key -t rsa -b 4096 -C xxxx@xxxxx 这是gitub推荐的生成新ssh key的方法.注意,请不要使用默认的名字,第一个就会提示输入名字,请使用自定义的名字. 3 修改~/.ssh/config 移动公钥和私钥到~/.ssh下. mv xxx xxx.pub ~/.ssh 修改~/.ssh/config: vim ~/.ssh/config 输入 Host github.com HostName github.com User git IdentityFile ~/.ssh/name 其中name为上一步的自定义的key名字,是私钥,不是.pub结尾的公钥. 4 添加公钥到github 在github首页中,点击右上角头像进入设置. 选择: 输入名字与公钥的内容,保存. 5 push 成功! ","link":"https://2293736867.github.io/post/git-push-shi-chu-xian-permission-deniedpublickeyde-jie-jue/"},{"title":"vim替换命令","content":"1 语法 :[range]s/source/target/[option] 2 range range表示要替换的范围,想要全局替换的话,可以使用一个百分号. :%s/xxx/xxxx 另外,小数点表示当前行,美元符号表示最后一行,数字表示范围. :1,.s 替换第一行到当前行 :.,$s 替换当前行到最后一行 :1,$s 替换第一行到最后一行,相当于 :%s 3 source与target 表示源字符串与目标字符串,如 :1,.s/123/456 表示把第一行到当前行的首次出现的123替换成456,注意是首次出现,如果要替换某一行全部源字符串需要在后面加上 /g 另外,对于一些特殊字符比如小数点,斜杠,双引号等需要转义,方式是使用反斜杠,在需要转义的字符面前加一个反斜杠 如把 &quot;123//&quot; 替换为 '123\\\\' 命令如下: :s/\\&quot;123\\/\\/\\&quot;/\\'123\\\\\\\\\\'/g 因为 &quot;123//&quot; 中 &quot; 转义为 \\&quot; / 转义为 \\/ '123\\\\' 中 ' 转义为 \\' \\ 转义为 \\\\ 4 option 选项如下: /g 全局替换 /c 确认 /p 替换结果逐行显示 注意选项的组合结果是 /cg /pc 这样的形式,而不是 /c/g /g/p 这样的形式. 5 总结 全局替换的话,使用 :%s/source/target/g 局部替换的话,使用 :n,ms/source/target n,m为行数,表示要替换的范围. 注意如果字符串需要转义要加上反斜杠. ","link":"https://2293736867.github.io/post/vim-ti-huan-ming-ling/"},{"title":"Spring Boot上传文件+部署到Tomcat","content":" 1 概述 2 环境 3 新建工程 4 新建包 5 exception 5.1 StorageException 5.2 StorageFileNotFoundException 6 properties 7 service 7.1 init 7.2 deleteAll 7.3 load 7.4 loadAll 7.5 loadAsResource 7.6 store 8 controller 8.1 listUploadedFiles 8.1.1 RequestMapping 8.1.2 Model 8.2 serveFile 8.3 handleFileUpload 8.4 handleStorageFileNotFound 9 main 10 application.properties 11 测试 12 打包部署到Tomcat上 12.1 改变打包方式 12.2 去除Tomcat依赖 12.3 修改Main类 12.4 路径问题 12.4.1 action 12.4.2 @GetMapping 12.4.3 @PostMapping 12.4.4 redirect 12.5 设置打包名字 12.6 Maven打包 12.7 打包完成 12.8 上传到服务器 12.9 开启Tomcat 12.10 测试 13 源码 14 参考 1 概述 Spring Boot上传文件,根据官方uploadfile示例修改的,可以打成war放到服务器上(笔者使用的是Tomcat).主要步骤是创建异常类,属性类,接口类与控制器类,最后进行少量修改打包部署到服务器上. 2 环境 win10 Tomcat 9.0.30 IDEA 2019.03 Spring boot 2.2.2 RELEASE 3 新建工程 选择spring initializer: 改一下包名,打包选项这里可以jar可以war,选jar的话可以在build的时候再生成war. 这里用的是模板引擎Thymeleaf,选择spring web与Thymeleaf. 最后点击finish. 4 新建包 4个包,service,properties,controller,exception. 5 exception 处理两个异常,分别是存储异常与存储文件找不到异常. 5.1 StorageException package kr.test.exception; public class StorageException extends RuntimeException { public StorageException(String message) { super(message); } public StorageException(String message,Throwable cause) { super(message,cause); } } 5.2 StorageFileNotFoundException package kr.test.exception; public class StorageFileNotFoundException extends StorageException { public StorageFileNotFoundException(String message) { super(message); } public StorageFileNotFoundException(String message,Throwable cause) { super(message,cause); } } Exception(String message,Throwable cause); 这个构造函数中的cause是引起这个异常的异常,允许空值,如果是空值则表示这个引起这个异常的异常不存在或者未知. 6 properties 新建StorageProperties.java,设定存储文件的位置,就是location的值,可以使用&quot;../../&quot;这样的值,什么也不加的话会在项目路径下新建文件夹,若有同名的文件夹会被删除再重新创建. 注意一下权限的问题,后面部署到Tomcat上面时可能会因为没有写权限而不能写入文件,要确保文件夹拥有写权限. package kr.test.properties; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(&quot;storage&quot;) public class StorageProperties { private String location = &quot;upload_dir&quot;; public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } } 这里使用@ConfigurationProperties会报红,提示没有@EnableConfigurationProperties: 可以先不管,后面会在Main类中添加@EnableConfigurationProperties(StorageProperties.class). 7 service 先加一个StorageService接口: package kr.test.service; import org.springframework.core.io.Resource; import org.springframework.web.multipart.MultipartFile; import java.nio.file.Path; import java.util.stream.Stream; public interface StorageService { void init(); void store(MultipartFile file); Stream&lt;Path&gt; loadAll(); Path load(String filename); Resource loadAsResource(String filename); void deleteAll(); } 然后新建一个FileSystemStorageService实现该接口: package kr.test.service; import kr.test.exception.StorageException; import kr.test.exception.StorageFileNotFoundException; import kr.test.properties.StorageProperties; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.Resource; import org.springframework.core.io.UrlResource; import org.springframework.stereotype.Service; import org.springframework.util.FileSystemUtils; import org.springframework.util.StringUtils; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardCopyOption; import java.util.stream.Stream; @Service public class FileSystemStroageService implements StorageService { private final Path rootLocation; @Autowired public FileSystemStroageService(StorageProperties properties) { this.rootLocation = Paths.get(properties.getLocation()); } @Override public void init() { try { Files.createDirectories(rootLocation); } catch (IOException e) { throw new StorageException(&quot;Could not initialize storage&quot;,e); } } @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } @Override public Path load(String filename) { return rootLocation.resolve(filename); } @Override public Stream&lt;Path&gt; loadAll() { try { return Files.walk(rootLocation,1) .filter(path -&gt; !path.equals(rootLocation)) .map(rootLocation::relativize); } catch (IOException e) { throw new StorageException(&quot;Failed to read stored file.&quot;,e); } } @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if(resource.exists() || resource.isReadable()) { return resource; } else { throw new StorageFileNotFoundException(&quot;Could not read file: &quot;+filename); } } catch (MalformedURLException e) { throw new StorageFileNotFoundException(&quot;Could not read file : &quot;+filename,e); } } @Override public void store(MultipartFile file) { String filename = StringUtils.cleanPath(file.getOriginalFilename()); try { if(file.isEmpty()) { throw new StorageException(&quot;Failed to store empty file : &quot;+filename); } if(filename.contains(&quot;..&quot;)) { throw new StorageException(&quot;Cannot store file with relative path outside current directory&quot;+filename); } try(InputStream inputStream = file.getInputStream()) { Files.copy(inputStream,rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new StorageException(&quot;Failed to store file : &quot;+ filename,e); } } } 7.1 init @Override public void init() { try { Files.createDirectories(rootLocation); } catch (IOException e) { throw new StorageException(&quot;Could not initialize storage&quot;,e); } } 使用java.nio.file.Files.createDirectories()创建存储目录,可以建立多级目录. 7.2 deleteAll @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } 使用工具类FileSystemUtils的方法递归删除文件与文件夹.参数是一个File. 下面是方法源码: public static boolean deleteRecursively(File root) { if (root != null &amp;&amp; root.exists()) { if (root.isDirectory()) { File[] children = root.listFiles(); if (children != null) { for (File child : children) { deleteRecursively(child); } } } return root.delete(); } return false; } 首先判断根是否为空,不为空的话判断是否是目录,不是目录的话直接删除,是目录的话,利用listFiles()获取所有文件及文件夹,判断是否为空并进行递归删除. 7.3 load @Override public Path load(String filename) { return rootLocation.resolve(filename); } Path.resolve(String)返回相对于this的路径,具体来说,等于执行 cd rootLocation cd filename pwd 返回pwd的值. 7.4 loadAll @Override public Stream&lt;Path&gt; loadAll() { try { return Files.walk(rootLocation,1) .filter(path -&gt; !path.equals(rootLocation)) .map(rootLocation::relativize); } catch (IOException e) { throw new StorageException(&quot;Failed to read stored file.&quot;,e); } } Files.walk遍历目录,返回一个Stream&lt;Path&gt;,返回的Stream包含打开的一个或多个目录的引用,会在Stream关闭时关闭,第二个参数1表示遍历的最大深度. 然后对这个Stream进行filter过滤,这里是把与rootLocation不相等的Path留下,注意是不相等,就是留下filter()中条件为真的Path,不是把条件为真的Path给&quot;删去&quot;. 最后进行map,relativize返回参数相对于调用者的路径,这里是返回Stream中的每个Path相对于rootLocation的路径. 对于relativize,无论什么情况下: Path a = xxxx; Path b = xxxx; 都有 a.relativize(a.resolve(b)).equals(b) 为真. 7.5 loadAsResource @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if(resource.exists() || resource.isReadable()) { return resource; } else { throw new StorageFileNotFoundException(&quot;Could not read file: &quot;+filename); } } catch (MalformedURLException e) { throw new StorageFileNotFoundException(&quot;Could not read file : &quot;+filename,e); } } 这里的Resource是org.springframework.core.io.Resource,是一个接口,可以通过它访问各种资源,实现类有UrlResource,InputStreamResource等,这里利用Path.toUri()把file转换为Resource后,判断这个源是否存在或者是否可读并返回,否则抛出存储文件找不到异常. 7.6 store @Override public void store(MultipartFile file) { String filename = StringUtils.cleanPath(file.getOriginalFilename()); try { if(file.isEmpty()) { throw new StorageException(&quot;Failed to store empty file : &quot;+filename); } if(filename.contains(&quot;..&quot;)) { throw new StorageException(&quot;Cannot store file with relative path outside current directory&quot;+filename); } try(InputStream inputStream = file.getInputStream()) { Files.copy(inputStream,rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new StorageException(&quot;Failed to store file : &quot;+ filename,e); } getOriginalFilename()获取文件原名字,然后通过StringUtils.cleanPath()将其标准化,.处理掉&quot;.&quot;与&quot;..&quot;,然后判断文件是否为空与是否包含相对路径,没有的话利用Files.copy()进行复制,resolve获取filename相对于rootLocation的值,复制选项是REPLACE_EXISTING. StandardCopyOption有三个可选值: ATOMIC_MOVE:原子性的移动操作,一般在移动文件或目录时使用. COPY_ATTRIBUTES:复制属性,可以保留源文件或源目录的属性. REPLACE_EXISTING:替换已存在的文件. 8 controller 新建FileUploadController. package kr.test.controller; import kr.test.exception.StorageFileNotFoundException; import kr.test.service.StorageService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.Resource; import org.springframework.http.HttpHeaders; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import java.util.stream.Collectors; @Controller public class FileUploadController { private final StorageService storageService; @Autowired public FileUploadController(StorageService storageService) { this.storageService = storageService; } @GetMapping(&quot;/&quot;) public String listUploadedFiles(Model model) { model.addAttribute(&quot;files&quot;,storageService.loadAll().map( path -&gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, &quot;serveFile&quot;,path.getFileName().toString()).build().toString()) .collect(Collectors.toList())); return &quot;uploadForm&quot;; } @GetMapping(&quot;/files/{filename:.+}&quot;) @ResponseBody public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) { Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot;).body(file); } @PostMapping(&quot;/&quot;) public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) { storageService.store(file); redirectAttributes.addFlashAttribute(&quot;message&quot;,&quot;You successully uploaded &quot;+file.getOriginalFilename()+&quot;!&quot;); return &quot;redirect:/&quot;; } @ExceptionHandler(StorageFileNotFoundException.class) public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException e) { return ResponseEntity.notFound().build(); } } 8.1 listUploadedFiles @GetMapping(&quot;/&quot;) public String listUploadedFiles(Model model) { model.addAttribute(&quot;files&quot;,storageService.loadAll().map( path -&gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, &quot;serveFile&quot;,path.getFileName().toString()).build().toString()) .collect(Collectors.toList())); return &quot;uploadForm&quot;; } @GetMapping是@RequestMapping(method = RequestMethod.GET)的简化写法,将HTTP GET路径映射到特定的处理方法上. 方法的参数是spring MVC中的Model,Model实质上是一个Map,添加的key可以在视图中用${key}获取值,比如,这里添加了&quot;files&quot;作为key,则在视图中可用 ${files}获取值. MvcUriComponentsBuilder可以为Controller指定uri,fromMethod简单地说就是会调用FileUploadController的serveFile(),参数是path.getFileName().toString(),由于serveFile()返回的是Stream&lt;Path&gt;,利用Stream的collect将其转换成List添加到model中,然后返回uploadForm,表示这是视图的名称,会到resource/templates下寻找. 这里说一下RequestMapping与Model: 8.1.1 RequestMapping 可以用@RequestMapping()来映射URL,可以映射到某个类或某个具体方法.@RequestMapping常用的有以下属性: value:请求的URL路径,支持URL模板,正则表达式. method:HTTP请求方法,如GET,POST,PUT,DELTE等. consumes:允许的媒体类型,如consumes=&quot;application/json&quot;.对应于HTTP请求的Content-Type. produces:相应的媒体类型,如produces=&quot;application/json&quot;,对于HTTP请求的Accept. params:请求参数,如params=&quot;action=update&quot;. headers:请求头. Spring提供了简化的@RequestMapping,提供了新的注解来标识HTTP方法: @GetMapping @PostMapping @PutMapping ... 所以这里的@GetMapping是简化了的@RequestMapping. 8.1.2 Model 可以向Model添加视图所需要的变量,Model主要有以下方法: Model addAttribute(Object value); Model addAttribute(String name,Object value); Model addAllAttributes(Map attributes); Model addAllAttributes(Collection&lt;?&gt; attributes); Model mergeAttributes(Map attributes); boolean containAttribute(String name); addAttribute()添加一个变量,对于两个参数的,使用name作为变量名称,后面的是值,对于只有一个Object的,变量的名字就是类名字首字母小写后转为的java变量. addAttributes()添加多个变量,如果变量存在则覆盖,其中参数为Collection&lt;?&gt;的方法添加变量名时与addAttribute(Object)的命名规范类似. mergeAttributes()也是添加多个变量,不过变量已存在的话会忽略. containAttributte()判断是否存在变量. 8.2 serveFile @GetMapping(&quot;/files/{filename:.+}&quot;) @ResponseBody public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) { Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot;).body(file); } 这里的@GetMapping用来表示显示的用来供下载的文件名,@ResponseBody表示直接返回内容而不是视图名,因为默认返回的是视图名称,@ResponseBody对于String直接返回,否则默认使用Jackson进行序列化. @PathVariable表示这是@GetMapping中的参数的值,可以省略,默认同名,就是形参的名字与GetMapping中的名字一样,从中取值赋给形参,通过filename加载资源后,作为ResponseEntity的请求体. ResponseEntity从HttpEntity继承而来,ResponseEntity.ok()是一个静态方法,表示构建一个状态为&quot;ok&quot;的ResponseEntity,然后添加请求头. HttpHeaders.CONTENT_DISPOSITION,&quot;attachment;filename=\\&quot;&quot;+file.getFilename()+&quot;\\&quot;&quot; content_disposition表示文件是直接在浏览器打开还是下载,attachment表示是要下载,文件名为file.getFilename(). 8.3 handleFileUpload @PostMapping(&quot;/&quot;) public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,RedirectAttributes redirectAttributes) { storageService.store(file); redirectAttributes.addFlashAttribute(&quot;message&quot;,&quot;You successully uploaded &quot;+file.getOriginalFilename()+&quot;!&quot;); return &quot;redirect:/&quot;; } @PostMapping()与@GetMapping()类似,只不过方法不是GET而是POST.@RequestParam表示请求参数,里面的是请求参数的名字,使用MultipartFile来处理文件上传. RedirectAttributes是用于重定向使用的,可以附带参数,RedirectAttributes有两种带参的形式: addAttribute(String name,Object value); addFlashAttribute(String name,Object value); addAttribute()相当于直接在重定向的地址添加 name=value 这样的形式,会将参数暴露在重定向的地址上. 而addFlashAttribute()隐藏了参数,只能在重定向的页面中获取参数的值,用到了session,session跳转到页面后就会删除对象. handleFileUpload首先保存文件,然后添加一个保存成功的信息,由于Controller中重定向可以返回以&quot;redirect:&quot;或以&quot;forward:&quot;为前缀的URI,因此返回&quot;redirect:/&quot;,重定向到根. 8.4 handleStorageFileNotFound @ExceptionHandler(StorageFileNotFoundException.class) public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException e) { return ResponseEntity.notFound().build(); } @ExceptionHandler()注解会处理Controller层抛出的所有StorageFileNotFoundException类及其子类的异常,ResponseEntity.notFound()相当于返回404标识码. 9 main package kr.test; import kr.test.properties.StorageProperties; import kr.test.service.StorageService; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; @SpringBootApplication @EnableConfigurationProperties(StorageProperties.class) public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Bean CommandLineRunner init(StorageService storageService) { return (args) -&gt; { storageService.deleteAll(); storageService.init(); }; } } 在原来的基础上添加 @EnableConfigurationProperties(StorageProperties.class) 与 @Bean CommandLineRunner init(StorageService storageService) { return (args) -&gt; { storageService.deleteAll(); storageService.init(); }; } @EnableConfigurationProperties可以为带有@ConfigurationProperties注解的Bean提供有效的支持,将带有@Configuration注解的类注入为Spring的Bean,在这里是使StorageProperties的@ConfigurationProperties生效,如果没有这一行会报红: @Bean标注在方法上,等价于spring的xml配置文件的&lt;bean&gt;,注册bean对象. CommandLineRunner接口用于应用初始化后去执行一段代码逻辑,这段代码在整个应用周期只执行一次. 10 application.properties 这里可以设置一些环境配置属性,Spring Boot允许准备多个配置文件,在部署时可以指定那个配置文件覆盖默认的application.properties.这里是有关上传文件的设置: 默认如下: spring.servlet.multipart.enabled=true spring.servlet.multipart.file-size-threshold=0 spring.servlet.multipart.location= spring.servlet.multipart.max-file-size=1MB spring.servlet.multipart.max-request-size=10MB spring.servlet.multipart.resolve-lazily=false enabled表示允许上传,file-size-threshold表示上传文件超过一定长度就先写入临时文件,单位MB或KB,location是临时文件存放目录,不设定的话使用web服务器提供的临时目录.max-file-size表示单个文件最大长度,默认1MB,max-request-size为单次HTTP请求上传的最大长度,默认10MB,resolve-lazily表示文件和参数被访问的时候再解析成文件. 在这里只需把max-size调大一点即可. 11 测试 这是在本地进行的测试.直接在IDE上点击运行应用,然后打开浏览器输入: localhost:8080 12 打包部署到Tomcat上 Spring Boot通常打成jar包或war包,这里部署到Tomcat上的是打成war包. 12.1 改变打包方式 pom.xml中,&lt;packaing&gt;改成war: 12.2 去除Tomcat依赖 Spring Boot默认自带了一个嵌入式的Tomcat,需要把Tomcat依赖方式改为provided. pom.xml中,在&lt;dependencies&gt;添加: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 12.3 修改Main类 修改Main类,让其继承SpringBootServletInitializer,重载configure(),同时main()保持不变. @SpringBootApplication public class MainClass extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(MainClass.class); } //main()不变 } 12.4 路径问题 这个很重要,设置不当的话就无法访问了,主要就是四个路径: action: @GetMapping @PostMapping redirect 12.4.1 action 这个是绝对路径,要加上/war项目名. /war项目名/上传路径名 比如这里war项目名是kr,上传路径名是upload. 12.4.2 @GetMapping 这个是相对路径,相对于当前项目的路径,不用加上/war项目名. /上传路径名 这里是upload. 12.4.3 @PostMapping 与@GetMapping一样,上传路径名. /上传路径名 12.4.4 redirect 这个是返回的重定向的路径名,相对路径,与上两个一样,也是上传路径名. /上传路径名 12.5 设置打包名字 在&lt;build&gt;中添加&lt;finalName&gt;,指定打包出来的war名,注意这个要与上面的war项目名一样,这里设置的是kr. 12.6 Maven打包 运行 mvn package 即可打包,对于IDEA,可以在IDEA右侧栏的Maven中,打开Lifecycle,选择package: 12.7 打包完成 打包后的war默认放在target下,名字默认为&lt;artifactId&gt;+&lt;version&gt;. 12.8 上传到服务器 上传的话笔者用的是密钥认证的scp: scp -i xxxx\\id_rsa kr.war username@ip:/usr/local/tomcat/webapps 放到服务器的Tomcat下的webapps目录. 12.9 开启Tomcat 进入到Tomcat目录的bin下: cd /usr/local/tomcat/bin ./startup.sh 如果正在运行的话就不用启动了,因为会自动检测到webapps目录的变化,把新的war自动解包. 12.10 测试 略,与本地测试类似,不过要注意的是上传的文件夹是在tomcat/bin下,想要修改的话可以修改StorageProperties的location. 13 源码 github 码云 14 参考 1.ConfigurationProperties 2.CommandLineRunner 3.RedirectAttribute ","link":"https://2293736867.github.io/post/spring-boot-shang-chuan-wen-jian-bu-shu-dao-tomcat/"},{"title":"软件工程学习笔记(三):需求工程","content":" 1 概述 2 需求获取 2.1 软件需求 2.1.1 功能需求 2.1.2 性能需求 2.1.3 用户或人的因素 2.1.4 环境需求 2.1.5 界面需求 2.1.6 文档需求 2.1.7 数据需求 2.1.8 资源使用需求 2.1.9 安全保密需求 2.1.10 可靠性需求 2.1.11 软件成本消耗与开发进度需求 2.1.12 其他非功能性需求 2.2 需求获取的方法即策略 2.2.1 建立顺畅的通信途径 2.2.2 访谈与调查 2.2.3 观察用户操作流程 2.2.4 成立联合小组 2.2.5 用况 3 需求分析 3.1 原则 3.2 信息域 3.2.1 信息内容 3.2.2 信息流 3.2.3 信息结构 3.3 需求协商 3.4 需求建模 4 需求规约 4.1 引言 4.2 信息描述 4.3 功能描述 4.4 行为描述 4.5 检验标准 4.6 参考书目 4.7 附录 5 需求验证 6 需求管理 1 概述 需求工程是应用已证实有效的技术与方法开展需求分析,确定客户需求,帮助分析人员理解问题,评估可行性,协商合理的解决方案,无歧义地规约方案,确认规约以及将规约转换到可运行系统时的需求管理.需求工程是一个不断反复的需求定义,文档记录,需求演进的过程,并最终在验证的基础上冻结需求.需求工程可以分为六个阶段:需求获取,需求分析与协商,系统建模,需求规约,需求验证,需求管理. 2 需求获取 需求获取阶段分析人员通过与用户的交流,对现有系统的观察以及对任务进行分析,确定系统或产品范围的限制性描述,与系统或产品有关的人员及特征列表,系统的技术环境的描述,系统功能列表及应用于每个需求的领域限制,描述不同运行条件下系统或产品使用状况的应用场景等,为需求分析打下基础. 2.1 软件需求 软件需求是指用户对目标软件系统在功能,行为,性能,设计约束等方面的期望,包括: 2.1.1 功能需求 考虑系统要做什么,在何时做,在何时及如何修改或升级等. 2.1.2 性能需求 考虑软件开发的技术性指标,例如,存储容量限制,执行速度,响应时间以及吞吐量. 2.1.3 用户或人的因素 考虑用户的类型,例如用户对使用计算机的熟练程度,需要接受的训练,用户理解,使用系统的难度,用户错误操纵系统的可能性等. 2.1.4 环境需求 考虑未来软件应用的环境,包括硬件和软件,对硬件设备的需求包括机型,外设,接口,地点,分布,温度,湿度,磁场干扰等.对软件的需求包括操作系统,网络,数据库等. 2.1.5 界面需求 考虑来自其他系统的输入,到其他系统的输出,对数据格式的特殊规定,对数据存储介质的规定. 2.1.6 文档需求 考虑需要哪些文档,文档针对的读者. 2.1.7 数据需求 考虑输入,输出数据的格式,接受,发送数据的频率,数据的准确度与精度,数据流量,数据需保持的时间等. 2.1.8 资源使用需求 考虑软件运行时所需要的数据,其他软件,内存空间等资源.软件开发,维护所需的人力,支撑软件,开发设备等. 2.1.9 安全保密需求 考虑是否需要对访问系统或系统信息加以控制,隔离用户数据与方法,用户程序如何与其他程序和操作系统隔离以及系统备份要求等等. 2.1.10 可靠性需求 考虑系统的可靠性技术,系统是否必须监测和隔离错误,出错后重启系统允许的时间等. 2.1.11 软件成本消耗与开发进度需求 考虑开发是否有规定的时间表,软硬件投资有无限制等. 2.1.12 其他非功能性需求 如采用某种开发模式,确定质量控制标准,里程碑和评审,验收标准,各种质量要求的优先级等,以及可维护性方面的需求. 2.2 需求获取的方法即策略 2.2.1 建立顺畅的通信途径 在用户,系统分析人员,软件开发小组,管理人员之间建立良好的沟通方式,以保证能顺利地对问题进行分析. 2.2.2 访谈与调查 分析人员要从分析已经存在的同类的软件产品,或从行业标准,规则中提取初步需求,然后以个别访谈的形式或小组会议的形式开始与用户进行初步的沟通.除了进行面谈外,可以进行市场调查,了解市场对将开发的软件有什么样的要求,可以采取多种调查方式,指定调查提纲,向不同层次的用户发调查表,或访问用户和领域专家. 2.2.3 观察用户操作流程 到用户的实际工作环境中对用户的工作流程进行观察,了解用户的实际操作环境,操作过程与操作要求,对照用户提交的问题陈述,对用户需求可以有更全面细致的认识. 2.2.4 成立联合小组 采用一种叫FAST(facilitated application sepcification techniques)的技术用户与开发方成立一个联合小组,发挥各自的长处,共同负责项目的推进.FAST鼓励建立用户与开发者队伍之间的合作,共同工作来标识问题,提出解决方法的要素,商议不同的方法以及刻画初步的解决方案. 它已经成为信息系统使用的主流技术,该技术为改善各种应用中的相互通信提供了潜在的可能.FAST团队由来自市场,软件与硬件工程以及制造方的代表组成,并选择外来人员作为协调者.该方法有一下基本原则: 在中立的地点举行由开发者和用户出席的会议 建立准备和参与会议的规则 建立一个足够正式的议程以便可以进行自由的交流 由一个&quot;协调者&quot;(用户,开发者,或其他人)来控制会议 使用一种&quot;定义机制&quot;(工作表,图标等) 目标是标识问题,提出解决方案的要素,商议不同的方法以及在有利于完成目标的氛围中刻画出初步的需求 2.2.5 用况 用况常被称为用例,应该包含: 执行者完成的主要任务或功能 执行者将获取,生产或改变什么信息 执行者是否必须通知系统关于外部环境的变化 执行者希望从系统获得什么信息 执行者是否希望被通知未预期的变化 3 需求分析 3.1 原则 必须能够表示和理解问题的信息域 必须能够定义软件将完成的功能 必须能够表示软件的行为 必须划分描述的数据,功能和行为的模型 分析过程应该从要素信息移向细节信息 3.2 信息域 信息域包括信息内容,信息流以及信息结构. 3.2.1 信息内容 信息内容表示了单个数据和控制对象,目标软件所有处理的信息集合由它们构成. 3.2.2 信息流 信息流表示了数据和控制在系统中流动时的变化方式,输入对象被变换为中间信息,然后进一步被变换为输出. 3.2.3 信息结构 信息结构表示了各种数据和控制项的内部组织形式. 3.3 需求协商 需求很容易出现冲突,这就需要进行协商,讨论需求冲突,通常会议是解决冲突最快的方式. 3.4 需求建模 创建模型是需求分析的重要活动.模型以一种简洁,准确,结构清晰的方式系统地描述了软件需求,从而帮助分析员理解系统的信息,功能与行为,模型还将成为软件设计的基础,为设计者提供软件要素的表示视图. 4 需求规约 需求规约是分析任务的最终产物,通过建立完整的信息描述,详细的功能和行为描述,性能需求和设计约束的说明,合适的验收标准,给出对目标软件的各种需求.软件需求规约的框架主要分为5部分: 4.1 引言 引言陈述软件目标,在基于计算机的系统语境内进行描述,包括系统参考文献,整体描述,软件项目约束等. 4.2 信息描述 信息描述给出软件必须解决的问题的详细描述,记录信息内容,信息流,信息结构. 4.3 功能描述 功能描述用以描述解决问题所需要的每个功能,其中包括为每个功能说明一个处理过程,叙述设计约束,叙述性能特征,用一个或多个图形来形象地表示软件的整体结构和软件功能与其他元素间的相互影响. 4.4 行为描述 行为描述用以描述作为外部事件和内部产生的控制特征的软件操作. 4.5 检验标准 检验标准描述检验系统成功的标志,即对系统进行什么样的测试,得到什么样的结果,就表示系统已经成功实现了.检验标准是确认测试的基础. 4.6 参考书目 对所有和该软件相关文档的引用,包括其他的软件工程的文档,技术参考文献,厂商文献和标准. 4.7 附录 包含了规约的补充信息,表格数据,算法的详细描述,图表和其他材料. 5 需求验证 需求验证的目的是检验是否能够反映用户的意愿,需要对需求文档中定义的需求执行多种检查,评审团队应该检查需求的有效性,一致性和作为一个整体的完备性.包括系统定义的目标是否与用户的要求一致,系统需求分析阶段提供的文档资料是否齐全,被开发的数据流与数据结构是否确定且充足,主要功能是否已包括在规定的软件范围之内,是否都已充分说明,设计的约束条件或限制条件是否符合实际,开发的技术风险是什么,是否详细制定了检验标准,它们能否对系统定义进行确认. 6 需求管理 需求管理是一组用于帮助项目组在项目进展中的任何时候去标识,控制和跟踪需求的活动.在需求管理中,每个需求被赋予唯一的标识符,一旦标示出需求,就可以为需求建立跟踪表,每个跟踪表标示需求与其他需求或设计文档,代码,测试用例的不同版本间的关系.这些跟踪表可以用于需求跟踪,在整个开发过程中,进行需求跟踪的目的是为了建立和维护从用户需求开始到测试之间的一致性与完整性.确保所有的实现是以用户需求为基础,所有的输出符合用户需求,并且全面覆盖了用户需求. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-san-xu-qiu-gong-cheng/"},{"title":"软件工程学习笔记(二):系统工程","content":" 1 系统工程 2 系统工程的任务 2.1 识别用户的要求 2.2 系统建模与模拟 2.2.1 硬件系统模型 2.2.2 软件系统模型 2.2.3 人机接口模型 2.2.4 数据模型 2.3 成本估算及进度安排 2.4 可行性分析 2.4.1 经济可行性 2.4.1.1 成本 2.4.1.2 效益 2.4.1.3 货币的时间价值 2.4.1.4 投资回收期 2.4.1.5 纯收入 2.4.2 技术可行性 2.4.2.1 风险分析 2.4.2.2 资源分析 2.4.2.3 技术分析 2.4.3 法律可行性 2.5 生成系统规格说明 1 系统工程 软件工程中的系统是指基于计算机的系统,而基于计算机的系统是指通过完成处理某些预定义目标而组织在一起的元素的集合或排列.系统工程过程依赖于应用领域而呈现不同的形式,当工作的语境集中于业务企业时,进行业务过程工程,当关注产品生产的过程时,称为产品工程. 2 系统工程的任务 系统工程主要包括以下5个方面的任务: 2.1 识别用户的要求 系统工程的第一步就是识别用户对基于计算机的系统的总体要求,标识系统的功能和性能范围,确定系统的功能,性能,约束和接口. 2.2 系统建模与模拟 系统模型通常可用图形来描述,配合相应的文字说明,.必要时在系统建模后可构造原型,进行系统模拟,以分析所建的模型是否满足整个基于计算机的系统的要求.一个基于计算机的系统通常可以考虑一下的模型: 2.2.1 硬件系统模型 硬件系统模型描述基于计算机系统中的硬件配置,通信协议,拓扑结构,以及确保基于计算机系统的安全性,可靠性,性能等要求的措施. 2.2.2 软件系统模型 基于计算机系统中的软件部分可以分为若干个子系统,软件系统模型描述各个子系统的功能,性能等要求,各软件子系统在硬件系统中的部署情况,以及软件子系统之间的交互. 2.2.3 人机接口模型 人机接口模型描述人如何与基于计算机的系统进行交互,包括用户环境,用户的活动,人机交互的语法与语义等. 2.2.4 数据模型 数据模型主要描述基于计算机的系统使用了哪些数据库管理系统,如果使用多个数据库管理系统还应描述它们之间的数据转换方式,必要时可给出主要的数据结构. 2.3 成本估算及进度安排 开发一个基于计算机的系统需要一定的资金投入和时间约束,因此在系统工程阶段对需开发的基于计算机的系统进行成本估算,并作出进度安排. 2.4 可行性分析 可行性分析主要从三方面进行: 2.4.1 经济可行性 主要进行成本效益分析,从经济角度确定系统是否值得开发. 2.4.1.1 成本 购置硬件,软件和设备的费用 系统的开发费用 系统安装,运行与维护费用 人员培训费用 2.4.1.2 效益 效益可以分为社会效益与经济效益,经济效益包括使用基于计算机的系统后可增加的收入和可节省的运行费用.社会效益指使用基于计算机的系统后对社会产生的影响,通常社会效益只能定性地估计,经济效益通常可用货币的时间价值,投资回收期和纯收入来度量. 2.4.1.3 货币的时间价值 通常可以利用年利率来衡量货币的时间价值,设银行储蓄的年利率为i,现存入钱P,在n年后可得到的钱F,则 因此,n年后得到的F,折合成现在的钱P的公式为: 2.4.1.4 投资回收期 投资回收期是指累计的经济效益正好等于投资成本所需的时间,投资回收期通常是用于评价开发一个工程的价值的重要经济指标. 2.4.1.5 纯收入 纯收入指出了若干年扣除成本后的实际收入: 纯收入 = 累计经济效益 - 成本. 2.4.2 技术可行性 技术可行性主要根据系统的功能,性能,约束条件等,分析在现有资源和技术条件系统下能否实现.主要包括: 2.4.2.1 风险分析 风险分析主要分析在给定的约束条件下设计和实现系统的风险,在可行性分析时,风险分析的目的是找出风险,评价风险的大小,分析能否有效地控制和缓解风险. 2.4.2.2 资源分析 资源分析主要论证是否具备系统开发所需的各类人员,软件,硬件等资源和相应的工作环境. 2.4.2.3 技术分析 技术分析主要分析当前的科学技术是否支持系统开发的各项活动.在技术分析过程中,分析员收集系统的性能,可靠性,可维护性和生产率方面的信息,分析实现系统功能,性能所需的技术,方法,算法或过程,从技术角度分析可能存在的风险,以及这些技术问题对成本的影响. 2.4.3 法律可行性 法律可行性主要研究系统开发过程中可能涉及到的合同,侵权,责任以及各种与法律相关抵触的问题.《中华人民共和国著作权法》与《计算机软件保护条例》是可行性分析的主要依据. 2.5 生成系统规格说明 完成以上任务后应生成一份系统规格说明,作为以后开发基于计算机的系统的依据.系统规格说明描述基于计算机的系统的功能,性能与约束条件,描述系统的输入与输出控制信息给出各系统元素的模型,进行可行性分析,最后给出成本估算以及进度安排计划. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-er-xi-tong-gong-cheng/"},{"title":"软件工程学习笔记(一):软件工程","content":" 1 计算机软件 1.1 软件 1.2 软件特点 1.3 软件分类 1.3.1 系统软件 1.3.2 支撑软件 1.3.3 应用软件 2 软件语言 2.1 需求定义语言 2.2 功能性语言 2.3 设计性语言 2.4 程序设计语言 2.5 文档语言 3 软件工程 4 软件工程的基本原则 4.1 适宜的开发规范 4.2 合适的设计方法 4.3 高质量的工程支持 4.4 有效的软件工程管理 5 软件生存周期 5.1 计算机系统工程 5.2 需求分析 5.3 设计 5.4 编码 5.5 测试 5.6 运行与维护 6 CMM 6.1 初始级 6.2 可重复级 6.3 已定义级 6.4 已管理级 6.5 优化级 7 CMMI 7.1 阶段式模型 7.1.1 初始的 7.1.2 已管理的 7.1.3 已定义的 7.1.4 定量管理的 7.1.5 优化的 7.2 连续式模型 7.2.1 CL0 7.2.2 CL1 7.2.3 CL2 7.2.4 CL3 7.2.5 CL4 7.2.6 CL5 8 软件过程模型 8.1 瀑布模型 8.1.1 优点 8.1.2 缺点 8.2 增量模型 8.2.1 优点 8.2.2 缺点 8.3 原型模型 8.3.1 优点 8.3.2 缺点 8.4 螺旋模型 8.4.1 优点 8.4.2 缺点 8.5 喷泉模型 8.5.1 优点 8.5.2 缺点 8.6 基于构件的开发模型 8.6.1 优点 8.6.2 缺点 8.7 形式化方法模型 8.7.1 优点 8.7.2 缺点 1 计算机软件 1.1 软件 计算机软件是指计算机系统中的程序以及文档,程序是计算任务处理对象和处理规则的描述. 1.2 软件特点 一种逻辑实体. 维护工作量大. 维护软件过程中会引入副作用. 1.3 软件分类 1.3.1 系统软件 最靠近硬件的一层,比如操作系统. 1.3.2 支撑软件 软件开发,维护与运行的软件,比如各种IDE等. 1.3.3 应用软件 应用于特定领域的软件. 2 软件语言 软件语言主要包括需求定义语言,功能性语言,设计性语言,程序设计语言与文档语言. 2.1 需求定义语言 用于书写软件需求定义的语言,包括功能需求与非功能需求.典型的语言有PSL. 2.2 功能性语言 书写软件功能规约的语言,描述软件做什么以及只做什么.典型语言有广谱语言,Z语言. 2.3 设计性语言 书写软件设计规约的语言,是软件设计的严格而完整的描述.典型语言有PDL. 2.4 程序设计语言 即编程语言,可以分为低级语言与高级语言,过程式语言与非过程式语言,通用语言与专用语言,交互式语言与非交互式语言,顺序语言与并发语言与分布语言. 2.5 文档语言 书写软件文档使用的语言,比如Z语言. 3 软件工程 软件工程是建立和使用一套合理的工程原则,以便获得经济的软件,这种软件是可靠的,可以在实际机器上高效地运行.软件工程是应用计算机科学理论以及工程管理原则的方法,按预算与进度实现满足用户要求的软件产品的工程,或以此为研究对象的学科. 4 软件工程的基本原则 4.1 适宜的开发规范 选用适宜的开发规范,以保证软件开发的可持续性,并使最终的软件产品满足客户的需求. 4.2 合适的设计方法 要考虑软件的模块化,信息隐藏,局部化,一致性以及适应性等问题,采用合适的设计方法有助于支持问题的解决与实现. 4.3 高质量的工程支持 需要提供高质量的工程支持,例如配置管理,质量保证等. 4.4 有效的软件工程管理 软件工程的管理直接影响可用资源的有效利用,以提高软件组织的生产能力. 5 软件生存周期 软件生存周期分为6个阶段: 5.1 计算机系统工程 计算机系统工程的任务是确定待开发软件的总体要求与范围,以及该软件与其他计算机系统元素之间的关系,进行成本估算,作出进度安排,并进行可行性分析. 5.2 需求分析 需求分析主要解决待开发软件要做什么的问题,确定软件的功能,性能,数据,界面等要求,生成软件需求规约. 5.3 设计 软件设计主要解决待开发软件怎么做的问题,通常可以分为系统设计与详细设计,系统设计的任务是设计软件系统的体系结构,详细设计的任务是设计各个组成成分的实现细节. 5.4 编码 利用程序设计语言进行编码. 5.5 测试 发现并纠正软件中的错误与缺陷,包括单元测试,集成测试,确认测试与系统测试. 5.6 运行与维护 软件运行期间需要进行维护,对软件进行修改. 6 CMM CMM是能力成熟度模型,定义了5个软件过程成熟度等级,包括初始级,可重复级,已定义级,已管理级,优化级. 6.1 初始级 软件过程的特点是无秩序的,甚至是混乱的,几乎没有什么过程是经过妥善定义的. 6.2 可重复级 建立了基本的项目管理过程来跟踪成本,进度与功能特性.制定了必要的过程纪律,能重复早先类似应用项目取得的成功. 6.3 已定义级 已将管理和工程活动两方面的软件过程文档化,标准化,并综合成该组织的标准软件过程.所有项目均使用经批准,剪裁的标准软件过程来开发与维护软件. 6.4 已管理级 收集对软件过程和产品质量的详细度量值,对软件过程和产品都有定量的理解与控制. 6.5 优化级 过程的量化反馈和先进的新思想,新技术促使过程不断改进. 7 CMMI CMMI是若干过程模型的综合与改进,是支撑多个工程学科和领域的系统的,一致的过程改进框架,能适应现代工程的特点与需要,能提高过程的质量与工作效率.CMMI有两种表示法:阶段式模型与连续式模型. 7.1 阶段式模型 阶段式模型的结构类似于CMM,分为5个成熟度等级: 7.1.1 初始的 过程不可预测且缺乏控制. 7.1.2 已管理的 过程为项目服务. 7.1.3 已定义的 过程为组织服务. 7.1.4 定量管理的 过程已度量和控制. 7.1.5 优化的 集中与过程改进. 7.2 连续式模型 连续式模型关注每个过程域的能力,一个组织对不同的过程域可以达到不同的过程域能力等级. CMMI包含了6个过程域能力等级,等级号为0-5,能力等级表明了单个过程域中组织执行的好坏程度.能力等级包括共性目标及相关的共性实践,可以独立地应用于任何单独的过程域,各能力等级的含义: 7.2.1 CL0 未完成的,过程域未执行或未达到CL1中定义的所有目标. 7.2.2 CL1 已执行的,其共性目标是过程可以将标识的输入工作产品转换成可标识的输出工作产品,以实现支持过程域的特定目标. 7.2.3 CL2 已管理的,共性目标是集中于已管理的过程的制度化.根据组织政策规定过程的运作将使用哪个过程,项目遵循已文档化的计划和过程描述,所有正在工作的人都有权使用足够的资源,所有工作任务和工作产品都被监督,控制和评审. 7.2.4 CL3 已定义的,共性目标是集中于已定义的过程的制度化.过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的,还必须收集过程资产和过程的度量,并用于将来对该过程的改进上. 7.2.5 CL4 定量管理的,共性目标是集中于可定量管理的过程的制度化.使用测量与质量保证来控制和改进过程域,建立和使用关于质量和过程执行的定量目标作为管理准则. 7.2.6 CL5 优化的,使用量化手段改变和优化过程域,以应对客户的要求的改变与持续改进计划的过程域的功效. 8 软件过程模型 软件过程模型习惯上也叫软件开发模型,是软件开发全部过程,活动和任务的结构框架. 8.1 瀑布模型 1970年由W.Royce提出,给出了软件生存周期活动的固定顺序,上一阶段的活动完成后向下一阶段活动过渡,最终得到开发的软件产品.瀑布模型中上一阶段的活动完成并经过评审后才能开始下一阶段的活动,特征是: 接受上一阶段活动的结果作为本阶段活动的输入. 依据上一阶段活动的结果实施本阶段应完成的活动. 对本阶段的活动进行评审. 将本阶段活动的结果作为输出,传递给下一阶段. 8.1.1 优点 最早出现应用最广泛的模型,确保软件开发的顺利进行,对提高软件项目的质量和开发效率起到重要作用. 8.1.2 缺点 用户难以清晰描述所有需求,开发过程中需求也有可能发生改变. 发现错误时,为了改正错误要回到前一阶段,造成瀑布倒流. 在测试完成后才可以看到可运行的软件,发现问题的修改代价极大. 8.2 增量模型 增量模型将软件的开发过程分成若干个日程时间交错的线性序列,每个线性序列产生一个可发布的增量版本,后一个版本是对前一个版本的修改和补充,重复增量发布的过程,直至产生最终的完善产品. 8.2.1 优点 适用于需求经常发生变化的软件开发,以后的增量中可以逐渐加入需求,另外可以有计划地管理技术风险. 8.2.2 缺点 需要良好的架构设计,避免加入的构件破坏已构造好的系统部分,需要对系统有好的全盘分析,否则容易退化成边做边改模型. 8.3 原型模型 原型是预期系统的一个可执行版本,反映了系统性质的一个选定的子集.一个原型不必满足目标软件的所有约束,目的是可以快速,低成本地构建原型.步骤是: graph TB 定义总体目标 --&gt; 标识需求 标识需求 --&gt; 指定原型开发计划 指定原型开发计划 --&gt; 确定原型目标和范围 确定原型目标和范围 --&gt; 快速设计建模 快速设计建模 --&gt; 构建原型 构建原型 --&gt; 交付使用 交付使用 --&gt; 收集反馈意见 收集反馈意见 --下一轮原型迭代开发--&gt; 定义总体目标 8.3.1 优点 用户与开发者在原型上达成一致,减少错误,缩短开发周期,加快进度,降低成本. 8.3.2 缺点 不利于原型系统作为最终产品,原型被建造仅仅是用户用来定义需求,之后便会被部分或全部抛弃,准确的原型设计比较困难,不利于开发人员创新. 8.4 螺旋模型 螺旋模型将原型实现的迭代特征与瀑布模型中的控制的和系统化的方面结合起来,增加了风险分析.螺旋模型沿着螺线自内向外旋转,4个任务区域(4个象限)内分别完成以下任务: 第一象限:风险分析,评价所选方案,识别风险,清楚风险. 第二象限:制订计划,确定软件目标,选定实施方案,弄清项目开发的限制条件. 第三象限:客户评估,评价开发工作,提出修正建议. 第四象限:工程实施,实施软件开发,验证工作产品. (图片来源:https://www.itread01.com/content/1544588849.html) 8.4.1 优点 设计灵活,成本计算容易,客户始终参加每个阶段的开发,可以进行有效的互动. 8.4.2 缺点 周期长,需要丰富的风险评估经验以及专门知识,如果未能及时标识风险,势必造成重大损失. 8.5 喷泉模型 喷泉模型是一种支持面向对象开发的过程模型.喷泉体现了面向对象的迭代与无间隙特性. 8.5.1 优点 各个阶段没有明显的边界,开发人员可以进行同步开发,提高软件项目的开发效率,节省开发时间. 8.5.2 缺点 不利于项目管理,要求严格编写文档,审核难度大. 8.6 基于构件的开发模型 利用预先包装的构件来构造应用系统.构件可以是内部开发的构件,也可以是商业化的构件. 8.6.1 优点 构件可重用,易于维护,对提高软件生产率,提高软件质量,降低成本有很大的帮助. 8.6.2 缺点 很难找到100%合适的构件,就是现有的构件不一定很适合使用,但基于已有构件构造出的构件未必经过100%的测试,难以保证质量. 8.7 形式化方法模型 形式化方法是建立在严格的数学基础上的一种软件开发方法,用严格的数学语言和语义描述功能规约与设计规约,通过数学的分析与推导,易于发现需求的歧义性,不完整性与不一致性,易于对分析模型,设计模型和程序进行验证.通过数学的演算,使得从形式化功能规约到形式化设计规约,以及从形式化设计规约到程序代码的转换成为可能. 8.7.1 优点 用数学语言解决了规格说明的二义性问题,提高了精确性用数学提供了确认手段,使得证明与验证软件按程序满足用户和系统的需求成为可能,可以可视化地模拟/执行模型. 8.7.2 缺点 形式化的方法比其他技术的抽象级别要低,容易陷入细节,需要提早确定系统边界,通常限于正确一致的模型,但大多数情况下模型并非正确与一致. ","link":"https://2293736867.github.io/post/ruan-jian-gong-cheng-xue-xi-bi-ji-yi-ruan-jian-gong-cheng/"},{"title":"win10美化,让你的win10独一无二,与众不同!","content":" 1.原则 2 桌面 2.1 桌面图标 2.2 任务栏 3 字体 4 开始菜单 5 透明化任务栏 5.1 TranslucentTB 5.2 Stardock Start10 6 右键菜单 6.1 备份 6.2 修改 6.3 子菜单 6.4 隐藏菜单 7 资源合集 7.1 壁纸 7.2 字体 7.3 任务栏透明 1.原则 美化之前,得先有一个目标对不对,笔者是一个喜欢简单的人,因此美化本着三大原则:简单,干净,整洁. 呃....好像很抽象的样子,上图吧.反正没图没真相. 怎么样,还可以吧,没有任何多余的东西. 再来一张美女: 嗯...看得挺舒服,算了还是换一点正常一点的. 嗯,大概就这样子了,下面是一个&quot;未处理前&quot;的win10,一步一步来. 2 桌面 首先第一步是修改可以看得见的东西,比如,桌面. 2.1 桌面图标 进入设置,个性化: 主题,桌面图标设置. 选择对应关闭即可. 2.2 任务栏 任务栏的图标可以直接右键选择取消固定,另外可以在设置里面进行进一步的设置.看个人喜好. 比如笔者喜欢只留下网络. 然后可以右键任务栏进行进一步的设置,如关闭搜索与任务视图按钮等. 然后就变成了这样: 3 字体 美化怎么能不美化字体呢?所以,一个好的字体很重要,这里笔者用的是Fira Code字体(好吧....这其实是编程专用的支持连字符的字体,用来做UI....好像不太恰当),纯碎是因为看习惯了.更换字体的工具很多,这里用的是软媒美化大师. 首先去下载字体,文末有链接,下载好后解压,右键字体选择安装,然后在软媒美化大师里面设置即可. 作为UI字体的话可能加粗比较好看,这个嘛...看个人. 4 开始菜单 接下来可以对开始菜单进行设置,设置--&gt;个性化--&gt;开始. 然后可以对磁贴进行修改. 5 透明化任务栏 这是目前的任务栏,呃...反正笔者觉得不太好. 这里推荐两种工具进行美化. 5.1 TranslucentTB 有安装版与绿色版的,这是使用效果. 换一张壁纸看看. 这个有两种模式可以选择:模糊与全透明.右键程序选择即可. 下面是模糊的效果. 5.2 Stardock Start10 这个是专门针对开始菜单进行美化的工具,可以对开始菜单样式进行美化,也可以对徽标美化. 好了,重点来了,要美化的是任务栏,选择Desktop,可以选择模糊与透明度,比TranslucentTB更强: 6 右键菜单 既然桌面什么东西都没有...打开东西会不会很不方便? 当然,有一点,是会有那么一点点不方便,可以利用桌面右键菜单弥补这个不足. 对,就是修改右键菜单. 这个操作涉及到注册表,建议操作前先备份注册表. 6.1 备份 win+r,输入regedit. 先备份一份. 若不小心出了错可以选择import恢复. 6.2 修改 打开HKEY_CLASSES_ROOT\\DesktopBackground\\Shell\\Display.可以看到这里对应着Display与Personalize两个选项. 比如要增加一个微信,可以先在shell下新建一个key,然后在这个key下新建一个string value,取名icon,表示要显示的图标. icon的值为微信exe的位置,然后再WeChat下新建一个叫command的key,里面的值也是微信exe的位置. 然后可以再桌面看一下效果. 6.3 子菜单 如果想要子菜单咋整? 比如view这里. 没问题,类似的,在shell下新建一个key,叫app.接着创建一个叫SubCoommands的string value. 新建一个叫shell的key. shell下新建想要的东西,比如这里是微信. 然后像上面一样,添加一个叫icon的string value与叫command的key,两者的值都是微信exe的位置. 可以测试了. 6.4 隐藏菜单 在上面的基础上,在App中添加一个叫Extended的string value. 这个需要按着shift再点击右键才会显示的. 7 资源合集 7.1 壁纸 7.2 字体 FiraCode 7.3 任务栏透明 TranslucentTB Stardock start10 ","link":"https://2293736867.github.io/post/win10-mei-hua-rang-ni-de-win10-du-yi-wu-er-yu-zhong-bu-tong/"},{"title":"windows利器使用与配置","content":" 1 概述 2 Listary 2.1 基础配置 2.2 搜索配置 2.2.1 web搜索 2.2.2 目录搜索 2.2.3 命令 2.3 过滤 2.4 外观 2.5 快捷打开 3 WGesture 3.1 基本设置 3.2 全局手势 3.3 触发角和摩擦边 4 cmder 4.1 基本配置 4.2 背景 4.3 标签栏 4.4 确认 4.5 启动 4.6 杂项 4.7 快捷键 5 QtTabBar 5.1 安装 5.2 界面 5.3 基础配置 5.4 标签 5.5 窗口设置 5.6 工具栏 5.7 事件 5.8 拖拽 5.9 文件夹视图 5.10 额外视图 5.11 外观 5.12 组 5.13 应用程序 5.14 快捷键 5.15 预览 5.16 子菜单 1 概述 这篇文章主要讲述了一些windows下的&quot;利器&quot;级别工具的使用以及配置. 2 Listary Listary是一款强大的搜索工具,可以快速搜索过滤各种文件. 点击这里下载 2.1 基础配置 右键进入配置选项,建议开机启动. 2.2 搜索配置 这里可以设置搜索的关键字,包括本地文件搜索,web搜索. 2.2.1 web搜索 比如这里默认自带了百度引擎,关键字为bd,按两次ctrl打开搜索框,输入bd,空格,再加上搜索关键字. 可以按需要修改自己的搜索引擎,比如添加一个Magi引擎,先去magi引擎中随便搜索一个东西. 网址复制下来.到Listary中添加: 把q=后面的改成{query}即可. 2.2.2 目录搜索 这里可以为常用长目录设置一个简单的别名,直接在搜索框里输入即可. 比如这里为D:\\Document设置了一个doc: 2.2.3 命令 可以设置一些执行命令.自带的有reboot,cmd,cmda等. 也是与上面一样,设置关键字,路径等即可. 2.3 过滤 Listary的一个强大功能是它的过滤功能,自带的有过滤文件夹,文件,文档,视频,图片,音频. 例如上面的Picture,关键字是在搜索框中输入的关键字,搜索中可以选定文件表示搜索相应的文件. 这里笔者把关键字改成了一个字母p,然后搜索框中输入p再加一个冒号,会过滤出所有图片. 可以在搜索范围设置相应的文件夹,表示在这个文件夹搜索,不设置默认为所有位置. 2.4 外观 选择即可,还可以点击&quot;编辑&quot;对每一项细致编辑.笔者喜欢深色的. 反正不喜欢亮色. 2.5 快捷打开 &quot;动作&quot;这里,有一些自带的快捷键,比如ctrl+enter是打开文件夹,也可以添加自定义的操作,比如用vscode打开一个文件. 输入文件名,再按快捷键即可. 3 WGesture 这是鼠标党的福音,有了这个可以减少很多的键盘操作.这是一个免费开源的软件. 点击这里下载. 3.1 基本设置 安装后打开设置,选项这里有开启自启,允许的手势键等,没有特别需要默认即可. 3.2 全局手势 这是核心部分.可以修改默认的手势设置与添加自己的手势. 比如添加一个google搜索,画出手势: 然后可以随便选中一些东西进行谷歌搜索. 当然还有其他很多功能比如窗口控制,运行程序等,这些就不一一演示了,根据个人喜好设置. 3.3 触发角和摩擦边 触发角就是鼠标指针放在四个角就会触发相应的操作,摩擦边就是在边上摩擦就会触发相应操作. 下面是触发角的演示,没有点击左键,自动弹出菜单. 这是摩擦边: 可以修改默认行为. 4 cmder 这个是windows下的一个好用的终端,具体有多好用...谁用谁知道. 点击这里下载 以下是初次打开的界面,默认进入用户文件夹. 4.1 基本配置 win+alt+p,打开设置. 按需要调整字体,字体大小,字符集等.下一个的&quot;Size &amp; Pos&quot;可以设置大小与位置,这个没什么好说的就跳过了. 第三个是外观,可以设置标签栏的按钮,搜索框,滚动条的显隐,标题栏的显隐等. 下一个是设置&quot;quake style&quot;,这个是一个下滑效果,非常舒服,设置一下出现与消失延迟与动画时间. 设置了&quot;quake style&quot;后默认为全屏,可以回到&quot;Size &amp; Pos&quot;设置一下大小, 然后去Keys &amp; Macro里设置一个快捷键,搜索quake,默认是ctrl+`. 然后可以按快捷键看一下效果了. 下拉效果非常的不错. 4.2 背景 Background这里,选中&quot;Background image&quot;后,可以设置图片路径,变暗,与放置的位置等.Placement建议选择stretch. 4.3 标签栏 设置是否显示,字体,鼠标双击时的动作等. 4.4 确认 这里可以在操作之前弹出确认的对话框,根据需要设置即可. 4.5 启动 这里可以设置启动的任务类型,可以选择cmder,cmder(admin),powershell,bash等. 选择启动位置,比如这里是D:\\Desktop,直接手动修改: 4.6 杂项 一些很杂的配置,比如光标样式: 主题,这里可以选择主题与配置颜色,需要花一点时间. 透明度,配合背景调暗使用. 状态栏,笔者不需要,隐藏了. 4.7 快捷键 比如这里设置了alt+n切换控制台,而不是默认的ctrl+n. 最后贴一张笔者的图: 5 QtTabBar 这是一个增强windows资源管理器的工具,包括增加标签栏,各种便利的快捷键等.目前最新的版本是1040,在此之前需要先下载1038版本再进行1040版本的升级. 点击这里下载1038 点击这里下载1040升级包 5.1 安装 直接安装1038即可,安装完后注销电脑使qttabbar生效,然后再安装1040即可,重启资源管理器. 5.2 界面 首先安装完后其实与原来的资源管理器没有什么不一样,需要手动开启一些视图,打开视图中的选项: 这是开启Qt Command Bar的: 这是开启Qt Command Bar2的: Qt Command Bar2比Qt Command Bar小巧而且好看很多,建议开启. 这是开启Qt Tab Bar的: 这个强烈建议开启,就像浏览器中的标签栏一样. 这是开启Extra View(Left)的,会在左边多一个视图出来,不过速度会变得稍慢. 这是开启Qt Command Bar(Vertical)的: 就是把上面那个变成了垂直排列,这个功能很多,而且不丑,建议开启. 这是开启Extra View(bottom)的: 在底部多一个视图,右边有预览窗口. 最后一个就是Qt Tab Bar(bottom): 底部的标签栏. 笔者喜欢开这两个,extra view平时用的不多,所以不选择开启. 5.3 基础配置 按下Alt+O可以打开设置. 一开始是语言的一些设置,还可以导出设置文件,设置升级等.默认即可. 下一个是历史记录,可以设置排序方式,何时添加到历史记录,最大存储数目等,一般也默认即可. 5.4 标签 这是一个重要的配置,可以方便地管理资源管理器的标签.Tab选项这里可以设置新标签的位置,关闭当前标签后激活哪一个标签以及标签单行还是多行显示(如果有多个标签)等.建议去掉Rename ambiguous tabs automatically,这个会自动重命名标签名相同的标签,在标签名后加一个@再加所在的位置,有可能会把整个标签所占的位置变得很长. 然后下一个是开启标签动画和当导航失效的时候关闭标签.其他的一些比如显示标签数字(第三个),在标签栏上添加一个+按钮(最后一个)按个人喜好选择. 接下来是关闭按钮等的设置,笔者在这里把显示关闭按钮与标签图标去掉了,关闭的话可以在后面设置一个鼠标的快捷键(比如在标签上双击就是关闭)或一个键盘快捷键关闭.另外还有一些锁住标签的行为,这些笔者不需要就不弄了. 下面是切换器的样式,开启可以选中&quot;Show tab switcher by ctrl+tab&quot;,按ctrl+tab开启. 5.5 窗口设置 窗口可以设置保存透明度与置顶状态,隐藏菜单栏等,一般默认即可,右边有一个捕捉和排除列表设置,需要的可以看一看. 5.6 工具栏 工具栏可以设置导航按钮,位置,自动隐藏等属性. 如上图如果设置了导航按钮,就是这两个东西: 自动隐藏的话看个人吧,可以把左侧的Command Bar与底部/顶部的Qt Tab Bar给隐藏掉. 5.7 事件 这里的事件实际上是为鼠标加上的快捷操作,只要能记住,可以配合ctrl,shift,alt使用,主要的操作是左键单击,左键双击,中键单击,右键单击. 比如笔者的这里把在标签栏上右击的操作设为关闭,有工具栏上的右击设为显示菜单. 当然还有很多,比如文件夹视图,地址栏,子菜单等,也是类似的. 5.8 拖拽 这里可以设置拖拽的设置,比如标签作为拖拽源与标签栏作为拖拽目标时的操作,一般默认即可: 5.9 文件夹视图 主要是一些方便的功能,比如第一个选项是按Backspace可以返回上一层,还有不用获取焦点就可以滚动视图等. 5.10 额外视图 设置默认的额外视图,额外视图的标签栏,地址栏和导航按钮的位置,默认的打开位置等.第一个选项是可以按tab进行切换. 5.11 外观 这里设置的东西可多了,一开始是标签的设置,包括标签的大小,可以选择固定或自动或设置最小宽度,标签的字体,选中的标签的字体,文本对齐,标签图标位置等: 下一个是按钮的设置,可以设置关闭按钮与锁图标的样式: 接下来是工具栏,可以设置工具栏的背景,颜色等. 剩下还有三个是菜单,文件夹视图,导航面板等,都是类似的设置一些颜色,就不详细说了. 5.12 组 组在Command Bar中显示,这个可以设置一些快捷的功能入口,比如快速打开某个控制面版,快速打开某个文件夹等,默认自带了三个组:用户文件夹组,系统文件夹组以及驱动器组,可以选择右侧的Add Place添加自己想要的位置,也可以通过右上侧&quot;上下箭头&quot;调整组的位置. 5.13 应用程序 可以添加快捷的应用程序运行入口,比如这里添加了一个微信: 然后在Command Bar中右键选择添加: 然后就可以看到了: 可以为某个应用程序设置快捷键以便快速打开,在添加的时候最下面有一个&quot;Keyboard shortcut&quot;的选项,选中添加快捷键即可. 5.14 快捷键 一堆快捷键...需要自己慢慢调. 这里建议设置一个标签的激活快捷键,笔者选择的是alt+n. 一些常用的默认快捷键: 快捷键 功能 ctrl+W 关闭当前标签 ctrl+shift+W 关闭除当前标签外的所有标签 ctrl+shift+Z 恢复关闭的标签 ctrl+N 克隆当前标签 ctrl+L 锁定当前标签 ctrl+O 浏览文件且在标签中打开,若已存在该标签则切换到该标签,不存在则在新标签中打开 ctrl+shift+1-8 切换文件视图,比如大图标,中图标,列表视图,有8个可以选择 ctrl+shift+T 新建一个txt 5.15 预览 这个功能是真的舒服啊,可以预览图片,视频等,只需要把鼠标移到文件上面即可,可以设置预览的尺寸,是否按住shift才开启预览等. 时间那里可以设置全屏自动切换的时间,比如想预览一个放有图片的文件夹,打开预览功能(先把鼠标移动到文件出现预览的图片后,按小键盘的小数点即可进入)后,会进入全屏然后自动切换到下一张循环播放. 进入的快捷键可以在快捷键里中的Full screen设置: 5.16 子菜单 这个也是一个厉害的功能,就是安装QtTabBar后,文件夹上带的小箭头: 一般默认即可,这里建议把拖拽到子菜单的显示时间缩短. 好了,设置就这样了,希望你们能用好. ","link":"https://2293736867.github.io/post/windows-li-qi-shi-yong-yu-pei-zhi/"},{"title":"chrome安装插件提示\"程序包错误\"","content":"1 修改下载crx的后缀 修改为zip或rar,然后解压. 2 修改文件夹 将里面的_metadata改成metadata,即去掉前面的下划线. 3 进入chrome 打开扩展程序,选中开发者模式,选择加载已解压的扩展程序. 4 选择刚才解压的文件夹 完成. ","link":"https://2293736867.github.io/post/chrome-an-zhuang-cha-jian-ti-shi-cheng-xu-bao-cuo-wu/"},{"title":"centos8搭建本地Web服务器","content":" 1 概述 2 安装httpd 3 启动服务 4 设置开机启动 5 访问 6 修改默认主页 1 概述 系统centos8,利用httpd搭建本地web服务器. 2 安装httpd sudo yum install -y httpd 3 启动服务 service httpd start 4 设置开机启动 先查看有没有设置开机启动: systemctl list-unit-files | grep httpd 没有的话设置: chkconfig httpd on 再确认一下: systemctl list-unit-files | grep httpd 5 访问 再浏览器输入内网ip地址(内网ip可以通过ifconfig查看).若出现以下页面则表示成功. 6 修改默认主页 默认的网站根目录位于/var/www/html下,可以通过修改/etc/httpd/conf/httpd.conf修改.这里只是修改主页.在/var/www/html创建一个index.html: cd /var/www/html sudo vim index.html 随便输入一点内容,然后刷新在浏览器即可. ","link":"https://2293736867.github.io/post/centos8-da-jian-ben-di-web-fu-wu-qi/"},{"title":"CentOS8搭建FTP服务器","content":" 1 概述 2 安装vsftpd 3 开启服务 4 设置开机启动 5 修改/etc/vsftpd/vsftpd.conf 6 创建测试文件 7 测试 7.1 浏览器测试 7.1.1 匿名测试 7.1.2 用户登录测试 7.2 ftp命令测试 7.2.1 匿名测试 7.2.1.1 上传测试 7.2.1.2 下载测试 7.2.2 用户登录测试 7.2.2.1 上传测试 7.2.2.2 下载测试 7.3 wget测试 7.3.1 匿名测试 7.3.2 用户登录测试 8 总结 1 概述 文章主要讲了CentOS8如何利用vsftpd搭建一个FTP服务器,然后进行简单的匿名上传/下载与用户上传/下载测试,还有使用了wget测试. 2 安装vsftpd yum install -y vsftpd 3 开启服务 service httpd start 4 设置开机启动 可以用 systemctl list-unit-files | grep vsftpd 查看是否开机启动.显示disabled. 通过 chkconfig vsftpd on 开启自启,再次执行systemctl,可以看到变成了enabled. 5 修改/etc/vsftpd/vsftpd.conf sudo vim /etc/vsftpd/vsftpd.conf 首先修改 为YES. 再添加一行anon_upload_enable=YES 第一行的意思是允许匿名登录,第二行的意思是允许匿名上传. 重启服务. service vsftpd restart 6 创建测试文件 cd /var/ftp/pub sudo vim test 7 测试 7.1 浏览器测试 7.1.1 匿名测试 ifconfig获取内网ip,在浏览器中输入ftp://ip. 可以看到有一个pub文件夹,里面有刚才新建的test文件. 右键保存即可下载文件. 下载完成. 去终端看看. 7.1.2 用户登录测试 输入 ftp://username@ip 再输入用户密码. 默认访问的是用户根目录下的文件,这里显示出来了. 下载的话同上,右键选择即可. 7.2 ftp命令测试 首先安装ftp: sudo yum install ftp 7.2.1 匿名测试 ftp ip 这里用户名选择ftp,密码为空,表示匿名登录.ftp为默认的匿名登录用户名,至于密码,可以在/etc/vsftpd/vsftpd.conf中设置一个 no_anon_password=YES 这样匿名用户可以不用密码登录. 7.2.1.1 上传测试 直接使用put命令,后面接上文件,这里的upload.txt是执行ftp之前的所在文件夹下的upload.txt 这里提示不能创建文件,是权限的原因,要确保/var/ftp/pub对&quot;other&quot;用户有写权限. 默认的/var/ftp/pub的权限是644,修改成647. sudo chmod 647 /var/ftp/pub 同时修改上传文件的权限,允许other用户可读. sudo chmod 644 /root/upload.txt 如果不行,使用selinux设置. getsebool -a | grep ftp 把ftpd_full_access开启: setsebool ftpd_full_access on 再进入upload.txt所在的文件夹,执行ftp,再次put. 成功! 7.2.1.2 下载测试 直接get文件即可,由于上面已经设置好了权限,所以不会出现问题. 若出现权限问题可从三方面入手: (1)/var/ftp/pub的对other用户的可读权限:因为是下载,而且匿名,所以只需要对other用户的可读权限 (2)被下载文件的对other用户的可读权限 (3)selinux的问题,设置ftpd_full_access为on 7.2.2 用户登录测试 执行ftp时用对应用户名与密码登录. 默认进入了用户根目录. 7.2.2.1 上传测试 直接put即可. 若出现权限问题参照上面7.2.1.2的那三条方法. 7.2.2.2 下载测试 随便在用户根目录新建一个文件,这里是kr. 直接get即可. 7.3 wget测试 wget用来下载文件,初始下载的目录与ftp登录时的目录一致,比如匿名登录ftp,登录的是/var/ftp目录,则wget会从这个/var/ftp目录下载文件,下载到执行wget命令所在的目录.使用用户&quot;kr&quot;登录ftp,则登录的是/home/kr目录,wget会从/home/kr下载文件. 7.3.1 匿名测试 注意,请确保被下载文件对other用户有可读权限. sudo chmod o+w xxxxxx 然后使用wget wget ftp://ip/pub/xxxx 7.3.2 用户登录测试 使用--ftp-user,--ftp-password指定用户名与密码,其余同上. wget ftp://ip/xxx --ftp-user=xxxx --ftp-password=xxxx 成功. 8 总结 呃....简单来说,就是先安装好ftp与vsftpd,然后修改/etc/vsftpd/vsftpd.conf添加相应权限,对于不能上传与下载的原因,基本上都是权限的问题,主要就是三方面: (1)ftp目录的权限:比如可以是/var/ftp/pub没有对应的写权限导致上传失败,没有对应读权限导致下载失败. (2)被上传文件的权限:比如上传的文件没有读权限导致上传失败. (3)selinux:使用setsebool设置为on. 解决权限问题后,基本就可以通过ftp或wget顺利地使用这个ftp服务器上传/下载文件了. ","link":"https://2293736867.github.io/post/centos8-da-jian-ftp-fu-wu-qi/"},{"title":"Python基础(八)","content":" 1 模块 1.1 模块 1.2 模块存在形式 1.2.1 非内置模块 1.2.2 内置模块 1.3 模块使用 1.3.1 导入整个模块 1.3.2 导入模块中的某个函数 1.4 查看内置模块 2 包 2.1 包 2.2 包管理 2.3 包管理命令 2.3.1 列出已安装的包 2.3.2 更新包 2.3.3 删除包 2.3.4 安装包 1 模块 1.1 模块 模块是一个python文件,其中包含对象定义与语句等.多个模块再加上__init__.py就变成了一个包. 1.2 模块存在形式 模块可以分成两种:非内置模块与内置模块. 1.2.1 非内置模块 非内置模块以.py文件的形式存在,放在对应的包下. 1.2.2 内置模块 内置模块就是内置到解释器中的模块,为了提高性能内置模块采用C语言而不是python编写. 1.3 模块使用 先导入再调用里面的函数,可以一次导入整个模块,或者选择性导入其中的函数. 1.3.1 导入整个模块 import math import cmath as cm 使用as设置模块别名. 1.3.2 导入模块中的某个函数 from math import sin from cmath import sqrt as cs 使用as设置函数别名. 1.4 查看内置模块 import sys sys.builtin_module_names 2 包 2.1 包 包是含有一个特殊的__init__.py文件的文件夹,通常还含有其他.py文件,表示不同的模块. 2.2 包管理 包的下载,安装,更新,删除可通过包管理器进行操作,常用的包管理器为pip与conda.pip设计目的是仅管理Python语言的包,对应的包服务器为PyPI,Conda设计目的是管理多种语言的包,对应的包服务器为Conda. 2.3 包管理命令 2.3.1 列出已安装的包 pip list conda list 2.3.2 更新包 pip install --upgrade package_name conda upgrade package_name 2.3.3 删除包 pip uninstall package_name conda uninstall package_name 2.3.4 安装包 pip install package_name conda install package_name ","link":"https://2293736867.github.io/post/python-ji-chu-ba/"},{"title":"Python基础(七)","content":" 1 模块函数 1.1 模块函数 1.2 导入 1.2.1 import moudle 1.2.2 import module as alias 1.2.3 from module import function 1.2.4 from module import function as alias 2 自定义函数 2.1 定义函数 2.2 设置docstring 2.3 函数调用 2.4 返回值 2.5 形参 2.5.1 形参分类 2.5.2 * 与 ** 2.5.3 命名关键字参数 2.6 实参 2.6.1 位置参数 2.6.2 关键字参数 2.7 变量可见性 2.7.1 局部变量 2.7.2 全局变量 2.7.3 非局部变量 2.8 参数传递规则 2.8.1 值传递 2.8.2 地址传递 2.9 lambda函数 2.9.1 定义 2.9.2 调用 1 模块函数 1.1 模块函数 模块函数指的是模块中的函数,模块函数有三种: 内置模块:又叫标准库. 第三方开源模块:可以通过包管理工具进行安装. 自定义模块. 1.2 导入 导入方法主要有三种: 1.2.1 import moudle import math math.e 1.2.2 import module as alias alias表示别名. 1.2.3 from module import function 从模块导入函数. 1.2.4 from module import function as alias 与上一种类似,加上了别名. 2 自定义函数 2.1 定义函数 使用关键字def定义: def func(): print(1) 2.2 设置docstring docstring就是注释,描述了函数的功能,使用三个单引号或三个双引号,可以用help()获取函数的docstring. def func(): ''' func docstring ''' print(1) help(func) 2.3 函数调用 直接使用函数名即可,需要的话要加上参数. func() func(22) 2.4 返回值 返回值在return里指定,可以返回多个值: def f(): return 1,2,3,4 相当于返回一个元组.若函数没有return,则返回None. 2.5 形参 2.5.1 形参分类 形参就是函数定义时的参数列表里面的参数,可以分为: 可选形参:给出默认值的形参. 必选形参:没有给出默认的形参. def f(x1,x2,x3=3) 其中x1,x2必选形参,x3可选形参. 2.5.2 * 与 ** 带一个 * 的形参表示该形参类型为元组,带两个 * 的形参表示该参数类型为字典. 2.5.3 命名关键字参数 出现在*后的参数. def f(x1,*x2,x3,x4) x3与x4就是命名关键字参数,在调用时必须显式使用参数名. 2.6 实参 python实参可以分为位置实参与关键字实参. 2.6.1 位置参数 位置参数就是没有指定形参名字的实参,每个实参基于顺序关联到一个形参. 2.6.2 关键字参数 关键字参数就是指定了形参名字的实参,用键值对的形式指定,可以不按顺序调用. def f(x1,x2,x3): print(x1,x2,x3) f(1,2,3) f(x3=999,x1=888,x2=999999) 2.7 变量可见性 python变量的可见性有三种:全局变量,局部变量,非局部变量. 2.7.1 局部变量 在函数内的变量为局部变量,因此,以下代码会输出9: x1 = 8 def f(): x1 = 9 print(x1) f() 如果在x1之前输出呢? 直接提示没有定义x1,就是全局变量x1在函数内不可见,但笔者不死心,一定要运行一下. 它说局部变量x1没有被赋值,注意,是局部变量,因此,这也证明了全局变量在函数内不可见. 2.7.2 全局变量 若要使全局变量在函数内可见,使用global: x1 = 8 def f(): global x1 print(x1) x1 = 9 print(x1) f() global x1表示x1是一个全局变量,注意global x1需要单独占一行. 2.7.3 非局部变量 用于嵌套函数中,使用nonlocal声明,表示内层函数的这个变量是外层函数的. x1 = 8 def f(): x1 = 9 print(x1) def f1(): nonlocal x1 print(x1) x1 = 10 print(x1) return f1 f() f()() 第一个与第二个9都是f()中的print()输出的,第三个9是f1()中的print()输出的. 2.8 参数传递规则 当实参传递给形参时,有两种传递规则,一是值传递,而是地址传递. 2.8.1 值传递 当实参为不可变对象时,采用值传递规则,常见的不可变对象类型包括int,float,str,bool,tuple. def f(x): x = 1 print(x) x = 3 print('-------int------') f(x) print(x) print() x = 'string' print('-------str------') f(x) print(x) print() x = (3,4,5) print('-------tuple------') f(x) print(x) print() x = 5.799 print('-------float------') f(x) print(x) print() 2.8.2 地址传递 参数为可变对象时,采用地址传递规则,修改形参的值会同时改变实参的值.常见的可变对象类型包括list,set,dict. def f(x): if type(x) == list: x = x.reverse() elif isinstance(x,set): x.add(8) else: x['0'] = 3 x = [1,2,3] print('-------list------') print(x) f(x) print(x) print() x = {4,5,6} print('-------set------') print(x) f(x) print(x) print() x = {'a':1,'b':2} print('-------dict------') print(x) f(x) print(x) print() 2.9 lambda函数 lambda是一种特殊的自定义函数,使用关键字lambda进行定义,是一种匿名函数,函数体一般很短. 2.9.1 定义 以关键字lambda开头,后面是参数列表,参数列表结束后加一个冒号,后面是返回值. y = lambda x:x*3 z = lambda x,y:x*y 2.9.2 调用 调用可以通过&quot;函数名&quot;调用,或者配合其他函数使用. ","link":"https://2293736867.github.io/post/python-ji-chu-qi/"},{"title":"Python基础(六)","content":" 1 函数 1.1 函数的分类 1.2 函数与方法 1.3 函数也是对象 1.4 注意事项 2 内置函数 2.1 查看帮助 2.2 数学函数 2.2.1 abs 2.2.2 max/min 2.2.3 pow 2.2.4 round 2.3 类型转换函数 2.4 其他函数 2.4.1 type() 2.4.2 isinstance() 2.4.3 dir() 2.4.4 len() 2.4.5 range() 2.4.6 callable() 2.4.7 bin() 2.4.8 oct() 2.4.9 hex() 2.4.10 int() 1 函数 1.1 函数的分类 函数可以分成三种: 内置函数(BIF):解释器中内置的函数,可以直接通过函数名调用,如len(). 模块函数:定义在模块中的函数,通过模块名调用,如math.sin(). 用户自定义函数. 1.2 函数与方法 函数是指在类外定义的,可以独立调用的一组语句集合,另外通过类去调用的语句,也叫函数而不是方法. 方法是指在类内定义的,需要通过对象与点调用的一组语句集合,方法中的self是隐式传递的. 1.3 函数也是对象 在python中,函数也是对象,比如: def xx(): print(4) print(type(xx)) 1.4 注意事项 函数的参数带一个 * 时,表示元组,带两个 * 时,表示字典.函数的返回值可以为迭代器,元组等,如果没有return,默认返回None. 另外就是docstring,docstring其实就是一堆注释,说明函数的作用,建议使用三引号. 2 内置函数 内置函数就是内置在python解释器中的函数,可以直接通过函数名调用,不需要import.查看内置函数可以使用内置函数dir(): dir(__builtins__) 2.1 查看帮助 可以使用help查看函数的帮助. 一般给出简单的帮助信息,详细信息可以去官网查询. 2.2 数学函数 2.2.1 abs 求绝对值. 2.2.2 max/min 求最大/小值,支持元组,列表,集合,字符串等. 2.2.3 pow 求次幂. 2.2.4 round 四舍五入,两个参数,第一个参数是要四舍五入的数,第二个参数是保留的小数位数,第二个参数可以省略,省略的话相当于取整. 若保留的小数位数为2则保留2位,保留的小数位数为1则保留1位,保留的小数位数为0则保留....0...呃...不是,保留1位,保留1位0. 2.3 类型转换函数 就是常用的int(),bool()等函数,这些也是内置函数. 2.4 其他函数 2.4.1 type() type()是查看类型的函数. 2.4.2 isinstance() isinstance()判断一个的类型,与type()类似,但是isinstance()会考虑继承关系,而type()不会考虑. class a: pass class b(a): pass print('type(a()) == a is ',type(a()) == a) print('type(b()) == a is ',type(b()) == a) print('isinstance(a(),a) is ',isinstance(a(),a)) print('isinstance(b(),a) is ',isinstance(b(),a)) 2.4.3 dir() dir()查看搜索的路径. 2.4.4 len() 求长度. 2.4.5 range() 快速生成序列,返回一个迭代器. 2.4.6 callable() 判断对象是否可以被调用,因为函数也是一个对象,所以可以通过callable()判断函数是否可以被调用. 2.4.7 bin() 十进制--&gt;二进制. 2.4.8 oct() 十进制--&gt;八进制. 2.4.9 hex() 十进制--&gt;十六进制. 2.4.10 int() n进制--&gt;十进制. ","link":"https://2293736867.github.io/post/python-ji-chu-liu/"},{"title":"pom.xml详解","content":" 1.pom.xml是什么 2.基本配置 (1)&lt;project&gt; (2)&lt;modelVersion&gt; (3)Maven坐标 A.&lt;groupId&gt; B.&lt;artifactId&gt; C.&lt;version&gt; (4)&lt;packaging&gt; (5)POM 关系 A.依赖 a.&lt;groupId&gt;与&lt;artifactId&gt; b.&lt;version&gt; c.&lt;classifier&gt; d.&lt;type&gt; e.&lt;scope&gt; f.&lt;systemPath&gt; g.&lt;optional&gt; h.&lt;exclusions&gt; B.继承 C.聚合(或多模块) (6)属性 ①env.x ②project.x ③settings.x ④java.x ⑤x 3.构建配置 (1)BaseBuild元素 A.&lt;defaultGoal&gt; B.&lt;directory&gt; C.&lt;finalName&gt; D.&lt;filters&gt; (2)资源 A.&lt;resource&gt; B.&lt;targetPath&gt; C.&lt;flitering&gt; D.&lt;directory&gt; E.&lt;include&gt; F.&lt;excludes&gt; (3)插件 A.&lt;groupId&gt;与&lt;artifactId&gt; B.&lt;version&gt; C.&lt;extensions&gt; D.&lt;inherited&gt; E.&lt;configuration&gt; F.&lt;dependencies&gt; G.&lt;executions&gt; (4)插件管理 (5)目录 A.项目源码目录 B.测试源码目录 C.class目录 D.测试class (6)扩展 (7)报表 A.&lt;excludeDefaults&gt; B.&lt;outputDirectory&gt; C.&lt;plugins&gt; D.&lt;reportSets&gt; 4.项目信息 (1)许可证 A.&lt;name&gt; B.&lt;url&gt; C.&lt;distribution&gt; D.&lt;comments&gt; (2)组织 (3)开发者 A.&lt;id&gt; B.&lt;name&gt; C.&lt;email&gt; D.&lt;url&gt; E.&lt;organization&gt; F.&lt;organizationUrl&gt; G.&lt;roles&gt; H.&lt;timeZone&gt; I.&lt;properties&gt; (4)贡献者 5.环境配置 (1)问题管理 (2)持续集成管理 A.&lt;system&gt; B.&lt;url&gt; C.&lt;notifiers&gt; a.&lt;type&gt; b.&lt;sendOnError&gt; c.&lt;sendOnFailure&gt; d.&lt;sendOnSuccess&gt; e.&lt;sendOnWarning&gt; f.&lt;configuration&gt; (3)邮件列表 A.&lt;name&gt; B.&lt;subscribe&gt; C.&lt;unsubscribe&gt; D.&lt;post&gt; E.&lt;archive&gt; (4)软件配置管理(SCM) A.&lt;connection&gt;与&lt;developConnection&gt; B.&lt;tag&gt; C.&lt;url&gt; (5)前提条件 (6)仓库 A.&lt;releases&gt; B.&lt;snapshots&gt; C.&lt;id&gt; D.&lt;name&gt; E.&lt;url&gt; F.&lt;layout&gt; (7)插件仓库 (8)分发管理 A.仓库 B.站点部署 C.重定位 (9)配置文件 A.&lt;activeByDefault&gt; B.&lt;jdk&gt; C.&lt;os&gt; D.&lt;property&gt; E.&lt;file&gt; 1.pom.xml是什么 pom是Project Object Model(项目对象模型)的缩写,是Maven中的项目文件,可用于管理与配置依赖,组织信息,项目授权,远程仓库等等.一个Maven项目,可以没有任何代码,但不能没有pom.xml. 2.基本配置 (1)&lt;project&gt; &lt;project&gt;是pom.xml的根元素,包含了一些约束信息. &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;/project&gt; (2)&lt;modelVersion&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; pom的版本,这是Maven 2&amp;3唯一支持的pom版本,而且不能忽略. (3)Maven坐标 &lt;groupId&gt;,&lt;artifactId&gt;与&lt;version&gt;标识了仓库中的一个特定位置,叫项目坐标.三个属性告诉了Maven项目中的一个特定版本,让Maven知道如何处理它们以及在生命周期内的哪一阶段需要它们. A.&lt;groupId&gt; &lt;groupId&gt;表示项目所属的组,通常是一个公司或者组织的名称,如org.springframework. B.&lt;artifactId&gt; &lt;artifactId&gt;表示项目的唯一标识. C.&lt;version&gt; &lt;version&gt;表示项目的版本号,通常来说项目的版本号分成三段: 主版本号.次版本号.修订版本号 主版本号:代表架构变动或者不兼容的实现. 次版本号:兼容性修改,功能增强. 修订版本号:bug修复. 版本号的后缀意味着项目的不同阶段: SNAPSHOT:开发中的版本 RELEASE:正式发布版 M1,M2:M指里程碑,表示即将发布 RC:Release Candidate,发布候选 GA:General Availablity,基本可用版本 (4)&lt;packaging&gt; 打包类型,没有提供的话默认值为jar,常见的有jar与war,也可以取值: maven-plugin pom ejb ear rar (5)POM 关系 Maven的一个强大之处是处理项目关系的方式,可以通过一个公共的本地仓库去解决问题. A.依赖 POM的基础就是依赖列表,Maven下载与在编译时链接依赖与其他所需要的目标,而且可以处理传递性依赖,使列表可以专注于项目所需的依赖.依赖放在&lt;dependencies&gt;里面,包含若干个&lt;dependency&gt;. &lt;dependencies&gt; &lt;dependency&gt; .... &lt;/dependency&gt; &lt;dependency&gt; .... &lt;/dependency&gt; &lt;/dependencies&gt; 一个&lt;dependency&gt;通常包含: a.&lt;groupId&gt;与&lt;artifactId&gt; 对应项目坐标 b.&lt;version&gt; 版本 c.&lt;classifier&gt; 可用于配置不同jdk的&lt;depenency&gt;,比如让一个&lt;dependency&gt;同时支持jdk8与jdk11,可以选择使用哪一个&lt;classifier&gt;,方便在不同jdk中使用. d.&lt;type&gt; 对应的依赖类型,默认为jar,通常对应与&lt;packaging&gt;. e.&lt;scope&gt; scope表示类库与项目的关系,可以取以下5个值: compile:默认值,编译依赖使其在所有类路径中可用,而且这些依赖项会传递到其他依赖项目,在编译和打包时都需要此类库. provided:类似compile,但是期望JDK或一个容器会在运行时提供,仅在编译和测试类路径上可用,不可传递. runtime:在运行时与测试类路径中可用,在编译类路径中不可用. test:测试编译与执行阶段可用,不可传递. system:类似于provided,但必须显式提供jar包. f.&lt;systemPath&gt; 当&lt;scope&gt;为system才需要这个,否则(当&lt;scope&gt;不为system时)会构建失败.路径必须为绝对路径. g.&lt;optional&gt; 标记依赖的可选状态. h.&lt;exclusions&gt; 排除不需要的依赖,包含子元素&lt;exclusion&gt;,每个&lt;exclusion&gt;都包含&lt;groupId&gt;与&lt;artifactId&gt;. B.继承 使用&lt;parent&gt;指定需要继承的pom. &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;/parent&gt; 子pom会继承父pom的&lt;groupId&gt;,&lt;version&gt;,&lt;build&gt;等众多属性,具体包括: groupId version description url inceptionYear organization licenses developers contributors mailingLists scm issueManagement ciManagement properties dependencyManagement dependencies repositories pluginRepositories build reporting profiles 但不能继承: artifactId name prerequisites 另外,就像java中所有类都继承于java.lang.Object一样,所有POM都有一个&quot;Super POM&quot;,pom都从它继承而来,下面是Maven3.5.4的&quot;Super pom&quot;: &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;build&gt; &lt;directory&gt;${project.basedir}/target&lt;/directory&gt; &lt;outputDirectory&gt;${project.build.directory}/classes&lt;/outputDirectory&gt; &lt;finalName&gt;${project.artifactId}-${project.version}&lt;/finalName&gt; &lt;testOutputDirectory&gt;${project.build.directory}/test-classes&lt;/testOutputDirectory&gt; &lt;sourceDirectory&gt;${project.basedir}/src/main/java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;${project.basedir}/src/main/scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;${project.basedir}/src/test/java&lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;${project.basedir}/src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;reporting&gt; &lt;outputDirectory&gt;${project.build.directory}/site&lt;/outputDirectory&gt; &lt;/reporting&gt; &lt;profiles&gt; &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt; &lt;profile&gt; &lt;id&gt;release-profile&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;/project&gt; C.聚合(或多模块) 模块是pom列出的项目,并作为一个组执行,每个模块通过pom文件或项目的相对路径进行列出. &lt;modules&gt; &lt;module&gt;my-project&lt;/module&gt; &lt;module&gt;another-project&lt;/module&gt; &lt;module&gt;third-project/pom-example.xml&lt;/module&gt; &lt;/modules&gt; 不需要考虑模块间的依赖关系,Maven会对其进行拓扑排序以便在依赖模块之前构建依赖关系. (6)属性 属性是Maven中的值占位符,像Ant一样,可以以 ${x} 这样的形式在pom.xml的任何位置访问一个值,也可以被用作默认值使用. 有5种形式使用值: ①env.x env会使用当前shell的环境变量的值. 例如 ${env.PATH} ②project.x &lt;project&gt;下的x元素的值,如 ${project.version} ③settings.x 使用settings.xml中的元素的值 ${settings.offline} ④java.x java系统属性值,通过java.lang.System.getProperties()获取,如 ${java.home} ⑤x 直接使用x,用的是&lt;properties&gt;下的属性,比如 &lt;properties&gt; &lt;aaa&gt;AAAAA&lt;/aaa&gt; &lt;/properties&gt; ${aaa} 3.构建配置 &lt;build&gt;,声明项目结构,管理插件等. (1)BaseBuild元素 A.&lt;defaultGoal&gt; 目标的默认值,可以取值install,copile B.&lt;directory&gt; 构建产生的文件存放目录 C.&lt;finalName&gt; 构建最终产生的项目名字,但有可能会被更改. D.&lt;filters&gt; 定义一组&lt;filter&gt;,&lt;filter&gt;内是.properties文件,项目中的占位符如xxx.xxx会被.properties中的xxx=xxx的具体值替换掉. (2)资源 &lt;resources&gt;,项目相关的资源文件的位置. A.&lt;resource&gt; 描述每个资源的根元素. B.&lt;targetPath&gt; 构建资源的位置,对于jar包放在META-INF里面. C.&lt;flitering&gt; 取值true或false,表示是否开启过滤 D.&lt;directory&gt; 资源位置. E.&lt;include&gt; 指定要包含的资源,使用*作为通配符. F.&lt;excludes&gt; 与include相反,要排除的资源列表. (3)插件 &lt;plugins&gt;下包含了若干个&lt;plugin&gt;,表示插件,每个&lt;plugin&gt;有以下元素: A.&lt;groupId&gt;与&lt;artifactId&gt; 与上面的&lt;groupId&gt;与&lt;artifactId&gt;一样. B.&lt;version&gt; 与上面的&lt;version&gt;一样. C.&lt;extensions&gt; 取值true或false,表示是否加载扩展,默认为false. D.&lt;inherited&gt; 取值ture或false,是否应用pom的继承关系,默认true. E.&lt;configuration&gt; 插件项的相关配置,可以配置&lt;finalName&gt;,&lt;appendAssemblyld&gt;,&lt;descriptor&gt;等. F.&lt;dependencies&gt; 引入插件的依赖,与前面的&lt;dependencies&gt;类似. G.&lt;executions&gt; 插件可能有多个目标,&lt;executions&gt;配置每一个&lt;execution&gt;作为插件的目标,在&lt;execution&gt;中,用&lt;id&gt;指定执行目标的标识符,用&lt;goals&gt;指定目标,&lt;goals&gt;包含一组&lt;goal&gt;,&lt;phase&gt;用于指定阶段,&lt;inherited&gt;用于指定是否启用继承关系.另外&lt;execution&gt;也可以包含&lt;configuration&gt;,与上面类似,用于配置特定的目标,而不是插件的所有目标. (4)插件管理 &lt;pluginManagement&gt;,包含一组&lt;plugins&gt;,继承于此项目的子项目都可以使用,子项目可以覆盖修改&lt;pluginManagement&gt;. (5)目录 可以为pom设置各种目录,比如 A.项目源码目录 &lt;sourceDirectory&gt;&lt;/sourceDirectory&gt; 构建项目时会编译该目录的源码,是相对于pom.xml的相对路径. B.测试源码目录 &lt;testSourceDirectory&gt;&lt;/testSourceDirectory&gt; 测试时会编译其中的源码,也是相对于pom.xml的相对路径. C.class目录 &lt;outputDirectory&gt;&lt;/outputDirectory&gt; 这里存放被编译过的class文件. D.测试class &lt;testOutputDirectory&gt;&lt;/testOutputDirectory&gt; 存放测试文件编译后的class文件. (6)扩展 &lt;extensions&gt;,将包含在运行中的构建的类路径中,在构建过程中可以激活扩展.比如可以为,例如这是支持ftp的wagon-ftp插件: &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groudId&gt; &lt;artifactId&gt;wagon-ftp&lt;/artifactId&gt; &lt;version&gt;3.3.4&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;/build&gt; (7)报表 &lt;reporting&gt;,描述产生报表的规范等,执行&quot;mvn site&quot;时报表就会运行. A.&lt;excludeDefaults&gt; 是否包含默认报表. B.&lt;outputDirectory&gt; 报表存放位置. C.&lt;plugins&gt; 报表包含的插件以及配置. D.&lt;reportSets&gt; 包含一组&lt;reportSet&gt;,与&lt;execution&gt;类似,配置多个目标,每个&lt;reportSet&gt;包含&lt;id&gt;,&lt;configuration&gt;,&lt;inherited&gt;,以及&lt;reports&gt;,&lt;id&gt;指定报表集合的标识符,&lt;configuration&gt;表示使用的报表配置,&lt;inherited&gt;表示是否继承到子pom,&lt;reports&gt;包含一组&lt;report&gt;,表示使用哪些报表. 4.项目信息 (1)许可证 &lt;licenses&gt;,包含一组&lt;license&gt;,每个&lt;license&gt;包含&lt;name&gt;,&lt;url&gt;,&lt;distribution&gt;,&lt;comments&gt;. A.&lt;name&gt; 名称. B.&lt;url&gt; 官方license页面的url. C.&lt;distribution&gt; 项目分发的方式,可以选择 repo:从Maven仓库下载. manual:手动安装. D.&lt;comments&gt; 一些补充信息. (2)组织 &lt;organazation&gt;,包含&lt;name&gt;,&lt;url&gt;,与&lt;license&gt;的类似. (3)开发者 &lt;developers&gt;,包含一组&lt;developer&gt;,每个&lt;developer&gt;包含: A.&lt;id&gt; 开发者id. B.&lt;name&gt; 姓名. C.&lt;email&gt; 邮箱. D.&lt;url&gt; 主页url. E.&lt;organization&gt; 所属组织. F.&lt;organizationUrl&gt; 所属组织的主页url. G.&lt;roles&gt; 角色,包含一组&lt;role&gt;,一个&lt;role&gt;描述一个角色. H.&lt;timeZone&gt; 时区,可以以America/New_York或Europe/Berlin这样的形式,或者设置一个整数,范围[-11,12]. I.&lt;properties&gt; 开发者属性,如如何处理即时消息等. (4)贡献者 &lt;contributors&gt;,包含一组&lt;contributor&gt;,类似于&lt;developer&gt;,包含&lt;name&gt;,&lt;email&gt;等元素. 5.环境配置 (1)问题管理 &lt;issueManagement&gt;,定义缺陷跟踪系统,如Bugzilla,TestTrack,ClearQuest等,包含&lt;system&gt;与&lt;url&gt;元素,&lt;system&gt;指定系统名字,&lt;url&gt;指定问题管理系统的url. (2)持续集成管理 &lt;ciManagement&gt;,使用了触发器,包含了: A.&lt;system&gt; 持续集成系统的名称. B.&lt;url&gt; 持续集成系统的url. C.&lt;notifiers&gt; 包含一组&lt;notifier&gt;,用来配置触发器,每个&lt;notifier&gt;包含: a.&lt;type&gt; 如何发送通知,比如可以取值mail. b.&lt;sendOnError&gt; 取值true/false,错误时发送. c.&lt;sendOnFailure&gt; 取值true/false,失败时发送. d.&lt;sendOnSuccess&gt; 取值true/false,成功时发送. e.&lt;sendOnWarning&gt; 取值true/false,发生警告时发送. f.&lt;configuration&gt; 相关配置,例如可以添加&lt;address&gt;,发送的地址. (3)邮件列表 &lt;mailingLists&gt;,包含一组&lt;mailingList&gt;,表示邮件信息,包括: A.&lt;name&gt; 邮件名称. B.&lt;subscribe&gt; 订阅邮件地址或链接. C.&lt;unsubscribe&gt; 取消订阅邮件或链接. D.&lt;post&gt; 要发送的邮件地址. E.&lt;archive&gt; 查看旧的邮件的url. (4)软件配置管理(SCM) &lt;scm&gt;,也叫Source Code/Control Management,允许配置代码库供web站点和其他插件使用.包含: A.&lt;connection&gt;与&lt;developConnection&gt; 描述如何通过Maven连接到版本控制系统,其中connection需要读权限,developConnection需要写权限. B.&lt;tag&gt; 代码标签,默认为HEAD. C.&lt;url&gt; 公开的可浏览的仓库,例如ViewVC或Fisheye. (5)前提条件 &lt;prerequisites&gt;,这是Maven2中的元素,只有一个子元素&lt;maven&gt;,指定maven的版本,且规定是2.x版本.Maven3中不需要&lt;prerequisites&gt;了,可以用: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-maven&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;requireMavenVersion&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/requireMavenVersion&gt; &lt;/rules&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 代替. (6)仓库 &lt;repositories&gt;,包含一组&lt;repository&gt;,表示仓库的位置,每个&lt;repository&gt;包含: A.&lt;releases&gt; 如何处理远征仓库的发布版本,包含: &lt;enabled&gt; true/false,是否启用. &lt;updatePolicy&gt; 更新频率,Maven将本地pom的时间戳与远程进行比较,可以选择:always,daily(默认),interval:X(X是一个整数,表示X分钟),never. &lt;checksumPolicy&gt; 校验错误或校验失败时的策略,可以选择ignore,fail或warn. B.&lt;snapshots&gt; 如何处理远程仓库的快照版本,包含的元素与&lt;releases&gt;一样. C.&lt;id&gt; 远程仓库的标识符. D.&lt;name&gt; 远程仓库的名称. E.&lt;url&gt; 远程仓库的url. F.&lt;layout&gt; 仓库布局类型,可以是default或legacy,Maven2.x为仓库提供了默认布局. (7)插件仓库 &lt;pluginRepositories&gt;,插件的远程仓库列表,包含一组&lt;pluginRepository&gt;,与&lt;repositories&gt;中的&lt;repository&gt;类似. (8)分发管理 &lt;distributeManagement&gt;,管理整个构建过程中的分发,可以把网站部署到远程服务器或者把构件部署到远程仓库.包含: A.仓库 &lt;repository&gt;,仓库信息,包含: &lt;uniqueVersion&gt;:唯一版本,取值true/false,表示是否生成一个唯一版本号或是使用部分地址作为版本号. &lt;name&gt;:仓库名字. &lt;id&gt;:仓库id. &lt;url&gt;:指定仓库位置. &lt;layout&gt;:布局,取值default或legacy. 还有一个叫&lt;snapshotRepository&gt;的元素,与&lt;repository&gt;类似,表示快照仓库. B.站点部署 &lt;site&gt;,定义了如何部署项目的站点与文档.包含: &lt;name&gt;:站点名称. &lt;id&gt;:站点id. &lt;url&gt;:站点url. C.重定位 &lt;relocation&gt;,表示项目的新位置.包含: &lt;groupId&gt;:新的&lt;groupId&gt;. &lt;artifactId&gt;:新的&lt;artifactId&gt;. &lt;version&gt;:新版本. &lt;message&gt;:提示信息. (9)配置文件 &lt;profiles&gt;,包含一组&lt;profile&gt;,每个&lt;profile&gt;可以定义不同的配置,包含的元素有: &lt;id&gt;:配置文件的id,比如测试的可以叫test. &lt;build&gt;:相关构建信息. &lt;modules&gt;:模块信息. &lt;repositories&gt;:远程仓库信息. &lt;pluginRepositories&gt;:插件仓库信息. &lt;dependencies&gt;:依赖信息. &lt;reporting&gt;:报表信息. &lt;dependencyManagement&gt;:依赖管理信息. &lt;distributeManagement&gt;:分发管理 &lt;activation&gt;:activation是profile的关键,profile的强大之处是某些情况下才可以修改基本pom,这些情况通过activation指定. &lt;activation&gt;包含以下元素: A.&lt;activeByDefault&gt; 是否默认激活,true或false. B.&lt;jdk&gt; 指定jdk版本. C.&lt;os&gt; &lt;os&gt;可以定义一些特定的操作系统属性,例如&lt;name&gt;,&lt;family&gt;,&lt;arch&gt;,&lt;version&gt;. D.&lt;property&gt; 若Maven检测到该属性就会激活该属性所在的配置文件,可以指定&lt;name&gt;与&lt;value&gt;. E.&lt;file&gt; 有&lt;exists&gt;与&lt;missing&gt;两个子元素,&lt;exists&gt;表示若存在&lt;exists&gt;元素中对应的文件,则激活此配置文件.&lt;miissing&gt;表示若不存在&lt;missing&gt;元素中对应的文件,则激活此配置文件. ","link":"https://2293736867.github.io/post/pomxml-xiang-jie/"},{"title":"Python基础(五)","content":" 1.集合 (1)集合 (2)定义 (3)特点 A.确定性 B.无序性 C.互异性 D.支持集合运算 E.可变对象 2.字典 (1)字典 (2)定义 (3)特点 A.可以通过对应的key访问对应的value B.可变对象 (4)用作函数参数 3.迭代器 (1)迭代器 (2)可迭代对象 (3)可迭代对象转换为迭代器 4.生成器 (1)生成器 (2)特点 (3)使用 1.集合 (1)集合 集合是一种可变的无序的容器. (2)定义 x = {1,2,3} #第一种方法,使用{} x = set([2,4,5]) #第二种方法,使用强制类型转换 (3)特点 A.确定性 类似数学中的集合的确定性,集合描述得很清楚,不存在不能判断一个元素是否在一个集合中,具体来说就是in或not in运算符不会得不到确定的结果. B.无序性 因此不能通过下标访问. subscriptable就是可以通过下标访问的.这里提示&quot;not subscriptable&quot;. C.互异性 没有重复元素. D.支持集合运算 包括==,!=,判断子集,真子集,超集,真超集,交集与并集,差集,对称差分. E.可变对象 可以通过add,remove改变集合本身. 另外有不可变集合frozenset: 2.字典 (1)字典 字典是一种可变的无序容器,每个值都有自己对应的键,是一个映射结构,本质上是一个以键为元素的集合. (2)定义 使用{},键与值用:分隔,键值对用逗号分隔. x = {'aa':1,'bb':2,'cc':3} (3)特点 A.可以通过对应的key访问对应的value B.可变对象 (4)用作函数参数 def func(arg1,**arg2): print(arg1) print(arg2) func('a',a=1,b=2,c=3,d=4) 3.迭代器 (1)迭代器 迭代器可以作为next()的参数被调用,不断返回下一个值. (2)可迭代对象 可以直接作用与循环语句的对象,对于for循环是in后的对象.判断一个对象是否是可迭代对象可以利用isinstance()与Iterable. from collections import Iterable isinstance([1,2,3],Iterable) (3)可迭代对象转换为迭代器 使用iter(): 4.生成器 (1)生成器 生成器是一个函数,不过相比起普通函数,返回的是迭代器. (2)特点 生成器用的不是return,而是yield,另外生成器有惰性计算的特性,调用生成器时不会立即执行它,会在调用每个元素时才进行计算. (3)使用 def gen(): x = range(-1,8) for i in x: yield i+2 for x in gen(): print(x,end = ' ') print() ","link":"https://2293736867.github.io/post/python-ji-chu-wu/"},{"title":"Python基础(四)","content":" 1.字符串 (1)定义 (2)特性 (3)转义 (4)常用操作 A.插入连接 B.去除空白 C.长度 D.unicode编码 2.序列 (1)序列 (2)特点 A.索引 B.切片 C.迭代 D.拆包赋值 E.重复运算 1.字符串 (1)定义 可以使用单引号,双引号,三引号定义字符串. x = '123' x = &quot;123&quot; x = '''123''' x = ''' 123 456 ''' 三引号可以跨行使用. (2)特性 python中的字符串是不可变对象: 字符串也属于序列的一种,支持切片操作: (3)转义 转义一般用于单引号,双引号,斜杠等特殊符号. x = '\\\\123' x = &quot;\\&quot;123\\&quot;&quot; 对于用单引号引起的字符串,若含有单引号,可以把外面的单引号改成双引号,对于双引号字符串也类似. 另一种可以不用转义的方法是在字符串前加一个r: (4)常用操作 A.插入连接 使用x.join(a)表示把x插入到a中的每个字符中间: B.去除空白 strip(),去除左右空白字符,包括空格,换行,制表符. C.长度 计算字符串长度,len(x): D.unicode编码 ord():计算unicode编码. chr():与ord()相反,解码. 注意参数是一个字符. 2.序列 (1)序列 序列是列表,元组,字符串等元素之间具有顺序关系的数据类型的统称,不是一个独立的数据类型. (2)特点 A.索引 可以通过索引来获取元素的值: B.切片 形式为: [start:end:step] start为起始位置,包含.end为结束位置,不包含,step为步长,默认为1,三者都可以省略.三者都可以为负数. C.迭代 序列是支持迭代的,可以放在for循环的in后: x = '123888' for i in x: print(i,end = ' ') print() D.拆包赋值 用逗号分隔等号左边的变量,等号右边为一个序列. E.重复运算 使用*表示重复n次. ","link":"https://2293736867.github.io/post/python-ji-chu-si/"},{"title":"Python基础(三)","content":" 1.list (1)定义方法 (2)下标 (3)切片 (4)反向遍历 A.[::-1] B.使用内置函数reversed() C.使用列表方法.reverse() (5)列表推导式 (6)列表的常用函数 A.extend() B.append() C.insert() D.pop() E.remove() F.len() G.sorted()与sort() H.enumerate() I.zip() 2.元组 (1)定义方法 (2)特点 (3)应用 1.list list是一种可变的有序容器,每个元素都拥有自己的下标.列表使用[]定义. (1)定义方法 x = [1,2,3] #第一种,使用[] y = x #第二种,赋值 y = list({1,2,3}) #第三种,使用强制转换函数 (2)下标 下标从0开始,允许负数作为下标,最后一个元素的下标为-1,第一个元素的下标为-n,第i个元素的下标为(i-1)或-(n-i+1). (3)切片 设x是一个列表,则 x[start:end:step] 为列表的一个切片,start为起始位置,包含,可以省略,end为结束位置,不包含,可以省略,step为步长,可以省略,默认为1. 三者都可以为负数. 三者都省略时为整个列表,反向遍历时可以省略start与end,步长设为-1: (4)反向遍历 反向遍历有三种方法: A.[::-1] 使用切片,像上面一样,步长设为-1 B.使用内置函数reversed() reversed()会返回一个迭代器,想要获取里面的内容可以转换为list(). C.使用列表方法.reverse() 前两种方法不会改变列表,列表方法reverse()改变了列表. (5)列表推导式 列表推导式可用于快速生成有规律性的列表,比如生成包含10个2的列表: [2 for i in range(10)] 有点类似于把for循环的循环体提到前面. (6)列表的常用函数 A.extend() extend()类似于直接使用+,但是+不会改变列表本身,而extend()会改变列表本身. B.append() append()把参数作为一个元素直接追加到列表中. C.insert() insert需要两个参数,分别表示插入的下标与插入的值. D.pop() 根据下标删除元素. E.remove() 根据值删除元素,删除第一个出现的元素,就是说对于重复元素仅删除第一次出现的元素. F.len() 列表长度,注意这个不是列表的方法. G.sorted()与sort() 这两个都是排序的方法,sorted()不是列表的方法,把列表作为函数的参数传递,sort是列表的方法,会改变列表本身. H.enumerate() 逐个显示对应的下标,返回的是一个迭代器.想要显示可以转换为列表. I.zip() 列表的并行计算. 2.元组 元组是不可变的有序容器,用()表示. (1)定义方法 x = (1,2,3,4,5) #第一种,使用() y = x #第二种,使用赋值 x = tuple('kkkrrr') #第三种,使用tuple强制转换 x = 1,2,3,4,5 #第四种,实质上还是第一种,省略了圆括号 (2)特点 用逗号分隔的都是元组,是不可变对象,支持拆包式赋值. (3)应用 交换两个变量: 函数的不定长参数: def fun(arg1,*arg2): print(arg1) if arg2 != (): if len(arg2) == 1: print(arg2[0]) else: print(arg2) fun(1) fun(2,3) fun(4,5,6) ","link":"https://2293736867.github.io/post/python-ji-chu-san/"},{"title":"Maven简介","content":" 1.Maven介绍 2.安装Maven 3.设置Maven 4.Maven常用命令 (1)编译 (2)打包 (3)安装到本地 (4)安装到远程仓库 (5)清理 1.Maven介绍 Maven最初用于代替Ant,用来简化项目的构建,Maven使构建项目变得容易,规定了源码总是放在src/main/java下,测试代码放在/src/test/java中,配置文件放在/src/main/resources中,通过使用pom.xml统一了描述项目的方式,可以自动解决库的依赖问题,只要声明了使用的库,会自动从中央仓库下载,并且可以自动管理冲突. 2.安装Maven 官网这里. 选择下载即可,作者用的是windows,选择zip.下一步是解压放到相应的位置. 然后添加环境变量MAVEN_HOME,是maven的解压位置.需要的话可以再配置一个环境变量M2_HOME,用来作为本地仓库的位置. 最后配置一个PATH,添加 %MAVEN_HOME%/bin 到path中. 在cmd中验证 mvn -version 即表示成功安装. 3.设置Maven 因为中心仓库位于国外,一般下载时会很慢,因此可以设置为国内的镜像,这里选择阿里云的镜像. 打开Maven安装目录下的conf/setting.xml,编辑&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 另外也需要在IDE中设置一下Maven.这里以IDEA为例. 打开settings--&gt;Build,Execution,Deployment--&gt;Build Tools--&gt;Maven,设置maven的位置. 另外也可以设置配置文件的位置与本地仓库的位置,配置文件默认是conf/settings.xml,本地仓库默认用户目录下的.m2文件夹. 4.Maven常用命令 (1)编译 mvn compile 编译Maven工程. (2)打包 mvn package 编译并打包工程,会根据pom.xml中的&lt;packaging&gt;打成jar或war包. (3)安装到本地 mvn install 打包并安装到本地仓库,这样可以通过项目坐标引用. (4)安装到远程仓库 mvn deploy 打包并安装到远程仓库.Maven仓库有两大类: 远程仓库,包括中心仓库与镜像仓库,还有利用nexus搭建的私服. 本地仓库,默认位于用户目录的.m2目录. (5)清理 mvn clean 删除target目录. ","link":"https://2293736867.github.io/post/maven-jian-jie/"},{"title":"Python基础(二)","content":" 1.赋值语句 (1)作用:定义+赋值 (2)复合与链式赋值 (3)特殊类型的赋值 2.注释 3.运算符 (1)算术运算符 (2)关系运算符 (3)赋值运算符 (4)逻辑运算符 (5)位运算符 (6)集合运算符 (7)特殊运算符 in运算符 is运算符 4.if语句 (1)基本语法 (2)单行if (3)配合pass的多行elif 5.for语句 (1)基本语法 (2)range() 6.while语句 (1)基本语法 (2)continue+break 1.赋值语句 (1)作用:定义+赋值 (2)复合与链式赋值 a = b = 2 a *= 2 (3)特殊类型的赋值 序列的赋值: a,b,c = (1,2,3) print(a,b,c) 变量交换: a,b = b,a 不需要额外的temp变量. 2.注释 以#开头的行即为注释. 3.运算符 (1)算术运算符 运算符 含义 + 加 - 减 * 乘 / 除 % 取模 // 整除(不是注释....) ** 幂 (2)关系运算符 运算符 含义 == 等于 != 或 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 (3)赋值运算符 运算符 含义 = 赋值 += x+=3等价于x=x+3 -= x-=3等价于x=x-3 *= x*=3等价于x=x*3 /= x/=3等价于x=x/3 %= x%=3等价于x=x%3 //= x//=3等价于x=x//3 **= x**=3等价于x=x**3 (4)逻辑运算符 运算符 含义 and 和 or 或 not 非 (5)位运算符 运算符 含义 &amp; 按位与 ¦ 按位或 ^ 按位异或 ~ 按位取反 &gt;&gt; 右移 &lt;&lt; 左移 (6)集合运算符 运算符 含义 in ∈\\in∈,属于 not in ∉\\notin∈/​,不属于 == 集合相等 != 集合不相等 &lt; ⊆\\subseteq⊆,真子集 &lt;= ⊂\\subset⊂,子集 &gt; ⊃\\supset⊃,真超集 &gt;= ⊇\\supseteq⊇,超集 &amp; ∩\\cap∩,交集 ¦ ∪\\cup∪,并集 - 差集或相对补集 ^ 对称差分 (7)特殊运算符 in运算符 判断某个变量是否在给定的容器中.可以配合not使用. x = {1,3,4} 1 in x 9 not in x is运算符 检查是否指向同一个引用 x = y = {1,3,4} x is y 注意,若写成 x = {1,3,4} y = {1,3,4} x is y 为False,指向的不是同一个对象. 4.if语句 (1)基本语法 if(xxx): print(a) elif(xxx): print(b) else: print(c) 注意冒号和缩进. (2)单行if 把 if(xxx): A else: B 变为 A if (xxx) else B 本质上是把if内的语句提前,然后写成一行. (3)配合pass的多行elif if(a &lt; 3): print(a) elif(a &gt; 8 and a &lt; 11): pass else: print(a) 注意不能用;代替pass. 5.for语句 (1)基本语法 for xxxx in xxxxx.其中in后面表示的是可迭代对象或迭代器. for x in (1,2,3): print(x) (2)range() 一般for配合range使用,range()返回一个迭代器,参数有三个,前两个为起始值与结束值,第三个可选,表示步长.注意范围是[start,end),就是包含start值,不包含end值. for x in range(1,10): print(x,end=' ') print() 顺序输出1到9, 6.while语句 (1)基本语法 x = 1 while(x&lt;10): print(x,end=' ') x+=1 print() 要注意的一个就是不要使用++......不要用自增运算符,没用的.... (2)continue+break x = 1 while(x &lt; 10): if(x == 3): break print(x,end=' ') x+=1 print() x = 1 while(x &lt; 10): if(x == 3): continue print(x,end=' ') x+=1 print() ","link":"https://2293736867.github.io/post/python-ji-chu-er/"},{"title":"Python基础(一)","content":" 1.基础类型 (1)整数 (2)实数 (3)复数 (4)布尔 (5)字符串 (6)列表 (7)元组 (8)集合 (9)集合常量 (10)字典 2.判断数据类型 3.变量定义 4.引用 5.代码规范 (1)python没有专门的结束符 (2)通常规则是一句一行 (3)可以一行多句或一句多行 (4)缩进 1.基础类型 python的数据类型可以分为两种,一种是内置的,一种是其他包中的,内置的数据类型可以分为10种: (1)整数 用int表示,强制转换函数为int(): x = 10 print(x) int(10.88) 输出都是10. (2)实数 用float表示,强制转换函数为float() x = 10.222 print(x) float(10) 看一个有趣的东西: (3)复数 用complex表示,python默认用j表示虚数单位. x = complex(3,4) y = complex(-9,4.55555) print(x+y) (4)布尔 用bool表示,可以取值Ture/False. x = Ture print(x,False) (5)字符串 用str表示,可以使用单引号或双引号,注意是常量,不可变的.支持序列操作. x = &quot;123&quot; print(x) x = str(5) print(x) (6)列表 用list表示,使用[],支持序列操作.与str相比,list是可变的. x = [1,3,4,4] x[2] = '2342' print(x) (7)元组 用tuple表示,使用(),不可变的,支持序列操作. x = (2,3,4) print(x) (8)集合 用set表示,使用[],可变的,无序的,不支持序列操作. x = {3,4,-4,343,-999} print(x) x.add(123) print(x) (9)集合常量 用frozenset表示,也是使用[],不可变的,不支持序列操作. x = frozenset(range(5)) y = frozenset('9900abc') print('x=',x,'\\ny=',y) (10)字典 用dict表示,使用[]配合键值对,是可变的. x = {'a':1,'b':2,'c':3} print(x['a']) 2.判断数据类型 使用isinstance(),判断一个对象是否是已知的类型,参数是判断的对象与类型: isinstance(10,str) isinstance([3,4],dict) isinstance({7,8,-99999},set} isinstance(8.0,int) 3.变量定义 python中使用赋值语句定义一个变量,用户不需要显示地声明变量的数据类型,python是动态强类型语言,动态是指变量的类型可以动态改变,而强类型是指运算过程中不会自动进行数据类型的转换(除了&quot;数值类&quot;的int,float,bool与complex). 比如,先赋值整数,再赋值列表是可以的,因为是动态类型语言. 可以让int与float相加,但是不能让int与str相加,因为是强类型语言. 4.引用 python中的变量名与c/c++/java的不同,变量名并不是直接表示变量的值,而是表示值的一个引用.因此,这可以解释为什么可以将一个str&quot;赋值&quot;给一个int,变量存放的并不是int或str的具体的值,而是地址. 5.代码规范 (1)python没有专门的结束符 python没有专门的结束符,没有如c,java的分号,python解释器根据其语法完整性判断语句是否结束. (2)通常规则是一句一行 (3)可以一行多句或一句多行 对于一行多句,使用分号分隔不同语句,对于一句多行,使用\\ . (4)缩进 python无固定的缩进单位,PEP8(Python代码编写规范)建议缩进为4个空格,python的缩进很重要,相当于其他语言的{},另外缩进要以:开始. ","link":"https://2293736867.github.io/post/python-ji-chu-yi/"},{"title":"java实现简单计算器","content":" 1.概述 2.UI (1)文本框 (2)按键 3.鼠标事件 4.键盘事件 5.计算表达式 6.测试 7.源码 1.概述 之前作者写过一篇文章,也是关于计算器的,用的是C++与Qt,链接在这里 这次用java的swing写的(这差距好像有点大,好吧是qt太强了). 先上图: 2.UI 总体布局使用流布局. (1)文本框 文本框就一个JPanel里面加一个JTextField. boxField.setLayout(new FlowLayout()); box.setPreferredSize(new Dimension(300, 25)); boxField.add(box); JTextField设置尺寸需要使用setPreferredSize()而不是setSize(). (2)按键 按键4*4网格布局,逐个添加button即可. buttonsField.setLayout(new GridLayout(4, 4, 20, 20)); buttonsField.setPreferredSize(new Dimension(300, 300)); buttonsField.add(xxx); //add.... 3.鼠标事件 鼠标事件针对button,仔细想一想,单击一个button,然后文本框里面就会有相应的反应,据此添加事件监听. num0.addActionListener(v -&gt; { box.setText(box.getText() + &quot;0&quot;); mainFrame.requestFocus(); }); requestFocus()这一行把焦点还给JFrame,因为鼠标点击button后,button会获取焦点,会影响后面的键盘监听. 4.键盘事件 键盘事件与鼠标事件类似,针对每个键判断即可. 在这里的是把KeyListener注册到JFrame上面,直接在里面重写以下三个KeyListener的方法: public void keyPressed(KeyEvent e); public void keyReleased(KeyEvent e); public void keyTyped(KeyEvent e); 基本上就是通过 if (e.getKeyCode() == KeyEvent.VK_xxxx) 来判断各个键,唯一要注意一下的是+与* 因为作者使用的键盘没有小键盘(尴尬....),+与*需要shift+=或8,尝试过直接 if (e.getKeyCode() == KeyEvent.VK_PLUS) if (e.getKeyCode() == KeyEvent.VK_ADD) if (e.getKeyCode() == KeyEvent.VK_MUTIPLY) 无效. 因此需要在KeyPressed这里判断是否按下了shift,然后到了KeyReleased()的时候,特判一下8与=: else if (e.getKeyCode() == KeyEvent.VK_8) box.setText(box.getText() + (shift ? &quot;*&quot; : &quot;8&quot;)); else if(e.getKeyCode() == KeyEvent.VK_EQUALS) { if(shift) box.setText(box.getText() + &quot;+&quot;); else setResult(); } 5.计算表达式 计算表达式部分这里讲了就不详细说了,代码在后面. 简单来说就是先使用 GetResult.setExpression(); 这个静态方法设置表达式,然后通过 GetResult.valid() 判断是否合法,合法的话通过 GetResult.result() 获取String结果. 6.测试 7.源码 github 码云 ","link":"https://2293736867.github.io/post/java-shi-xian-jian-dan-ji-suan-qi/"},{"title":"java简单的用户登录界面+mysql","content":" 1.概述 2.UI (1)主界面 (2)用户信息界面 3.数据库操作 4.完整代码 1.概述 一个简单的swing登录界面,使用了简单的JDBC. 如图: 2.UI (1)主界面 主界面使用了31网格布局+三个JPanel,中间的JPanel使用了22网格布局: import java.awt.FlowLayout; import java.awt.Font; import java.awt.GridLayout; import java.util.Enumeration; import java.awt.Container; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JPasswordField; import javax.swing.JTextField; import javax.swing.UIManager; import javax.swing.plaf.FontUIResource; public class UserManagement { private JFrame mainFrame = new JFrame(&quot;登录&quot;); private Container container = mainFrame.getContentPane(); private JLabel titleLabel = new JLabel(&quot;登录/注册&quot;, JLabel.CENTER); private JPanel inputField = new JPanel(); private JLabel usernameLabel = new JLabel(&quot;用户名:&quot;, JLabel.CENTER); private JTextField username = new JTextField(); private JLabel passwordLabel = new JLabel(&quot;密码:&quot;, JLabel.CENTER); private JPasswordField password = new JPasswordField(); private JPanel buttonField = new JPanel(); private JButton save = new JButton(&quot;登录/注册&quot;); private JButton cancel = new JButton(&quot;取消&quot;); public UserManagement() { init(); setFont(new Font(&quot;微软雅黑&quot;,Font.PLAIN,14)); addEvent(); } private void init() { container.setLayout(new GridLayout(3, 1, 0, 10)); container.add(titleLabel); inputField.setLayout(new GridLayout(2, 2, 5, 5)); inputField.add(usernameLabel); inputField.add(username); inputField.add(passwordLabel); inputField.add(password); container.add(inputField); buttonField.setLayout(new FlowLayout(FlowLayout.CENTER,20,0)); buttonField.add(save); buttonField.add(cancel); container.add(buttonField); mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); mainFrame.setSize(300, 200); mainFrame.setLocationRelativeTo(null); mainFrame.setVisible(true); } private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for(Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if(value instanceof FontUIResource) UIManager.put(key, fontRes); } } private void addEvent() { save.addActionListener( e-&gt; { User user = new User(); user.setName(username.getText()); user.setPassword(new String(password.getPassword())); if(DBUtils.exists(user)) new UserInformation(DBUtils.getByName(user.getName())); else JOptionPane.showConfirmDialog(null, &quot;添加&quot;+(DBUtils.add(user) ? &quot;成功&quot; : &quot;失败&quot;), &quot;&quot;,JOptionPane.CLOSED_OPTION); } ); cancel.addActionListener( e-&gt; { mainFrame.dispose(); } ); } public static void main(String[] args) { new UserManagement(); } } 重点说一下几行代码: mainFrame.setLocationRelativeTo(null); 使整个JFrame处于屏幕水平居中与垂直居中位置. private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for(Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys();keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if(value instanceof FontUIResource) UIManager.put(key, fontRes); } } 设置所有组件的字体. cancel.addActionListener( e-&gt; { mainFrame.dispose(); } ); 按钮添加关闭窗口事件. JOptionPane.showConfirmDialog(null,&quot;添加&quot;+(DBUtils.add(user) ? &quot;成功&quot; : &quot;失败&quot;), &quot;&quot;,JOptionPane.CLOSED_OPTION); 提示信息框. (2)用户信息界面 用户信息界面采用了31网格,同样3个JPanel,中间的JPanel布局为32网格. import java.awt.FlowLayout; import java.awt.Font; import java.awt.GridLayout; import java.util.Enumeration; import java.awt.Container; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JPasswordField; import javax.swing.JTextField; import javax.swing.UIManager; import javax.swing.plaf.FontUIResource; public class UserInformation { private JFrame mainFrame = new JFrame(&quot;用户信息&quot;); private Container container = mainFrame.getContentPane(); private JLabel titleLabel = new JLabel(&quot;用户信息&quot;, JLabel.CENTER); private JPanel inputField = new JPanel(); private JLabel idLabel = new JLabel(&quot;Id&quot;,JLabel.CENTER); private JTextField id = new JTextField(); private JLabel usernameLabel = new JLabel(&quot;Username&quot;, JLabel.CENTER); private JTextField username = new JTextField(); private JLabel passwordLabel = new JLabel(&quot;Password&quot;, JLabel.CENTER); private JPasswordField password = new JPasswordField(); private JPanel buttonField = new JPanel(); private JButton update = new JButton(&quot;更新&quot;); private User user; public UserInformation(User user) { if(user == null) mainFrame.dispose(); this.user = user; init(); setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 14)); addEvent(); } private void init() { container.setLayout(new GridLayout(3,1,0,10)); container.add(titleLabel); inputField.setLayout(new GridLayout(3,2,0,3)); inputField.add(idLabel); inputField.add(id); id.setText(user.getId()); id.setEditable(false); inputField.add(usernameLabel); username.setText(user.getName()); inputField.add(username); inputField.add(passwordLabel); password.setText(user.getPassword()); inputField.add(password); container.add(inputField); buttonField.setLayout(new FlowLayout()); buttonField.add(update); container.add(buttonField); mainFrame.setVisible(true); mainFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); mainFrame.setLocationRelativeTo(null); mainFrame.setSize(300,250); } private void setFont(Font font) { FontUIResource fontRes = new FontUIResource(font); for (Enumeration&lt;Object&gt; keys = UIManager.getDefaults().keys(); keys.hasMoreElements();) { Object key = keys.nextElement(); Object value = UIManager.get(key); if (value instanceof FontUIResource) UIManager.put(key, fontRes); } } private void addEvent() { update.addActionListener( e-&gt; { user.setName(username.getText()); user.setPassword(new String(password.getPassword())); JOptionPane.showConfirmDialog(null, &quot;更新&quot;+(DBUtils.modify(user) ? &quot;成功&quot; : &quot;失败&quot;),&quot;确认&quot;,JOptionPane.CLOSED_OPTION); } ); } } 这个JFrame不能设置EXIT_ON_CLOSE.因为这不是&quot;主窗体&quot;,不然的话点击关闭主窗体也没了. mainFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); 3.数据库操作 import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.UUID; public class DBUtils { private final static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;; private final static String username = &quot;aa&quot;; private final static String password = &quot;123456&quot;; private final static String url = &quot;jdbc:mysql://127.0.0.1/user_test&quot;; private final static String insert = &quot;insert into user(id,username,password) values(?,?,?)&quot;; private final static String update = &quot;update user set username = ?,password = ? where id = ?&quot;; private final static String delete = &quot;delete from user where id = ?&quot;; private final static String select = &quot;select * from user where username = ?&quot;; private static Connection connection; static { try { Class.forName(driver); connection = DriverManager.getConnection(url,username,password); } catch(Exception e) { e.printStackTrace(); connection = null; } } public static boolean exists(User user) { try { PreparedStatement exist = connection.prepareStatement(select); exist.setString(1,user.getName()); ResultSet existResult = exist.executeQuery(); return existResult.next(); } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean add(User user) { try { PreparedStatement add = connection.prepareStatement(insert); user.setId(UUID.randomUUID().toString().substring(0, 8)); add.setString(1, user.getId()); add.setString(2, user.getName()); add.setString(3, user.getPassword()); return add.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean modify(User user) { try { PreparedStatement modify = connection.prepareStatement(update); System.out.println(user.getName()); modify.setString(1, user.getName()); modify.setString(2, user.getPassword()); modify.setString(3, user.getId()); return modify.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); return false; } } public static boolean delete(User user) { if(exists(user)) { try { PreparedStatement del = connection.prepareStatement(delete); del.setString(1, user.getId()); return del.executeUpdate() == 1; } catch (SQLException e) { e.printStackTrace(); } } return false; } public static User getByName(String name) { try { PreparedStatement exist = connection.prepareStatement(select); exist.setString(1, name); ResultSet existResult = exist.executeQuery(); if(existResult.next()) { User user = new User(); user.setId(existResult.getString(&quot;id&quot;)); user.setName(existResult.getString(&quot;username&quot;)); user.setPassword(existResult.getString(&quot;password&quot;)); return user; } return null; } catch (SQLException e) { e.printStackTrace(); return null; } } } 注册驱动后,增删查改,就是注意一下mysql版本与驱动名对应. 4.完整代码 github 码云 ","link":"https://2293736867.github.io/post/java-jian-dan-de-yong-hu-deng-lu-jie-mian-mysql/"},{"title":"Gson?So easy.","content":" 1.概述 2.Gson是什么? (1)JSON (2)Gson (3)Gson的好处 3.配置Gson环境 (1)Gradle (2)Maven (3)jar 4.Gson基础 (1)基础类型 (2)嵌套对象 (3)数组 a.普通数组 b.List (4)Map (5)Set (6)null (7)混合 5.Gson注解 (1)@SerializedName a.单独使用value b.同时使用value与alternate (2)@Expose 6.Gson Builder (1)基础 (2)命名规则 a.使用系统命名规则 b.自定义命名规则 (3)null (4)排除 a.属性名排除 b.类型排除 c.修饰符排除 d.@Expose排除 (5)Lenient (6)Floats &amp; Doubles (7)模型版本化 (8)格式化日期 7.Gson进阶 (1)枚举 (2)泛型 (4)自定义序列化 (5)自定义反序列化 (6)默认实例 (7)@JsonAdapter 8.源码 9.参考链接 1.概述 这篇文章主要讲述了Gson的使用.包括从最基础的基本类型的序列化,到对象,数组,集合,再到Gson注解,Gson Builder,再到格式化,自定义序列化与反序列化等内容. 另外文章篇幅较长,建议挑选所需部分查看.所有例子都提供了完整源码,在文章的后面. 2.Gson是什么? (1)JSON JSON全称为JavaScript Object Notation,一种轻量级的数据交换格式. 类似于XML但比XML更小,更易解析. (2)Gson Gson是Google提供的可以使Java对象与JSON互转的类库,可将Java对象转换为JSON,也可将JSON转换成Java对象. (3)Gson的好处 a.容易,高效,强大:Gson是Google管理的标准化库,经过高度优化,同时api简单,比如fromJSON(),toJSON(). b.无依赖性:不需要其他库,当然jdk除外. c.结果简单:转换成的json易于阅读. d.支持泛型,支持内部类. e.开源,免费提供. 3.配置Gson环境 目前最新的是2.8.6版本. (1)Gradle dependencies { implementation 'com.google.code.gson:gson:2.8.6' } (2)Maven &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;/dependency&gt; (3)jar 点击下载. 4.Gson基础 (1)基础类型 int intJSON = 1; long longJSON = 1L; double doubleJSON = 1.0; float floatJSON = 1.0f; byte byteJSON = 1; char charJSON = 'G'; short shortJSON = 1; boolean boooleanJSON = true; System.out.println(gson.toJson(intJSON)); System.out.println(gson.toJson(longJSON)); System.out.println(gson.toJson(doubleJSON)); System.out.println(gson.toJson(floatJSON)); System.out.println(gson.toJson(byteJSON)); System.out.println(gson.toJson(charJSON)); System.out.println(gson.toJson(shortJSON)); System.out.println(gson.toJson(boooleanJSON)); System.out.println(&quot;----------------------------------------&quot;); System.out.println(gson.fromJson(&quot;1&quot;,Integer.class)); System.out.println(gson.fromJson(&quot;1.0&quot;,Double.class)); System.out.println(gson.fromJson(&quot;1&quot;,Long.class)); System.out.println(gson.fromJson(&quot;true&quot;,Boolean.class)); System.out.println(gson.fromJson(&quot;B&quot;,Character.class)); 就是对应输出,没啥好说的. (2)嵌套对象 Gson gson = new Gson(); System.out.println(gson.toJson(new A())); String str = &quot;{'field':'gggg','field2':33,'field3':'G','field4':'true'}&quot;; A a = gson.fromJson(str,A.class); System.out.println(a.getField1()); System.out.println(a.getField2()); System.out.println(a.getField3()); System.out.println(a.getField4()); A类: class A { private String field1 = &quot;123&quot;; private int field2 = 1; private char field3 = 'X'; private Boolean field4 = true; } 序列化出来的对象用{}表示. 反序列化时,注意格式,注意名字对应,用单引号引起来,还有char会自动变为String类型,另外对于布尔类型可以加单引号或不加单引号,都可以正常反序列化. (3)数组 a.普通数组 int [] a = new int []{1,2,3}; double [] b = new double []{1.0,2.0,3.0}; String [] c = new String []{&quot;123&quot;,&quot;456&quot;}; System.out.println(gson.toJson(a)); System.out.println(gson.toJson(b)); System.out.println(gson.toJson(c)); int [] aa = gson.fromJson(&quot;[6,7,8]&quot;,int [].class); double [] bb = gson.fromJson(&quot;[6.0,8.0,9.0]&quot;,double [].class); String [] cc = gson.fromJson(&quot;['123123','5464']&quot;,String [].class); System.out.println(Arrays.toString(aa)); System.out.println(Arrays.toString(bb)); System.out.println(Arrays.toString(cc)); 对普通数组的话,{}变成了[]. 还有就是反序列化时,默认会在逗号后面添一个空格. b.List List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;123&quot;); list.add(&quot;456&quot;); System.out.println(gson.toJson(list)); List&lt;AAAA&gt; list2 = new ArrayList&lt;&gt;(); list2.add(new AAAA()); list2.add(new AAAA(&quot;45345&quot;,8888,false)); System.out.println(gson.toJson(list2)); System.out.println(&quot;---------------------------------&quot;); Type type = new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType(); String strList = &quot;['234234','45457']&quot;; List&lt;String&gt; list3 = gson.fromJson(strList, type); System.out.println(list3); String strList2 = &quot;[&quot; + &quot;{'field1':'9999','field2':666,'field3':'true'}&quot; + &quot;,&quot; + &quot;{'field1':'sdlkfkl','field2':-234234,'field3':'false'}&quot; + &quot;]&quot;; List&lt;AAAA&gt; list4 = gson.fromJson(strList2, new TypeToken&lt;List&lt;AAAA&gt;&gt;(){}.getType()); System.out.println(list4); class AAAA { private String field1 = &quot;123&quot;; private int field2 = 5; private boolean field3 = true; } 序列化没什么问题,直接toJson即可,反序列化时,需要配合java.lang.reflect.Type使用,明确指出所要转换的类型: Type type = new TypeToken&lt;List&lt;String&gt;&gt;(){}.getType(); TypeToken&lt;T&gt;中T为所需要的类型,再把这个Type对象传递给fromJson即可完成转换. List序列化出来的用[]表示. (4)Map Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;123&quot;,88); map.put(&quot;2349&quot;,999); System.out.println(gson.toJson(map)); String str = &quot;{'123':23423423,'9999':-234234}&quot;; Map&lt;String,Integer&gt; map2 = gson.fromJson(str, new TypeToken&lt;Map&lt;String,Integer&gt;&gt;(){}.getType()); System.out.println(map2.get(&quot;123&quot;).toString()); System.out.println(map2.get(&quot;9999&quot;).toString()); Map同样序列化时直接toJson,反序列化时使用java.lang.reflect.Type.Map序列化出来的用{}表示. (5)Set Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;123123&quot;); set.add(&quot;2349594&quot;); set.add(&quot;-234()@#$@#&quot;); System.out.println(gson.toJson(set)); String str = &quot;['38483','@*#$(@#$)','SD&lt;FGDF&gt;G']&quot;; Set&lt;String&gt; set2 = gson.fromJson(str, new TypeToken&lt;Set&lt;String&gt;&gt;(){}.getType()); set2.stream().forEach(System.out::println); set序列化出来的用[]表示. (6)null System.out.println(gson.toJson(new AAA())); String str = &quot;{'field2':333,'field3':null}&quot;; System.out.println(gson.fromJson(str, AAA.class)); class AAA { private String field1 = null; private Integer field2 = null; private Double field3 = 3.0; @Override public String toString() { return &quot;field1:&quot;+field1+&quot;,field2:&quot;+field2+&quot;,field3:&quot;+field3; } } Gson会忽略空值,在序列化时看不到null对应的键值对,反序列化时,直接对应为空. (7)混合 一个对象里面包含了List,Map,Set,null. System.out.println(gson.toJson(new Test())); class Test { private List&lt;String&gt; listField = new ArrayList&lt;&gt;(); private Map&lt;String,Double&gt; mapField = new HashMap&lt;&gt;(); private Set&lt;Integer&gt; setField = new HashSet&lt;&gt;(); private List&lt;User&gt; userListFiled = new ArrayList&lt;&gt;(); private Map&lt;String,User&gt; userMapField = new HashMap&lt;&gt;(); private Set&lt;User&gt; userSetField = new HashSet&lt;&gt;(); private Set&lt;String&gt; nullSetField = null; private Map&lt;String,User&gt; nullMapField = null; private List&lt;User&gt; nullListField = null; private Long longField = 23423423423L; private int intField = 234234; private Double doubleField = 234234.23423; private User userField = new User(); { listField.add(&quot;234234&quot;); mapField.put(&quot;23432&quot;,-234.0); setField.add(-23423); userListFiled.add(new User(&quot;3459&quot;,-23423,new int []{4,5,5})); userListFiled.add(new User()); userMapField.put(&quot;()&quot;,new User()); userMapField.put(&quot;------&quot;, new User(&quot;345345&quot;,3434,new int []{4,44})); userSetField.add(new User()); userSetField.add(new User()); } } class User { private String name = &quot;noName&quot;; private int age = 0; private int [] nums = new int[]{2,3,4}; public User() { } public User(String name,int age,int [] nums) { this.name = name; this.age = age; this.nums = nums; } } 这个就不反序列化了,可以看到对象,Map用{},List,Set用[].与上面的一致. 5.Gson注解 (1)@SerializedName SerializedName注解有两个参数,分别是value与alternate.SerializedName由注解名字可以知道与序列化成的Json名字有关. 默认情况下,json的键名与对象的字段名一致,@SerializedName可以解决序列化/反序列化时json键名与对象字段名不一致的问题,使其将json可以正确映射到对应的字段. a.单独使用value 单独使用一个参数时,即@SerializedName(&quot;xxx&quot;)或@SerializedName(value=&quot;xxx&quot;),序列化时,对象字段会变为@SerializedName中的值,反序列化时,若不是@SerializedName()中的值则不会反序列化: public class SerializedNameValueTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new SerializedNameValueTest().new User())); String str = &quot;{'this is a name':'what????','this is an age':13,'email':'33333@222.com'}&quot;; System.out.println(gson.fromJson(str,User.class)); String str2 = &quot;{'name':'askldfklaslk','age':-222,'email':'234234@23423.com'}&quot;; System.out.println(gson.fromJson(str2, User.class)); } class User { @SerializedName(&quot;this is a name&quot;) private String name = &quot;123&quot;; @SerializedName(&quot;this is an age&quot;) private int age = 0; private String email = &quot;xxx@xxx.com&quot;; private double[] nums = new double[] { 1.0, 2.0 }; @Override public String toString() { return &quot;name:&quot; + name + &quot;,age:&quot; + age + &quot;,eamil:&quot; + email + &quot;,nums:&quot; + Arrays.toString(nums); } } } 最后一个反序列化不成功,因为'name'不对应@SerializedName()中的'this is a name'. b.同时使用value与alternate 同时使用两者可以解决上面的问题,即name字段---&gt;json中的'this is a name'---&gt;name字段: public class SerializedNameValueAndAlternateTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new SerializedNameValueAndAlternateTest().new User())); String str = &quot;{'this is a name':'what????','this is an age':13,'email':'33333@222.com'}&quot;; System.out.println(gson.fromJson(str, User.class)); String str2 = &quot;{'name':'askldfklaslk','age':-222,'email':'234234@23423.com'}&quot;; System.out.println(gson.fromJson(str2, User.class)); } class User { @SerializedName(value = &quot;this is a name&quot;,alternate = &quot;name&quot;) private String name = &quot;123&quot;; @SerializedName(value = &quot;this is an age&quot;,alternate = &quot;age&quot;) private int age = 0; private String email = &quot;xxx@xxx.com&quot;; private double[] nums = new double[] { 1.0, 2.0 }; @Override public String toString() { return &quot;name:&quot; + name + &quot;,age:&quot; + age + &quot;,eamil:&quot; + email + &quot;,nums:&quot; + Arrays.toString(nums); } } } alternate就是为反序列化准备的,若找不到value中对应的值,则寻找alternate对应的值,找不到再设为null. 若同时存在value与alternate: String str3 = &quot;{'name':'altername','this is a name':'value'}&quot;; System.out.println(gson.fromJson(str3, User.class)); String str4 = &quot;{'this is a name':'value','name':'altername'}&quot;; System.out.println(gson.fromJson(str4, User.class)); 则以&quot;最晚&quot;出现的值为标准. (2)@Expose @Expose可以忽略某个字段,有两个参数: serialize deserialize 默认情况下都是true,分别表示序列化与反序列化. System.out.println(gson.toJson(new User())); class User { @Expose(serialize = false) private String name = &quot;123&quot;; @Expose(deserialize = false) private int age = 0; @Expose(serialize = false,deserialize = false) private String email = &quot;xxx@xxx.com&quot;; @Expose(serialize = true,deserialize = true) private double [] nums = new double [] {1.0,2.0}; } name不允许序列化,age不允许反序列化,email不允许序列化与反序列化,nums既允许也允许反序列化.(此时效果等于没加@Expose) 输出: 咦?好像没用的样子? 因为Gson对象会默认忽略@Expose,想要@Expose生效需要使用Gson Builder: GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithoutExposeAnnotation(); Gson gson = gsonBuilder.create(); System.out.println(gson.toJson(new User())); String str = &quot;{'name':'234','age':-3,'email':'23423','nums':[3,4,3]}&quot;; System.out.println(gson.fromJson(str, User.class)); class User { @Expose(serialize = false) private String name = &quot;123&quot;; @Expose(deserialize = false) private int age = 0; @Expose(serialize = false,deserialize = false) private String email = &quot;xxx@xxx.com&quot;; @Expose(serialize = true,deserialize = true) private double [] nums = new double [] {1.0,2.0}; @Override public String toString() { return &quot;name:&quot;+name+&quot;,age:&quot;+age+&quot;,eamil:&quot;+email+&quot;,nums:&quot;+Arrays.toString(nums); } } 不能反序列化age与email,输出的是age与email的默认值. 6.Gson Builder 前面的例子基本上都是通过 Gson gson = new Gson(); 来直接实例化一个Gson来使用Gson的,使用Gson Builder可以设置Gson的某些属性,使用其中的create()返回一个Gson. (1)基础 创建一个简单的Gson,通过create()创建: GsonBuilder gsonBuilder = new GsonBuilder(); Gson gson = gsonBuilder.create(); (2)命名规则 a.使用系统命名规则 使用 gsonBuilder.setFieldNamingPolicy(); 设置json中键的命名规则.6个值可选: IDENTITY:相同,json中的键名与字段名相同. LOWER_CASE_WITH_DASHES:在原来字段的大写字母前加-,并且把大写变成小写 LOWER_CASE_WITH_DOTS:在原来字段的大写字母前加.,并且把大写变成小写 LOWER_CASE_WITH_UNDERSCORES:在原来字段的大写字母前加_,并且把大写变成小写 UPPER_CAMEL_CASE:首字母大写 UPPER_CAMEL_CASE_WITH_SPACES:在原来字段的大写字母前加空格 public class NamingRulesTest { public static void main(String[] args) { NamingRulesTest n = new NamingRulesTest(); GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE); System.out.println(gsonBuilder.create().toJson(n.new User())); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES); System.out.println(gsonBuilder.create().toJson(n.new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String Name_Name_name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private int _age_age_Age_age = 645; @SuppressWarnings(&quot;unused&quot;) private double numsNumsNums = 34.45; } } 注意,若某个字段有了@SerializedName,则这个字段遵循@SerializedName的策略. b.自定义命名规则 重写FieldNamingStrategy中的translateName(Field field),把自定义的FieldNamingStrategy传递给GsonBuilder的setFieldNamingStrategy(). 比如想要前缀加上某人的名字: public class CustomNamingRulesTest { public static void main(String[] args) { FieldNamingStrategy myNamingStrategy = new FieldNamingStrategy(){ @Override public String translateName(Field field) { return &quot;kr&quot;+field.getName(); } }; GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setFieldNamingStrategy(myNamingStrategy); Gson gson = gsonBuilder.create(); System.out.println(gson.toJson(new CustomNamingRulesTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private int num = 5; } } (3)null 默认情况下,Gson实例不允许序列化null,如果想要序列化null,借助GsonBuilder的serializeNulls()方法: public class NullTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES); System.out.println(gsonBuilder.create().toJson(new NullTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String thisIsANullField; @SuppressWarnings(&quot;unused&quot;) private Integer andThisIsANullFieldToo; } } (4)排除 前面已经接触到了@Expose这样的排除策略,下面看看更加强大的配合GsonBuilder使用的排除策略.主要有四种:属性名排除,类型排除,修饰符排除,@Expose排除. a.属性名排除 public class ExclusionNameTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); ExclusionStrategy exclusionName = new ExclusionStrategy(){ @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().endsWith(&quot;e&quot;); } @Override public boolean shouldSkipClass(Class&lt;?&gt; arg0) { return false; } }; gsonBuilder.setExclusionStrategies(exclusionName); System.out.println(gsonBuilder.create().toJson(new ExclusionNameTest().new User())); } class User { private String name; private int num; } } 排除字段名以e结尾的字段.下面是重点: public boolean shouldSkipField(FieldAttributes f) { return f.getName().endsWith(&quot;e&quot;); } 重写的shouldSkipField从名字可以看出跳过某些字段,返回true表示跳过,即排除这个字段.上面的例子中若名字以e结尾则跳过,因此输出: b.类型排除 public class ExclusionTypeTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); ExclusionStrategy exclusionType = new ExclusionStrategy(){ @Override public boolean shouldSkipField(FieldAttributes arg0) { return false; } @Override public boolean shouldSkipClass(Class&lt;?&gt; cls) { return cls == String.class; } }; gsonBuilder.setExclusionStrategies(exclusionType); System.out.println(gsonBuilder.create().toJson(new ExclusionNameTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name; @SuppressWarnings(&quot;unused&quot;) private int num; } } 重写的shouldSkipClass表示要跳过的类,这里跳过了String,只剩下num. @Override public boolean shouldSkipClass(Class&lt;?&gt; cls) { return cls == String.class; } c.修饰符排除 这个不用重写方法了,直接使用GsonBuilder的excludeFieldsWithModifiers(),参数是java.lang.reflect.Modifier: 这个可选的比较多就不一一列举了,只选了一个final的例子: public class ExclusionModifierTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithModifiers(Modifier.FINAL); System.out.println(gsonBuilder.create().toJson(new User())); } } class User { @SuppressWarnings(&quot;unused&quot;) private final String name = &quot;123&quot;; @SuppressWarnings(&quot;unused&quot;) private static int num; } d.@Expose排除 这个准确来说是排除没有被@Expose注解的字段: public class ExclusionExposeTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.excludeFieldsWithoutExposeAnnotation(); System.out.println(gsonBuilder.create().toJson(new ExclusionExposeTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private String name; @SuppressWarnings(&quot;unused&quot;) private int num; @Expose(serialize = true,deserialize = true) private int age; } } (5)Lenient 这是有关于反序列化时JSON的容错机制的问题,因为通常来说将一个对象通过Gson转换成json没什么大问题,但是将json转换为对象的时候就...就难说了,因为不知道是否符合标准的json格式,因此Gson提供了一定的容错机制,就是Lenient. Lenient翻译过来是&quot;宽容的&quot;的意思,可以通过: GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setLenient(); 开启. Gson内部有一个JsonReader类,默认情况下,JsonReader是严格的且仅接受符合RFC 4627标准的json(RFC 4627标准可以看看这里),设置为lenient后可以&quot;容忍&quot;以下几种错误: a.以 ) ] } ' \\n 开头 b.多个顶层值. c.任何类型的顶层值 d.数字可能是NaNs或infinites e.以行注释//或#结尾 f.以一个换行符结束 g.C风格的注释/**/,可能会嵌套 h.键/字符串没有引号或者单引号 i.数组元素以;分隔 j.不必要的数组分隔符,&quot;默认&quot;null为省略值,比如[1,,2],&quot;默认&quot;第二个元素为null k.键值以=或=&gt;分隔而非使用: l.键值对以;分隔而非使用, 设置setLenient()后,Gson会尽可能解析有错误的json,若实在无能为力,会抛出MalformedJsonException异常. 下面是一个不严格的json的例子: public class LenientTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setLenient(); String str = &quot;{'name'='234';'num'=6}&quot;; System.out.println(gsonBuilder.create().fromJson(str,User.class)); } class User { private String name; private int num; @Override public String toString() { return &quot;name:&quot;+name+&quot;,num:&quot;+num; } } } 下面是一个异常的例子: String errorStr = &quot;{'name'=????,,,,,,}&quot;; System.out.println(gsonBuilder.create().fromJson(errorStr,User.class)); (6)Floats &amp; Doubles 先看一个例子: public class FloatTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new FloatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private float f = Float.POSITIVE_INFINITY; } } 会报错: 它说Infinity在JSON标准是一个非法值.想要重写这个行为需要使用GsonBuilder.serializeSpecialFloatingPointValues(). 因为JSON规范不允许NaN,-Infinity,Infinity,因此会报错.下面使用GsonBuilder: public class FloatTest { public static void main(String[] args) { // Gson gson = new Gson(); // System.out.println(gson.toJson(new FloatTest().new User())); GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeSpecialFloatingPointValues(); System.out.println(gsonBuilder.create().toJson(new FloatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private float f = Float.POSITIVE_INFINITY; } } 直接输出Infinity: double也类似: public class DoubleTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeSpecialFloatingPointValues(); System.out.println(gsonBuilder.create().toJson(new DoubleTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private double ni = Double.NEGATIVE_INFINITY; @SuppressWarnings(&quot;unused&quot;) private double pi = Double.POSITIVE_INFINITY; @SuppressWarnings(&quot;unused&quot;) private double nan = Double.NaN; } } (7)模型版本化 通过@Since与@Until添加版本控制,控制某个版本在序列化与反序列化时忽略或忽略某个字段. @Since表示从某个版本开始这个字段不忽略,@Until表示这个版本后将忽略该字段. 需要配合GsonBuilder的setVersion使用,设定版本号. public class VersionTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); System.out.println(gsonBuilder.setVersion(0.9).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.0).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.4).create().toJson(new VersionTest().new User())); System.out.println(gsonBuilder.setVersion(1.5).create().toJson(new VersionTest().new User())); } class User { @Since(1.0) private String name; @Until(1.4) private int num; } } @Since的范围包含了左区间端点,@Until的范围不包含右区间端点. (8)格式化日期 可以使用setDateForamt()来格式化日期输出: gsonBuilder.setDateFormat(int style); gsonBuilder.setDateFormat(String pattern); gsonBuilder.setDateFormat(int dateStyle,int timeStyle); 第一个函数的参数为DateFormat中的常量值,第二个函数的参数是类似SimpleDateFormat中的String,第三个函数的参数与第一个类似,分开日期与时间设置. 再说以下setPrettyPrinting()这个函数,看名字就知道,美化打印的.会加上空格. public class FormatTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setPrettyPrinting(); System.out.println(gsonBuilder.setDateFormat(DateFormat.SHORT, DateFormat.SHORT).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.SHORT,DateFormat.LONG).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.MEDIUM, DateFormat.MEDIUM).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.LONG, DateFormat.MEDIUM).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(DateFormat.FULL, DateFormat.FULL).create().toJson(new FormatTest().new User())); System.out.println(gsonBuilder.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create().toJson(new FormatTest().new User())); } class User { @SuppressWarnings(&quot;unused&quot;) private Date date = new Date(); } } 7.Gson进阶 (1)枚举 枚举其实也与普通的字段类似,序列化与反序列化正常操作. public class EnumTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new EnumTest().new User())); String str = &quot;{\\&quot;season\\&quot;:\\&quot;SUMMER\\&quot;,\\&quot;name\\&quot;:\\&quot;8888\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } enum Season { SPRING, SUMMER, AUTUMN, WINTER } class User { private Season season = Season.SPRING; private String name = &quot;123&quot;; @Override public String toString() { return &quot;season:&quot;+season.toString()+&quot;,name:&quot;+name; } } } 主要配合@SerializedName()使用,例如对于月份,可以使用1,2,3来表示: public class EnumTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new EnumTest().new User())); String str = &quot;{\\&quot;season\\&quot;:\\&quot;SUMMER\\&quot;,\\&quot;name\\&quot;:\\&quot;8888\\&quot;,\\&quot;month\\&quot;:\\&quot;2\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } enum Season { SPRING, SUMMER, AUTUMN, WINTER } class User { private Season season = Season.SPRING; private String name = &quot;123&quot;; private Month month = Month.January; @Override public String toString() { return &quot;season:&quot;+season.toString()+&quot;,name:&quot;+name+&quot;,month:&quot;+month.toString(); } } enum Month { @SerializedName(&quot;1&quot;) January, @SerializedName(&quot;2&quot;) February, @SerializedName(&quot;3&quot;) March, @SerializedName(&quot;4&quot;) April, @SerializedName(&quot;5&quot;) May, @SerializedName(&quot;6&quot;) June, @SerializedName(&quot;7&quot;) July, @SerializedName(&quot;8&quot;) August, @SerializedName(&quot;9&quot;) September, @SerializedName(&quot;10&quot;) October, @SerializedName(&quot;11&quot;) November, @SerializedName(&quot;12&quot;) December } } (2)泛型 这里主要说一下反序列化泛型.因为序列化泛型...直接toJson()就好了. 想想这样的情景:有一个待解析的Json String,类型为List,因此想有一个这样的方法: public &lt;T&gt; List&lt;T&gt; fromJSON(String json,Class&lt;T&gt; cls); 好了,怎么写呢,之前用的是TypeToken()实现反序列化: List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); integerList.add(3); integerList.add(-999); gson.toJson(integerList, new TypeToken&lt;List&lt;Integer&gt;&gt;() {}.getType()); 答案就是使用ParameterizedType:重写里面的getActualTypeArguments(),getOwnerTpye()与getRawType(): public class GenericsTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setPrettyPrinting(); Gson gson = gsonBuilder.create(); List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); integerList.add(3); integerList.add(-999); gson.toJson(integerList, new TypeToken&lt;List&lt;Integer&gt;&gt;() {}.getType()); List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(&quot;12321&quot;); stringList.add(&quot;(@)#$@#&quot;); String t1 = gson.toJson(integerList); String t2 = gson.toJson(stringList); new GenericsTest().fromJSON(t1, Integer.class).stream().forEach(System.out::println); new GenericsTest().fromJSON(t2, String.class).stream().forEach(System.out::println); } public &lt;T&gt; List&lt;T&gt; fromJSON(String json,Class&lt;T&gt; cls) { return new Gson().fromJson(json,new ParameterizedTypeImpl(cls)); } class ParameterizedTypeImpl implements ParameterizedType { private Class cls; public ParameterizedTypeImpl(Class cls) { this.cls = cls; } @Override public Type[] getActualTypeArguments() { return new Type[]{cls}; } @Override public Type getRawType() { return List.class; } @Override public Type getOwnerType() { return null; } } } @Override public Type[] getActualTypeArguments() { return new Type[]{cls}; } 返回实际参数类型数组,在这里是String.class与Integer.class. @Override public Type getRawType() { return List.class; } 返回声明这个类型的类或接口,在这里是List.class. @Override public Type getOwnerType() { return null; } 返回其成员之一的类型,就是说如果完全限定类名为A.B,则返回A,在这里没有A,因此为null. 定义好实现ParameterizedTpye接口的类后,把它传递给fromJson()作为第二参数,构造方法的参数为List&lt;T&gt;中的T.class. (4)自定义序列化 自定义序列化一般用于自定义简化json. 比如有一个User类: class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; } 想要不序列化name,可以使用@Expose(serialize = false),但是想要部分序列化nums,比如只是需要第一个nums[0],上面的@Expose,@SerializedName等注解都用不上,这时需要使用JsonSerializer自定义序列化,重写其中的: public JsonElement serialize(T t,Type type,JsonSerializationContext context) 可以返回一个JsonObject,这里的JsonObject可以自定义添加属性(即键值对). 需要配合GsonBuilder使用,创建了自己的JsonSerializer&lt;T&gt;后,把它传递给GsonBuilder的registerTypeAdapter(): public class SerializeCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); JsonSerializer&lt;User&gt; serializer = new JsonSerializer&lt;SerializeCustomTest.User&gt;() { @Override public JsonElement serialize(User u,Type type,JsonSerializationContext context) { JsonObject object = new JsonObject(); object.addProperty(&quot;name&quot;,u.getName()); object.addProperty(&quot;email&quot;,u.getEmail()); object.addProperty(&quot;nums&quot;,u.getNums()[0]); return object; } }; gsonBuilder.registerTypeAdapter(User.class,serializer); System.out.println(gsonBuilder.create().toJson(new SerializeCustomTest().new User())); } class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; public int [] getNums() { return nums; } public String getName() { return name; } public String getEmail() { return email; } } } (5)自定义反序列化 自定义反序列化主要就是针对有多余键值对的json,比如User只需要name字段,但是传来的json包含了诸如age这样的键,因此只需挑选所需的进行反序列化.与序列化类似,首先定义自己的JsonDeserializer&lt;T&gt;,重写其中的: public T deserialize(JsonElement,Type,JsonDeserializationContext); 返回一个自定义的反序列化的对象.最后在GsonBuilder中registerTypeAdapter()即可. public class DeserializedCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); JsonDeserializer&lt;User&gt; deserializer = new JsonDeserializer&lt;DeserializedCustomTest.User&gt;() { @Override public User deserialize(JsonElement json,Type type,JsonDeserializationContext context) { JsonObject object = json.getAsJsonObject(); User user = new DeserializedCustomTest().new User(object.get(&quot;name&quot;).getAsString()); return user; } }; gsonBuilder.registerTypeAdapter(User.class, deserializer); String str = &quot;{\\&quot;aaa\\&quot;:\\&quot;bbbb\\&quot;,\\&quot;name\\&quot;:\\&quot;this is a name\\&quot;,\\&quot;age\\&quot;:\\&quot;444\\&quot;}&quot;; System.out.println(gsonBuilder.create().fromJson(str,User.class)); } class User { private String name; private int age; public User(String name) { this.name = name; } @Override public String toString() { return &quot;name:&quot;+name+&quot;,age:&quot;+age; } } } (6)默认实例 可以设置反序列化时的默认值,通过构造方法实现.比如json中没有所需要的字段的值,默认情况下为null,如果想要不为null,可以设定默认值,对于对象可以设定构造方法. 通过实现InstanceCreator&lt;T&gt;来实现,重写其中的createInstance方法,再配合GsonBuilder的registerTypeAdapter(). public class InstanceCustomTest { public static void main(String[] args) { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter( AA.class, new InstanceCustomTest().new AAInstance( new InstanceCustomTest().new BB(&quot;123&quot;,&quot;456&quot;) ) ); String str = &quot;{\\&quot;name\\&quot;:\\&quot;123123\\&quot;}&quot;; System.out.println(gsonBuilder.create().fromJson(str, AA.class)); } class AAInstance implements InstanceCreator&lt;AA&gt; { private BB bb; public AAInstance(BB bb) { this.bb = bb; } @Override public AA createInstance(Type type) { return new AA(bb); } } class AA { private String name = &quot;AA&quot;; private BB bb; public AA(BB bb) { this.bb = bb; } @Override public String toString() { return &quot;name:&quot;+name+&quot;,bb:&quot;+bb.toString(); } } class BB { private String field1; private String field2; public BB(String field1,String field2) { this.field1 = field1; this.field2 = field2; } @Override public String toString() { return &quot;field1:&quot;+field1+&quot;,field2:&quot;+field2; } } } json没有为BB类设定值,采用默认值. (7)@JsonAdapter 这个是自定义序列化/反序列化的注解,可以简化JsonSerializer与JsonDeserializer.另外不用配合GsonBuilder使用,直接使用new Gson().toJson()/fromJson()即可,比直接使用JsonSerializer与JsonDeserializer要简单. 首先使一个类实现JsonSerializer&lt;T&gt;接口,接着把这个类作为要注解的字段的@JsonAdapter的参数: class Serializer implements JsonSerializer&lt;User&gt; class ContainUser { private String userId = &quot;x&quot;; @JsonAdapter(Serializer.class) private User user = new User(); } public class JsonAdapterSerializeTest { public static void main(String[] args) { Gson gson = new Gson(); System.out.println(gson.toJson(new JsonAdapterSerializeTest().new ContainUser())); } class Serializer implements JsonSerializer&lt;User&gt; { @Override public JsonElement serialize(User u,Type type,JsonSerializationContext context) { JsonObject object = new JsonObject(); object.addProperty(&quot;name&quot;,u.getName()); object.addProperty(&quot;email&quot;,u.getEmail()); object.addProperty(&quot;nums&quot;,u.getNums()[0]); return object; } } class ContainUser { private String userId = &quot;x&quot;; @JsonAdapter(Serializer.class) private User user = new User(); } class User { private String name = &quot;123&quot;; private String email = &quot;xxx@xxx.com&quot;; private int [] nums = new int [] {1,2,3}; public int [] getNums() { return nums; } public String getName() { return name; } public String getEmail() { return email; } } } 反序列化也类似. public class JsonAdapterDeserializeTest { public static void main(String[] args) { Gson gson = new Gson(); String str = &quot;{\\&quot;aaaa\\&quot;:\\&quot;bbbb\\&quot;,\\&quot;name\\&quot;:\\&quot;this is a name\\&quot;,\\&quot;age\\&quot;:\\&quot;444\\&quot;}&quot;; System.out.println(gson.fromJson(str,User.class)); } class Deserialize implements JsonDeserializer&lt;User&gt; { @Override public User deserialize(JsonElement json,Type type,JsonDeserializationContext context) { JsonObject object = json.getAsJsonObject(); User user = new JsonAdapterDeserializeTest().new User(object.get(&quot;name&quot;).getAsString()); return user; } } @JsonAdapter(Deserialize.class) class User { private String name = &quot;123&quot;; public User() { } public User(String name) { this.name = name; } @Override public String toString() { return &quot;name:&quot;+name; } } } 实现JsonDeserializer&lt;T&gt;,重写deserialize(),在所需的类上添加注解. 注意@JsonAdapter注解只能添加在类上. 8.源码 所有例子的完整源码. github. 码云. Gson官方github. 9.参考链接 1.Gson Tutorial Series by Future Studio 2.gson完全教程 3.gson教程 4.gson用户指南 5.Gson User guide 6.gson ","link":"https://2293736867.github.io/post/gsonso-easy/"},{"title":"java实现UDP通信","content":" 1.概述 2.发送端 (1)创建DatagramSocket与DatagramPacket (2)创建DatagramPacket (3)发送 3.接收端 (1)创建DatagramSocket (2)创建DatagramPacket (3)接收 (4)获取数据 4.完整代码 (1)Server.java (2)Client.java 5.测试 1.概述 用DatagramSocket与DatagramPacket实现UDP通信.UDP比TCP相对来说简单一点,不需要等待连接,且处理数据不需要用输出输出流,只需要DatagramPacket.严格来说,UDP没有服务端和客户端之分,只有发送端与接收端之分. 2.发送端 发送端首先建立DatagramSocket与DatagramPacket,设置好DatagramPacket的端口与ip,再通过DatagramSocket发送. (1)创建DatagramSocket与DatagramPacket DatagramSocket socket = new DatagramSocket(55555); 这里的55555端口是指数据通过这个端口发送. (2)创建DatagramPacket InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 12345; String message = &quot;message&quot;; DatagramPacket packet = new DatagramPacket(message.getBytes(),message.getBytes().length,ip,port); 构造方法DatagramPacket()的四个参数分别为 发送的字节数组 字节数组长度 ip 端口 这里端口不能与上面的一致,不然的话会提示端口被占用. (3)发送 socket.send(packet); 3.接收端 接收端只需指定端口进行接收,这里的端口在DatagramSocket中的构造方法中指定,与发送端的发送的packet中设置的端口一致. (1)创建DatagramSocket DatagramSocket socket = new DatagramSocket(12345); (2)创建DatagramPacket 这里创建的DatagramPacket只需要指定存储数据的字节数组与该字节数组的长度. byte [] message = new byte[2048]; DatagramPacket packet = new DatagramPacket(message, message.length); (3)接收 socket.receive(packet); 这个方法会阻塞,直到接收到packet. (4)获取数据 接收到packet后可以使用getData()获取数据,返回字节数组,可以传递给String的构造方法创建String. String str = new String(packet.getData()); 4.完整代码 这里人为地设定了客户端与服务端,可以互相发送数据,服务端输入后发送到服务端,服务端返回固定数据, &quot;客户端&quot;与&quot;服务端&quot;轮流扮演了发送端与接收端的角色.配合了swing使用. (1)Server.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import javax.swing.*; public class Server { public static void main(String[] args) { JFrame frame = new JFrame(&quot;Server&quot;); JTextArea text = new JTextArea(); frame.add(text); frame.setSize(600, 300); frame.setLocationRelativeTo(null); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try { byte [] message = new byte[2048]; DatagramSocket socket = new DatagramSocket(12345); DatagramPacket packet = new DatagramPacket(message, message.length); socket.receive(packet); InetAddress ip = packet.getAddress(); int port = packet.getPort(); text.setText(&quot;ip : &quot;+ip.toString()+&quot;\\n&quot;); text.append(&quot;port : &quot;+port+&quot;\\n&quot;); text.append(&quot;message : &quot;+new String(packet.getData())); String messageFromServer = &quot;Message from server&quot;; packet = new DatagramPacket(messageFromServer.getBytes(),messageFromServer.getBytes().length,ip,port); socket.send(packet); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } (2)Client.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.Socket; import javax.swing.*; import java.awt.GridLayout; public class Client { public static void main(String[] args) { JFrame frame = new JFrame(); JTextArea text = new JTextArea(); JButton send = new JButton(&quot;send&quot;); GridLayout layout = new GridLayout(2,1,1,1); frame.setLayout(layout); frame.setTitle(&quot;Client&quot;); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.setSize(600, 300); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(text); frame.add(send); send.addActionListener( v-&gt; { try { InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 12345; DatagramSocket socket = new DatagramSocket(55555); String message = text.getText(); DatagramPacket packet = new DatagramPacket(message.getBytes(),message.getBytes().length,ip,port); socket.send(packet); byte [] messageFromServer = new byte[2048]; packet = new DatagramPacket(messageFromServer, messageFromServer.length); socket.receive(packet); text.setText(new String(packet.getData())); socket.close(); } catch (IOException e) { e.printStackTrace(); } }); } } 5.测试 ","link":"https://2293736867.github.io/post/java-shi-xian-udp-tong-xin/"},{"title":"java实现TCP通信","content":" 1.概述 2.服务端 (1)新建ServerSocket (2)接收socket (3)数据处理 (4)完整代码Server.java 3.客户端 (1)新建一个Socket (2)输入输出 (3)完整代码Client.java 4.测试 1.概述 通过ServerSocket与Socket实现的TCP的通信,这个例子配合了swing使用,其实作者之前发过一篇ServerSocker与Socket的通信,在这里,这边文章就是在这个例子上修改而成的. 其实原理很简单的,就是一个服务端一个客户端,服务端这边创建好ServerSocket后,使用accept()堵塞一直等待客户端发送socket. 好吧,不废话了.进正题. 2.服务端 swing的部分就不说了,说一下主要操作. (1)新建ServerSocket ServerSocket serverSocket = null; serverSocket = new ServerSocket(12345);//一个不被占用的端口即可 构造方法的参数是端口,默认使用本地ip. ServerSocket有三个构造方法. ServerSocket(int port); ServerSocket(int port,int backlog); ServerSocker(int poer,int backlog,InetAddress ip); 详情可以看这里 (2)接收socket Socket socket = serverSocket.accept(); 返回一个Socket(),会一直等待,处于阻塞状态. 一般设置一个while(true)循环接收. (3)数据处理 使用DataInputStream与DataOutputStream: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); DataOutputStram outputStream = new DataOutputStream(socket.getOutputStream()); 然后使用read与write方法即可. 注意关闭的时候要等输入输出完成后再一起关闭,就是说,不能这样: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); String data = inputStream.readUTF(); inputStream.close(); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); outputStream.close(); 这样的话getInputStream()没有问题,但是到了getOutputStream()的时候就有问题了,会提示异常: Socket is closed. 所以解决办法就是等输出完之后再一起关闭: DataInputStream inputStream = new DataInputStream(socket.getInputStream()); String data = inputStream.readUTF(); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); inputStream.close();//等输出完成后再关闭 outputStream.close(); (4)完整代码Server.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import javax.swing.*; public class Server { public static void main(String[] args) { JFrame frame = new JFrame(&quot;Server&quot;); JPanel panel = new JPanel(); JTextArea text = new JTextArea(); panel.add(text); frame.setContentPane(panel); frame.setSize(600, 300); frame.setLocationRelativeTo(null); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(12345); while (true) { Socket socket = serverSocket.accept(); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); text.setText(inputStream.readUTF()); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(&quot;ok&quot;); inputStream.close(); outputStream.close(); socket.close(); } } catch (IOException e) { e.printStackTrace(); } finally { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } 3.客户端 客户端的操作就是开启一个Socket,再通过这个socket获取对应的输入输出流就可以了. (1)新建一个Socket Socket socket = new Socket(&quot;127.0.0.1&quot;,12345);//这个端口与服务端的端口对应 Socket有三个构造方法: Socket(InetAddress ip,int port); Socket(String ip,int port); Socket(InetAddress ip,int port,InetAddress localIp,int localPort); Socket(String ip,int port,InetAddress localIp,int localPort); 详情可以看这里 (2)输入输出 同样使用DataInputStream与DataOutputStream: DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); (3)完整代码Client.java import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.Socket; import javax.swing.*; import java.awt.GridLayout; public class Client { public static void main(String[] args) { JFrame frame = new JFrame(); JTextArea text = new JTextArea(); JButton send = new JButton(); GridLayout layout = new GridLayout(2, 1, 0, 5); frame.setTitle(&quot;Client&quot;); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.setSize(600, 300); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLayout(layout); frame.add(text); frame.add(send); send.setText(&quot;send&quot;); send.addActionListener(v -&gt; { try { String host = &quot;127.0.0.1&quot;; int port = 12345; Socket socket = new Socket(host, port); DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream()); outputStream.writeUTF(text.getText()); DataInputStream inputStream = new DataInputStream(socket.getInputStream()); text.setText(inputStream.readUTF()); outputStream.close(); inputStream.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } }); } } 4.测试 先开启服务端,再开启客户端,这里设置了服务端返回给客户端的信息为&quot;ok&quot;. ","link":"https://2293736867.github.io/post/java-shi-xian-tcp-tong-xin/"},{"title":"java swing hello world","content":"1.概述 一个简单的java swing程序hello world,只有一个button 2.源码 import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JButton button = new JButton(&quot;Test button&quot;); jFrame.add(button);//把button添加到JFrame中 jFrame.setSize(300,300);//设置JFrame大小 jFrame.setVisible(true);//设置可见,不然的话看不到 } } 3.第一次修改 有没有觉得有点奇怪,整个button占满了窗口? 没错,少了一个JPanel: import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JPanel jPanel = new JPanel(); JButton button = new JButton(&quot;Test button&quot;); jPanel.add(button); jFrame.setContentPane(jPanel); jFrame.setSize(300,300); jFrame.setVisible(true); } } 添加一个JPanel,把Button添加到JPanel中,然后设置JFrame的contenPane. 效果如下: 4.第二次修改 嗯,有点hello world的样子了,但是你有没有点击过左上角的x按钮? 点了之后,这个东西是&quot;消失&quot;了,但是在后台还在运行着,所以... jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 需要这样设置它的默认关闭操作. 另一个修改就是对它居中显示,要不然的话总是启动的时候在左上角. 很简单,一行就可以了. jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 完整代码: import javax.swing.*; public class server { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;title&quot;); JPanel jPanel = new JPanel(); JButton button = new JButton(&quot;Test button&quot;); jPanel.add(button); jFrame.setContentPane(jPanel); jFrame.setSize(300,300); jFrame.setLocationRelativeTo(null); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } ","link":"https://2293736867.github.io/post/java-swing-hello-world/"},{"title":"ssh连接服务器","content":" 1.概述 2.密码认证 3.密钥认证 (1)产生公钥与私钥 (2)复制公钥到服务器 (3)修改本地私钥权限 (4)连接 (5)如果还是需要密码 1.概述 ssh是一种网络通信协议,用于计算机之间的加密登录.一般用ssh连接服务器有两种方式:密码认证与密钥认证. 密码认证就是通过传统的输入密码的方式登录,密钥认证就是把产生的公钥注册到服务器后,用私钥登录,这样就可以不用每次登录输入密码.特别适合作者这种脑残记不住密码的懒人. 2.密码认证 密码认证登录直接在终端使用ssh命令即可: ssh username@xxx.xxx.xxx.xxx username为用户名,后面为ip. 3.密钥认证 (1)产生公钥与私钥 这一步使用ssh-keygen命令生成id_rsa与id_rsa.pub文件: ssh-keygen -t rsa -b 4096 -C &quot;eamil&quot; 其中email为你的邮箱. 然后一直enter就好了(当然你也可以修改参数,比如生成的公钥与私钥的文件名等,后面要对应). (2)复制公钥到服务器 cd ~/.ssh ssh-copy-id -i id_rsa.pub username@xxx.xxx.xxx.xxx 注意复制的是公钥(.pub结尾,不是私钥id_rsa). (3)修改本地私钥权限 若出现以上情况,根据提示说是私钥的权限问题,修改为: chmod 600 id_rsa 在windows上使用wsl的要注意,wsl不能直接修改文件权限,需要修改一下/etc/wsl.conf文件(没有的话就新建). vim /etc/wsl.conf 输入 [automount] enabled = true options = &quot;metadata,umask=22,fmask=11&quot; mountFsTab = false 退出wsl重启. (4)连接 ssh -i ~/.ssh/id_rsa username@xxx.xxx.xxx.xxx 如果上面配置没出现的话就可以连接上了. (5)如果还是需要密码 先用密码认证的方式登录服务器,修改/etc/ssh/sshd_config(注意有一个d,/etc/ssh下有一个叫ssh_config的文件,不要ssh然后按tab....) vim /etc/ssh/sshd_config 找到PasswordAuthentication这一行. 修改为no. 然后重启服务: service ssh restart 或者 /etc/init.d/ssh restart 重启服务后连接: ssh -i ~/.ssh/id_rsa username@xxx.xxx.xxx.xxx ","link":"https://2293736867.github.io/post/ssh-lian-jie-fu-wu-qi/"},{"title":"后端spring boot+前端Android交互+mysql增删查改","content":" 1.概述 2.开发环境 3.后端 (1)新建一个spring boot项目 (2)Entity (3)Repository (4)Service (5)Controller 4.前端 (1)增 (2)删 (3)查 (4)改 (5)界面 (6)依赖与其他 (7)网络权限 5.测试 6.源码 1.概述 使用spring boot作为后端框架与Android端配合mysql进行基本的交互,包含了最基本的增删查改功能. 2.开发环境 win10 IDEA tomcat9.0.27 mysql8.0.17 spring boot 3.后端 (1)新建一个spring boot项目 可以看这里 (2)Entity 新建User类作为实体类: package com.test; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 这里其实使用的是(1)中的代码,里面有详细的解释. (3)Repository 新建UserRepository去实现增删查改: package com.test; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.query.Param; import org.springframework.stereotype.Repository; import org.springframework.web.bind.annotation.RequestParam; import java.util.List; @Repository public interface UserRepository extends CrudRepository&lt;User,Integer&gt; { @Query(value = &quot;select * from user where name = ?1&quot;,nativeQuery = true) public List&lt;User&gt; findByName(String name); @Modifying @Query(value = &quot;delete from user where name = ?1&quot;,nativeQuery = true) public int deleteByName(String name); } 由于CrudRepository中已经包含了&quot;增&quot;与&quot;改&quot;,所以按需要实现自己的&quot;查&quot;与&quot;删&quot;即可. CrudRepository的api很简单,官方文档在这里. &quot;增&quot;使用save即可,参数为实体类 &quot;删&quot;使用deleteById,通过主键删除,若不想通过主键删除可以自己编写sql,像上面一样 &quot;查&quot;使用findAll或findById,自定义查找的话需要自己编写sql. &quot;改&quot;也可使用save,注意需要设置主键. @Query用于设置sql,nativeQuery表示使用原生sql. (4)Service 新建一个MainService.java package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import javax.transaction.Transactional; import java.util.List; @Transactional @Service public class MainService { @Autowired private UserRepository userRepository; public Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } public List&lt;User&gt; findByName(String name) { return userRepository.findByName(name); } public boolean add(String name) { User user = new User(); user.setName(name); userRepository.save(user); return true; } public boolean modify(Integer id,String name) { User user = new User(); user.setName(name); user.setId(id); userRepository.save(user); return true; } public boolean deleteByName(String name) { return userRepository.deleteByName(name) != 0; } } getAllUsers()返回所有行,Iterable&lt;E&gt;类型 findByName()根据name返回所有name相同的行. add直接使用了save,由于save返回的是实体类,原本的代码是这样写的: return userRepository.save(user) != null; 但是文档说了不会为null,所以只能强制返回true了. modify使用了id与name作为参数,新建一个user,将其作为setter的参数,然后交给save. deleteByName使用了自定义的删除函数,返回的是int,在UserRepository中这个int代表sql影响的行数,删除成功则行数不为0,删除失败,或者没有这行数据则行数为0.因此将返回值与0进行比较. (5)Controller package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.List; @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private MainService mainService; @GetMapping(path = &quot;/getAll&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return mainService.getAllUsers(); } @PostMapping(path = &quot;/get&quot;) public @ResponseBody List&lt;User&gt; findByName(String name) { return mainService.findByName(name); } @PostMapping(path = &quot;/add&quot;) public @ResponseBody boolean add(@RequestParam String name) { return mainService.add(name); } @PostMapping(path = &quot;/modify&quot;) public @ResponseBody boolean modify(@RequestParam Integer id,@RequestParam String name) { return mainService.modify(id,name); } @PostMapping(path = &quot;/delete&quot;) public @ResponseBody boolean deleteByName(@RequestParam String name) { return mainService.deleteByName(name); } } Controller主要就是几个注解,除了getAllUsers使用Get外,其他的都是用Post.另外就是路径设置,直接在path中设置即可. 后端的话到这里就基本完成了,剩下的打包部署操作就..... 4.前端 什么新建工程之类的就不说了. 直接上MainActivity: package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.os.Looper; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import com.alibaba.fastjson.JSONArray; import com.example.myapplication.model.dao.*; import com.example.myapplication.model.entity.*; import java.io.IOException; import java.util.List; import okhttp3.FormBody; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button register = findViewById(R.id.register); register.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button login = findViewById(R.id.login); login.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button delete = findViewById(R.id.delete); delete.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); Button modify = findViewById(R.id.modify); modify.setOnClickListener( v -&gt; { new Thread(()-&gt; { OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } }).start(); } ); } } (1)增 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.ADD) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 使用okhttp,通过FormBody设置参数,然后创建Request通过OkHttpClient发送. 由于后端&quot;增&quot;的方法返回的是一个true,因此这里将response.body().string()转换成boolean判断是否操作成功. 稍微提一下, Looper.prepare(); Looper.loop(); 这两行可以在非UI线程中使用Toast. (2)删 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.DELETE) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 删这部分也是差不多的,就是改一下url,然后....然后没有了....好像很简单的样子? (3)查 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build(); Request request = new Request.Builder() .url(Constant.GET) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); Looper.prepare(); if(users.size() == 0) { Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 查这里注意一下后端返回的是List,这里借助阿里的fastjson转换成List. List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class); 然后判断有没有的话就判断长度是否为0即可. (4)改 OkHttpClient okHttpClient = new OkHttpClient(); String name = ((EditText) findViewById(R.id.name)).getText().toString(); String id = ((EditText)findViewById(R.id.id)).getText().toString(); FormBody formBody = new FormBody.Builder() .add(&quot;name&quot;, name) .add(&quot;id&quot;,id) .build(); Request request = new Request.Builder() .url(Constant.MODIFY) .post(formBody) .build(); try (Response response = okHttpClient.newCall(request).execute()) { Looper.prepare(); if (Boolean.parseBoolean(response.body().string())) { Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show(); } Looper.loop(); } catch (IOException e) { e.printStackTrace(); } 改的话只需一个额外的ID参数,在FormBody中add一个即可,不难. (5)界面 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/delete&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;280dp&quot; android:layout_marginTop=&quot;404dp&quot; android:text=&quot;删除&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/register&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;293dp&quot; android:text=&quot;注册&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/modify&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;404dp&quot; android:text=&quot;修改&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;EditText android:id=&quot;@+id/name&quot; android:layout_width=&quot;336dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;192dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:ems=&quot;10&quot; android:hint=&quot;请输入姓名&quot; android:inputType=&quot;textPersonName&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;EditText android:id=&quot;@+id/id&quot; android:layout_width=&quot;336dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginStart=&quot;32dp&quot; android:layout_marginTop=&quot;112dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:ems=&quot;10&quot; android:hint=&quot;请输入id&quot; android:inputType=&quot;textPersonName&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/login&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;293dp&quot; android:layout_marginEnd=&quot;43dp&quot; android:text=&quot;登录&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 界面不详细说了,不难. (6)依赖与其他 注意一下依赖,还有设置java8. (7)网络权限 这个作者之前的文章有说. 请看这里. 5.测试 这是&quot;原本的&quot;数据库. 没办法为了测试. 注册一个. 看看数据库: 试试登录一个不存在的. 修改: 最后是删除: 删除一个不存在的会删除失败. 6.源码 github 码云 ","link":"https://2293736867.github.io/post/hou-duan-spring-bootqian-duan-android-jiao-hu-mysql-zeng-shan-cha-gai/"},{"title":"Spring boot+Mysql+Spring data JPA一个Web的Demo","content":" 1.概述 2.创建初始spring demo 3.配置数据源 (1)建库 (2)建用户 (3)用户授权 (4)配置application.properties a.none b.update c.create d.create-drop 4.创建实体类 5.创建Repository 6.创建控制器 7.IDE上测试 8.打包发布 9.完整代码 1.概述 因为要用spring boot,最近刚刚学习.这是一个web项目的配合mysq+Hibernate+tomcat的简单示例demo,很容易在此基础上扩展成自己的项目. 2.创建初始spring demo 作者用的IDE是IDEA,新建一个工程,选择Spring Initalizer. 下一步的话由于作者需要部署到服务器上面,选择了war.不需要的话可以选择jar. 选择spring web+spring Data JPA+Mysql Driver. 然后完成即可,首次运行的话配置依赖需要一点时间,请耐心等待. 3.配置数据源 配置数据源分为两部分,一部分是建表与建用户,另一部分是在application.properties中配置的. (1)建库 create database test; 注意这里不用创建表了,因为Hibernate从实体类自动创建一个同名的表. (2)建用户 create user 'db'@'%' identified by 'xxxxx'; (3)用户授权 grant all on test.* to 'db'@'%'; 这里建议授权all,因为后面Hibernate会用到建表权限,不能仅仅授权增删查改. (4)配置application.properties 配置四个属性: spring.jpa.hibernate.ddl-auto= spring.datasource.url= spring.datasource.username= spring.datasource.password= 第一个属性是可以取值 none update create create-drop a.none none是对mysql的默认值,不会改变数据库结构. b.update Hibernate会根据给出的实体类去改变数据库. c.create 创建数据库但是不会在关闭的时候删除. d.create-drop 创建数据库,当SessionFactory关闭时删除数据库.这个是对H2与其他嵌入式数据库的默认选项. 第一次运行时必须设置为update或create,因为还不知道确切的实体类,第一次运行后,可以设置为update或none. url的话对于mysql来说是 jdbc:mysql://ip:3306/database 剩下的两个为用户名与密码. 以下是作者的配置,供参考: 4.创建实体类 这里创建一个简单的User实体类,需要用到javax中的Entity,Id,GeneratedValue与GenerationType注解. Entity用于标识实体类,Id用于标识主键,GeneratedValue与GenerationType用于配置主键. package com.test; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 除了主键之外,可以加上自己想要的属性,还有setter与getter,Hibernate会自动将实体类制作成一个数据表. 5.创建Repository 创建仓库保存用户记录.需要继承CrudRepository&lt;T,ID&gt;,第一个类型为实体类,第二个类型为主键类型. package com.test; import org.springframework.data.repository.CrudRepository; public interface UserRepository extends CrudRepository&lt;User,Integer&gt; { } 6.创建控制器 控制器用于控制Http请求,在控制器中可以配置不同的路径实现不同的操作. package com.test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; @Controller @RequestMapping(path = &quot;/demo&quot;) public class MainController { @Autowired private UserRepository userRepository; @PostMapping(path = &quot;/add&quot;) public @ResponseBody String addNewUser(@RequestParam String name) { User user = new User(); user.setName(name); userRepository.save(user); return &quot;Saved.&quot;; } @GetMapping(path = &quot;/all&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUsers() { return userRepository.findAll(); } } @RequestMapping中的值表示url以此值开头. @PostMapping是仅处理post请求的路径. @ResponseBody表示返回的类型. @RequestParam表示一个从get或post中获取的参数. getAllUsers()会返回一个json或者xml. 7.IDE上测试 首先输入 localhost:8080/demo/all 由于作者先前已经有一行数据所以有显示. 否则的话应该显示为[] 接下来可以添加数据: curl localhost:8080/demo/add -d name=123 回应: 接下来可以选择再次查看: 在看看数据库: 8.打包发布 Build-&gt;Build Artifacts. Build即可. 然后会在项目目录的target下有一个test-0.0.1-xxx的war文件,就是这个了. 改名字放到tomcat的webapps/下,比如作者改成了demo.war: 然后可以去访问了,注意路径,这里的路径是war的路径再加上@RequestMapping中的路径再加上 @PostMapping或 @GetMapping路径: 完成! 9.完整代码 github 码云 ","link":"https://2293736867.github.io/post/spring-bootmysqlspring-data-jpa-yi-ge-web-de-demo/"},{"title":"JDBC+C3P0+DBCP 基本使用","content":" 1.概述 2.mysql的处理 (1)新建用户 (2)建立数据表 (3)用户权限 2.JDBC (1)jar包 (2)连接 (3)Statement (4)PreparedStatement (5)事务 3.C3P0 (1)jar包 (2)配置文件 (3)工具类 4.DBCP (1)jar包 (2)配置文件 (3)工具类 5.源码 1.概述 这篇文章主要说了JDBC的基本使用,包括Statement,PreparedStatement,JDBC的连接,Mysql创建用户创建数据表,C3P0的连接与配置,DBCP的连接与配置. 2.mysql的处理 这里的JDBC使用Mysql作为DBMS,请先安装Mysql,未安装的请点击这里下载,安装教程在这里,作者使用的Mysql的8.0.17版本. (1)新建用户 随便新建一个用户,比如这里作者新建的是aa,密码是aa123bb. create user 'aa'@'localhost' identified by 'aa123bb' (2)建立数据表 建立测试用的数据表与数据库. create database db; use db; create table db ( id int PRIMARY key, name char(20) ); (3)用户权限 对刚才新建的用户授权: grant select,update,delete,insert on db.* to 'aa'@'localhost'; 2.JDBC (1)jar包 8.0.17版本在这里 各个版本的在这里下载 (2)连接 首先注册驱动,驱动需要一个url,用户名和密码,用户名和密码是上一步创建好的,url包含ip地址,端口和数据库的名字. private static final boolean mysqlVersionGreaterThen8 = true; private static final String driver = &quot;com.mysql&quot; + (mysqlVersionGreaterThen8 ? &quot;.cj&quot; : &quot;&quot;) + &quot;.jdbc.Driver&quot;; private static final String ip = &quot;127.0.0.1&quot;; private static final String port = &quot;3306&quot;; private static String databaseName = &quot;db&quot;; private static String url; private static String username = &quot;aa&quot;; private static String password = &quot;k041400r&quot;; private static Connection connection = null; public static Connection getConnection() { try { url = &quot;jdbc:mysql://&quot; + ip + &quot;:&quot; + port + &quot;/&quot; + databaseName; Class.forName(driver); return connection = DriverManager.getConnection(url, username, password); } catch (Exception e) { e.printStackTrace(); } return null; } 这里要注意以下旧版本的mysql的驱动叫com.mysql.jdbc.Driver,新版本的叫com.mysql.cj.jdbc.Driver.还有就是url的格式: jdbc:mysql://ip:port/database (3)Statement 获取数据库连接后,使用createStatement方法创建Statement 对于select,使用Statement的executeQuery(sql),返回ResultSet 对于update,delete,insert,使用Statement的executeUpdate(sql) 其中sql是要执行的sql语句,一个String. public void useStatement() { try { useStatementInsert(); useStatementSelect(); useStatementUpdate(); useStatementSelect(); useStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void useStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; Statement statement = connection.createStatement(); statement.executeUpdate(sql); } public void useStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) { System.out.println(resultSet.getObject(i)); } } } public void useStatementUpdate() throws SQLException { Statement statement = connection.createStatement(); String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; statement.executeUpdate(sql); } 这里对ResultSet使用的getMetaData,可以获取结果集的各种类型信息,包括字段的类型,个数,等等. (4)PreparedStatement PreparedStatement与Statement使用基本一样.调用的时候先使用Connection的prepareStatement(sql)创建,然后 对于select,使用executeQuery(),返回一个ResultSet 对于update,delete,insert使用executeUpdate(). public void usePrepareStatement() { try { usePrepareStatementInsert(); usePrepareStatementSelect(); usePrepareStatementUpdate(); usePrepareStatementSelect(); usePrepareStatementDelete(); } catch (SQLException e) { e.printStackTrace(); } } public void usePrepareStatementInsert() throws SQLException { String sql = &quot;insert into db(id,name) values(1,'23')&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementDelete() throws SQLException { String sql = &quot;delete from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } public void usePrepareStatementSelect() throws SQLException { String sql = &quot;select * from db&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); ResultSet resultSet = preparedStatement.executeQuery(); ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); int count = resultSetMetaData.getColumnCount(); while (resultSet.next()) { for (int i = 1; i &lt;= count; ++i) System.out.println(resultSet.getObject(i)); } } public void usePrepareStatementUpdate() throws SQLException { String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); } (5)事务 Connection有一个setAutoCommit()方法,把它设置成false即可关闭自动提交,所有语句准备好后,一次性使用commit()提交即可. 实现回滚可以配合SavePoint使用. 3.C3P0 (1)jar包 两个: c3p0 mchange-commons (2)配置文件 src下创建一个叫c3p0.properties的文件: c3p0.driverClass=com.mysql.cj.jdbc.Driver c3p0.jdbcUrl=jdbc:mysql://127.0.0.1:3306/db c3p0.user=aa c3p0.password=aa123bb 这里按自己需要更改即可. (3)工具类 import com.mchange.v2.c3p0.ComboPooledDataSource; import java.sql.Connection; public class DbUtil { private static ComboPooledDataSource C3P0dataSource = new ComboPooledDataSource(&quot;c3p0.properties&quot;); public static void releaseConnection(Connection connection) { try { if(connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getC3P0Connection() { try { return C3P0dataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } } 4.DBCP (1)jar包 三个: commons-dbcp commons-logging commons-pool (2)配置文件 src下新建dbcp.properties: driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/db username=aa password=k041400r initialSize=10 maxActive=50 maxIdle=15 minIdle=10 maxWait=60000 connectionProperties=useUnicode=true;characterEncoding=utf8 defaultAutoCommit=true 分别是驱动,url,用户名,密码,初始化连接数,最大连接数,最大空闲连接数,最小空闲连接数,最大等待实际,连接属性(这里设置了编码),自动提交. (3)工具类 import org.apache.commons.dbcp2.BasicDataSourceFactory; import java.io.InputStream; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; public class DbUtil { private static DataSource DBCPdataSource; static { try { InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); DBCPdataSource = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getDBCPConnection() { try { return DBCPdataSource.getConnection(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void releaseConnection(Connection connection) { try { if (connection != null) connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 首先加载属性文件,再使用Properties的load方法将其加载到一个Properties对象中,最后交给BasicDataSourceFactory处理. 5.源码 包含了jar包,配置文件,sql文件与测试代码. github 码云 ","link":"https://2293736867.github.io/post/jdbcc3p0dbcp-ji-ben-shi-yong/"},{"title":"从0开始自制计算器!","content":"先看看效果吧: 很炫酷吧? 想不想要? 想要吧. 当然作者知道你们肯定想. 不然也不会点进来对不对. 好.进入正题. 1.概述 2.新建工程 2.界面 (1) 按键 a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 d.复制制作好的button,布好局 e.改内容 f.整体修改大小,同时加上间隔 (2) 输出框 a.添加QLineEdit b.调整好大小,设置好背景颜色 c.设置字体,只读,对齐 (3) 标题栏 a.新建Horizontal Layout b.添加细节 (4)整体处理 a.标题栏 b.调整整体大小,同时添加透明度 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 b.最小化与关闭 B.按键 a.移入与移出事件 b.单击事件 (2)键盘事件 A.添加阴影 B.添加输出 4.整体细节再处理 (1)淡入效果 (2)设置固定尺寸 (3)淡出效果 5.表达式处理 (1)判断 a.去除所有空格 b.分类判断 c.加0 (2)计算 a.calc辅助类 b.计算部分 c.测试 6.整合 (1)设置界面的调用进程,并获取输出结果 (2)修改一些细节地方 a.鼠标键盘修改事件 b.exe中设置数字的格式 c.设置错误提示 d.可以考虑把错误处理整合过来 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 (3) 打包库文件 (4) 生成单个exe (5) 测试 8.源码 9.参考链接 10.最后 1.概述 这个是仿照win10自带的计算器制作的简化版本.是用Qt做的,直接把整个表达式输入然后得出计算结果. 主要分为三部分.界面部分,事件处理部分与表达式处理部分. 界面部分就是看到的计算器,包括标题栏,中间的输出框,还有各个按键. 事件处理就是处理对应的鼠标与键盘事件. 表达式处理部分就是处理整个输入的字符串,返回计算的结果,当然这个还支持错误判断功能. 2.新建工程 选择Widgets Application. 起名字. 一般只需MinGW. 这里默认即可,名字可以随便改 2.界面 (1) 按键 按键的话,基本上按着改就可以了.改布局,改颜色,改字体,主要就是这三个. 首先先打开.ui文件: a.添加一个Grid Layout,调整好大小. b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding. c.调整好颜色,设置styleSheet与字体 这里给出作者的参考style: border:1px groove rgb(220,220,220); background-color:rgb(243,243,243); 字体: 这里按个人喜好调整即可. d.复制制作好的button,布好局 e.改内容 这里不仅把里面的字符改变,还要把相应的对象名也改变. 再细调每一个按键,包括大小,字体与颜色,使总体效果更好. 数字要注意有&quot;加粗&quot;效果,符号的话尽量&quot;精细&quot;一点. f.整体修改大小,同时加上间隔 调整好间隔.注意细节. 下面是win10自带的计算器: 看到间隔了没? 作者要的就是这种效果. 可以先运行看看. 两边的间隔的话一会配合widget的大小调整即可. (2) 输出框 输出框很简单,就是一个QLineEdit. a.添加QLineEdit b.调整好大小,设置好背景颜色 作者的qss: border:0px groove rgb(243,243,243); background-color:rgb(245,245,245); c.设置字体,只读,对齐 (3) 标题栏 标题栏其实也很简单,一个QBoxLayout a.新建Horizontal Layout b.添加细节 QLabel输入标题,两个QPushButton表示最小化与关闭,同时加入两个Spacer,让标题与左边空出一些距离. 其实就是模仿win10的标题栏的效果 这里就不做最大化了.因为涉及到按钮的重新排布问题,这个可以自己选择实现. (4)整体处理 a.标题栏 把上一步做的标题栏移到合适的位置,同时删除自带的QMenuBar,QToolBar,QStatusBar. b.调整整体大小,同时添加透明度 调整好后大概就那样,透明度这里选择了0.9. 真是完美啊! 3.事件处理 (1)光标事件 A.标题栏 a.拖动效果 首先把本来那个标题栏去掉. setWindowFlags(windowFlags() | Qt::FramelessWindowHint); 再在protected中加入鼠标监听函数: void mousePressEvent(QMouseEvent *); void mouseMoveEvent(QMouseEvent *); 私有成员中加入两个QPoint.分别表示当前窗口坐标与光标的坐标. QPoint mousePoint; QPoint windowPoint; 第一个函数是鼠标按下时触发的,根据event-&gt;button()判断是否是左键,是的话获取mouse坐标,在设置window坐标. 当触发第二个函数时,即先判断是否按住左键不放,使用MainWindow的move方法移动窗口. event-&gt;globalPos()获取坐标后减去原来光标的坐标得到window坐标的变化量,再用原坐标加上这个变化量. void MainWindow::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton) { mousePoint = event-&gt;globalPos(); windowPoint = frameGeometry().topLeft(); } } void MainWindow::mouseMoveEvent(QMouseEvent *event) { if(event-&gt;buttons() &amp; Qt::LeftButton) { move(windowPoint + event-&gt;globalPos() - mousePoint); } } b.最小化与关闭 这里以最小化为例,关闭也一样的,改一下函数调用即可. 在最小化按钮中右键选择Go to slot: 选择clicked() 添加一个最小化函数: 下面是关闭的函数: B.按键 按键的鼠标事件包括两个: 光标移入与移出事件,为按键添加阴影,加深颜色等 单击事件,在输出框中增减对应的字符 a.移入与移出事件 这里的实现方式是通过事件过滤器实现的.增加一个eventFilter()函数 bool eventFilter(QObject *,QEvent *); 首先通过event-&gt;type()判断事件类型,如果是光标悬停,再判断对应的各个对象增加阴影效果. addNumButtonEffet(): void MainWindow::addNumButtonEffect(QPushButton *button,QGraphicsDropShadowEffect *shadow) { shadow-&gt;setEnabled(true); button-&gt;setStyleSheet( &quot;border:1px groove rgb(220,220,220);&quot; &quot;background-color:rgb(193,193,193);&quot; ); } 这里QGraphicsDropShadowEffect *shadow事先初始化好了. 然后在添加事件过滤器: 这里可以对比一下有没有阴影的效果: 没有阴影: 加上阴影: 呃....这里可能是截图工具的问题,看不来多大的效果,但是直接在机器上看是有比较大的区别的,建议还是加上阴影. b.单击事件 单击事件就是单击了某个按键然后用户可以在输出框中看到对应的反应. 依次选择按键,右键Go to slot: 选择clicked() 然后添加处理函数,作者这里自己实现了一个添加文本与清除焦点的函数,添加文本就是对应按键被光标单击后添加到输出框,至于为什么要清除焦点.... 因为... 因为空格. 因为作者的&quot;良好&quot;习惯,习惯在运算符前后加上空格 单击后会把焦点保留在这个按钮上,键盘上敲空格默认会帮你&quot;按一次&quot;这个按钮,因此如果不清除焦点的话,在光标单击了某个按钮,比如7,按空格就会在输出框上输出7,光标单击了8后,按空格就会在输出框上输出8. 这里添加文本时还要注意默认的起提示作用的0. void MainWindow::appendText(const QString &amp;s) { if(ui-&gt;box-&gt;text() == &quot;0&quot;) ui-&gt;box-&gt;setText(s); else ui-&gt;box-&gt;setText(ui-&gt;box-&gt;text()+s); } void MainWindow::appendTextAndClearFocus(QPushButton *button, const QString &amp;s) { appendText(s); button-&gt;clearFocus(); } (2)键盘事件 键盘事件就是主要处理各个按键按下时的阴影与输出框添加输出. 键盘事件通过以下两个函数处理: void keyPressEvent(QKeyEvent *); void keyReleaseEvent(QKeyEvent *); 第一个是按键按下时触发的,第二个是松开按键触发的. A.添加阴影 在按键按下时添加上阴影与颜色加深效果. 通过event-&gt;key()依次判断各个键. 键位可以看这里 然后添加在keyRealeseEvent()中把对应的阴影去掉: void MainWindow::keyReleaseEvent(QKeyEvent *event) { switch (event-&gt;key()) { case Qt::Key_0: case Qt::Key_1: case Qt::Key_2: case Qt::Key_3: case Qt::Key_4: case Qt::Key_5: case Qt::Key_6: case Qt::Key_7: case Qt::Key_8: case Qt::Key_9: case Qt::Key_Plus: case Qt::Key_Minus: case Qt::Key_Asterisk: case Qt::Key_Slash: case Qt::Key_AsciiCircum: case Qt::Key_Percent: case Qt::Key_ParenLeft: case Qt::Key_ParenRight: case Qt::Key_BraceLeft: case Qt::Key_BraceRight: case Qt::Key_BracketLeft: case Qt::Key_BracketRight: case Qt::Key_Backspace: case Qt::Key_Space: case Qt::Key_Period: case Qt::Key_Escape: case Qt::Key_Equal: case Qt::Key_Return: removeNumButtonEffect(ui-&gt;num0,num0_shadow); removeNumButtonEffect(ui-&gt;num1,num1_shadow); removeNumButtonEffect(ui-&gt;num2,num2_shadow); removeNumButtonEffect(ui-&gt;num3,num3_shadow); removeNumButtonEffect(ui-&gt;num4,num4_shadow); removeNumButtonEffect(ui-&gt;num5,num5_shadow); removeNumButtonEffect(ui-&gt;num6,num6_shadow); removeNumButtonEffect(ui-&gt;num7,num7_shadow); removeNumButtonEffect(ui-&gt;num8,num8_shadow); removeNumButtonEffect(ui-&gt;num9,num9_shadow); removeSignButtonEffect(ui-&gt;plus,plus_shadow); removeSignButtonEffect(ui-&gt;minus,minus_shadow); removeSignButtonEffect(ui-&gt;mutiply,mutiply_shadow); removeSignButtonEffect(ui-&gt;divide,divide_shadow); removeSignButtonEffect(ui-&gt;pow,pow_shadow); removeSignButtonEffect(ui-&gt;percent,percent_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;brace,brace_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;bracket,bracket_shadow); removeSignButtonEffect(ui-&gt;backspace,backspace_shadow); removeSignButtonEffect(ui-&gt;blank,space_shadow); removeSignButtonEffect(ui-&gt;dot,dot_shadow); removeSignButtonEffect(ui-&gt;C,c_shadow); removeSignButtonEffect(ui-&gt;equal,equal_shadow); break; } } 这里之所以没有一个个按键去判断是因为有可能同时多个按键按下,然后同时松开后发现某个按键还存在阴影,因此统一当其中一个按键释放时去除所有按键的阴影. B.添加输出 在输出框中添加输出,调用一个函数即可: 4.整体细节再处理 (1)淡入效果 看看效果: 这里实际使用了Qt的动画,针对透明度改变的动画. void MainWindow::fadeIn(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0); changeOpacity-&gt;setEndValue(0.91); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); } 第一行表示改变的是透明度,第二三行设置起始值与结束值,接下来设置动画时间(单位ms),然后开始动画. (2)设置固定尺寸 这里可以不设置最大尺寸,但一定要设置最小尺寸. 设置这个实际上禁止了拖拽去改变大小. (3)淡出效果 淡出效果与淡入效果类似. 不同的时需要添加计时处理,不能直接在exit(0)前调用fadeOut()函数,因为动画会在另一个线程启动,所以需要在主线程休眠指定秒数,等待淡出效果完成后,主线程再调用exit(0); void MainWindow::fadeOut(void) { QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;); changeOpacity-&gt;setStartValue(0.9); changeOpacity-&gt;setEndValue(0); changeOpacity-&gt;setDuration(2500); changeOpacity-&gt;start(); QTime start = QTime::currentTime().addMSecs(2500); while(QTime::currentTime() &lt; start) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } 其中addMSecs()表示要延迟的秒数,while循环体中表示处理本线程的事件,其中100表示处理事件最多100ms就返回本语句. 这里就不放淡出效果的图片了. 5.表达式处理 由于这是整个字符串作为表达式进行输入,需要先进行判断再计算.所以分为判断与计算两部分. 这里使用了一个新开的控制台工程,后面会把这个整合起来. (1)判断 使用了一个check类判断,由于只有10个数字按键,加减乘除,小数点,求余,求次幂,大中小括号,空格,所以可以分成这几类进行判断. a.去除所有空格 void removeAllBlank(void) { size_t i = 0; while((i = s.find(' ',i)) != string::npos) s.erase(i,1); } 首先把所有空格去除,避免之后的判断. b.分类判断 把表达式中的所有字符分成5类: 数字 小数点 运算符号 + - * / ^ % 左括号类 ( [ { 右括号类 ) ] } 然后就是针对每个类型判断它的下一个字符是否是允许的类型,不是的话返回false. 比如碰上了一个 ( 或 [ 或 { 则它的下一个不能是运算符号或者小数点,当然允许-与+,因为有 (-7) (+234) 这种情况. 然后把这个符号保存下来判断后面是否是对应的右括号. if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } braces.push(s[i]); } 整个判断函数如下: bool valid(void) { if(isSignOrDot(0) || isRightBrace(0)) return false; len = s.size(); stack&lt;char&gt; braces; for(size_t i=0;i&lt;len;++i) { if(isLeftBrace(i)) { if(isSignOrDot(i+1)) { if(s[i+1] != '-' &amp;&amp; s[i+1] != '+') return false; } if(isRightBrace(i+1)) return false; braces.push(s[i]); } else if(isRightBrace(i)) { if(isDot(i+1) || isDigit(i+1) || isLeftBrace(i+1)) return false; if(isRightBrace(i+1)) { stack&lt;char&gt; braces_copy(braces); if(braces_copy.empty()) return false; braces_copy.pop(); if(braces_copy.empty()) return false; } if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i] != ')') || (brace == '[' &amp;&amp; s[i] != ']') || (brace == '{' &amp;&amp; s[i] != '}')) return false; braces.pop(); } else if(isSign(i)) { if(isSign(i+1) || isDot(i+1) || isRightBrace(i+1)) return false; } else if(isDot(i)) { if(isSignOrDot(i+1) || isBrace(i+1)) return false; } else if(isDigit(i)) { if(isRightBrace(i+1)) { if(braces.empty()) return false; char brace = braces.top(); if((brace == '(' &amp;&amp; s[i+1] != ')') || (brace == '[' &amp;&amp; s[i+1] != ']') || (brace == '{' &amp;&amp; s[i+1] != '}')) return false; } } } return braces.empty(); } 特别要注意下的就是碰到右括号的情况,除了要判断是否是单独存在的右括号,还有判断是否与前一个左括号匹配. c.加0 这是针对单目运算符-的情况,比如(-7),然后把它转化为(0-7): string getResult(void) { size_t len = s.size(); for(size_t i = 0;i&lt;len;++i) { if(s[i] == '(' &amp;&amp; (s[i+1] == '-' || s[i+1] == '+')) s.insert(i+1,&quot;0&quot;); } return s; } 在左小括号后判断是否是-或+,是的话对应位置插入0. (2)计算 a.calc辅助类 calc辅助类中使用了两个栈,运算符栈与操作数栈. private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; 其中有两个重要的方法: bool canCalculate(char sign); void calculate(void); 第一个方法将下一个准备进入的符号作为参数,判断是否可以计算操作数栈的前两个数,如果可以的话,使用第二个函数进行计算. calculate()会将出栈两个操作数与一个运算符,得出结果后在将其压回操作数栈. void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } 下面是calc类: class calc { private: stack&lt;char&gt; operators; stack&lt;double&gt; operands; char getSign(void) { return operators.top(); } double getNum(void) { return operands.top(); } void popSign(void) { operators.pop(); } void popNum(void) { operands.pop(); } double popAndGetNum(void) { double num = getNum(); popNum(); return num; } char popAndGetSign(void) { char sign = getSign(); popSign(); return sign; } public: void push(double num) { operands.push(num); } void push(char sign) { operators.push(sign); } char get(void) { return getSign(); } void pop(void) { popSign(); } double result(void) { return getNum(); } void calculate(void) { double post = popAndGetNum(); char sign = popAndGetSign(); double pre = popAndGetNum(); double result = 0.0; switch (sign) { case '+': result = pre+post; break; case '-': result = pre-post; break; case '*': result = pre*post; break; case '/': if(fabs(post) &lt; 1e-6) { cout&lt;&lt;&quot;Error.Divisor is 0.&quot;; exit(EXIT_FAILURE); } else result = pre / post; break; case '^': result = pow(pre,post); break; case '%': result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post); break; } push(result); } bool canCalculate(char sign) { if(sign == '(' || sign == '[' || sign == '{' || operators.empty()) return false; char t = getSign(); if(t == '^') return true; switch (t) { case '+': case '-': return sign == '+' || sign == '-'; case '*': case '/': case '%': return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%'; } return false; } bool empty(void) { return operators.empty(); } }; private封装了一些简单的对两个栈进行操作的工具方法,公有的pop()与get()是对运算符栈进行的操作.因为外部不需要对操作数栈进行操作,由calculate()进行操作,公有的push重载了,可以push到操作数栈或运算符栈. b.计算部分 计算部分在这里直接放在了main中: int main(void) { check chk; while(!chk.inputAndCheck()) cout&lt;&lt;&quot;Error!Please input again.\\n&quot;; string s = chk.getResult(); size_t len = s.size(); calc c; for(size_t i=0;i&lt;len;++i) { if(isdigit(s[i])) { double num; size_t i1 = i+1; while(i1 &lt; len &amp;&amp; (isdigit(s[i1]) || s[i1] == '.')) ++i1; istringstream input(s.substr(i,i1)); input&gt;&gt;num; i = i1-1; c.push(num); } else if(s[i] == '}' || s[i] == ']' || s[i] == ')') { char sign; char start = (s[i] == '}' ? '{' : ( s[i] == ']' ? '[' : '(')); while((sign = c.get()) != start) c.calculate(); c.pop(); } else //s[i] is [ ( { + - * / ^ % { while(c.canCalculate(s[i])) c.calculate(); c.push(s[i]); } } while(!c.empty()) c.calculate(); cout&lt;&lt;&quot;result is &quot;&lt;&lt;c.result()&lt;&lt;endl; return 0; } 对表达式的每个字符逐个处理,若是数字,提取出来并压栈. 若是右括号类,不断从运算符栈中提取直到把这段括号内的表达式计算完成. 否则若是左括号或者是运算符,当可以计算的时候一直计算,提取两个操作数运算并压栈,再把新的运算符压栈. 最后使用result()获取结果. c.测试 这里就显示几个很长的例子算了 当然作者测试了很多的例子 6.6/{2.3+34.3*2.22-5%2+22%4*[2+3.4/5-(4.3+3.2*33.3)]+34.3} + 7.8*{2.4-6/6+0-0*[23.4-3.4/6+4*(2.2+3)]}+0 - 0 + 0.0 = 10.8569 3.4 - (+3.34) + 34.3 * (-2) / 3.34 + {[(-3.4)^2/3.4+3.4/3]-3.32+[3*(-3)]} = -28.2656 9^5-34.4^2.3+5%6-34+66%78-78%4 + (-3)*3.4 / {3*(-7)+[3*(-8)+3*(3.4+4.34)/9.3-3.2 + 0.0 - 0]+0.0 - 0}+3.4^4/6.888 = 55683.2 不信的话可以手工计算一下. 6.整合 这部分把界面部分与表达式处理部分整合起来. (1)设置界面的调用进程,并获取输出结果 计算表达式的程序叫MyCalc.exe,注意把它放在对应的工程文件夹下面,然后使用QProcess调用. 使用execute执行,表达式先去除所有的空格,然后作为命令行参数传递给计算程序,然后计算程序把计算结果写入到result.txt文件,Qt读取这个文件,如果读到#表示表达式输入错误,否则,则是正确的计算结果. 对于结果因为在计算程序中设置了fixed格式,因此对于 1+2 也会返回 3.000000 这步把多余的0去掉,还要注意小数点的情况. (2)修改一些细节地方 a.鼠标键盘修改事件 修改setText的内容,把结果传递过去. b.exe中设置数字的格式 设置fixed格式,否则的话显示的是科学计数法,对小数位数有要求的话可以设置setprecision. c.设置错误提示 这里出现错误时,输出&quot;#&quot;,然后主程序读取到就会提示&quot;表达式错误,请重新输入.&quot; 还有除数为0的错误提示,这个要注意一下: d.可以考虑把错误处理整合过来 比如输入了一个点,不能继续输入点,输入了一个乘号或者除号不能再继续输入另一个符号: 7.打包发布 (1) 首先去下载Enigma Virtual Box (2) 添加环境变量 把Qt文件夹下的如图所示的bin添加到Path环境变量, (3) 打包库文件 使用windeployqt打包,首先把程序调成release模式,运行一次,生成release的exe,然后把exe复制到一个单独的文件夹,再用命令行进入到这个文件夹,运行 windelpoyqt xxx.exe 这个命令把需要的dll复制到当前所在文件夹. (4) 生成单个exe 打开Enigma Virtual Box,选择 第一个选择release的exe,第二个选择打包之后的文件夹,然后选择添加文件,选择递归添加,添加上一步生成的所有文件(夹). 这里选择压缩文件. 然后选择压缩等待完成即可. (5) 测试 点击运行. 大功告成!! 8.源码 1.github(里面包含完整可执行的单个exe) 注:由于使用了lfs上传大文件,所以clone的时候请使用 git lfs clone 2.码云 9.参考链接 1.Qt淡入 2.Qt按键 3.Qt标题栏 4.事件过滤器 5.Qt鼠标事件 6.Qt延时处理 7.Qt文件读写 8.Qt打包成单文件 10.最后 这个简单的计算器有很大的改进空间,比如可以添加各种&quot;数&quot;: 正弦函数,余弦函数,正切函数,反正弦函数,指数函数,对数函数,高阶导数,抽象函数,复合函数.心里没数 等等.另外还可以改进矩形的按钮,可以改成圆角矩形或者椭圆形. 另外,对于阴影的处理可以添加淡入淡出效果. 最后就是磨砂.因为win10的是有磨砂效果的,这个作者还不会.... 最后再上几个图,看看效果(由于动图大小的限制只是简单的表达式...): 希望你们也有一个属于自己的计算器! ","link":"https://2293736867.github.io/post/cong-0-kai-shi-zi-zhi-ji-suan-qi/"},{"title":"java多种文件复制方式以及效率比较","content":" 1.背景 2.概述 3.jar包 4.遍历 (1)listFiles() (2)list() (3)org.codehaus.plexus.util.FileUtils.getFiles (4)Commons.io工具包 (5)NIO--walkFileTree 5.复制 (1)FileInputStream+FileOutputStream A.read() B.read(b) C.read(b,off,len) (2)BufferedInputStream+BufferedOutputStream A.read(b) B.read(b,off,len) C.readAllBytes() (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)NIO--FileChannel (6)NIO--FileChannel+ByteBuffer (7)FileUtils.copyFile() (8)Files.copy() 6.其他 (1)swing布局 A.网格布局 B.居中 C.组件的添加与删除 (2)进度条 7.测试 (1)1G文件 (2)10G文件 (3)1G目录 (4)10G目录 8.源码 1.背景 java复制文件的方式其实有很多种,可以分为 传统的字节流读写复制FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStream 传统的字符流读写复制FileReader,FileWriter,BufferWriter,BufferedWriter,BufferedReader NIO系列的FileChannel FileChannel+缓冲 java.nio.Files.copy() 第三方包中的FileUtils.copy方法,比如org.apache.commons.io.FileUtils,org.codehaus.plexus.util.FileUtils等等. 所以呢,看看各种方法效率怎么样,主要衡量的标准就是时间,另外的一些标准包括大文件的复制时的内存溢出等问题. 2.概述 由于很多时候复制文件都包括了文件夹下的所有子目录及文件的复制,所以作者采用的遍历+复制方法去复制文件.就是把整个复制过程分为先遍历,遍历的过程中遇到文件夹就创建,遇到文件就调用不同的复制方法. 遍历的5种方法: (1)File.listFiles() (2)File.list() (3)org.codehaus.plexus.util.FileUtils.getFiles() (4)org.apache.commons.io.FileUtils.listFiles() (5)java nio中的java.nio.file.Files.walkFileTree 复制的8种方法: (1)FileInputStream+FileOutputStream (2)BufferedInputStream+BufferedOutputStream (3)FileReader+FileWriter (4)BufferedReader+BufferedWriter (5)FileChannel (6)FileChannel+buffer (7)org.apache.commons.io.FileUtils.copyFile() (8)java.nio.file.Files.copy() 另外作者不太想看控制台.....所以配合了一点swing使用. 3.jar包 1.org.apache.commons 2.org.codehaus.plexus 4.遍历 (1)listFiles() private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 通过srcFile的listFiles()获取所有的子文件与子文件夹,然后判断是否是目录 如果是目录,首先判断有没有这个文件(有时候本来是文件夹但是却存在同名的文件,就先删除),再创建文件夹,然后递归执行函数. 如果不是目录,直接把两个File作为参数进行文件复制,里面用什么方法后面会设置. (2)list() private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } list与第一种listFiles()类似,不过是String[],也是先判断目录,创建目录,不是目录直接复制 (3)org.codehaus.plexus.util.FileUtils.getFiles private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 这是用了别人的工具类进行遍历. org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); 返回的结果的java.util.List (4)Commons.io工具包 private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } 使用org.apache.commons.io.FileUtils的listFiles方法，参数为要遍历的目录，一个null和一个false，第二个参数表示过滤器，表示过滤出特定后缀名的文件，类型为String [],第三个布尔参数表示是否递归访问子目录. (5)NIO--walkFileTree 利用FileVisitor这个接口.实际中常用SimpleFileVisitor. private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } FileVisitor接口定义了四个方法，分别为： public interface FileVisitor&lt;T&gt; { FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir前的操作，dir类型一般为java.nio.Path } FileVisitResult postVisitDirectory(T dir,BasicFileAttributes attrs) { //访问dir后的操作 } FileVisitResult visitFile(T file,BasicFileAttributes attrs) { //访问file时的操作 } FileVisitResult visitFileFailed(T file,BasicFileAttributes attrs) { //访问file失败时的操作 } } 在上面的例子中只是实现了visitFile，因为只是复制操作，首先判断是否是源目录的路径，不是的话创建文件夹再复制文件. 这里说一下返回值FileVisitResult.FileVisitResult是一个枚举类型，根据返回值判断是否继续遍历. FileVisitResult可取值: CONTINUE:继续 TERMINNATE:结束 SKIP_SIBLINGS:继续，跳过同一目录的节点 SKIP_SUBTREE:继续，跳过子目录，但会访问子文件 5.复制 (1)FileInputStream+FileOutputStream 首先是经典的字节流FileInputStream+FileOutputStream,这个比较简单,使用FileInputStream读取后使用FileOutputStream写入,不过效率嘛.....一般般. private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } 这里说一下三个read方法的区别,FileInputStream有三个read方法: input.read(); input.read(b); input.read(b,off,len); A.read() 逐个字节进行读取,返回int,写入时直接使用write(n); int n = input.read(); output.write(n); 这个可以说是三个read中最慢的....作者试了一个2G左右的文件,用了大概10分钟才复制160M...... B.read(b) 参数是一个byte [],将字节缓冲到其中,返回数组的字节个数,这个比read()快很多. byte [] b = new byte[1024]; while(input.read(b) != -1) output.write(b); C.read(b,off,len) 这个方法其实和read(b)差不多,read(b)相当于省略了参数的read(b,off,len). byte [] b = new byte[1024]; int n; while((n = input.read(b,0,1024))!=-1) output.write(b,0,n); public int read(byte b[], int off, int len) throws IOException { return readBytes(b, off, len); } public int read(byte b[]) throws IOException { return readBytes(b, 0, b.length); } 这两个都是调用一样的readBytes(): private native int readBytes(byte b[], int off, int len) throws IOException; 至于效率...可以看看结果(作者用的是10G内的小文件): 可以看到,没有哪个一定比另外一个更快(不过最后一个误差有点太大了?7G不够的文件.). 采用哪一个建议自己去测试,毕竟这存在很多误差,比如文件,java版本,机器本身等等,仅供参考. (2)BufferedInputStream+BufferedOutputStream 缓冲字节流BufferedInputStream+BufferedOutputStream,相比起FileInputStream,BufferedInputStream读取时会先从缓冲区读取数据,缓冲区无可读数据再从文件读取,所以会比FileInputStream快. private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } 这里也说一下BufferedInputStream的三个read(实际上还有,还有readN,与read(),read()肯定最慢,readN作者很少用,所以就没列出来了) read(b); read(b,off,len); readAllBytes(); A.read(b) 这个其实和FileInputStream的那个没啥区别,把一个字节数组仍进去就好了. B.read(b,off,len) 这个....也和FileInputStream那个没啥区别,不说了 C.readAllBytes() 这个一次可以读取所有的字节.不过用这个虽然省事,可以直接 output.write(input.readAllBytes()); 但是呢,有代价的: 会出现OutOfMemory错误,就是对于大文件还是老老实实分开吧,不要&quot;一口搞定&quot;,&quot;多吃几口&quot;. 看看效率: readAllBytes对于大文件(作者这个是5G内的文件)直接爆内存.... readAllBytes()又爆了.....这个才2G不到的文件...readAllBytes()看来不是很给力啊....不过对于小文件效率还可以接受. (3)FileReader+FileWriter 字符流读写FileReader+FileWriter,相比起字节流的read,基本上把byte[]换成char[]即可,因为是逐个字符读取,而字节流是逐个字节读取因此采用byte[]. 注意这个不能用来读取图片,音乐等文件,不然复制出来的文件打不开. private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (4)BufferedReader+BufferedWriter 缓冲字符流读写BufferedReader+BufferedWriter,BufferedReader相比起FileReader有一个readLine()方法,可以每行读入,会比FileReader快.对应的BufferedWriter提供了write(String)方法,当然也有write(String s,int off,int len).同样这个不能用来读取图片等. private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } (5)NIO--FileChannel 通过FileChannel复制,首先通过FileInputStream与FileOutputStream打开流,再用getChannel()方法.最后使用transferTo()或transferFrom()进行复制,一条语句即可,十分方便,而且效率很高. private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } (6)NIO--FileChannel+ByteBuffer 在利用了FileInputStream与FileOutputStream打开了FileChannel的基础上,配合ByteBuffer使用. private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } flip的意思是&quot;翻转&quot;, buffer.flip(); 把Buffer从写模式变为读模式,接着write(buffer),再把buffer清空. 看看这两种方法效率: 另外作者发现transferTo的&quot;上限&quot;为2G,就是对于大于2G的单个文件最多最能复制2个G. 所以...对于大文件没有可比性了. (7)FileUtils.copyFile() 这是工具类,没啥好说的,参数是两个File,分别表示源与目标. private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } (8)Files.copy() 这是官方提供的Files工具类,前两个参数为Path,分别表示源与目标,可以设置第三个参数(或者省略),表示选项.例如可以设置 StandardCopyOption.REPLACE_EXISTING private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } 注意Files.copy会保持文件的隐藏属性,原来是隐藏的文件复制后也是隐藏的.以上7种则不会. 6.其他 (1)swing布局 A.网格布局 主JFrame采用了网格布局 setLayout(new GridLayout(3,1,5,3)); 三行一列，因为只要三个按钮，选择源文件(夹),选择目标文件夹,选择遍历方式. 选择遍历方式/复制方式的JFrame同样适用了网格布局: showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); B.居中 setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); 高400,宽400,利用ToolKit.getDefaultToolKit().getScreenSize()获取屏幕的高度和宽度实现居中. C.组件的添加与删除 由于在主JFrame中只有三个按钮,选择完遍历方式后需要更新这个组件,作者的做法是先删除这个组件在添加组件: traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); 设置它不可见再删除,再添加另一组件,再设置可见. (2)进度条 进度条这个东西把作者搞得很惨啊......其实就是新建一个线程就可以了. 核心代码为: new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); 作者的JProgressBar是直接添加在一个JFrame中的,不用什么太复杂的布局. 获取百分比后调用setValue(),一定要新建一个线程操作,不然不能正常显示进度条. 另外复制的操作建议使用SwingWorker. SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); 7.测试 说了那么多来点实际的. (以下所有的测试都是删除复制的文件后再进行新一次的复制.) (1)1G文件 1G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 20.189s 21.152s 18.249s 20.131s 21.782s BufferedInput/OuputStream 17.761s 23.786s 22.118s 19.646s 16.806s FileReader/Writer 61.334s 58.3s 58.904s 58.679s 55.762s BufferedReader/Writer 63.287s 59.546s 56.664s 58.212s 59.884s FileChannel 20.097s 22.272s 22.751s 22.765s 20.291s FileChannel+ByteBuffer 18.857s 22.489s 23.148s 22.337s 17.213s FileUtils.copyFile 25.398s 21.95s 22.808s 25.325s 22.483s Files.copy 16.272s 14.166s 17.057s 14.987s 10.653s 文件的话其实纵向比较即可,因为基本不用怎么遍历,横向比较可以勉强看作求平均值. 对于非文本文件,FileReader/Writer和BufferedReader/Writer没有太大的参考意义,比如复制视频文件是打不开的,而且复制出来的文件会变大.对于单文件Files.copy的性能非常好,java的nio果然厉害. (2)10G文件 10G file File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 171.427s 173.146s 172.611s 184.182s 250.251s BufferedInput/OuputStream 203.509s 174.792s 167.727s 177.451s 217.53s FileReader/Writer 187.55s 169.306s 226.571s 168.982s 218.303s BufferedReader/Writer 155.134s 165.883s 166.192s 176.488s 206.306s FileChannel 34.48s 35.445s 43.896s 41.827s 41.755s FileChannel+ByteBuffer 175.632s 167.091s 178.455s 182.977s 183.763s FileUtils.copyFile 203.997s 206.623s 201.01s 213.949s 208.739s Files.copy 209.898s 186.889s 244.355s 222.336s 244.68s 这个10G的文件是文本文件. 现在可以看看FileChannel的这一行,明显所花的时间要比其他要少,为什么呢? 因为文件大于2G.FileChannel的trasferTo方法只能写入最多2G的文件,所以对于大于2G的文件复制出来只有2G,因此FileChannel的这一行没有太大可比性.对于文本文件,BufferedReader/Writer的复制速度是最快的了,其次是FileInput/OutputStream.对于单个大文件,apache的FileUtils与NIO的Files.copy的速度比FileInputStream慢啊... (3)1G目录 1G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 23.549s 99.386s 143.388s 13.451s 10.773s BufferedInput/OuputStream 6.306s 59.458s 20.704s 6.668s 6.616s FileReader/Writer 49.059s 103.257s 51.995s 49.729s 51.509s BufferedReader/Writer 59.932s 127.359s 51.731s 51.418s 50.317s FileChannel 40.082s 71.713s 17.617s 15.782s 19.777s FileChannel+ByteBuffer 33.355s 83.845s 19.68s 10.288s 17.152s FileUtils.copyFile 24.163s 63.979s 8.277s 6.115s 19.513s Files.copy 14.528s 28.215s 6.578s 5.883s 7.502s 对于目录的话可以考虑放弃BufferedReader与FileReader了,除非全部是文本文件,否则推荐使用BufferedInput/OutputStream与Files.copy()进行复制,工具类FileUtils的复制方法表现还是不错的,但相比起java标准的Files.copy效率都差了. 对于FileChannel与配合缓冲使用的FileChannel,1G的话好像不相上下. 遍历方式的话...可以看到plexus的遍历方法表现差距很大,而apache的listFiles或者java nio的walkFileTree比较稳定且速度还可以,推荐使用这两种方式遍历目录. (4)10G目录 10G dir File.listFiles() File.list() plexus.util.FileUtils.getFiles() commons.io.FileUtils.listFiles Files.walkFileTree FileIntput/OutputStream 216.822s 228.792s 227.908s 240.042s 191.863s BufferedInput/OuputStream 218.599s 210.941s 207.375s 213.991s 167.614s FileReader/Writer 536.747s 550.755s 550.415s 548.881s 516.684s BufferedReader/Writer 587.612s 552.55s 549.716s 553.484s 498.18s FileChannel 115.126s 117.538s 117.456s 118.207s 97.626s FileChannel+ByteBuffer 225.887s 224.932s 222.077s 223.812s 180.177s FileUtils.copyFile 233.724s 230.199s 232.133s 223.286s 189.737s Files.copy 229.819s 227.562s 226.793s 226.78s 181.071s FileReader与BufferedReader这两行可以忽略了.对于小文件用FileChannel的话还是不错的,对于大文件一定要用FileChannel的话可以配合ByteBuffer使用,不过从数据上看效果比BufferedInput/OutputStream要低. 再看看org.apache.commons.io.FileUtils与java.nio.file.Files的copy,差别不太,效果接近,但在1G的时候差距有点大. 遍历方式的话,java nio的walkFileTrees最快. 当然这些测试仅供参考,具体使用哪一个要看看具体环境,另外这种方式把遍历与复制分开,apache的FileUtils有方法可以直接复制目录的,因此,使用哪个更合适还需要个人具体测试. 8.源码 作者比较偷懒全部仍在一个文件了.七百行. import java.awt.*; import javax.swing.*; import java.nio.*; import java.nio.channels.*; import java.io.*; import java.nio.file.*; import java.nio.file.attribute.*; import java.util.*; import org.apache.commons.io.*; public class Test extends JFrame { public static final long serialVersionUID = 12398129389122L; private JFrame showTraverseMethod = new JFrame(&quot;遍历方式&quot;); private JFrame showCopyMethod = new JFrame(&quot;复制方式&quot;); private JButton traverseMethodButton = new JButton(&quot;请选择遍历方式&quot;); private JButton copyMethodButton = new JButton(&quot;请选择复制方式&quot;); private JButton copyButton = new JButton(&quot;开始复制&quot;); private JButton traverseByListFiles = new JButton(&quot;File.listFiles()&quot;); private JButton traverseByList = new JButton(&quot;File.list()&quot;); private JButton traverseByGetFiles = new JButton(&quot;(plexus)getFiles()&quot;); private JButton traverseByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton traverseByNIO2 = new JButton(&quot;NIO2&quot;); private JButton copyByFileStream = new JButton(&quot;File stream&quot;); private JButton copyByBufferStream = new JButton(&quot;Buffer stream&quot;); private JButton copyByFileReader = new JButton(&quot;File reader&quot;); private JButton copyByBufferReader = new JButton(&quot;Buffer reader&quot;); private JButton copyByFileChannel = new JButton(&quot;File channel&quot;); private JButton copyByFileChannelWithBuffer = new JButton(&quot;File channel with buffer&quot;); private JButton copyByCommonsIO = new JButton(&quot;Commons IO&quot;); private JButton copyByFiles = new JButton(&quot;Files.copy&quot;); public Test() { JButton src = new JButton(&quot;选择源文件(夹)&quot;); src.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new Label(), &quot;选择文件(夹)&quot;); FilesCopy.setSrc(fileChooser.getSelectedFile()); } ); JButton des = new JButton(&quot;选择目标文件夹&quot;); des.addActionListener( event -&gt; { JFileChooser fileChooser = new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES); fileChooser.showDialog(new JLabel(),&quot;选择文件夹&quot;); FilesCopy.setDes(fileChooser.getSelectedFile()); } ); traverseMethodButton.addActionListener( event -&gt; { traverseByListFiles.addActionListener( e-&gt; { FilesCopy.setTraverseByListFiles(); showTraverseMethod.dispose(); } ); traverseByList.addActionListener( e -&gt; { FilesCopy.setTraverseByList(); showTraverseMethod.dispose(); } ); traverseByGetFiles.addActionListener( e -&gt; { FilesCopy.setTraverseByGetfiles(); showTraverseMethod.dispose(); } ); traverseByCommonsIO.addActionListener( e -&gt; { FilesCopy.setTraverseByCommonsIO(); showTraverseMethod.dispose(); } ); traverseByNIO2.addActionListener( e -&gt; { FilesCopy.setTraverseByNIO2(); showTraverseMethod.dispose(); } ); showTraverseMethod.setLayout(new GridLayout(5,1,3,3)); showTraverseMethod.setTitle(&quot;遍历方式&quot;); showTraverseMethod.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showTraverseMethod.setVisible(true); showTraverseMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showTraverseMethod.add(traverseByListFiles); showTraverseMethod.add(traverseByList); showTraverseMethod.add(traverseByGetFiles); showTraverseMethod.add(traverseByCommonsIO); showTraverseMethod.add(traverseByNIO2); traverseMethodButton.setVisible(false); remove(traverseMethodButton); add(copyMethodButton); copyMethodButton.setVisible(true); } ); copyMethodButton.addActionListener( event -&gt; { copyByFileStream.addActionListener( e -&gt; { FilesCopy.setCopyByFileStream(); showCopyMethod.dispose(); } ); copyByBufferStream.addActionListener( e -&gt; { FilesCopy.setCopyByBufferStream(); showCopyMethod.dispose(); } ); copyByFileReader.addActionListener( e -&gt; { FilesCopy.setCopyByFileReader(); showCopyMethod.dispose(); } ); copyByBufferReader.addActionListener( e -&gt; { FilesCopy.setCopyByBufferReader(); showCopyMethod.dispose(); } ); copyByFileChannel.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannel(); showCopyMethod.dispose(); } ); copyByFileChannelWithBuffer.addActionListener( e -&gt; { FilesCopy.setCopyByFileChannelWithBuffer(); showCopyMethod.dispose(); } ); copyByCommonsIO.addActionListener( e -&gt; { FilesCopy.setCopyByCommonsIO(); showCopyMethod.dispose(); } ); copyByFiles.addActionListener( e -&gt; { FilesCopy.setCopyByFiles(); showCopyMethod.dispose(); } ); showCopyMethod.setLayout(new GridLayout(4,2,5,5)); showCopyMethod.setTitle(&quot;复制方式&quot;); showCopyMethod.setBounds( (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); showCopyMethod.setVisible(true); showCopyMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); showCopyMethod.add(copyByFileStream); showCopyMethod.add(copyByBufferStream); showCopyMethod.add(copyByFileReader); showCopyMethod.add(copyByBufferReader); showCopyMethod.add(copyByFileChannel); showCopyMethod.add(copyByFileChannelWithBuffer); showCopyMethod.add(copyByCommonsIO); showCopyMethod.add(copyByFiles); copyMethodButton.setVisible(false); remove(copyMethodButton); add(copyButton); copyButton.setVisible(true); } ); copyButton.addActionListener( event -&gt; { if(FilesCopy.haveSelectedSrcAndDes()) { FilesCopy.copy(); copyButton.setVisible(false); remove(copyButton); add(traverseMethodButton); traverseMethodButton.setVisible(true); } else JOptionPane.showMessageDialog(null,&quot;请先选择源文件(夹)与目标文件夹!&quot;); } ); setLayout(new GridLayout(3,1,5,3)); setTitle(&quot;复制文件&quot;); setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); add(src); add(des); add(traverseMethodButton); } public static void main(String[] args) { new Test(); } } class FilesCopy { private static File src = null; private static File des = null; private static long desSize = 0; private static long srcSize = 0; private static boolean [] traverseMethod = {false,false,false,false,false,false}; private static boolean[] copyMethod = { false, false, false, false, false, false ,false,false}; private static JFrame showProgressBar = new JFrame(); private static JProgressBar copyProgressBar = new JProgressBar(); private static JTextField textField = new JTextField(); private static int index = 0; private static int getCopyPercent() { return (int)(desSize * 100.0 / srcSize); } private static void addCopySize() { desSize += 1024L; } public static void setTraverseByListFiles() { traverseMethod[0] = true; } private static void traverseByListFiles(File srcFile,File desFile) throws IOException { if(srcFile.isDirectory()) { File[] files = srcFile.listFiles(); assert files != null; for(File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByList() { traverseMethod[1] = true; } private static void traverseByList(File srcFile,File desFile) throws IOException { if (srcFile.isDirectory()) { String[] files = srcFile.list(); assert files != null; for (String file : files) { File subSrcFile = new File(srcFile, file); File subDesFile = new File(desFile, file); if (subSrcFile.isDirectory()) { if (subDesFile.exists()) subDesFile.delete(); subDesFile.mkdirs(); } traverseByList(subSrcFile, subDesFile); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByGetfiles() { traverseMethod[2] = true; } private static void traverseByGetFiles(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null); for (File file : fileList) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByListFiles(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByCommonsIO() { traverseMethod[3] = true; } private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException { if (srcFile.isDirectory()) { Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false); for (File file : files) { File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName()); if(file.isDirectory()) { if(desFileOrDir.exists()) desFileOrDir.delete(); desFileOrDir.mkdirs(); } traverseByCommonsIO(file, desFileOrDir); } } else { copyFile(srcFile, desFile); } } public static void setTraverseByNIO2() { traverseMethod[4] = true; } private static void traverseByNIO2(File srcFile) throws IOException { java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() { @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException { File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length())); new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs(); copyFile(path.toFile(), d); return FileVisitResult.CONTINUE; } }); } public static void setCopyByFileStream() { copyMethod[0] = true; } private static void copyByFileStream(File srcFile,File desFile) throws IOException { FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(desFile); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { outputStream.write(b); addCopySize(); } inputStream.close(); outputStream.close(); } public static void setCopyByBufferStream() { copyMethod[1] = true; } private static void copyByBufferStream(File srcFile,File desFile) throws IOException { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile)); byte [] b = new byte[1024]; while(inputStream.read(b) != -1) { addCopySize(); outputStream.write(b); } inputStream.close(); outputStream.close(); } public static void setCopyByFileReader() { copyMethod[2] = true; } private static void copyByFileReader(File srcFile,File desFile) throws IOException { FileReader reader = new FileReader(srcFile); FileWriter writer = new FileWriter(desFile); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByBufferReader() { copyMethod[3] = true; } private static void copyByBufferReader(File srcFile,File desFile) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(srcFile)); BufferedWriter writer = new BufferedWriter(new FileWriter(desFile)); char [] c = new char[1024]; while(reader.read(c) != -1) { addCopySize(); writer.write(c); } reader.close(); writer.close(); } public static void setCopyByFileChannel() { copyMethod[4] = true; } private static void copyByFileChannel(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); srcChannel.transferTo(0,srcChannel.size(),desChannel); srcChannel.close(); desChannel.close(); } public static void setCopyByFileChannelWithBuffer() { copyMethod[5] = true; } private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException { FileChannel srcChannel = new FileInputStream(srcFile).getChannel(); FileChannel desChannel = new FileOutputStream(desFile).getChannel(); ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while(srcChannel.read(buffer) != -1) { buffer.flip(); desChannel.write(buffer); buffer.clear(); addCopySize(); } srcChannel.close(); desChannel.close(); } public static void setCopyByCommonsIO() { copyMethod[6] = true; } private static void copyByCommonsIO(File srcFile,File desFile) throws IOException { FileUtils.copyFile(srcFile, desFile); } public static void setCopyByFiles() { copyMethod[7] = true; } private static void copyByFiles(File srcFile,File desFile) throws IOException { Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING); } public static void setSrc(File srcFile) { src = srcFile; if(srcFile.isDirectory()) srcSize = org.apache.commons.io.FileUtils.sizeOfDirectory(srcFile); else srcSize = src.length(); } public static void setDes(File desFile) { des = desFile; desSize = 0; } public static void setSrc(Path srcPath) { setSrc(srcPath.toFile()); } public static void setDes(Path desPath) { setDes(desPath.toFile()); } private static void copyFile(File srcFile,File desFile) throws IOException { if (copyMethod[0]) copyByFileStream(srcFile,desFile); else if (copyMethod[1]) copyByBufferStream(srcFile, desFile); else if (copyMethod[2]) copyByFileReader(srcFile, desFile); else if (copyMethod[3]) copyByBufferReader(srcFile, desFile); else if (copyMethod[4]) copyByFileChannel(srcFile, desFile); else if (copyMethod[5]) copyByFileChannelWithBuffer(srcFile, desFile); else if (copyMethod[6]) copyByCommonsIO(srcFile, desFile); else if (copyMethod[7]) copyByFiles(srcFile, desFile); else showMessage(&quot;复制失败,找不到复制方法.&quot;); } private static void showMessage(String message) { JOptionPane.showMessageDialog(null, message); } public static boolean haveSelectedSrcAndDes() { return src != null &amp;&amp; des != null; } public static void copy() { long start = System.currentTimeMillis(); if(haveSelectedSrcAndDes()) { if(src.isFile()) { des = new File(des.getAbsolutePath()+File.separator+src.getName()); } SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;() { @Override protected String doInBackground() { try { if (traverseMethod[0]) traverseByListFiles(src, des); else if (traverseMethod[1]) traverseByList(src, des); else if (traverseMethod[2]) traverseByGetFiles(src, des); else if (traverseMethod[3]) traverseByCommonsIO(src, des); else if (traverseMethod[4]) traverseByNIO2(src); else { showProgressBar.dispose(); showMessage(&quot;遍历失败,找不到遍历方法&quot;); } } catch (IOException e) { e.printStackTrace(); showProgressBar.dispose(); showMessage(&quot;未知错误复制失败&quot;); } finish(start); return null; } }; copyTask.execute(); if (!copyMethod[4] &amp;&amp; !copyMethod[6] &amp;&amp; !copyMethod[7]) { copyProgressBar.setMinimum(0); copyProgressBar.setMaximum(100); copyProgressBar.setValue(0); copyProgressBar.setVisible(true); copyProgressBar.setStringPainted(true); showProgressBar.add(copyProgressBar); showProgressBar.setTitle(&quot;复制进度&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 150, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 50, 300, 100); showProgressBar.setVisible(true); new Thread( () -&gt; { int percent; while ((percent = getCopyPercent()) &lt; 100) { try { Thread.sleep(100); } catch(InterruptedException e) { e.printStackTrace(); } copyProgressBar.setValue(percent); } } ).start(); } else { final String [] text = {&quot;.&quot;,&quot;..&quot;,&quot;...&quot;,&quot;....&quot;,&quot;.....&quot;,&quot;.......&quot;,&quot;......&quot;,&quot;.....&quot;,&quot;....&quot;,&quot;...&quot;,&quot;..&quot;,&quot;.&quot;}; textField.setVisible(true); textField.setHorizontalAlignment(JTextField.CENTER); textField.setEditable(false); showProgressBar.add(textField); showProgressBar.setTitle(&quot;复制中&quot;); showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 120, (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 40, 240, 80); showProgressBar.setVisible(true); new Thread( () -&gt; { while (getCopyPercent() &lt; 100) { try { Thread.sleep(400); } catch(InterruptedException e) { e.printStackTrace(); } if(index &lt; text.length) textField.setText(&quot;复制中&quot;+text[index++]); else index = 0; } } ).start(); } } } private static void finish(long start) { long end = System.currentTimeMillis(); showProgressBar.dispose(); showMessage(&quot;复制成功,用时:&quot; + (end - start) / 1000.0 + &quot;s&quot;); copyProgressBar.setVisible(false); showProgressBar.remove(copyProgressBar); textField.setVisible(false); showProgressBar.remove(textField); Arrays.fill(traverseMethod, false); Arrays.fill(copyMethod, false); des = src = null; desSize = srcSize; } } ","link":"https://2293736867.github.io/post/java-duo-chong-wen-jian-fu-zhi-fang-shi-yi-ji-xiao-lu-bi-jiao/"},{"title":"聊聊java中final那点事","content":" 1.final是什么 2.final有什么用 3.final修饰成员变量 (1)修饰静态变量 (2)修饰普通成员变量 4.final修饰局部变量 (1)修饰形参 (2)修饰局部变量 (3)final修饰引用变量 5.final修饰方法 6.final修饰类 1.final是什么 final是一个java关键字,一个修饰符,可用于修饰变量,方法,修饰类. 2.final有什么用 final可以修饰变量时,可以使其值不能改变 final修饰方法时使其不能被重写 final修饰类时,使其不能被继承. 3.final修饰成员变量 fianl最常见的用法时用来修饰成员变量,成员变量分为静态变量与普通变量. 对于final修饰的变量,不是不能被赋值,是其值不能被改变,可以理解成只能赋一次值.可以在定义时赋值,也可以在定义后在另外赋值,但无论何种方式只能被赋值一次. (1)修饰静态变量 修饰静态变量时,可以选择以下两种方式赋值: 在定义时赋值 静态初始化块内赋值 final static int a = 6; final static int b; static { b = 6; } (2)修饰普通成员变量 修饰普通成员变量时,可以选择以下三种方式赋值: 定义时赋值 初始化块内赋值 构造方法赋值 public class test { int c = 1; int d; int e; { d = 2; } public test() { e = 3; } } 根据&quot;静态&quot;不能访问&quot;非静态&quot;规则,就是说静态的方法不能访问非静态成员,static初始化块不能初始化非静态成员,普通初始化块也不能初始化静态变量. 但是,有一个&quot;bug&quot;就是java允许通过方法访问final成员,因此...有趣的事情发生了. public class test { final int a; { System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } 以上这段代码会报错,因为java不允许final成员未初始化前访问. 把上面那一行出错的代码注释后...居然通过了编译?! public class test { final int a; { //System.out.println(a);//这里会报错 printA(); a = 3; printA(); } void printA() { System.out.println(a); } public static void main(String[] args) { new test(); } } printA()中只是用方法包装了一下输出函数,居然就通过了编译...有没有兴趣看一下结果? emmmmmm....final&quot;默认值&quot;为0.....总之就不要想这些歪门邪道去在final初始化之前访问final变量了 ,在使用final变量前初始化,初始化,初始化,重要的事情说三遍. 4.final修饰局部变量 final修饰局部变量其实也分两种,一种是修饰形参,一种是修饰方法内部的局部变量 (1)修饰形参 没什么好说的...就是形参的值不能改变. public void f(final int a) { a = 3;//报错. } (2)修饰局部变量 修饰局部变量时可以定义时赋值,也可以在定义后在赋值(仅一次). public void f() { final int a = 3; final int b; b = 2; } (3)final修饰引用变量 嗯.....这个是一个特别一点的例子,Talk is cheap.上代码. import java.util.Arrays; public class test { public static void main(String[] args) { final int[] arr = {1,2,3}; arr[1] = 5; Arrays.stream(arr).forEach(System.out::print); System.out.println(); final A a = new A(); a.setA(9); System.out.println(a.getA()); } } class A { private int a = 3; public void setA(int a) { this.a = a; } public int getA() { return a; } } 为什么final数组可以赋值???fianl对象的值被改变了???看看结果: final数组居然被改变了??final对象的值也被改变了?? 其实呢,因为数组是引用类型,final修饰引用类型时,只能保证这个变量永远&quot;指向&quot;那一段内存空间,保存的仅仅是一个引用,但是那段内存空间的值是可以改变的.修饰对象时也是一样的道理. 5.final修饰方法 final修饰的方法不能被重写,当然,不能&quot;配合&quot;private&quot;使用&quot;,因为private把方法变成了私有,相当于对子类不可见,子类都不知道父类&quot;还有这玩意&quot;,就可以进行所谓的&quot;重写&quot;了. class A { private final void f(){} } class B extends A { public final void f(){}//没毛病 } 因为B类的f()是属于B类的,不是从A类继承过来的. 6.final修饰类 final修饰类时表示该类不能被继承. final class A{} class B extends A{}//出错 ","link":"https://2293736867.github.io/post/liao-liao-java-zhong-final-na-dian-shi/"},{"title":"java自定义的getInstance()返回泛型","content":"1.背景 实际中经常使用getInstance()方法返回一个对象,对于工厂模式,传入对应的参数返回与之相对应的对象.但是,问题来了,返回的对象需要被强制转换,很麻烦. import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(&quot;test1&quot;); test2 t2 = factory.getInstance(&quot;test2&quot;); } } class factory { public static Object getInstance(String className) { try { return Class.forName(className).getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } 编译不通过,说类型不兼容. 因此加上强制类型转换,编译通过了. test1 t1 = (test1)factory.getInstance(&quot;test1&quot;); test2 t2 = (test2)factory.getInstance(&quot;test2&quot;); 2.如何处理 例子只有两个类,手动强制转换还可以,但如果多个类咋办啊?而且作者是那种非常懒的人,也不想手动去转换,因此,用大招-----泛型! 3.使用泛型 使用Class&lt;T&gt; 泛型可以避免强制转换从而更有效地偷懒 ,需要把返回类型改成&lt;T&gt; T,同时由于使用了T,必须修改传进来的参数. public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { test1 t1 = factory.getInstance(test1.class); test2 t2 = factory.getInstance(test2.class); } } class factory { public static &lt;T&gt; T getInstance(Class&lt;T&gt; t) { try { return t.getConstructor().newInstance(); } catch(Exception e) { e.printStackTrace(); } return null; } } class test1 { public test1() { } } class test2 { public test2() { } } ","link":"https://2293736867.github.io/post/java-zi-ding-yi-de-getinstancefan-hui-fan-xing/"},{"title":"java反射Array的使用","content":" 1.什么是Array 2.Array有什么用 3.Array使用示例 (1)创建 (2)赋值 (3)获取值 (4)强制类型转换 4.完整代码 5.运行结果 1.什么是Array Array是一个类的简写,全限定类名是java.lang.reflect.Array. 2.Array有什么用 Array可以代表所有的数组,可以通过Array动态创建与修改里面的元素. 3.Array使用示例 (1)创建 使用静态方法newInstance()构造Object对象.方法如下: public static Object newInstance(Class&lt;?&gt; element, int ... length); 第一个参数是代表元素的类,剩下的参数表示维数,一个参数表示一维数组,两个参数表示二维数组(数组的数组),参数的值代表维数的长度. Object intArray = Array.newInstance(int.class,3); //int [3] Object stringArray = Array.newInstance(String.class,2,3); //String [2][3] (2)赋值 赋值使用静态方法set即可,参数为Array返回的Object对象,下标与对应的值. public static void set(Object array,int index,Object value); public static void setBoolean(Object array,int index,boolean b); public static void setXxxx(Object array,int index,xxx); 其中最后一个表示对应的基本类型,第二个为boolean类型的示例. Array.set(intArray,2,3); Array.set(stringArray,1,new String[]{&quot;123&quot;,&quot;456&quot;}); (3)获取值 使用静态方法get,参数为Array返回的Object对象与下标. public static Object get(Object array,int index); public static boolean getBoolean(Object array,int index); public static xxx getXxx(Object array,int index); 最后一个表示对应的基本类型,第二个为boolean类型的示例 System.out.println(Array.get(intArray,2)); System.out.println(Array.get(Array.get(stringArray,1),1)); (4)强制类型转换 可以通过强制类型转换使Array返回的Object对象转换为对应的数组. var castIntArray = (int [])intArray; var castStringArray = (String [][])stringArray; 这样可以当作一个普通数组使用. 4.完整代码 import java.lang.reflect.*; public class test { public static void main(String[] args) { var intArray = Array.newInstance(int.class, 3); var stringArray = Array.newInstance(String.class, 2,3); Array.set(intArray, 2, 3); Array.set(stringArray, 1, new String[] { &quot;123&quot;, &quot;456&quot; }); System.out.println(Array.get(intArray, 2)); System.out.println(Array.get(Array.get(stringArray,1),1)); System.out.println(&quot;-------cast-------&quot;); System.out.println(((int[]) intArray)[2]); System.out.println(((String [][])stringArray)[1][1]); } } 5.运行结果 ","link":"https://2293736867.github.io/post/java-fan-she-array-de-shi-yong/"},{"title":"log4j2入门hello world","content":" 1.什么是log4j2 (1)log4j (2)log4j2 3.VScode下使用log4j2(不用Maven) (1)准备jar包 (2)准备插件 (3)创建项目 (4)设置jar包路径 (5)新建测试文件 (6)运行 (7)创建配置文件使其输出更多信息 (8)再次运行 4.VScode下使用log4j2(带Maven) (1)创建maven项目 (2)在pom.xml配置依赖 (3)创建log4j2.xml (4)修改测试类 (5)测试 5.IDEA下使用log4j2(不用Maven) (1)创建项目 (2)添加jar包 (3)新建测试类 (4)新建log4j2.xml (5)测试 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 (2)配置依赖 (3)创建log4j2.xml (4)创建测试类 (5)测试 1.什么是log4j2 (1)log4j log4j是apache的一个开源项目,表示log for java.是一个日志工具,可以将日志信息输出到文件,控制台等其他地方 ,还可以定义日志的输出格式,另外还有日志级别的区分,可通过配置文件去配置输出格式,输出目的地等信息. (2)log4j2 log4j2从名字就知道了,是log4j的升级版本,性能有了很大提升,增加了很多新特性(如自定义级别,lambda表达式)与新的API,直接与tomcat等服务器集成. 3.VScode下使用log4j2(不用Maven) (1)准备jar包 点击这里下载 作者用的是win10,下载zip. (2)准备插件 搜索安装:Eclipse New Java Project (3)创建项目 ctrl+shift+p调出命令面板,输入new java project 项目名 JavaSE版本 创建完毕. (4)设置jar包路径 在项目根路径下新建lib文件夹,把下载的 这两个jar包放进去. 下一步设置.classpath. 添加 &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-api-2.12.1.jar&quot; /&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-core-2.12.1.jar&quot; /&gt; (5)新建测试文件 src下直接建立test.java test.java: import org.apache.logging.log4j.*; public class test { private final static Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (6)运行 点击main上的Run 结果: 输出了fatel与error信息. 另外还提示了没有找到log4j2配置文件,使用默认的配置文件,默认输出到控制台. (7)创建配置文件使其输出更多信息 src下创建log4j2.xml配置文件. log4j2的配置文件只能是.xml或.json或.jsn文件,默认会在classpath下寻找(在这里classpath相当于图中的src). 默认情况下系统选择配置文件的优先级如下: 1.classpath下名为 log4j-test.json 或者log4j-test.jsn文件 2.classpath下名为 log4j2-test.xml 3.classpath下名为 log4j.json 或者log4j.jsn文件 4.classpath下名为 log4j2.xml 这里使用log4j2. xml.log4j2.xml如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Logger三个主要的组件为 logger(记录器) appender(输出目的地) layout(布局,定义日志的格式) &lt;appenders&gt;了输出目的地,&lt;Console&gt;表示控制台,&lt;PatternLayout&gt;定义了布局,里面的布局表示时间格式(%d,HH:mm:ss.SSS),接着是日志线程名(%t),%-5表示最小长度为5左对齐,level表示输出日志级别. %logger表示输出logger名称. %m是%msg与%message的缩写,表示输出应用提供的与记录事件有关的信息. %n表示换行. &lt;loggers&gt;定义的logger与logger使用的appender.root为log默认的输出形式,如果一个类的没有明确loggers中的输出格式就会采用root的格式. (8)再次运行 没有之前的&quot;没有配置文件&quot;的提示了. 4.VScode下使用log4j2(带Maven) (1)创建maven项目 使用插件maven for java创建,命令面板(ctrl+shift+p)输入. 选择quickstart. 选择版本. 最后选择项目路径即可. 在控制台中vscode会下载相关文件,然后会提示以交互模式创建: 这里等一会就好了. 然后会提示输入一些值. ok. (2)在pom.xml配置依赖 在&lt;dependencies&gt;中添加如下代码: &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; 以下是完整的pom.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;/project&gt; 右键选择Update project configuration. (3)创建log4j2.xml 在java目录下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.App&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)修改测试类 修改默认的App.java. package com.example; import org.apache.logging.log4j.*; public class App { private static final Logger logger = LogManager.getLogger(App.class.getName()); public static void main( String[] args ) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 run即可. 5.IDEA下使用log4j2(不用Maven) (1)创建项目 什么也不用选,直接next. 勾选从模板创建项目. 选好路径与填好项目名即可. (2)添加jar包 选择刚才的lib目录,或者自己手动改成两个jar包(log4j-api-版本.jar,log4j-core-版本.jar). (3)新建测试类 项目结构如下: Main.java package com.test; import org.apache.logging.log4j.*; public class Main { private static final Logger logger = LogManager.getLogger(Main.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (4)新建log4j2.xml 在src下新建log4j2.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.test.Main&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (5)测试 直接点击run按钮. 6.IDEA下使用log4j2(带Maven) (1)创建maven项目 模块 这里作者偷懒就直接在上面项目的基础上新建模块不新建项目了. 都不用选直接next. 填好GroupId与ArtifactId之后next. 最后选好位置. (2)配置依赖 pom.xml中加入: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下是完整的pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 右键选择同步pom.xml. 选择右下角弹出的提示中的Import Changes. (3)创建log4j2.xml 在target下的classes下创建log4j2.xml. log4j2.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration status=&quot;OFF&quot;&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.example.test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; (4)创建测试类 创建包与test.java. test.java package com.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class test { private static final Logger logger = LogManager.getLogger(test.class.getName()); public static void main(String[] args) { logger.info(&quot;info&quot;); logger.error(&quot;error&quot;); logger.debug(&quot;debug&quot;); logger.trace(&quot;trace&quot;); logger.fatal(&quot;fatel&quot;); } } (5)测试 新建配置Application. 输入Main class与名字. run. 参考: 1.log4j2(1) 2.log4j2(2) 3.log4j2(3) 4.log4j2(4) 5.log4j2(5) ","link":"https://2293736867.github.io/post/log4j2-ru-men-hello-world/"},{"title":"java通过ServerSocket与Socket实现通信","content":" 1.ServerSocket (1) (2) (3) 2.Socket (1) (2) (3) (4) 3.服务器端 4.客户端 5.运行结果 6.Socket设置超时 首先说一下ServerSocket与Socket. 1.ServerSocket ServerSocket是用来监听客户端Socket连接的类,如果没有连接会一直处于等待状态. ServetSocket有三个构造方法: (1) ServerSocket(int port); 这个使用指定的端口去创建ServerSocket,IP地址使用默认的本地IP地址. (2) ServetSocket(int port,int backlog); 除了端口外,还有一个用来改变队列长度参数的backlog,指定当服务器繁忙时,可以与之保持连接请求的客户端数量,默认为50. (3) ServetSocket(int port,int backlog,InetAddress ip); 这个使用指定的端口,backlog,ip地址去创建ServerSocket. (这里简单提一下InetAddress,InetAddress没有构造方法,只有两个静态方法获取InetAddress对象,分别是 getByName(String hostName); getByAddress(byte[] address); ) 2.Socket Socket一般用来连接到服务器,程序通过Socket发出网络请求或应答网络请求. Socket有三个构造方法: (1) Socket(InetAddress address,int port); 使用指定IP与指定端口构造Socket,对于本地地址,默认使用本地ip,对于本地端口则动态分配. (2) Socket(String address,int port); 与(1)一样,使用String表示远程ip. (3) Socket(InetAddress address,int port,InetAddress localAddr,int localPort); 创建指定了远程ip,远程端口,本地ip,本地端口的Socket. (4) Socket(String address,int port,InetAddress localAddr,int localPort) 与(2)类似,使用String表示远程ip,用InetAddress表示本地ip. 了解了ServerSocket与Socket后可以编写实现简单的通信了. 3.服务器端 import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(12345);//这个端口自己随意,建议1024以上未使用的端口. while(true) { Socket socket = serverSocket.accept();//一直等待来自客户端的请求. PrintStream printStream = new PrintStream(socket.getOutputStream());//创建输出流 printStream.println(&quot;Server message.&quot;); printStream.close(); socket.close(); } } } 说一下ServetSocket的accept()方法: Socket accept(); 没有参数,返回一个Socket,如果接收到客户端的一个Socket,则返回,否则一直处于等待状态,线程也被阻塞. 4.客户端 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetAddress; import java.net.Socket; public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(&quot;This message comes from server:&quot;+bufferedReader.readLine()); bufferedReader.close(); socket.close(); } } Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); 表示创建一个本地地址,端口为12345的Socket,创建好了后服务器的.accept()方法就会接收到这个Socket,并创建输出流输出相应信息,然后客户端从Socket获取输入流进行读取,读取到了来自服务器的信息. 5.运行结果 (由于作者的漂亮终端不知道什么原因坏了....只能让用VScode的默认终端了....) 先运行服务器端的代码: 服务器端这边因为accept()方法会一直阻塞直到客户端发送请求. 客户端这边一运行就收到了来自服务器端的信息. 6.Socket设置超时 可以为Socket设置超时设置,当Socket超过这个时间没有连接上时系统会认为连接失败. Socket socket = new Socket(&quot;127.0.0.1&quot;,12345); socket.setToTimeout(10000);//单位:ms,在这里是10s 但是未连接上之前无法创建Socket对象,并且Socket没有提供指定超时的构造方法,因此常见的做法是先创建一个无连接的Socket,再调用connect()方法连接. Socket socket = new Socket(); socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,12345),12345); connect()方法其实有两个重载方法,分别是 void connect(SocketAddress endpoint); void connect(SocketAddress endpoint,int timeout); 对于第一个connect()官方文档没有提及超时之类的,就是直接连接. 对于第二个connect,timeout指定的超时时间,单位为ms,设置为0则为无限期等待. 参考链接 1.socket ","link":"https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/"},{"title":"java7与java9中的try-finally关闭资源","content":"1.java7中的try 在java7之前,对于一些需要使用finally关闭资源的操作,会显得很臃肿. try { // } catch(Exception e) { // } finally { if(xxxx != null) { xxxx.close(); } } 在java7中引入了可以在try中直接声明需要关闭的资源的功能,在try后的圆括号直接定义一个或多个资源即可. try( var xxx = new xxx(); var xxx = new xxx(); ) { // } 但是这些类都需要实现了Closeable或AutoCloseable接口,实现其中的close(). 2.Closeable接口 Closeable接口是AutoCloseable的子接口,其中的close()抛出了IOException异常,实现接口时要注意抛出的异常需是IOException异常或IOException子类异常. 3.AutoCloseable接口 AutoCloseable接口中的close()抛出的异常是Exception,实现接口时可以抛出任何类型的异常. java7几乎把所有的&quot;资源类&quot;(包括文件IO的各种类,JDBC编程的Connection,Statement等接口)进行了改写,改写后的资源都实现了AutoCloseable或Closeable接口.(引自&lt;&lt;疯狂Java讲义&gt;&gt;(第5版) P381) 4.java9中的try java9不像java7一样在try中定义资源,只需要自动关闭的资源有final修饰即可.也就是说,可以不在try中声明,在try前声明且使用final修饰即可. final var xxx = new xxx(); final var xxx = new xxx(); try(xxx;xxx) { // } ","link":"https://2293736867.github.io/post/java7-yu-java9-zhong-de-try-finally-guan-bi-zi-yuan/"},{"title":"一文带你理解脏读,幻读,不可重复读与mysql的锁,事务隔离机制","content":" 1 ACID (1) A:原子性(Atomicity) (2) C:一致性(Consistency) (3) I:隔离性(Isolation) (4) D:持久性(Durability) 2 Mysql的锁 (1) S锁与X锁 Ⅰ.S锁 Ⅱ.X锁 (2) 乐观锁与悲观锁 Ⅰ.乐观锁 Ⅱ.悲观锁 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 (2) 幻读 (3) 不可重复读 (4) 第一类丢失更新 (5) 第二类丢失更新 5 封锁协议与隔离级别 (1) 一级封锁协议 a.引发脏读 b.引发幻读 c.引发不可重复读 (2) 二级封锁协议 Ⅰ.Read committed a.避免脏读 b.引发幻读 c.引发不可重复读 Ⅱ.Repeatable read a.避免脏读 b.避免不可重复读 c.引发幻读 (3) 三级封锁协议 a.避免脏读 b.避免幻读 c.避免不可重复读 6 两段锁协议 (1) 加锁 (2) 解锁 首先说一下数据库事务的四大特性 1 ACID 事务的四大特性是ACID(不是&quot;酸&quot;....) (1) A:原子性(Atomicity) 原子性指的是事务要么完全执行,要么完全不执行. (2) C:一致性(Consistency) 事务完成时,数据必须处于一致的状态.若事务执行途中出错,会回滚到之前的事务没有执行前的状态,这样数据就处于一致的状态.若事务出错后没有回滚,部分修改的内容写入到了数据库中,这时数据就是不一致的状态. (3) I:隔离性(Isolation) 同时处理多个事务时,一个事务的执行不能被另一个事务所干扰,事务的内部操作与其他并发事务隔离. (4) D:持久性(Durability) 事务提交后,对数据的修改是永久性的. 2 Mysql的锁 Mysql的锁其实可以按很多种形式分类: 按加锁机制分,可分为乐观锁与悲观锁. 按兼容性来分,可分为X锁与S锁. 按锁粒度分,可分为表锁,行锁,页锁. 按锁模式分,可分为记录锁,gap锁,next-key锁,意向锁,插入意向锁. 这里主要讨论S锁,X锁,乐观锁与悲观锁. (1) S锁与X锁 S锁与X锁是InnoDB引擎实现的两种标准行锁机制.查看默认引擎可使用 show variables like '%storage_engine%'; 作者的mysql版本为8.0.17,结果如下: 先建好测试库与测试表,很简单,表就两个字段. create database test; use test; create table a ( id int primary key auto_increment, money int ); Ⅰ.S锁 S锁也叫共享锁,读锁,数据只能被读取不能被修改. 玩一下,上锁! lock table a read; 然后..... 只能读不能改,删,也不能增. Ⅱ.X锁 X锁也叫排他锁,写锁,一个事务对表加锁后,其他事务就不能对其进行加锁与增删查改操作. 设置手动提交,开启事务,上X锁. set autocmmmit=0; start transaction; lock table a write; 在开启另一个事务,使用select语句. set autocommit=0; start transaction; select * from a; 这里是阻塞select操作,因为一直都没释放X锁. 同样也不能再加锁,也是阻塞中. 回到原来那个加锁的事务,嗯,什么事也没有,正常读写. 释放锁后: unlock table; 在另一个事务中可以看到中断时间. (2) 乐观锁与悲观锁 Ⅰ.乐观锁 乐观锁就是总是假设是最好的情况,每次去操作的时候都不会上锁,但在更新时会判断有没有其他操作去更新这个数据,是一种宽松的加锁机制. mysql本身没有提供乐观锁的支持,需要自己来实现,常用的方法有版本控制和时间戳控制两种. 版本控制 版本控制就是为表增加一个version字段,读取数据时连同这个version字段一起读出来,之后进行更新操作,版本号加1,再将提交的数据的版本号与数据库中的版本号进行比较,若提交的数据的版本号大于数据库中的版本号才会进行更新. 举个例子,假设此时version=1,A进行操作,更新数据后version=2,与此同时B也进行操作,更新数据后version=2,A先完成操作,率先将数据库中的version设置为2,此时B提交,B的version与数据库中的version一样,不接受B的提交. 时间戳控制 时间戳控制与版本控制差不多,把version字段改为timestamp字段 还有一种实现方法叫CAS算法,这个作者不怎么了解,有兴趣可以自行搜索. Ⅱ.悲观锁 悲观锁就是总是假设最坏的情况,在整个数据处理状态中数据处于锁定状态,悲观锁的实现往往依靠数据库的锁机制.每次在拿到数据前都会上锁. mysql在调用一些语句时会上悲观锁,如(先关闭自动提交,开启事务): set autocommit=0; start transaction; 两个事务都这样操作,然后其中一个事务输入: select * from a where xxx for update; 在另一事务也这样输入: 这时语句会被阻塞,直到上锁的那个事务commit(解开悲观锁). 在另一事务中可以看到这个事务被阻塞了2.81s. *** lock in share mode. 也会加上悲观锁. 4 脏读,幻读,不可重复读与两类丢失更新 (1) 脏读 脏读是指一个事务读取到了另一事务未提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据,但没有提交,此时事务B却读取了,这时事务B就形成了脏读,一般事务A的后续操作是回滚,事务B读取到了临时数值. 事务A 事务B 开始事务 开始事务 更新X,旧值X=1,新值X=2 读取X,X=2(脏读) 回滚X=1 结束事务(X=1) 结束事务 (2) 幻读 幻读是指并不是指同一个事务执行两次相同的select语句得到的结果不同, 而是指select时不存在某记录,但准备插入时发现此记录已存在,无法插入,这就产生了幻读. 事务A 事务B 开始事务 开始事务 select某个数据为空,准备插入一个新数据 插入一个新数据 提交,结束事务 插入数据,发现插入失败,由于事务B已插入相同数据 结束事务 (3) 不可重复读 不可重复读指一个事务读取到了另一事务已提交的数据,造成select前后数据不一致. 比如事务A修改了一些数据并且提交了,此时事务B却读取了,这时事务B就形成了不可重复读. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交,结束事务 读取X=2 结束事务 (4) 第一类丢失更新 第一类丢失更新就是两个事务同时更新一个数据,一个事务更新完毕并提交后,另一个事务回滚,造成提交的更新丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 修改X=2 修改X=3 提交,结束事务 回滚 结束事务(X=1) X=1,X本应为提交的3 (5) 第二类丢失更新 第二类丢失更新就是两个事务同时更新一个数据,先更新的事务提交的数据会被后更新的事务提交的数据覆盖,即先更新的事务提交的数据丢失. 事务A 事务B 开始事务 开始事务 读取X=1 读取X=1 更新X=2 提交事务,X=2,结束 更新X=3 提交事务,X=3,事务A的更新丢失,结束 5 封锁协议与隔离级别 封锁协议就是在用X锁或S锁时制定的一些规则,比如锁的持续时间,锁的加锁时间等.不同的封锁协议对应不同的隔离级别.事务的隔离级别一共有4种,由低到高分别是Read uncommitted,Read committed,Repeatable read,Serializable,分别对应的相应的封锁协议等级. (1) 一级封锁协议 一级封锁协议对应的是Read uncommitted隔离级别,Read uncommitted,读未提交,一个事务可以读取另一个事务未提交的数据,这是最低的级别.一级封锁协议本质上是在事务修改数据之前加上X锁,直到事务结束后才释放,事务结束包括正常结束(commit)与非正常结束(rollback). 一级封锁协议不会造成更新丢失,但可能引发脏读,幻读,不可重复读. 设置手动提交与事务隔离等级为read uncommited,并开启事务(注意要先设置事务等级再开启事务). set autocommit=0; set session transaction isolation level read uncommitted; start transaction; (中间有一行打多了一个t可以忽略.....) a.引发脏读 在一个事务中修改表中的值,不提交,另一个事务可以select到未提交的值. 出现了脏读. b.引发幻读 在一个事务中插入一条数据,提交. 另一事务中select时没有,准备insert,但是insert时却提示已经存在.引发幻读. c.引发不可重复读 未操作提交前: 另一事务修改并提交: 再次读: 引发不可重复读. (2) 二级封锁协议 二级封锁协议本质上在一级协议的基础上(在修改数据时加X锁),在读数据时加上S锁,读完后立即释放S锁,可以避免脏读.但有可能出现不可重复读与幻读.二级封锁协议对应的是Read committed与Repeatable Read隔离级别. 先设置隔离等级 set session transaction isolation level read committed; Ⅰ.Read committed Read committed,读提交,读提交可以避免脏读,但可能出现幻读与不可重复读. a.避免脏读 开启一个事务并更新值,在这个事务中money=100(更新后) 另一事务中money为未更新前的值,这就避免了脏读. 注意,事实上脏读在read committed隔离级别下是不被允许的,但是mysql不会阻塞查询,而是返回未修改之前数据的备份,这种机制叫MVCC机制(多版本并发控制). b.引发幻读 在一个事务中插入数据并提交. 另一事务中不能插入&quot;不存在&quot;的数据,出现幻读. c.引发不可重复读 事务修改并提交前: 事务修改并提交: 出现不可重复读. Ⅱ.Repeatable read Repeatable read比Read committed严格一点,是Mysql的默认级别,读取过程更多地受到MVCC影响,可防止不可重复读与脏读,但仍有可能出现幻读. a.避免脏读 在一个事务中修改数据,不提交. 另一事务中两次select的结果都不变,没有出现脏读. b.避免不可重复读 一个事务修改数据并提交. 另一事务中select的结果没有发生改变,即没有出现不可重复读. c.引发幻读 同理,一个事务插入一条数据并提交. 另一个事务插入时出现幻读. (3) 三级封锁协议 三级封锁协议,在一级封锁协议的基础上(修改时加X锁),读数据时加上S锁(与二级类似),但是直到事务结束后才释放S锁,可以避免幻读,脏读与不可重复读.三级封锁协议对应的隔离级别是Serializable. 先设置Serializable隔离级别 set session transaction isolation level serializable a.避免脏读 设置事务隔离等级后开启事务并update,发现堵塞.从而避免了脏读. b.避免幻读 插入时直接阻塞,避免了幻读. c.避免不可重复读 在脏读的例子中可以知道,update会被堵塞,都不能提交事务,因此也避免了不可重复读. 6 两段锁协议 事务必须分为两个阶段对数据进行加锁与解锁,两端锁协议叫2PL(不是2PC),所有的加锁都在解锁之前进行. (1) 加锁 加锁会在更新或者 select *** for update *** lock in share mode 时进行 (2) 解锁 解锁在事务结束时进行,事务结束包括rollback与commit. 参考链接 1:ACID1 2:ACID2 3:mysql的锁1 4:乐观锁与悲观锁1 5:乐观锁与悲观锁2 6:乐观锁与悲观锁3 7:mysql修改事务隔离等级 8:mysql三级封锁与二段锁 9:数据库封锁协议 10:mysql事务隔离机制1 11:mysql事务隔离机制2 12:mysql幻读 13:mysql脏读,不可重复读与幻读 14:mysql两段锁1 15:mysql两段锁2 ","link":"https://2293736867.github.io/post/yi-wen-dai-ni-li-jie-zang-du-huan-du-bu-ke-chong-fu-du-yu-mysql-de-suo-shi-wu-ge-chi-ji-zhi/"},{"title":"android通过web与后台数据库交互","content":" 1.背景 2.开发环境 3.相关资源 4.配置开发环境 一. 安装Mysql8.0.17 (1) 下载mysql (2) 安装mysql (3) 启动服务 (4) 查看初始化密码,用于下一步设置自己的root密码 (5) 本地使用root登录 (6) 更改密码 (7) 允许外部访问 (8) 配置防火墙(可选) 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 (2) 连接到服务器,解压压缩包 (3) 修改tomcat默认端口(可选) (4) 启动tomcat (5) 测试 (6)开机启动 5.建库建表 (1) 创建user.sql (2) 导入到数据库 6.后端部分 (1) 创建项目 (2) 添加jar包 (3) 创建包与类 (4) 先来处理DBUtils类 (5) 接下来处理User类 (6) 接下来是UserDao (7) servlet包的SignIn与SignUp类 (8) 添加servlet到web.xml (9) 最后添加一个叫Hello.html的html文件用于测试. 7.打包发布 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (6) 添加Hello.html与web.xml (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 (9) 测试 8.前端页面部分 (1) 新建工程 (2) MainActivity.java (3) UserService.java (4) activity_main.xml 9.测试 (1) 注册测试 (2) 登录测试 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 (2) 网络权限问题 (3) 防火墙问题 (4) 使用HTTP注意事项 * * * 1 使用HTTPS * 2 修改默认的AndroidManifest.xml使其允许HTTP连接 (5) 线程问题 (6) AVD问题 11 最后 1.背景 开发一个app与后台数据库交互,基于mysql+jdbc+tomcat,没有使用DBUtils或jdbc框架,纯粹底层jdbc实现. 以后逐步改用Spring框架,优化mysql,进一步部署tomcat等等,现在项目刚刚起步,还有很多不懂的东西,得慢慢来...... 这几天踩了很多坑,说得夸张点真是踩到我没有知觉,希望能帮助别人少踩坑... 2.开发环境 系统 : win10 IDE : Android Studio 3.5.1,IntelliJ IDEA 2019.02 DBMS : Mysql 8.0.17 web服务器: tomcat9 3.相关资源 1.相关jar包: mysqlV8.0.17驱动(注意这个要与自己的mysql版本对应) java-servlet-api-V4.0.1 其他版本可以来这里搜索下载 Maven仓库 2.github 这是源码地址,包括前后端与建表等所有代码. (欢迎star) 3.码云 这也是源码地址 4.配置开发环境 IDE就不说了,重点说一下mysql与tomcat9的安装 一. 安装Mysql8.0.17 这个是目前比较新的mysql版本. 服务器系统是centos 其他系统安装看这里 win10 ubuntu fedroa reahat centos使用yum命令安装(参考链接) (1) 下载mysql sudo yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm (2) 安装mysql sudo yum install mysql-community-server (3) 启动服务 sudo service mysqld start (4) 查看初始化密码,用于下一步设置自己的root密码 sudo grep 'temporary password' /var/log/mysqld.log (5) 本地使用root登录 mysql -u root -p 输入上一步看到的密码 (6) 更改密码 alter mysql.user 'root'@'localhost' identified by 'password'; 注意新版本的mysql不能使用太弱的密码 如果出现如下提示 则说明密码太弱了,请使用一个更高强度的密码 (7) 允许外部访问 use mysql; update user set host='%' where user='root'; 这个可以根据自己的需要去修改,host='%'表明允许所有的ip登录,也可以设置特定的ip,若使用host='%'的话建议新建一个用户配置相应的权限. (8) 配置防火墙(可选) 由于作者使用的是阿里云的服务器,没配置防火墙的话远程连接不上,因此需要手动配置,如图 其中授权对象可以根据自己的需要更改,0.0.0.0/0表示允许所有的ip. 二.安装tomcat9 (1) 先去官网下载,下载后上传文件到服务器 作者使用的是scp命令,不会的可以看这里 scp apache-tomcat-xxxx.tar.gz username@xx.xx.xx.xx:/ 改成自己的用户名和ip (2) 连接到服务器,解压压缩包 mkdir /usr/local/tomcat mv apache-tomcat-xxxx.tar.gz /usr/local/tomcat tar -xzvf apache-tomcat-xxx.tar.gz (3) 修改tomcat默认端口(可选) 修改conf/server.xml文件,一般只需修改 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 中的8080端口,修改这个端口即可 这个懒的话(比如作者)可以不改 (4) 启动tomcat 运行bin目录下的startup.sh cd bin ./startup.sh (5) 测试 浏览器输入 服务器IP:端口 若出现 则表示成功. (6)开机启动 建议配置开机启动,修改/etc/rc.local文件 vim /etc/rc.local 添加 sh /usr/local/tomcat/bin/startup.sh 这个根据自己的tomcat安装路径修改,指定bin下的startup.sh即可 5.建库建表 创建用户表,这里简化操作(好吧我喜欢偷懒)就不创建新用户不授权了 这是一个在本地用root登录的示例,请根据实际情况创建并授权用户. (1) 创建user.sql CREATE DATABASE userinfo; USE userinfo; CREATE TABLE user ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NULL, password CHAR(30) NULL ); (2) 导入到数据库 mysql -u root -p &lt; user.sql 6.后端部分 (1) 创建项目 选择web application 选好路径,改好名字后finish (2) 添加jar包 创建一个叫lib的目录 添加两个jar包: mysql-connector-java-8.0.17.jar javax.servlet-api-4.0.1.jar 打开Project Structure Modules--&gt; + --&gt; JARs or directories 选择刚才新建的lib下的两个jar包 打勾,apply (3) 创建包与类 总共4个包 com.servlet 用于处理来自前端的请求,包含SignUp.java,SignIn.java com.util 主要功能是数据库连接,包含DBUtils.java com.entity 用户类,包含User.java com.dao 操作用户类的类,包含UserDao.java (4) 先来处理DBUtils类 这个是连接数据库的类,纯粹的底层jdbc实现,注意驱动版本. package com.util; import java.sql.*; public class DBUtils { private static Connection connection = null; public static Connection getConnection() { try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; connection = DriverManager.getConnection(url,usename,password); } catch (Exception e) { e.printStackTrace(); return null; } return connection; } public static void closeConnection() { if(connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 主要就是获取连接与关闭连接两个函数. String url = &quot;jdbc:mysql://127.0.0.1:3306/数据库名字&quot;; String usename = &quot;账号&quot;; String password = &quot;密码&quot;; 这几行根据自己的用户名,密码,服务器ip和库名修改 注意,mysql8.0以上使用的注册驱动的语句是 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 旧版的是 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 注意对应. (5) 接下来处理User类 User类比较简单,就是就三个字段与getter,setter package com.entity; public class User { private int id; private String name; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } (6) 接下来是UserDao package com.dao; import com.entity.User; import com.util.DBUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class UserDao { public boolean query(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;select * from user where name = ? and password = ?&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); ResultSet resultSet = preparedStatement.executeQuery(); return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } public boolean add(User user) { Connection connection = DBUtils.getConnection(); String sql = &quot;insert into user(name,password) values(?,?)&quot;; try { PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,user.getName()); preparedStatement.setString(2,user.getPassword()); preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; } catch (SQLException e) { e.printStackTrace(); return false; } finally { DBUtils.closeConnection(); } } } 主要就是查询与添加操作,查询操作中存在该用户就返回true,否则返回false 添加操作中使用executeUpdate()与getUpdateCount() != 0.注意不能直接使用 return preparedStatement.execute(); 去代替 preparedStatement.executeUpdate(); return preparedStatement.getUpdateCount() != 0; 咋一看好像没有什么问题,那天晚上我测试的时候问题可大了,android那边显示注册失败,但是数据库这边的却insert进去了.........我...... 好吧说多了都是泪,还是函数用得不够熟练. 一般来说select使用executeQuery() executeQuery()返回ResultSet,表示结果集,保存了select语句的执行结果,配合next()使用 delete,insert,update使用executeUpdate() executeUpdate()返回的是一个整数,表示受影响的行数,即delete,insert,update修改的行数,对于drop,create操作返回0 create,drop使用execute() execute()的返回值是这样的: 如果第一个结果是ResultSet对象,则返回true 如果第一个结果是更新计数或者没有结果则返回false 所以在这个例子中 return preparedStatement.execute(); 肯定返回false,所以才会数据库这边insert进去,但前端显示注册失败(这个bug作者找了很久......) (7) servlet包的SignIn与SignUp类 SingIn类用于处理登录,调用jdbc查看数据库是否有对应的用户 SignUp类用于处理注册,把user添加到数据库中 这两个使用的是http连接,后期作者会采用https加密连接. SignIn.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/SignIn&quot;) public class SingIn extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException, ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.query(user))//若查询失败 { httpServletResponse.sendError(204,&quot;query failed.&quot;);//设置204错误码与出错信息 } } } @WebServlet(&quot;/SignIn&quot;) 这行代码表示这是一个名字叫SignIn的servlet,可用于实现servlet与url的映射,如果不在这里添加这个注解,则需要在WEB-INF目录下的web.xml添加一个 &lt;servlet-mapping&gt; 叫servlet的映射 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 这行代码设置响应类型与编码 String name = httpServletRequest.getParameter(&quot;name&quot;); String password = httpServletRequest.getParameter(&quot;password&quot;); HttpServletRequest.getParameter(String name)方法表示根据name获取相应的参数 下面是SignUp.java package com.servlet; import com.dao.UserDao; import com.entity.User; import javax.servlet.annotation.*; import javax.servlet.http.*; import javax.servlet.*; import java.io.IOException; @WebServlet(&quot;/SignUp&quot;) public class SignUp extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { this.doPost(httpServletRequest,httpServletResponse); } @Override protected void doPost(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws IOException,ServletException { httpServletRequest.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//设定编码防止中文乱码 httpServletResponse.setContentType(&quot;text/plain;charset=utf-8&quot;);//设置相应类型为html,编码为utf-8 String name = httpServletRequest.getParameter(&quot;name&quot;);//根据name获取参数 String password = httpServletRequest.getParameter(&quot;password&quot;);//根据password获取参数 UserDao userDao = new UserDao(); User user = new User(); user.setName(name); user.setPassword(password); if(!userDao.add(user)) //若添加失败 { httpServletResponse.sendError(204,&quot;add failed.&quot;);//设置204错误码与出错信息 } } } (8) 添加servlet到web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SingIn&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;SignUp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.SignUp&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;/web-app&gt; 要把刚才创建的Servlet添加进web.xml,在&lt;servlet&gt;中添加子元素&lt;servlet-name&gt;与&lt;servlet-class&gt; &lt;servlet-name&gt;是Servlet的名字,最好与类名一致. &lt;servlet-class&gt;是Servlet类的位置. 如果在Servlet类中没有添加 @WebServlet(&quot;/xxxx&quot;) 这个注解,则需要在web.xml中添加 &lt;servlet-mapping&gt; &lt;servlet-name&gt;SignIn&lt;/servlet-name&gt; &lt;url-pattern&gt;/SignIn&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中&lt;servlet-name&gt;与&lt;servlet&gt;中的子元素&lt;servlet-name&gt;中的值一致 &lt;url-pattern&gt;是访问的路径 (9) 最后添加一个叫Hello.html的html文件用于测试. &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello web. &lt;/body&gt; &lt;/html&gt; 7.打包发布 作者用的是IDEA,Eclipse的打包请看这里 (1) 打开project structure (2) 选择Artifacts,Web Application:Archive (3) 改名字,创建WEB-INF目录与子目录classes (4) 选中classes,添加Module Output,选择自己的web项目 (5) 添加jar包,选中lib目录后添加jar包文件 (那个lib文件夹被挡住了.....) (6) 添加Hello.html与web.xml web.xml这个需要在WEB-INF目录里,Hello.html在WEB-INF外面 (7) 打包,Build-&gt;Build Artifacts (8) 上传到服务器 把打包好的.war文件上传到服务器的tomcat的/webapps目录下的 scp ***.war username@xxx.xxx.xxx.xxx:/usr/local/tomcat/webapps 注意改成自己的webapps目录. (9) 测试 在浏览器输入 服务器IP:端口/项目/Hello.html 作者是在本地上开了tomcat后测试的 8.前端页面部分 (1) 新建工程 (2) MainActivity.java package com.cx; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button signin = (Button) findViewById(R.id.signin); signin.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signIn(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); Button signup = (Button) findViewById(R.id.signup); signup.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String name = ((EditText) findViewById(R.id.etname)).getText().toString(); String password = ((EditText) findViewById(R.id.etpassword)).getText().toString(); if (UserService.signUp(name, password)) runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); } }); else { runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show(); } }); } } }); } } 没什么好说的,就为两个Button绑定事件,然后设置两个Toast提示信息. (3) UserService.java package com.cx; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; public class UserService { public static boolean signIn(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } public static boolean signUp(String name, String password) { MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); try { myThread.start(); myThread.join(); } catch (InterruptedException e) { e.printStackTrace(); } return myThread.getResult(); } } class MyThread extends Thread { private String path; private String name; private String password; private boolean result = false; public MyThread(String path,String name,String password) { this.path = path; this.name = name; this.password = password; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000);//设置连接超时时间 httpURLConnection.setReadTimeout(8000);//设置读取超时时间 httpURLConnection.setRequestMethod(&quot;POST&quot;);//设置请求方法,post String data = &quot;name=&quot; + URLEncoder.encode(name, &quot;utf-8&quot;) + &quot;&amp;password=&quot; + URLEncoder.encode(password, &quot;utf-8&quot;);//设置数据 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//设置响应类型 httpURLConnection.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;);//设置内容长度 httpURLConnection.setDoOutput(true);//允许输出 OutputStream outputStream = httpURLConnection.getOutputStream(); outputStream.write(data.getBytes(&quot;utf-8&quot;));//写入数据 result = (httpURLConnection.getResponseCode() == 200); } catch (Exception e) { e.printStackTrace(); } } public boolean getResult() { return result; } } MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignUp&quot;,name,password); MyThread myThread = new MyThread(&quot;http://本机IP:8080/cx/SignIn&quot;,name,password); 这两行换成自己的ip,本地ip的话可以用ipconfig或ifconfig查看,修改了默认端口的话也把端口一起改了. 路径的话就是 端口/web项目名/Servlet名 web项目名是再打成war包时设置的,Servlet名在web.xml中的&lt;servlet&gt;的子元素&lt;servlet-name&gt;设置,与java源码中的@WebServlet()注解中的一致 另外一个要注意的就是线程问题,需要新开一个线程进行http的连接 (4) activity_main.xml 前端页面部分很简单,就两个button,用于验证功能. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;用户名&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etname&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;密码&quot; /&gt; &lt;EditText android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:id=&quot;@+id/etpassword&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;注册&quot; android:id=&quot;@+id/signup&quot; /&gt; &lt;Button android:layout_width=&quot;120dp&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;登录&quot; android:id=&quot;@+id/signin&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 9.测试 (1) 注册测试 随便输入用户名与密码 查看数据库 这里没有加密保存,后期会添加加密保存 (2) 登录测试 perfect! 10.注意事项 (1) 数据库的用户名和密码一定要设置正确,要不然会这样提示 这个错误在加载驱动错误时也可能会出现这个错误,因此要确保打成war包时lib目录正确且jar包版本正确. 还有就是由于这个是jdbc的底层实现,注意手写的sql语句不能错 千万千万别像我这样: (2) 网络权限问题 这个需要在AndroidManifest.xml添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; (3) 防火墙问题 服务器的话一般会有相应的相应的网页界面配置,比如作者的是阿里云服务器,当然也可以手动配置iptables 修改/etc/sysconfig/iptables vim /etc/sysconfig/iptables 添加 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启iptables service iptables restart (4) 使用HTTP注意事项 由于从Android P开始,google默认要求使用加密连接,即要使用HTTPS,所以会禁止使用HTTP连接 使用HTTP连接时会出现以下异常 W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 两种建议: 1 使用HTTPS 2 修改默认的AndroidManifest.xml使其允许HTTP连接 在res下新建一个文件夹xml,创建一个叫network_security_config.xml的文件,文件内容如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt; &lt;/network-security-config&gt; 然后在AndroidMainfest.xml中加入 &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; /&gt; 即可 另一种办法是直接加入一句 android:usesCleartextTraffic=&quot;true&quot; &lt;application android:usesCleartextTraffic=&quot;true&quot; /&gt; (5) 线程问题 从android4.0开始,联网不能再主线程操作,万一网络不好就会卡死,所以有关联网的操作都需要新开一个线程,不能在主线程操作. (6) AVD问题 这个bug作者找了很久,http连接没问题,服务器没问题,数据库没问题,前端代码没问题,然后去了stackoverflow,发现是AVD的问题,我....... 简单来说就是卸载了再重启AVD,居然成功了..... 11 最后 作者小白一枚,有什么不对的地方请大家指正,评论作者会好好回复的.最后分享一首歌希望你们喜欢. 薛之谦-暧昧 参考网站 1.Android 通过Web服务器与Mysql数据库交互 2.Android高版本联网失败 3.IDEA 部署Web项目 4.PreparedStatement的executeQuery、executeUpdate和execute 5.preparedstatement execute()操作成功！但是返回false 6.HttpServletResponse(一) 7.HttpServletResponse(二) 8.HttpServletRequest 9.HttpUrlConnection 10.java.net.socketexception ","link":"https://2293736867.github.io/post/android-tong-guo-web-yu-hou-tai-shu-ju-ku-jiao-hu/"},{"title":"强大的工具(一):Capslock+","content":" 基本功能 高级功能 Capslock+利用了键盘少用的Capslock键,实现了很多强大的操作。 Capslock+是开源的，源码在Github上，点击这里查看，不强制收费。 官网:Capslock+官网 基本功能 光标移动 capslock+e 光标向上 capslock+d 光标向下 capslock+s 光标向左 capslock+f 光标向右 capslock+a 光标向左跳过一个词 capslock+g 光标向右跳过一个词 使用a和g时汉字可能会整句跳过 capslock+y 光标向上5行 capslock+b 光标向下5行 capslock+= 光标向下移动一页 capslock+- 光标向上移动一页 capslock+p 光标到行首 capslock+; 光标向行尾 光标选择 capslock+i 光标向上选中 capslock+k 光标向下选中 capslock+j 光标向左选中 capslock+l(是字母L的小写) 光标向右选中 capslock+h 光标向左选中一个词 capslock+n 光标向右选中一个词 与a、g一样，h和n对于汉字可能会选择整句 capslock+0 光标向上选中5行 capslock+m 光标向下选中5行 capslock+u 光标向行首选中 capslock+o 光标向行尾选中 插入符号 capslock+9 插入() capslock+[ 插入{} capslock+' 插入&quot;&quot; capslock+, 插入&lt;&gt; 以上4项在选中文本时插入到文本两侧 其他修改操作 capslock+w 等于Backspace capslock+r 等于delete capslock+Backspace 删除光标所在的一行 capslock+z 撤销 连续按下capslock+z会交替撤销与重做 capslock+space 等于Enter capslock+Enter 不论光标是否在行尾，直接换行 capslock+c capslock+x capslock+v 与ctrl+c独立的一套剪切板 当选中文字时，对所选的文字操作 不选中文字时，对光标所在行的文字进行操作 翻译 capslock+t 翻译，默认使用有道翻译，可以选中或不选中翻译 不选中的话，若光标在整个句子或整个单词的右侧，或者光标在句子或单词的中间时，可以翻译光标所在的句子或单词 光标在句子或单词的左侧时，会翻译上一个句子或单词 建议英文不选中翻译，中文选中翻译 注意 1.翻译的面板可以修改，重新输入后按Enter可继续翻译 2.获取单词发送通过ctrl+c实现，请确保按下capslock+t的时候ctrl+c不会有额外操作 3.翻译功能通过有道API实现，请求频率限制为每小时1000次，也就是所有使用该翻译功能的人一小时内翻译次数不能超过1000次，突破限制的方法在下面介绍 与LAlt(左边的Alt键)结合 临时改变鼠标速度 按住capslock+LAlt可临时改变鼠标的速度，按住capslock+LAlt再配合滚轮上下滚动可以增加或减慢速度，一般是先配合滚轮设定速度，松开LAlt与capslock后再一起按从而临时改变速度 切换不同窗口 capslock+LAlt+e 切换当前窗口上面的窗口 capslock+LAlt+d 切换当前窗口下面的窗口 capslock+LAlt+s 切换当前窗口左边的窗口 capslock+LAlt+f 切换当前窗口右边的窗口 capslock+LAlt+a 切换当前窗口最左侧的窗口 capslock+LAlt+g 切换当前窗口最右侧的窗口 对窗口位置的判定是以当前窗口的横竖中线为依据 快速打开/关闭窗口 capslock+LAlt+j 把当前窗口最小化且记录当前窗口为capslock+LAlt+l(小写L)即将打开的窗口 capslock+LAlt+k 把当前窗口最小化且记录当前窗口为capslock+LAlt+l最后一个打开的窗口 这与队列差不多，capslock+LAlt+j把窗口放进队首，capslock+LAlt+k把窗口放进队尾 capslock+LAlt+l 打开队列中的第一个窗口，并将其移出队列 capslock+LAlt+h 清楚窗口队列的记录 切换标签 capslock+LAlt+w 等于ctrl+shift+tab capslock+LAlt+r 等于ctrl+tab 模拟光标滚动 capslock+LAlt+y 页面向上移动5行，光标不动 capslock+LAlt+b 页面向下移动5行，光标不动 capslock+LAlt+- 光标移动到页首 capslock+LAlt+= 光标移动到页尾 第三套剪切板 ctrl+x/c/v为第一套，capslock+x/c/v为第二套，capslock+LAlt+x/c/v为第三套 当选中文字时复制文字，不选中文字时复制光标所在行的文字 capslock+F12可关闭独立剪切板的功能，关闭后capslock+x/c/v与capslock+LAlt+x/c/v失效，capslock+F12可重新开启 F1-F6的功能 capslock+F1 打开帮助文档网页 capslock+F2 弹出计算面板 在计算面版被激活的情况下，若切换为大写，主键盘一部分被替换成小键盘，对应关系如下 u-----------8 i-----------9 o----------0 p-----------* [---------------/ j------------4 k----------5 l----------6 ;------------+ '---------------(减号) m----------1 ,-----------2 .-----------3 space----0 RAlt----------. shift+Enter会将计算结果输出到下一行，ctrl+Enter或capslock+space为换行 capslock+F3 下一首歌 capslock+F4 短按时将窗口变为半透明 长按时配合滚轮改变透明度 若当前窗口的透明度，不是完全不透明，或不是半透明，则先将窗口变为完全不透明 capslock+F5 重载capslock+ capslock+F6 置顶/解除置顶一个窗口，即若该窗口不是处于置顶的状态，则将该窗口置顶，若窗口处于置顶的状态，则解除窗口的置顶状态 高级功能 CapsLock+settings.ini中的[Global]全局设置 loadScript:要加载的JS文件(要放在loadScript文件夹里)，用逗号分隔 allowClipboard:是否允许使用独立剪切板，1为是，0为否，默认1 mouseSpeed:按下capslock+LAlt时鼠标的速度，范围1-20，默认3 autostart:是否开机启动，1为是，0为否，默认0 loadingAnimation:是否开启程序加载动画，1为是，0为否，默认1 capslock+Tab:补全+计算 1.补全 这个补全其实是将某一字符串替换成你自定义的字符串，需要在capslock+的位置下的CapsLock+settings.ini中进行设置 CapsLock+settings.ini中有三个字段有字符串替换功能，分别是[TabHotString]、[QRun]与[QWeb]，优先级是[TabHotString]&gt;[QRun]&gt;[QWeb]，也就是如果三个字段下都有相同的键名，会按优先级顺序替换，但最好不要重复键名，替换的最好都在[TabHotString]中设置 格式为:键名 = 要替换的字符串 2.计算(对于比较严格的计算，如金钱计算，慎用) 计算其实是运行相应的JavaScript代码，处理的是光标左边的字符，直到遇到第一个空格或行首，之间的字符串会被认为是表达式 当表达式不带=时，会替换掉原来的表达式，当表达式带=时，将结果输出到=右侧，计算不出结果时返回? 若表达式带有空格，则要先选中表达式或在表达式头部加上`，若表达式在跨越多行只能选中 用JS自定义函数 首先要编写自己的.js文件，把它放到capslock+文件夹下的loadScript文件夹，然后在CapsLock+settings.ini中的[Global]中，在loadScript=scriptDemo.js后面加上,在加上自己的js文件名，保存，capslock+F5重载capslock+，然后就可以使用了 scriptDemo.js中有一些定义好的函数和事例，可以参照一下 比如说我自己写的my.js中包含了如下两个函数(我不太会JS...以下只是模仿别人写的) 然后... 如果直接打函数名字的话会出现函数的源代码 还可以对多行字符串使用字符串函数，但要先选中 翻译的高级设置 由于有道API每小时只能翻译1000次，想要更多请前往有道智云申请一个独立的Key， 申请到后把key写进capslock+安装目录下的CapsLock+settings.ini下的[TTranslate]段 免费版的填apiType=0 apiKey=xxxx(你申请的key) KeyFrom=xxxx 收费版的填apiType=1 apiKey=xxxx(你申请的key) 窗口绑定 窗口绑定有三种模式： 第一种：直接绑定 capslock+LAlt+1-8,把当前的窗口绑定到相应按键 然后capslock+1-8，会激活绑定到相应按键的窗口 （1-8，capslock+9是插入括号，capslock+0是向上选中5行） 若当前窗口不是绑定的窗口则先切换到按键绑定的窗口，若当前窗口是按键绑定的窗口，则会最小化该窗口，或从最小化复原 另外，capslock+LAlt+反单引号(`，主键盘区数字1左边)也可绑定窗口，激活时capslock+反单引号 第二种：绑定多个窗口到同一按键（按两次） 先选中某一个窗口，capslock+LAlt+1绑定（按两次1），在选中另一个窗口后，再capslock+LAlt+两次1，然后capslock+1会按绑定次序打开窗口，多次按下时类似用Alt+tab切换绑定的窗口，会优先打开最常使用的窗口 第三种：把当前窗口所属程序的所有窗口绑定（按三次） 比如你打开了3个txt，切换到三个txt之一后，按capslock+LAlt+1（按三次1），然后三个txt都被绑定到capslock+1上，然后按capslock+1会在这三个txt之间切换，类似于Alt+tab，也会优先打开最常用的窗口 模式三类似于模式二，模式二可对不同程序的窗口绑定到同一按键，要分别绑定，模式三对同一程序的所有窗口绑定，只需绑定一次 Qbar Qbar是按capslock+q弹出的框，可以方便地浏览文件、打开文件、与打开网页或是用引擎搜索，Esc可关闭，重新按capslock+q可获得焦点，选中字符后按capslock+q会自动填入，选中文件会将路径填入。 输入cl set可以设置CapsLock+settings.ini文件 Qbar还能使用通配符，?表示单个，表示多个，如a?b匹配aab，abb，acb，adb等 ab匹配abb,abbb,accb等(不区分大小写) 可以按/或\\或tab进入下一层文件夹，按capslock+,返回上一层 Qbar中的QRun 可以在CapsLock+settings.ini中的[QRun]下添加想要快速运行的程序，只需在Qbar中键入相应名字即可，也可直接在Qbar中使用&quot; -&gt;run &quot;来设定，格式为： xxx -&gt; xxx 或 xxx -&gt;run xxx 注意第一种-&gt;两旁有空格，第二种-&gt;前面有空格，后面紧接run，run后面有空格 QRun也可设定用来打开文件的程序，比如在[QRun]下有aa = &quot;xxxx/xxx.exe&quot;，bb = &quot;xxx/xxxx&quot;，就会用aa打开bb Qbar中的QSearch 这个可以用搜索引擎快速搜索，内置了bd(百度)，wk（维基），g（谷歌），m（MDN），tb（淘宝），默认为百度 当然可以自定义... 例如改变默认搜索引擎，在CapsLock+settings.ini中的[QSearch]添加default=xxxxx) 也可以直接在Qbar中default -&gt; xxxx 这需要通过网址定位到搜索的关键词，并将关键词修改成{q} 添加自己的搜索引擎类似，CapsLock+settings.ini中的[QSearch]中添加，或在Qbar中使用 -&gt;search 添加 Qbar中的QWeb 打开网站，直接输入网址即可，可以在Qbar中使用-&gt;web 定义，也可在CapsLock+settings.ini中的[QWeb]下定义，xxx = xxxx ctrl+Enter可在前面加www.，后面加.com，如输入taobao，ctrl+Enter会打开www.taobao.com，对于含有.net，.com，.org，www.，http://，https://可以直接当作网址打开而不是用默认引擎去搜索，一些特定的网站可以加上web xxxx打开 自定义Qbar的样式 在CapsLock+settings.ini中的[QStyle]下设置 颜色可以是指定16种HTML基础颜色之一或6位的RGB颜色值(0x前缀可以省略)。例如：red、ffffaa、FFFFAA、0xFFFFAA。下面的颜色设置也一样。 borderBackgroundColor-----背景颜色，默认red borderRadius-------------------边框四角圆角程度，默认9 textBackgroundColor---------文字输入框的背景颜色，默认green textColor-------------------------输入文字的颜色，默认ffffff，白色 editFontName------------------输入文字的字体，默认Hiragino Sans GB W6 editFontSize--------------------输入文字大小，默认12 listFontName-------------------提示列表字体，默认consoals listFontSize---------------------提示列表字体大小，默认10 listBackgroundColor----------提示列表背景颜色，默认blue listColor--------------------------提示列表文字颜色，默认0x000000 listCount-------------------------提示列表行数，默认5 lineHeight-----------------------提示列表每行高度，默认19 progressColor------------------进度条颜色，默认0x00cc99 比如这是我的Qbar（好丑，对不对，好像比默认的还。。。） 自定义某些按键 在CapsLock+settings.ini中的[Keys]下可以改变一些capslock+按键的功能，也可以增加一些按键，capslock+支持的按键有: Capslock + (LALt + ) F1~F12 Capslock + (LALt + ) 0~9 Capslock + (LALt + ) a~z Capslock + (LALt + ) -=[];',./ Capslock + (LALt + ) Backspace, Tab, Enter, Space, RAlt keyFunc_volumeMute 静音 keyFunc_volumeDown 音量增大 keyFunc_volumeUp 音量减少 keyFunc_mediaPrev 上一首 keyFunc_mediaPlayPause 播放/暂停 以caps_开头，字母用小写表示，F1-F12用f1-f12表示，LALt用lalt表示，键位以keyFunc_开头，如caps_j=keyFunc_selectLeft，具体可用capslock+q输入cl CapsLock+settingsDemo.ini中查看 比如在CapsLock+settings.ini中的[Keys]下添加了caps_lalt_9=keyFunc_volumeMut，则按capslock+LAlt+9可以静音 ------------------------------------------------没有了---------------------------------------------------------- 这基本上就是capslock+的所有功能了，作者好像不怎么更新了，最新的版本是16年的 有一个问题就是其实capslock+e/d/s/f并不能完全代替上下左右的方向键，比如Alt+←是后退，但Alt+capslcok+s没有任何反应，当上下左右和其他键联合使用capslock还不能代替 ","link":"https://2293736867.github.io/post/qiang-da-de-gong-ju-yi-capslock/"}]}