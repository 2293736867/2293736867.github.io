<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-08-08T02:30:14.582Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第58期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-58-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-58-qi/">
        </link>
        <updated>2020-08-13T16:42:48.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596852564005.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你就是个土豆思，又土又逗，又屌丝。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>1914年至1925年之间，伏特加的生产和销售在俄罗斯遭到禁止。沙皇之所以颁布此法令，是为了辅助动员俄罗斯参加第一次世界大战。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>最爱湖东行不足，绿杨阴里白沙堤。<br>
——白居易《钱塘湖春行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>谎话被歌颂，扮清醒的人作哑装聋。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=416966041">几度梦回大唐-深七</a></p>
</blockquote>
<blockquote>
<p>几度梦回大唐<br>
心中无限凄凉<br>
昔日王者断肠<br>
我弯弓齐射天狼<br>
苍穹一轮朱轮回<br>
我看破轮回梦相随<br>
随风逐浪霸天国<br>
那生死轮回震天锤<br>
这一次我踏入语音<br>
手持神兵天魔琴<br>
我这一生独步武林<br>
其实另类似龙吟<br>
昔日将你打入深渊<br>
随这时光的变迁<br>
青龙火凤盘双肩<br>
尽日我定杀破天<br>
三届之中听我号令<br>
携带神兵昆仑镜<br>
势必拿下二郎狗命<br>
还我帝都的安宁<br>
违抗王者命<br>
杀<br>
犯上作乱者<br>
杀<br>
不忠不孝者<br>
杀<br>
不仁不义者<br>
杀<br>
望九幽<br>
魔战群仙<br>
销毁挥霍写诗篇<br>
看天下我烽火狼烟<br>
让我孤身斗苍天<br>
王道没有那么短<br>
苍天在为我逆转<br>
这一次我要重返<br>
天下为我来呐喊<br>
就算如今一人走<br>
不会提到我怒吼<br>
当我站在暴风口<br>
是否还会牵我手</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第57期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-57-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-57-qi/">
        </link>
        <updated>2020-08-12T16:42:28.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596852501344.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你们之所以喝鸡汤，是因为肉被别人吃光了。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>2016年，一名英国男子为一部长达十小时的油漆风干视频众筹了资金，以此迫使英国电影分类委员会（BBFC）观看该电影，这是对BBFC要求独立电影制片人为每次提交审核支付1000英镑的抗议。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>桃花尽日随流水，洞在清溪何处边。<br>
——张旭《桃花溪》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>当你手里有了锤子，那么敌人就是钉子。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1294910382">我的将军啊-半阳</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1596851751281.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>狼烟风沙口<br>
还请将军少饮酒<br>
前方的路不好走<br>
我在家中来等候<br>
可愿柳下走<br>
满头杨画共白首<br>
十两相思二两酒<br>
我才把爱说出口</p>
</blockquote>
<blockquote>
<p>狼烟风沙口<br>
还请将军少饮酒<br>
前方的路不好走<br>
我在家中来等候<br>
可愿柳下走<br>
满头杨花共白首<br>
十两相思二两酒<br>
我才把爱说出口</p>
</blockquote>
<blockquote>
<p>他一路凶险一路漂泊<br>
从未安静过活<br>
也受过挫折依旧执着<br>
也曾信仰过佛<br>
她风月佳人傲骨温存<br>
似桃花般撩人<br>
也曾有座坟住着亡人<br>
她说她不信神<br>
可她等了有三载<br>
她等到碧落沧海<br>
她等到四季交换<br>
她依旧死不悔改<br>
她口口声声和雪中<br>
只手掌着孤灯<br>
她醉醉疯疯渺渺空空<br>
终日敲着佛钟</p>
</blockquote>
<blockquote>
<p>她诵经<br>
她敲钟<br>
她扑空<br>
她成疯<br>
水成冰<br>
风无声<br>
雪冻松<br>
她寿终<br>
她最后也没等到他<br>
他最后也没回家<br>
她见到一朵彼岸花<br>
她却说那好像他</p>
</blockquote>
<blockquote>
<p>我的将军啊<br>
你究竟去了哪啊<br>
你说你去把敌杀啊<br>
何故你不回家<br>
我的英雄啊<br>
你爱上别人了吗<br>
如果是的告诉我吧<br>
让我随风飘吧</p>
</blockquote>
<blockquote>
<p>狼烟风沙口<br>
还请将军少饮酒<br>
前方的路不好走<br>
我在家中来等候<br>
可愿柳下走<br>
满头杨花共白首<br>
十两相思二两酒<br>
我才把爱说出口</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第56期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-56-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-56-qi/">
        </link>
        <updated>2020-08-11T16:42:02.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596819654121.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>两个人吵架，打他是解决不了问题的，但是解气啊。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>2016年，现存最老的闰年婴儿Daisy Belle Ward在她诞辰100周年时庆祝了自己的25岁生日。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>阴阴夏木啭黄鹂，何处飞来白鹭立移时。</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>结局需要的是一个开始。<br>
没开始说什么都是废话。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1313558186">一曲相思-半阳</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1596851689999.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>这人间袅袅炊烟<br>
和风花雪月浪漫<br>
痴情人多半贪恋<br>
爱恨情仇都好看<br>
又让你痛不欲生<br>
又让你趁醉装疯<br>
终有天脱胎换骨<br>
直到哭着笑才懂</p>
</blockquote>
<blockquote>
<p>欲问青天<br>
这人生有几何<br>
怕这去日苦多<br>
往事讨一杯相思喝<br>
倘若这回还像曾经执着<br>
心执念你一个<br>
那我可能是多情了</p>
</blockquote>
<blockquote>
<p>浊酒一杯<br>
余生不悲不喜<br>
何俱爱恨别离<br>
一路纵马去斟酌<br>
一曲相思<br>
入江水与山河<br>
在油伞下走过<br>
悠然入梦却恍若昨</p>
</blockquote>
<blockquote>
<p>这人间袅袅炊烟<br>
和风花雪月浪漫<br>
痴情人多半贪恋<br>
爱恨情仇都好看<br>
又让你痛不欲生<br>
又让你趁醉装疯<br>
终有天脱胎换骨<br>
直到哭着笑才懂</p>
</blockquote>
<blockquote>
<p>欲问青天<br>
这人生有几何<br>
怕这去日苦多<br>
往事讨一杯相思喝<br>
倘若这回<br>
还像曾经执着<br>
心执念你一个<br>
那我可能是多情了</p>
</blockquote>
<blockquote>
<p>浊酒一杯<br>
余生不悲不喜<br>
何俱爱恨别离<br>
一路纵马去斟酌<br>
一曲相思<br>
入江水与山河<br>
在油伞下走过<br>
悠然入梦却恍若昨</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第55期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-55-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-55-qi/">
        </link>
        <updated>2020-08-10T16:41:45.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596819637415.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>考试真是so easy，哪里不会考哪里！</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>根据一项研究表明，观看高质量的电视剧可以提高你的情商，并增强你读懂他人情绪的能力。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>多少恨，昨夜梦魂中。<br>
——李煜《忆江南·多少恨》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>——什么是孤独？<br>
——心里明明空荡荡的，却什么也装不下。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=36861903">芳华绝代-梅艳芳/张国荣</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1596820611901.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>你想不想<br>
吻一吻<br>
倾国倾城<br>
是我大名</p>
</blockquote>
<blockquote>
<p>蒙罗丽莎<br>
只是一幅画<br>
如何艳压天下<br>
皇朝外的<br>
伊莉莎白<br>
谁来跪拜她</p>
</blockquote>
<blockquote>
<p>梦露若果<br>
庄重高雅<br>
何来绝世佳话<br>
红颜祸水<br>
锦上添花<br>
教你荡产倾家</p>
</blockquote>
<blockquote>
<p>唯独是<br>
天资国色<br>
不可一世<br>
天生我高贵艳丽到底<br>
颠倒众生<br>
吹灰不费<br>
收你做我的迷</p>
</blockquote>
<blockquote>
<p>你敢不敢<br>
抱一抱<br>
疯魔一时<br>
是我罪名</p>
</blockquote>
<blockquote>
<p>罗兰自称<br>
芳名苏菲亚<br>
男孩就会倒下<br>
如能获得<br>
芭铎亲一下<br>
铁塔亦会垮</p>
</blockquote>
<blockquote>
<p>怕你甚么<br>
称王称霸<br>
来臣服我之下<br>
银河艳星<br>
单人匹马<br>
胜过漫天烟花</p>
</blockquote>
<blockquote>
<p>唯独是<br>
天资国色<br>
不可一世<br>
天生我高贵艳丽到底<br>
颠倒众生<br>
吹灰不费<br>
收你做我的迷<br>
唯独是<br>
天资国色<br>
不可一世<br>
天生我高贵艳丽到底<br>
得我艳与天齐</p>
</blockquote>
<blockquote>
<p>唯独是<br>
天资国色<br>
不可一世<br>
天生我高贵艳丽到底<br>
颠倒众生<br>
吹灰不费<br>
收你做我的迷<br>
唯独是<br>
天资国色<br>
不可一世<br>
天生我高贵艳丽到底<br>
颠倒众生<br>
吹灰不费<br>
得我艳与天齐</p>
</blockquote>
<blockquote>
<p>你想不想吻一吻<br>
倾国倾城<br>
是我大名</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1596820619374.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第54期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-54-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-54-qi/">
        </link>
        <updated>2020-08-09T16:41:12.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596819532703.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我生平最讨厌一个字，略！尤其是题不会做时。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>自1950年以来，美国共发生了32起核武器事故，这些事故被称为“断箭”，其中多达6枚核弹已经丢失并且下落不明。前苏联丢失了41枚，找回数量不详。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>料得年年场断处，明月夜，短松冈。<br>
——苏轼《江城子 乙卯正月二十日记梦》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>黎明前的黑暗，是最深不见底的黑暗。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1336228739">卜卦-崔子格</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1596819458098.jpeg" alt="" loading="lazy"></figure>
<blockquote>
<p>风吹沙蝶恋花千古佳话<br>
似水中月情迷着镜中花<br>
竹篱笆木琵琶拱桥月下<br>
谁在弹唱思念远方牵挂<br>
那年仲夏你背上行囊离开家<br>
古道旁我欲语泪先下<br>
庙里求签我哭诉青梅等竹马<br>
求菩萨保佑我俩</p>
</blockquote>
<blockquote>
<p>不停的猜猜猜又卜了一卦<br>
吉凶祸福还是担惊受怕<br>
对你的爱爱爱望断了天涯<br>
造化弄人缘分阴错阳差</p>
</blockquote>
<blockquote>
<p>风吹沙蝶恋花千古佳话<br>
似水中月情迷着镜中花<br>
竹篱笆木琵琶拱桥月下<br>
谁在弹唱思念远方牵挂<br>
那年仲夏你背上行囊离开家<br>
古道旁我欲语泪先下<br>
庙里求签我哭诉青梅等竹马<br>
求菩萨保佑我俩</p>
</blockquote>
<blockquote>
<p>不停的猜猜猜又卜了一卦<br>
吉凶祸福还是担惊受怕<br>
造化弄人缘分阴错阳差<br>
猜猜猜又卜了一卦<br>
是上上签可还是放不下<br>
对你的爱爱爱挨过几个冬夏<br>
日夜思念求别再变卦</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1596819464620.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第53期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-53-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-53-qi/">
        </link>
        <updated>2020-08-09T08:44:57.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789926856.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>假期定了个Plan，半个暑假结束了只完成了P，因为lan。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>科学家们认为，西伯利亚北方森林中的云杉和松树之所以可在-60摄氏度的温度下存活，是因为其树木组织可以通过“硬化”过程的一部分变成玻璃。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>昨夜个人曾有约，严城玉漏三更。<br>
——纳兰性德《临江仙·昨夜个人曾有约》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>前进吧，星星在你的头上闪耀哦！</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1376142151">无名之辈-陈雪燃</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1596818240381.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>城市黎明的灯火<br>
总有光环在陨落<br>
模仿者一个又一个<br>
无人问津的角色<br>
你选择去崇拜谁呢<br>
怨恨谁呢</p>
</blockquote>
<blockquote>
<p>假装热情的冷落<br>
假装自由的枷锁<br>
你最后成为了什么<br>
燃烧华丽的烟火<br>
绽放一次就足够了<br>
奢求什么</p>
</blockquote>
<blockquote>
<p>无名之辈<br>
我是谁<br>
忘了谁<br>
也无所谓<br>
谁不是<br>
拼了命走到生命的结尾<br>
也许很累一身狼狈<br>
也许卑微一生无为<br>
也许永远成为不了<br>
你的光辉</p>
</blockquote>
<blockquote>
<p>无名之辈<br>
我是谁<br>
忘了谁<br>
也无所谓<br>
继续追<br>
谁的光荣不是伴着眼泪<br>
也许很累一身狼狈<br>
也许卑微一生无为<br>
谁生来不都是一样<br>
尽管叫我无名之辈</p>
</blockquote>
<blockquote>
<p>假装热情的冷落<br>
假装自由的枷锁<br>
你最后成为了什么<br>
燃烧华丽的烟火<br>
绽放一次就足够了<br>
奢求什么</p>
</blockquote>
<blockquote>
<p>无名之辈<br>
我是谁<br>
忘了谁<br>
也无所谓<br>
谁不是<br>
拼了命走到生命的结尾<br>
也许很累一身狼狈<br>
也许卑微一生无为<br>
也许永远也成为不了谁</p>
</blockquote>
<blockquote>
<p>无名之辈<br>
我是谁<br>
忘了谁<br>
也无所谓<br>
继续追<br>
谁的光荣不是伴着眼泪<br>
也许很累一身狼狈<br>
也许卑微一生无为<br>
谁生来不都是一样<br>
尽管叫我无名之辈</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第52期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-52-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-52-qi/">
        </link>
        <updated>2020-08-08T08:44:06.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789873416.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>哪有什么感同身受的心，全是站着说话不腰疼的嘴。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>咖啡在土耳其文化中无比重要，以至于根据15世纪的法律规定，如果丈夫无法为自己提供足够的咖啡，则妻子有权与其丈夫离婚。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>谁家今夜扁舟子，何处相思明月楼？<br>
——张若虚《春江花月夜》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>人没有回忆是无法活下去的哟</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://y.qq.com/n/yqq/song/001M3ReL41hPEW.html">维也纳的忧伤-钟洁</a></p>
</blockquote>
<blockquote>
<p>维也纳的忧伤随着河静静流淌<br>
我把心事写在了信纸上<br>
折成船飘向远方<br>
维也纳的广场夜晚下显得悲凉<br>
我用泪光记叙这段感伤<br>
一直哭到了天亮</p>
</blockquote>
<blockquote>
<p>静止的雕像<br>
仿佛诉说着过往<br>
表情上略带几分忧伤<br>
是否曾经很迷茫<br>
墙上的石板画<br>
记录那一段时光<br>
没能牵住恋人的双手<br>
从此走向了绝望<br>
忧郁的目光<br>
显得安静而端详<br>
隐约听到华丽的乐章<br>
随着琴声在远望<br>
旧旧的琴房<br>
月光洒在了琴上<br>
看见弹奏夜曲的肖邦<br>
忧伤被悄悄释放</p>
</blockquote>
<blockquote>
<p>维也纳的忧伤随着河静静流淌<br>
我把心事写在了信纸上<br>
折成船飘向远方<br>
维也纳的广场夜晚下显得悲凉<br>
我用泪光记叙这段感伤<br>
一直哭到了天亮</p>
</blockquote>
<blockquote>
<p>静止的雕像<br>
仿佛诉说着过往<br>
表情上略带几分忧伤<br>
是否曾经很迷茫<br>
墙上的石板画<br>
记录那一段时光<br>
没能牵住恋人的双手<br>
从此走向了绝望</p>
</blockquote>
<blockquote>
<p>忧郁的目光<br>
显得安静而端详<br>
隐约听到华丽的乐章<br>
随着琴声在远望<br>
旧旧的琴房<br>
月光洒在了琴上<br>
看见弹奏夜曲的肖邦</p>
</blockquote>
<blockquote>
<p>哦<br>
忧郁的目光<br>
显得安静而端详<br>
隐约听到华丽的乐章<br>
随着琴声在远望<br>
旧旧的琴房<br>
月光洒在了钢琴上<br>
看见弹奏夜曲的肖邦<br>
忧伤被悄悄释放</p>
</blockquote>
<blockquote>
<p>维也纳的忧伤随着河静静流淌<br>
我把心事写在了信纸上<br>
折成船飘向远方<br>
维也纳的广场夜晚下显得悲凉<br>
我用泪光记叙这段感伤<br>
一直哭到了天亮</p>
</blockquote>
<blockquote>
<p>维也纳的忧伤随着河静静流淌<br>
我把心事写在了信纸上<br>
折成船飘向远方<br>
维也纳的广场夜晚下显得悲凉<br>
我用泪光记叙这段感伤</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoF设计模式合集]]></title>
        <id>https://2293736867.github.io/post/gof-she-ji-mo-shi-he-ji/</id>
        <link href="https://2293736867.github.io/post/gof-she-ji-mo-shi-he-ji/">
        </link>
        <updated>2020-08-07T09:28:37.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E5%9F%BA%E7%A1%80">2 基础</a>
<ul>
<li><a href="#21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">2.1 设计模式概述</a></li>
<li><a href="#22-uml%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">2.2 UML与面向对象设计原则</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">3 创建型模式</a>
<ul>
<li><a href="#31-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">3.1 单例模式</a></li>
<li><a href="#32-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">3.2 简单工厂模式</a></li>
<li><a href="#33-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">3.3 工厂方法模式</a></li>
<li><a href="#34-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">3.4 抽象工厂模式</a></li>
<li><a href="#35-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">3.5 原型模式</a></li>
<li><a href="#36-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">3.6 建造者模式</a></li>
</ul>
</li>
<li><a href="#4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">4 结构型模式</a>
<ul>
<li><a href="#41-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">4.1 适配器模式</a></li>
<li><a href="#42-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">4.2 桥接模式</a></li>
<li><a href="#43-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">4.3 组合模式</a></li>
<li><a href="#44-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">4.4 装饰模式</a></li>
<li><a href="#45-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">4.5 外观模式</a></li>
<li><a href="#46-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">4.6 享元模式</a></li>
<li><a href="#47-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">4.7 代理模式</a></li>
</ul>
</li>
<li><a href="#5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">5 行为型模式</a>
<ul>
<li><a href="#51-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">5.1 职责链模式</a></li>
<li><a href="#52-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">5.2 命令模式</a></li>
<li><a href="#53-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">5.3 解释器模式</a></li>
<li><a href="#54-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">5.4 迭代器模式</a></li>
<li><a href="#55-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">5.5 中介者模式</a></li>
<li><a href="#56-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">5.6 备忘录模式</a></li>
<li><a href="#57-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">5.7 观察者模式</a></li>
<li><a href="#58-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">5.8 状态模式</a></li>
<li><a href="#59-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">5.9 策略模式</a></li>
<li><a href="#510-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">5.10 模板方法模式</a></li>
<li><a href="#511-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">5.11 访问者模式</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>这篇文章是对GoF23种设计模式+1种非GoF模式的合集，由笔者自己的笔记整理而来，每个模式都详细描述了步骤，角色等，以及使用Java实现的具体的例子。</p>
<h1 id="2-基础">2 基础</h1>
<h2 id="21-设计模式概述">2.1 <a href="https://www.bingling.site/post/she-ji-mo-shi-xue-xi-bi-ji-yi-she-ji-mo-shi/">设计模式概述</a></h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200728163506210.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="22-uml与面向对象设计原则">2.2 <a href="https://www.bingling.site/post/she-ji-mo-shi-xue-xi-bi-ji-er-uml-yu-mian-xiang-dui-xiang-she-ji-yuan-ze/">UML与面向对象设计原则</a></h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200711005605808.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711094651100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-创建型模式">3 创建型模式</h1>
<h2 id="31-单例模式">3.1 <a href="https://www.bingling.site/post/she-ji-mo-shi-xue-xi-bi-ji-san-dan-li-mo-shi/">单例模式</a></h2>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200728163932717.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-简单工厂模式">3.2 <a href="https://www.bingling.site/post/she-ji-mo-shi-xue-xi-bi-ji-si-jian-dan-gong-han-mo-shi/">简单工厂模式</a></h2>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200728175216328.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-工厂方法模式">3.3 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi/">工厂方法模式</a></h2>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200728202541743.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="34-抽象工厂模式">3.4 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-liu-chou-xiang-gong-han-mo-shi/">抽象工厂模式</a></h2>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200728225937668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="35-原型模式">3.5 <a href="https://2293736867.github.io/post/she-ji-mo-shi-qi-yuan-xing-mo-shi/">原型模式</a></h2>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200729063842999.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="36-建造者模式">3.6 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-ba-jian-zao-zhe-mo-shi/">建造者模式</a></h2>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200729071550422.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-结构型模式">4 结构型模式</h1>
<h2 id="41-适配器模式">4.1 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-jiu-gua-pei-qi-mo-shi/">适配器模式</a></h2>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200729075145937.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-桥接模式">4.2 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qiao-jie-mo-shi/">桥接模式</a></h2>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200729090053291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-组合模式">4.3 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-yi-zu-he-mo-shi/">组合模式</a></h2>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200729131832481.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-装饰模式">4.4 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi/">装饰模式</a></h2>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200729132833584.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="45-外观模式">4.5 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-san-wai-guan-mo-shi/">外观模式</a></h2>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200726233051374.png" alt="" loading="lazy"></figure>
<h2 id="46-享元模式">4.6 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-si-xiang-yuan-mo-shi/">享元模式</a></h2>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200729140109974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="47-代理模式">4.7 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-wu-dai-li-mo-shi/">代理模式</a></h2>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200806025456945.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-行为型模式">5 行为型模式</h1>
<h2 id="51-职责链模式">5.1 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-liu-zhi-ze-lian-mo-shi/">职责链模式</a></h2>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/2020073115020561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="52-命令模式">5.2 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/">命令模式</a></h2>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200801012404628.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="53-解释器模式">5.3 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/">解释器模式</a></h2>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20200802081552906.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="54-迭代器模式">5.4 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/">迭代器模式</a></h2>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/2020080116201951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="55-中介者模式">5.5 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-zhong-jie-zhe-mo-shi/">中介者模式</a></h2>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/20200803014225125.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="56-备忘录模式">5.6 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-yi-bei-wang-lu-mo-shi/">备忘录模式</a></h2>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20200803031745173.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="57-观察者模式">5.7 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-er-guan-cha-zhe-mo-shi/">观察者模式</a></h2>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/20200803215719507.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="58-状态模式">5.8 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-san-zhuang-tai-mo-shi/2">状态模式</a></h2>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/20200804113352370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="59-策略模式">5.9 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-si-ce-lue-mo-shi/">策略模式</a></h2>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/20200804183310775.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="510-模板方法模式">5.10 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/">模板方法模式</a></h2>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/20200805003325546.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="511-访问者模式">5.11 <a href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/">访问者模式</a></h2>
<figure data-type="image" tabindex="27"><img src="https://img-blog.csdnimg.cn/20200805173507935.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="28"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十六）：访问者模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/">
        </link>
        <updated>2020-08-07T09:28:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%85%83%E7%B4%A0">2.2 抽象元素</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0">2.3 具体元素</a></li>
<li><a href="#24-%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84">2.4 对象结构</a></li>
<li><a href="#25-%E6%8A%BD%E8%B1%A1%E8%AE%BF%E9%97%AE%E8%80%85">2.5 抽象访问者</a></li>
<li><a href="#26-%E5%85%B7%E4%BD%93%E8%AE%BF%E9%97%AE%E8%80%85">2.6 具体访问者</a></li>
<li><a href="#27-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.7 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">3 层次结构</a>
<ul>
<li><a href="#31-%E6%96%B0%E5%A2%9E%E8%AE%BF%E9%97%AE%E8%80%85">3.1 新增访问者</a></li>
<li><a href="#32-%E6%96%B0%E5%A2%9E%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0">3.2 新增具体元素</a></li>
<li><a href="#33-%E6%89%A9%E5%B1%95%E6%80%BB%E7%BB%93">3.3 扩展总结</a></li>
</ul>
</li>
<li><a href="#4-%E5%AE%9E%E4%BE%8B">4 实例</a></li>
<li><a href="#5-%E5%88%86%E6%B4%BE">5 分派</a>
<ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89">5.1 定义</a></li>
<li><a href="#52-%E9%9D%99%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">5.2 静/动态分派</a>
<ul>
<li><a href="#521-%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE">5.2.1 静态分派</a></li>
<li><a href="#522-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">5.2.2 动态分派</a></li>
</ul>
</li>
<li><a href="#53-%E5%8D%95%E5%A4%9A%E5%88%86%E6%B4%BE">5.3 单/多分派</a></li>
<li><a href="#54-java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">5.4 Java语言特性</a></li>
<li><a href="#55-%E4%BC%AA%E5%8A%A8%E6%80%81%E5%8F%8C%E5%88%86%E6%B4%BE">5.5 伪动态双分派</a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>患者就医时，医生开具处方后通常由药房工作人员准备药品，由划价人员根据药品数量计算总价，这里，可以将处方看作是一个药品信息的集合，里面包含了一种或多种不同类型的药品信息，不同类型的工作人员在操作同一个药品信息集合时将提供不同的处理方式，而且可能还会增加新类型的工作人员来操作处方单。</p>
<p>在软件开发中，有时候也需要处理像处方单这样的集合结构，在该对象结构中存储了多个不同类型的对象信息，而且对同一对象结构中的元素的操作方式不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式。这时候可以使用访问者模式进行处理。</p>
<p>访问者模式是一种较为复杂的行为型设计模式，它包含访问者与被访问者两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>访问者模式：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</strong></p>
<p>访问者模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200805004835533.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Visitor</code>（抽象访问者）：为每一个具体元素类声明一个具体访问者的操作</strong></li>
<li><strong><code>ConcreteVisitor</code>（具体访问者）：实现抽象访问者中的操作</strong></li>
<li><strong><code>Element</code>（抽象元素）：接口/抽象类，定义一个<code>accept</code>方法表示接受访问者的访问</strong></li>
<li><strong><code>ConcreteElement</code>（具体元素）：实现了<code>accept</code>方法，在<code>accept</code>中调用访问者的访问方法完成对具体元素的访问</strong></li>
<li><strong><code>ObjectStructure</code>（对象结构）：抽象元素的集合，用于存放抽象元素对象，提供了遍历内部元素的方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象元素：声明一个<code>accept</code>方法表示接受访问者访问，由具体元素实现具体访问操作</li>
<li>定义具体元素：实现抽象元素中的<code>accept</code>方法，同时定义访问属性的方法供访问者调用</li>
<li>定义对象结构：使用<code>List</code>或<code>Set</code>等存储抽象元素集合，包含管理集合元素的方法，同时也包含<code>accept</code>方法，该方法会遍历元素并调用每个元素的<code>accept</code>方法</li>
<li>定义抽象访问者：声明<code>visit</code>方法，作为对具体元素的访问方法，一般使用重载实现，也就是一个具体元素对应一个<code>visit</code></li>
<li>定义具体访问者：实现抽象访问者中的访问具体元素方法</li>
</ul>
<h2 id="22-抽象元素">2.2 抽象元素</h2>
<pre><code class="language-java">interface Element
{
    void accept(Visitor visitor);
}
</code></pre>
<p>这里实现为一个接口，包含一个<code>accept</code>方法，表示接受访问者的访问。</p>
<h2 id="23-具体元素">2.3 具体元素</h2>
<pre><code class="language-java">class ConcreteElementA implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素A&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素A&quot;);
    }
}

class ConcreteElementB implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素B&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素B&quot;);
    }
}
</code></pre>
<p>这里定义了两个具体元素，重点是其中的<code>accept</code>方法，通过参数<code>visitor</code>，将自身（具体元素类）作为参数调用<code>visit</code>方法，以表示该访问者（<code>visitor</code>）访问该元素（<code>this</code>）。这里涉及到了&quot;双分派&quot;，简单来说就是运行时确定抽象访问者（<code>visitor</code>）以及抽象元素（<code>this</code>）的具体类型，下面会有一小节详细说明分派的概念。</p>
<h2 id="24-对象结构">2.4 对象结构</h2>
<pre><code class="language-java">class ObjectStructure
{
    private List&lt;Element&gt; list = new ArrayList&lt;&gt;();
    public void accept(Visitor visitor)
    {
        list.forEach(t-&gt;t.accept(visitor));
    }

    public void add(Element element)
    {
        list.add(element);
    }
}
</code></pre>
<p>使用一个集合存储所有的抽象元素，同时提供管理方法以注入或删除具体元素，也包含<code>accept</code>方法，接收一个抽象访问者参数，表示接受该访问者访问这个对象结构里面的所有具体元素。</p>
<h2 id="25-抽象访问者">2.5 抽象访问者</h2>
<pre><code class="language-java">interface Visitor
{
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
}
</code></pre>
<p>这里重载了<code>visit</code>实现对不同具体元素的访问。注意一个具体元素类对应一个<code>visit</code>方法。</p>
<h2 id="26-具体访问者">2.6 具体访问者</h2>
<pre><code class="language-java">class ConcreteVisitorA implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show1();
    }
}

class ConcreteVisitorB implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }
}
</code></pre>
<p>实现抽象访问者中的访问方法，获取具体元素对象后，通过该元素对象的公有方法获取其中的内部数据，或者直接调用具体元素对象的某些公有方法。</p>
<h2 id="27-客户端">2.7 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    Visitor visitor = new ConcreteVisitorA();
    elements.accept(visitor);
    visitor = new ConcreteVisitorB();
    elements.accept(visitor);
}
</code></pre>
<p>客户端只需要针对抽象元素以及抽象访问者进行编程，通过对象结构对元素进行统一的管理，添加具体元素到对象结构后，动态注入不同的访问者以不同的方式访问对象结构中的所有元素。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200805023902817.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-层次结构">3 层次结构</h1>
<p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构：</p>
<ul>
<li>访问者层次结构：提供了抽象访问者以及具体访问者</li>
<li>元素层次结构：提供了抽象元素以及具体元素</li>
</ul>
<p><strong>相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同方式的访问。</strong></p>
<p>在访问者模式中：</p>
<ul>
<li>新增具体访问者方便：继承/实现抽象访问者即可，同时定义访问不同具体元素的不同方法</li>
<li>新增具体元素类麻烦：增加新的具体元素类需要进行大幅度的修改，首先需要新增抽象访问者中对新具体元素的访问方法，其次，原有的具体访问者都需要对新方法进行实现，修改量极大</li>
</ul>
<h2 id="31-新增访问者">3.1 新增访问者</h2>
<p>新增具体访问者很容易，在上面例子的基础上，只需要实现新增一个类实现抽象访问者接口即可：</p>
<pre><code class="language-java">class ConcreteVisitorC implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }
}
</code></pre>
<p>对于客户端只需要在对象结构中在<code>accept</code>中注入新的访问者即可：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    Visitor visitor = new ConcreteVisitorC();
    elements.accept(visitor);
}
</code></pre>
<h2 id="32-新增具体元素">3.2 新增具体元素</h2>
<p>新增具体元素会导致大量源码的修改，在上面例子的基础上，首先增加一个实现抽象元素接口的具体元素：</p>
<pre><code class="language-java">class ConcreteElementC implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素C&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素C&quot;);
    }
}
</code></pre>
<p>这时IDE应该会提示<code>visitor.visit(this)</code>这行报错，因为抽象访问者接口没有针对新的具体元素类型的<code>visit</code>方法，也就是说此时需要修改抽象访问者，增加访问新的具体元素类型的<code>visit</code>方法：</p>
<pre><code class="language-java">interface Visitor
{
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
    void visit(ConcreteElementC element);//新增
}
</code></pre>
<p>但是此时IDE又会提示具体访问者有错误，因为这是抽象访问者是一个接口，而所有的具体访问者都实现了该接口，也就是下一步需要修改所有的具体访问者，增加新的接口方法：</p>
<pre><code class="language-java">class ConcreteVisitorA implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementC element) //新增
    {
        element.show1();
    }
}

class ConcreteVisitorB implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementC element) //新增
    {
        element.show2();
    }
}
</code></pre>
<p>对于客户端来说无须修改太多代码，同样创建具体元素后添加到对象结构中：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    Element elementC = new ConcreteElementC();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    elements.add(elementC);
    elements.accept(new ConcreteVisitorA());
}
</code></pre>
<h2 id="33-扩展总结">3.3 扩展总结</h2>
<p>新增访问者步骤如下：</p>
<ul>
<li>新建一个实现/继承抽象访问者的具体访问者类</li>
<li>客户端中将新的具体访问者传入对象结构的访问方法中</li>
</ul>
<p>新增元素步骤如下：</p>
<ul>
<li>新建一个实现/继承抽象元素类的具体元素类</li>
<li>抽象访问者新增访问该具体元素的方法</li>
<li>原有的所有具体访问者新增访问该元素的方法</li>
<li>客户端中创建新元素对象后添加到对象结构中</li>
</ul>
<p><strong>总的来说，这和抽象工厂模式有点类似，对OCP（开闭原则）的支持具有倾斜性，新增访问者（产品族）很容易，新增元素（产品等级结构）需要修改大量代码。</strong></p>
<h1 id="4-实例">4 实例</h1>
<blockquote>
<p>设计一个员工信息管理子系统，包括正式员工以及临时工，管理人员是人力资源部以及财务部的人员，两个部门的人员进行的操作不同，使用访问者模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象元素：<code>Employee</code></li>
<li>具体元素：<code>FulltimeEmployee</code>+<code>ParttimeEmployee</code></li>
<li>对象结构：<code>EmployeeList</code></li>
<li>抽象访问者：<code>Department</code></li>
<li>具体访问者：<code>FADepartment</code>+<code>HRDepartment</code></li>
</ul>
<p>首先是抽象元素的代码：</p>
<pre><code class="language-java">interface Employee
{
    void accept(Department department);
}
</code></pre>
<p>只有一个<code>accept</code>表示接受抽象访问者访问的方法。</p>
<p>具体元素：</p>
<pre><code class="language-java">class FulltimeEmployee implements Employee
{
    private String name;
    public FulltimeEmployee(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return name;
    }
    @Override
    public void accept(Department department)
    {
        department.visit(this);
    }
}

class ParttimeEmployee implements Employee
{
    private String name;
    public ParttimeEmployee(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return name;
    }
    @Override
    public void accept(Department department)
    {
        department.visit(this);
    }
}
</code></pre>
<p>实现其中的<code>accept</code>方法，在里面调用抽象访问者的<code>visit</code>方法，将自身作为参数。</p>
<p>对象结构如下：</p>
<pre><code class="language-java">class EmployeeList
{
    private List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
    public void add(Employee employee)
    {
        list.add(employee);
    }

    public void accept(Department department)
    {
        list.forEach(t-&gt;t.accept(department));
    }
}
</code></pre>
<p><code>accept</code>会遍历元素集合，实现访问者对每一个具体元素的访问。</p>
<p>抽象访问者如下：</p>
<pre><code class="language-java">interface Department
{
    void visit(FulltimeEmployee employee);
    void visit(ParttimeEmployee employee);
}
</code></pre>
<p>两个参数不同的<code>visit</code>，分别表示对这两个不同具体元素的访问操作。</p>
<p>具体访问者：</p>
<pre><code class="language-java">class FADepartment implements Department
{
    @Override
    public void visit(FulltimeEmployee employee)
    {
        System.out.println(&quot;财务部访问全职员工&quot;+employee.getName());
    }
    @Override
    public void visit(ParttimeEmployee employee)
    {
        System.out.println(&quot;财务部访问兼职员工&quot;+employee.getName());
    }
}

class HRDepartment implements Department
{
    @Override
    public void visit(FulltimeEmployee employee)
    {
        System.out.println(&quot;人力资源部访问全职员工&quot;+employee.getName());
    }
    @Override
    public void visit(ParttimeEmployee employee)
    {
        System.out.println(&quot;人力资源部访问兼职员工&quot;+employee.getName());
    }
}
</code></pre>
<p>对于不同的具体元素，不同的具体访问者有不同的处理方法，这里简单处理只是进行输出。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Employee fulltimeEmployee = new FulltimeEmployee(&quot;A&quot;);
    Employee parttimeEmployee = new ParttimeEmployee(&quot;B&quot;);
    EmployeeList list = new EmployeeList();
    list.add(fulltimeEmployee);
    list.add(parttimeEmployee);
    list.accept(new HRDepartment());
    list.accept(new FADepartment());
}
</code></pre>
<p>客户端针对抽象元素以及抽象访问者编程，创建具体元素后添加到对象结构中，接着将具体访问者作为参数传入对象结构的访问方法中。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200805033900393.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-分派">5 分派</h1>
<p>在访问者模式中涉及到了“伪动态双分派”的概念，首先看一下什么是分派。</p>
<h2 id="51-定义">5.1 定义</h2>
<p>变量被声明时的类型叫静态类型，变量所引用的类型叫实际类型。比如：</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>中，<code>list</code>的静态类型为<code>List</code>，实际类型为<code>ArrayList</code>。</p>
<p><strong>根据对象的类型对方法进行的选择，就是分派。</strong></p>
<p>分派按照分派的方式可以分为：</p>
<ul>
<li>静态分派</li>
<li>动态分派</li>
</ul>
<p>按照分派基于的宗量，可以分为：</p>
<ul>
<li>单分派</li>
<li>多分派</li>
</ul>
<p>先来看一下静/动态分派。</p>
<h2 id="52-静动态分派">5.2 静/动态分派</h2>
<h3 id="521-静态分派">5.2.1 静态分派</h3>
<p><strong>静态分派：发生在编译时期，分派根据静态类型信息发生，比如方法重载</strong>。</p>
<p>比如下面的例子：</p>
<pre><code class="language-java">public class Test 
{
    public static void main(String[] args) 
    {
        test(Integer.valueOf(1));
        test(&quot;1&quot;);
    }

    public static void test(String s)
    {
        System.out.println(&quot;String&quot;);
    }

    public static void test(Integer i)
    {
        System.out.println(&quot;Integer&quot;);
    }
}
</code></pre>
<p>对于<code>test</code>方法，会根据静态类型选择方法版本，依据<code>test</code>方法的参数类型和参数数量可以确定唯一一个重载方法版本。</p>
<h3 id="522-动态分派">5.2.2 动态分派</h3>
<p><strong>动态分派：发生在运行时期，动态置换掉某个方法，比如面向对象的多态特性</strong>。</p>
<p>与静态分派相反，动态分派在运行时确定具体方法，比如：</p>
<pre><code class="language-java">public class Test 
{
    public static void main(String[] args) 
    {
        A b = new B();
        A c = new C();
        b.test();
        c.test();
    }
}

interface A
{
    void test();
}

class B implements A
{
    @Override
    public void test()
    {
        System.out.println(&quot;B方法&quot;);
    }
}

class C implements A
{
    @Override
    public void test()
    {
        System.out.println(&quot;C方法&quot;);
    }
}
</code></pre>
<p>例子的<code>test</code>方法，无法根据对象的静态类型去判断，因为都是同一接口，而是在运行时判断，这就是动态分派，运行时获取到对象的具体引用类型，再确定具体的方法。</p>
<h2 id="53-单多分派">5.3 单/多分派</h2>
<p>在了解单/多分派之前，先了解一下宗量。</p>
<p><strong>一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称为方法的宗量。</strong></p>
<p>比如下面的<code>Test</code>类：</p>
<pre><code class="language-java">public class Test
{
	public void print(String str){}
}
</code></pre>
<p><code>print()</code>属于<code>Test</code>对象，所以接收者就是<code>Test</code>对象，<code>print()</code>有参数<code>str</code>，类型为<code>String</code>。所以<code>print</code>的宗量有两个：</p>
<ul>
<li>接收者<code>Test</code></li>
<li>参数<code>String str</code></li>
</ul>
<p>根据分派基于多少种宗量，可以将分派划分为单分派与多分派：</p>
<ul>
<li>单分派根据一个宗量的类型对方法进行选择</li>
<li>多分派根据多个宗量的类型对方法进行选择（双分派是多分派的一种形式，根据两个宗量的类型对方法进行选择）</li>
</ul>
<h2 id="54-java语言特性">5.4 Java语言特性</h2>
<p><strong>Java是静态多分派，动态单分派语言。</strong></p>
<p>理由如下：</p>
<ul>
<li>静态多分派：从上面方法重载的例子可以看到，静态时确定方法，而且选择方法的依据是多个宗量（方法接收者，方法参数，参数数量，参数顺序），因此可以说的静态多分派</li>
<li>动态单分派：从上面动态分派的例子可以知道，Java中动态分派仅仅考虑到方法的接收者，也就是只根据一个宗量（方法接收者）去选择方法，所以说是动态单分派</li>
</ul>
<h2 id="55-伪动态双分派">5.5 伪动态双分派</h2>
<p>一个方法根据两个宗量的类型来决定执行不同的代码，这就是双分派。<strong>Java是动态单分派语言，也就是不支持动态双分派。但是使用访问者模式可以达到一种“动态双分派”的效果。因为这不是真正的动态双分派，所以加上了一个“伪”，这种“伪动态双分派”其实是通过两次“动态单分派”来实现。</strong></p>
<p>访问者模式的双分派中，不仅要根据被访问者的运行时区别，还要根据访问者的运行时区别，在客户端中将具体访问者作为参数传递给被访问者（具体元素）：</p>
<pre><code class="language-java">@Override
public void accept(Department department)
{
    department.visit(this);
}
</code></pre>
<p>由于<code>department</code>是抽象访问者，运行时确定具体调用哪一个具体访问者的<code>visit</code>，这里完成第一次动态单分派。</p>
<p>另外<code>visit</code>接受抽象元素作为参数，把具体元素（<code>this</code>）作为参数传递，根据<code>方法接收者宗量</code>选择相应的<code>visit</code>方法，在这里完成第二次动态分派。</p>
<p><strong>也就是说，访问者模式是首先根据访问者的动态单分派，再根据具体元素（被访问者）的动态单分派，来达到“动态双分派”的效果，由于这不是真正的动态双分派，而且Java是动态单分派语言，因此这种机制也叫“伪动态双分派”。</strong></p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>新增访问操作方便：使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，符合开闭原则</li>
<li>集中访问行为：将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>新增元素类困难：访问者模式中每新增一个元素类以为着抽象访问者角色需要增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了开闭原则</li>
<li>破坏封装：访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>一个对象结构中包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而且需要避免让这些操作“污染”这些对象的类，也不希望在新增操作时修改这些类。访问者模式将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者者类所使用，将对象本身于对象的访问操作分离</li>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200805173507935.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十五）：模板方法模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/">
        </link>
        <updated>2020-08-07T09:27:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
<li><a href="#15-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5 模板方法与基本方法</a>
<ul>
<li><a href="#151-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">1.5.1 模板方法</a></li>
<li><a href="#152-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5.2 基本方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E7%B1%BB">2.2 抽象类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%AD%90%E7%B1%BB">2.3 具体子类</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">4 主要优点</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">5 主要缺点</a></li>
<li><a href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6 适用场景</a></li>
<li><a href="#7-%E6%80%BB%E7%BB%93">7 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>模板方法模式是结构最简单的行为型设计模型，在其结构中只存在父类与之类之间的继承关系，通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</strong></p>
<p>模板方法模式是一种类行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804195920960.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>AbstractClass</code>（抽象类）：抽象类中定义了一系列基本操作，这些操作是具体的也可以是抽象的，每一个基本操作对应算法的一个步骤，在子类中可以重定义或实现这些步骤，同时抽象类实现了一个模板方法，定义一个算法的框架</strong></li>
<li><strong><code>ConcreteClass</code>（具体子类）：实现父类中的抽象基本方法，或者覆盖父类中具体基本操作</strong></li>
</ul>
<h2 id="15-模板方法与基本方法">1.5 模板方法与基本方法</h2>
<h3 id="151-模板方法">1.5.1 模板方法</h3>
<p>模板方法是在抽象类中定义的，把基本操作方法组合成一个总算法或总行为的方法。模板方法在抽象类中定义，并由子类不加以修改完全继承。模板方法是一个具体方法，给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。另外由于模板方法是具体方法，因此抽象层只能实现为抽象类而不能是接口。</p>
<h3 id="152-基本方法">1.5.2 基本方法</h3>
<p>基本方法是实现算法的各个步骤，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li>抽象方法：抽象方法就是在抽象类中声明并由子类实现的方法</li>
<li>具体方法：具体方法可以由抽象类实现，或者由子类覆盖实现</li>
<li>钩子方法：钩子方法可以由抽象类实现，子类可以加以扩展</li>
</ul>
<p>在模板方法模式中，钩子方法一般有两类：</p>
<ul>
<li>第一类钩子方法是可以与一些具体步骤挂钩，以实现在不同条件下执行模板方法的不同步骤，这类方法一般返回<code>boolean</code>，方法名一般为<code>isXXX</code></li>
<li>第二类钩子方法是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法</li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象类：声明模板方法以及基本方法</li>
<li>定义模板方法：模板方法是抽象类中的具体方法，按照实际需要将基本方法进行组合</li>
<li>定义基本方法：定义抽象方法，具体方法以及钩子方法，确定好哪些方法交由抽象类实现，哪些方法交由子类实现以及拥有哪些钩子方法</li>
<li>定义具体子类：实现抽象类的抽象方法，按照需要对钩子方法或者具体方法进行覆盖</li>
</ul>
<h2 id="22-抽象类">2.2 抽象类</h2>
<pre><code class="language-java">abstract class AbstractClass
{
    public void templateMethod()
    {
        primitiveOperation1();
        primitiveOperation2();
        if(primitiveOperation3())
            System.out.println(&quot;符合钩子方法条件&quot;);
        else
            System.out.println(&quot;不符合钩子方法条件&quot;);
        primitiveOperation4();
    }

    public void primitiveOperation1()
    {
        System.out.println(&quot;抽象类具体方法&quot;);
    }

    //抽象类抽象方法
    abstract public void primitiveOperation2();

    //第一类钩子方法
    public boolean primitiveOperation3()
    {
        return false;
    }
    
    //第二类钩子方法
    public void primitiveOperation4()
    {

    }
}
</code></pre>
<p>首先定义了模板方法，作为客户端操作的入口。模板方法中对基本方法进行了组合，这里声明了四个基本方法：</p>
<ul>
<li>第一个是抽象类的具体方法：这是所有子类都拥有的相同实现的方法，不应该被子类覆盖</li>
<li>第二个是抽象类的抽象方法：子类需要实现该方法以实现变化</li>
<li>第三个是第一类钩子方法：这类钩子方法返回一个<code>boolean</code>，可以用于控制是否执行某个步骤，子类可以通过这类钩子方法对模板方法的执行过程进行限制，比如如果不想执行某个步骤可以永远返回<code>false</code></li>
<li>第四个是第二类钩子方法：这类钩子方法中父类提供一个空实现，子类选择性进行覆盖</li>
</ul>
<h2 id="23-具体子类">2.3 具体子类</h2>
<pre><code class="language-java">class ConcreteClass extends AbstractClass
{
    public void primitiveOperation2()
    {
        System.out.println(&quot;子类具体方法&quot;);
    }

    public boolean primitiveOperation3()
    {
        return true;
        // 如果想钩子方法返回false可以不实现该方法
        // 因为父类默认返回false
        // return false;
    }

    public void primitiveOperation4()
    {
        System.out.println(&quot;子类覆盖父类第二类钩子方法&quot;);
    }
}
</code></pre>
<p>这里子类实现了抽象类的抽象方法，同时覆盖了两类钩子方法。</p>
<h2 id="24-客户端">2.4 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    AbstractClass class1 = new ConcreteClass();
    class1.templateMethod();
}
</code></pre>
<p>客户端调用很简单，创建一个具体类对象并执行其中的模板方法即可。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200805000357803.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>为银行业务开发一个利息计算模块，该计算模块拥有标准流程：系统验证用户信息，接着判断用户状态，正常状态用户能计算利息，受限制状态用户无法计算利息，最后显示利息，使用模板方法模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象类：<code>Account</code></li>
<li>具体方法：<code>validate(String name)</code></li>
<li>抽象方法：<code>calculate()</code></li>
<li>钩子方法：<code>canCalculate()</code>+<code>display()</code></li>
<li>具体子类：<code>NormalAccount</code>+<code>RestrictedAccount</code></li>
</ul>
<p>首先是抽象类的设计：</p>
<pre><code class="language-java">abstract class Account
{
    public void handle(String name)
    {
        if(validate(name))
        {
            if(canCalculate())
            {
                calculate();
            }
            display();
        }
        else
        {
            System.out.println(&quot;用户名非法&quot;);
        }
    }

    public boolean validate(String name)
    {
        return &quot;1&quot;.equals(name);
    }

    //抽象类抽象方法
    abstract public void calculate();

    //第一类钩子方法
    public boolean canCalculate()
    {
        return true;
    }
    
    //第二类钩子方法
    public void display()
    {

    }
}
</code></pre>
<p>首先通过<code>validate()</code>验证用户名，接着根据第一类钩子方法<code>canCalculate()</code>判断能否计算利息，然后调用抽象计算方法<code>calculate()</code>进行计算，最后无论能够计算利息都会调用第二类钩子方法<code>display()</code>。</p>
<p>具体子类代码如下：</p>
<pre><code class="language-java">class NormalAccount extends Account
{
    public void calculate()
    {
        System.out.println(&quot;正常状态用户计算利息&quot;);
    }

    public void display()
    {
        System.out.println(&quot;正常状态用户显示利息&quot;);
    }
}

class RestrictedAccount extends Account
{
    public boolean canCalculate()
    {
        return false;
    }

    public void calculate()
    {}

    public void display()
    {
        System.out.println(&quot;受限状态用户无法计算利息&quot;);
    }
}
</code></pre>
<p>正常状态用户中实现抽象方法<code>calculate()</code>，并覆盖第二类钩子方法<code>display()</code>，对于受限状态用户，覆盖了第一类钩子方法<code>canCalculate()</code>，永远返回<code>false</code>，同时对抽象方法<code>calculate</code>提供空实现，最后也对第二类钩子方法<code>display</code>进行了覆盖，提示<code>&quot;无法计算利息&quot;</code>。</p>
<h1 id="4-主要优点">4 主要优点</h1>
<ul>
<li>形式化算法：模板方法模式在父类中形式化地定义一个算法，而由子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li>
<li>代码复用：模板方法模式是一种代码复用技术，提取公共行为并放在父类中，通过子类实现不同的行为</li>
<li>实现反向控制：模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否执行</li>
<li>增加子类方便：模板方法模式中可通过子类覆盖父类的基本方法，不同子类可以提供基本方法的不同实现，更换以及增加新的子类很方便</li>
</ul>
<h1 id="5-主要缺点">5 主要缺点</h1>
<ul>
<li>子类数量多：模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
</ul>
<h1 id="6-适用场景">6 适用场景</h1>
<ul>
<li>对一些复杂算法进行分割，将其算法中固定不变的部分设计为模板方法和父类方法，而一些改变的细节由子类实现，也就是一次性实现算法中不变部分，并将可变部分交由子类实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>需要通过子类决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li>
</ul>
<h1 id="7-总结">7 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200805003325546.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>