<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-08-07T09:29:03.521Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第53期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-53-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-53-qi/">
        </link>
        <updated>2020-08-09T08:44:57.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789926856.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第52期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-52-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-52-qi/">
        </link>
        <updated>2020-08-08T08:44:06.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789873416.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoF设计模式合集]]></title>
        <id>https://2293736867.github.io/post/gof-she-ji-mo-shi-he-ji/</id>
        <link href="https://2293736867.github.io/post/gof-she-ji-mo-shi-he-ji/">
        </link>
        <updated>2020-08-07T09:28:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>这篇文章是对GoF23种设计模式+1种非GoF模式的合集，由笔者自己的笔记整理而来，每个模式都详细描述了步骤，角色等，以及使用Java实现的具体的例子，下面是目录：</p>
<h2 id="基础">基础</h2>
<ul>
<li>设计模式概述</li>
<li>UML基础</li>
</ul>
<h2 id="创建型模式">创建型模式</h2>
<ul>
<li>单例模式</li>
<li>简单工厂模式（非GoF模式）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<h2 id="结构型模式">结构型模式</h2>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<h2 id="行为型模式">行为型模式</h2>
<ul>
<li>职责链模式</li>
<li>命令模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>访问者模式</li>
</ul>
<h1 id="2-基础">2 基础</h1>
<h2 id="21-设计模式概述">2.1 <a href="https://blog.csdn.net/qq_27525611/article/details/107247594">设计模式概述</a></h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200728163506210.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="22-uml与面向对象设计原则">2.2 <a href="https://blog.csdn.net/qq_27525611/article/details/107250163">UML与面向对象设计原则</a></h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200711005605808.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711094651100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-创建型模式">3 创建型模式</h1>
<h2 id="31-单例模式">3.1 <a href="https://blog.csdn.net/qq_27525611/article/details/107294099">单例模式</a></h2>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200728163932717.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-简单工厂模式">3.2 <a href="https://blog.csdn.net/qq_27525611/article/details/107304159">简单工厂模式</a></h2>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200728175216328.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-工厂方法模式">3.3 <a href="https://blog.csdn.net/qq_27525611/article/details/107364031">工厂方法模式</a></h2>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200728202541743.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="34-抽象工厂模式">3.4 <a href="https://blog.csdn.net/qq_27525611/article/details/107369024">抽象工厂模式</a></h2>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200728225937668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="35-原型模式">3.5 <a href="https://blog.csdn.net/qq_27525611/article/details/107409590">原型模式</a></h2>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200729063842999.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="36-建造者模式">3.6 <a href="https://blog.csdn.net/qq_27525611/article/details/107424630">建造者模式</a></h2>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200729071550422.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-结构型模式">4 结构型模式</h1>
<h2 id="41-适配器模式">4.1 <a href="https://blog.csdn.net/qq_27525611/article/details/107542693">适配器模式</a></h2>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200729075145937.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-桥接模式">4.2 <a href="https://blog.csdn.net/qq_27525611/article/details/107573144">桥接模式</a></h2>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200729090053291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-组合模式">4.3 <a href="https://blog.csdn.net/qq_27525611/article/details/107588437">组合模式</a></h2>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200729131832481.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-装饰模式">4.4 <a href="https://blog.csdn.net/qq_27525611/article/details/107588445">装饰模式</a></h2>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200729132833584.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="45-外观模式">4.5 <a href="https://blog.csdn.net/qq_27525611/article/details/107588453">外观模式</a></h2>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200726233051374.png" alt="" loading="lazy"></figure>
<h2 id="46-享元模式">4.6 <a href="https://blog.csdn.net/qq_27525611/article/details/107588459">享元模式</a></h2>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200729140109974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="47-代理模式">4.7 <a href="https://blog.csdn.net/qq_27525611/article/details/107614490">代理模式</a></h2>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200806025456945.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-行为型模式">5 行为型模式</h1>
<h2 id="51-职责链模式">5.1 <a href="https://blog.csdn.net/qq_27525611/article/details/107614581">职责链模式</a></h2>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/2020073115020561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="52-命令模式">5.2 <a href="https://blog.csdn.net/qq_27525611/article/details/107614816">命令模式</a></h2>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200801012404628.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="53-解释器模式">5.3 <a href="https://blog.csdn.net/qq_27525611/article/details/107614931">解释器模式</a></h2>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20200802081552906.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="54-迭代器模式">5.4 <a href="https://blog.csdn.net/qq_27525611/article/details/107615004">迭代器模式</a></h2>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/2020080116201951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="55-中介者模式">5.5 <a href="https://blog.csdn.net/qq_27525611/article/details/107615079">中介者模式</a></h2>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/20200803014225125.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="56-备忘录模式">5.6 <a href="https://blog.csdn.net/qq_27525611/article/details/107615162">备忘录模式</a></h2>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20200803031745173.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="57-观察者模式">5.7 <a href="https://blog.csdn.net/qq_27525611/article/details/107615247">观察者模式</a></h2>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/20200803215719507.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="58-状态模式">5.8 <a href="https://blog.csdn.net/qq_27525611/article/details/107615332">状态模式</a></h2>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/20200804113352370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="59-策略模式">5.9 <a href="https://blog.csdn.net/qq_27525611/article/details/107615394">策略模式</a></h2>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/20200804183310775.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="510-模板方法模式">5.10 <a href="https://blog.csdn.net/qq_27525611/article/details/107615456">模板方法模式</a></h2>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/20200805003325546.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="511-访问者模式">5.11 <a href="https://blog.csdn.net/qq_27525611/article/details/107615529">访问者模式</a></h2>
<figure data-type="image" tabindex="27"><img src="https://img-blog.csdnimg.cn/20200805173507935.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="28"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十六）：访问者模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-liu-fang-wen-zhe-mo-shi/">
        </link>
        <updated>2020-08-07T09:28:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%85%83%E7%B4%A0">2.2 抽象元素</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0">2.3 具体元素</a></li>
<li><a href="#24-%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84">2.4 对象结构</a></li>
<li><a href="#25-%E6%8A%BD%E8%B1%A1%E8%AE%BF%E9%97%AE%E8%80%85">2.5 抽象访问者</a></li>
<li><a href="#26-%E5%85%B7%E4%BD%93%E8%AE%BF%E9%97%AE%E8%80%85">2.6 具体访问者</a></li>
<li><a href="#27-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.7 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">3 层次结构</a>
<ul>
<li><a href="#31-%E6%96%B0%E5%A2%9E%E8%AE%BF%E9%97%AE%E8%80%85">3.1 新增访问者</a></li>
<li><a href="#32-%E6%96%B0%E5%A2%9E%E5%85%B7%E4%BD%93%E5%85%83%E7%B4%A0">3.2 新增具体元素</a></li>
<li><a href="#33-%E6%89%A9%E5%B1%95%E6%80%BB%E7%BB%93">3.3 扩展总结</a></li>
</ul>
</li>
<li><a href="#4-%E5%AE%9E%E4%BE%8B">4 实例</a></li>
<li><a href="#5-%E5%88%86%E6%B4%BE">5 分派</a>
<ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89">5.1 定义</a></li>
<li><a href="#52-%E9%9D%99%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">5.2 静/动态分派</a>
<ul>
<li><a href="#521-%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE">5.2.1 静态分派</a></li>
<li><a href="#522-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE">5.2.2 动态分派</a></li>
</ul>
</li>
<li><a href="#53-%E5%8D%95%E5%A4%9A%E5%88%86%E6%B4%BE">5.3 单/多分派</a></li>
<li><a href="#54-java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">5.4 Java语言特性</a></li>
<li><a href="#55-%E4%BC%AA%E5%8A%A8%E6%80%81%E5%8F%8C%E5%88%86%E6%B4%BE">5.5 伪动态双分派</a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>患者就医时，医生开具处方后通常由药房工作人员准备药品，由划价人员根据药品数量计算总价，这里，可以将处方看作是一个药品信息的集合，里面包含了一种或多种不同类型的药品信息，不同类型的工作人员在操作同一个药品信息集合时将提供不同的处理方式，而且可能还会增加新类型的工作人员来操作处方单。</p>
<p>在软件开发中，有时候也需要处理像处方单这样的集合结构，在该对象结构中存储了多个不同类型的对象信息，而且对同一对象结构中的元素的操作方式不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式。这时候可以使用访问者模式进行处理。</p>
<p>访问者模式是一种较为复杂的行为型设计模式，它包含访问者与被访问者两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>访问者模式：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</strong></p>
<p>访问者模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200805004835533.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Visitor</code>（抽象访问者）：为每一个具体元素类声明一个具体访问者的操作</strong></li>
<li><strong><code>ConcreteVisitor</code>（具体访问者）：实现抽象访问者中的操作</strong></li>
<li><strong><code>Element</code>（抽象元素）：接口/抽象类，定义一个<code>accept</code>方法表示接受访问者的访问</strong></li>
<li><strong><code>ConcreteElement</code>（具体元素）：实现了<code>accept</code>方法，在<code>accept</code>中调用访问者的访问方法完成对具体元素的访问</strong></li>
<li><strong><code>ObjectStructure</code>（对象结构）：抽象元素的集合，用于存放抽象元素对象，提供了遍历内部元素的方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象元素：声明一个<code>accept</code>方法表示接受访问者访问，由具体元素实现具体访问操作</li>
<li>定义具体元素：实现抽象元素中的<code>accept</code>方法，同时定义访问属性的方法供访问者调用</li>
<li>定义对象结构：使用<code>List</code>或<code>Set</code>等存储抽象元素集合，包含管理集合元素的方法，同时也包含<code>accept</code>方法，该方法会遍历元素并调用每个元素的<code>accept</code>方法</li>
<li>定义抽象访问者：声明<code>visit</code>方法，作为对具体元素的访问方法，一般使用重载实现，也就是一个具体元素对应一个<code>visit</code></li>
<li>定义具体访问者：实现抽象访问者中的访问具体元素方法</li>
</ul>
<h2 id="22-抽象元素">2.2 抽象元素</h2>
<pre><code class="language-java">interface Element
{
    void accept(Visitor visitor);
}
</code></pre>
<p>这里实现为一个接口，包含一个<code>accept</code>方法，表示接受访问者的访问。</p>
<h2 id="23-具体元素">2.3 具体元素</h2>
<pre><code class="language-java">class ConcreteElementA implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素A&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素A&quot;);
    }
}

class ConcreteElementB implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素B&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素B&quot;);
    }
}
</code></pre>
<p>这里定义了两个具体元素，重点是其中的<code>accept</code>方法，通过参数<code>visitor</code>，将自身（具体元素类）作为参数调用<code>visit</code>方法，以表示该访问者（<code>visitor</code>）访问该元素（<code>this</code>）。这里涉及到了&quot;双分派&quot;，简单来说就是运行时确定抽象访问者（<code>visitor</code>）以及抽象元素（<code>this</code>）的具体类型，下面会有一小节详细说明分派的概念。</p>
<h2 id="24-对象结构">2.4 对象结构</h2>
<pre><code class="language-java">class ObjectStructure
{
    private List&lt;Element&gt; list = new ArrayList&lt;&gt;();
    public void accept(Visitor visitor)
    {
        list.forEach(t-&gt;t.accept(visitor));
    }

    public void add(Element element)
    {
        list.add(element);
    }
}
</code></pre>
<p>使用一个集合存储所有的抽象元素，同时提供管理方法以注入或删除具体元素，也包含<code>accept</code>方法，接收一个抽象访问者参数，表示接受该访问者访问这个对象结构里面的所有具体元素。</p>
<h2 id="25-抽象访问者">2.5 抽象访问者</h2>
<pre><code class="language-java">interface Visitor
{
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
}
</code></pre>
<p>这里重载了<code>visit</code>实现对不同具体元素的访问。注意一个具体元素类对应一个<code>visit</code>方法。</p>
<h2 id="26-具体访问者">2.6 具体访问者</h2>
<pre><code class="language-java">class ConcreteVisitorA implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show1();
    }
}

class ConcreteVisitorB implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }
}
</code></pre>
<p>实现抽象访问者中的访问方法，获取具体元素对象后，通过该元素对象的公有方法获取其中的内部数据，或者直接调用具体元素对象的某些公有方法。</p>
<h2 id="27-客户端">2.7 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    Visitor visitor = new ConcreteVisitorA();
    elements.accept(visitor);
    visitor = new ConcreteVisitorB();
    elements.accept(visitor);
}
</code></pre>
<p>客户端只需要针对抽象元素以及抽象访问者进行编程，通过对象结构对元素进行统一的管理，添加具体元素到对象结构后，动态注入不同的访问者以不同的方式访问对象结构中的所有元素。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200805023902817.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-层次结构">3 层次结构</h1>
<p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构：</p>
<ul>
<li>访问者层次结构：提供了抽象访问者以及具体访问者</li>
<li>元素层次结构：提供了抽象元素以及具体元素</li>
</ul>
<p><strong>相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同方式的访问。</strong></p>
<p>在访问者模式中：</p>
<ul>
<li>新增具体访问者方便：继承/实现抽象访问者即可，同时定义访问不同具体元素的不同方法</li>
<li>新增具体元素类麻烦：增加新的具体元素类需要进行大幅度的修改，首先需要新增抽象访问者中对新具体元素的访问方法，其次，原有的具体访问者都需要对新方法进行实现，修改量极大</li>
</ul>
<h2 id="31-新增访问者">3.1 新增访问者</h2>
<p>新增具体访问者很容易，在上面例子的基础上，只需要实现新增一个类实现抽象访问者接口即可：</p>
<pre><code class="language-java">class ConcreteVisitorC implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }
}
</code></pre>
<p>对于客户端只需要在对象结构中在<code>accept</code>中注入新的访问者即可：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    Visitor visitor = new ConcreteVisitorC();
    elements.accept(visitor);
}
</code></pre>
<h2 id="32-新增具体元素">3.2 新增具体元素</h2>
<p>新增具体元素会导致大量源码的修改，在上面例子的基础上，首先增加一个实现抽象元素接口的具体元素：</p>
<pre><code class="language-java">class ConcreteElementC implements Element
{
    @Override
    public void accept(Visitor visitor)
    {
        visitor.visit(this);
    }

    public void show1()
    {
        System.out.println(&quot;用第一种方式访问具体元素C&quot;);
    }

    public void show2()
    {
        System.out.println(&quot;用第二种方式访问具体元素C&quot;);
    }
}
</code></pre>
<p>这时IDE应该会提示<code>visitor.visit(this)</code>这行报错，因为抽象访问者接口没有针对新的具体元素类型的<code>visit</code>方法，也就是说此时需要修改抽象访问者，增加访问新的具体元素类型的<code>visit</code>方法：</p>
<pre><code class="language-java">interface Visitor
{
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
    void visit(ConcreteElementC element);//新增
}
</code></pre>
<p>但是此时IDE又会提示具体访问者有错误，因为这是抽象访问者是一个接口，而所有的具体访问者都实现了该接口，也就是下一步需要修改所有的具体访问者，增加新的接口方法：</p>
<pre><code class="language-java">class ConcreteVisitorA implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show1();
    }

    @Override
    public void visit(ConcreteElementC element) //新增
    {
        element.show1();
    }
}

class ConcreteVisitorB implements Visitor
{
    @Override
    public void visit(ConcreteElementA element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementB element)
    {
        element.show2();
    }

    @Override
    public void visit(ConcreteElementC element) //新增
    {
        element.show2();
    }
}
</code></pre>
<p>对于客户端来说无须修改太多代码，同样创建具体元素后添加到对象结构中：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Element elementA = new ConcreteElementA();
    Element elementB = new ConcreteElementB();
    Element elementC = new ConcreteElementC();
    ObjectStructure elements = new ObjectStructure();
    elements.add(elementA);
    elements.add(elementB);
    elements.add(elementC);
    elements.accept(new ConcreteVisitorA());
}
</code></pre>
<h2 id="33-扩展总结">3.3 扩展总结</h2>
<p>新增访问者步骤如下：</p>
<ul>
<li>新建一个实现/继承抽象访问者的具体访问者类</li>
<li>客户端中将新的具体访问者传入对象结构的访问方法中</li>
</ul>
<p>新增元素步骤如下：</p>
<ul>
<li>新建一个实现/继承抽象元素类的具体元素类</li>
<li>抽象访问者新增访问该具体元素的方法</li>
<li>原有的所有具体访问者新增访问该元素的方法</li>
<li>客户端中创建新元素对象后添加到对象结构中</li>
</ul>
<p><strong>总的来说，这和抽象工厂模式有点类似，对OCP（开闭原则）的支持具有倾斜性，新增访问者（产品族）很容易，新增元素（产品等级结构）需要修改大量代码。</strong></p>
<h1 id="4-实例">4 实例</h1>
<blockquote>
<p>设计一个员工信息管理子系统，包括正式员工以及临时工，管理人员是人力资源部以及财务部的人员，两个部门的人员进行的操作不同，使用访问者模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象元素：<code>Employee</code></li>
<li>具体元素：<code>FulltimeEmployee</code>+<code>ParttimeEmployee</code></li>
<li>对象结构：<code>EmployeeList</code></li>
<li>抽象访问者：<code>Department</code></li>
<li>具体访问者：<code>FADepartment</code>+<code>HRDepartment</code></li>
</ul>
<p>首先是抽象元素的代码：</p>
<pre><code class="language-java">interface Employee
{
    void accept(Department department);
}
</code></pre>
<p>只有一个<code>accept</code>表示接受抽象访问者访问的方法。</p>
<p>具体元素：</p>
<pre><code class="language-java">class FulltimeEmployee implements Employee
{
    private String name;
    public FulltimeEmployee(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return name;
    }
    @Override
    public void accept(Department department)
    {
        department.visit(this);
    }
}

class ParttimeEmployee implements Employee
{
    private String name;
    public ParttimeEmployee(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return name;
    }
    @Override
    public void accept(Department department)
    {
        department.visit(this);
    }
}
</code></pre>
<p>实现其中的<code>accept</code>方法，在里面调用抽象访问者的<code>visit</code>方法，将自身作为参数。</p>
<p>对象结构如下：</p>
<pre><code class="language-java">class EmployeeList
{
    private List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
    public void add(Employee employee)
    {
        list.add(employee);
    }

    public void accept(Department department)
    {
        list.forEach(t-&gt;t.accept(department));
    }
}
</code></pre>
<p><code>accept</code>会遍历元素集合，实现访问者对每一个具体元素的访问。</p>
<p>抽象访问者如下：</p>
<pre><code class="language-java">interface Department
{
    void visit(FulltimeEmployee employee);
    void visit(ParttimeEmployee employee);
}
</code></pre>
<p>两个参数不同的<code>visit</code>，分别表示对这两个不同具体元素的访问操作。</p>
<p>具体访问者：</p>
<pre><code class="language-java">class FADepartment implements Department
{
    @Override
    public void visit(FulltimeEmployee employee)
    {
        System.out.println(&quot;财务部访问全职员工&quot;+employee.getName());
    }
    @Override
    public void visit(ParttimeEmployee employee)
    {
        System.out.println(&quot;财务部访问兼职员工&quot;+employee.getName());
    }
}

class HRDepartment implements Department
{
    @Override
    public void visit(FulltimeEmployee employee)
    {
        System.out.println(&quot;人力资源部访问全职员工&quot;+employee.getName());
    }
    @Override
    public void visit(ParttimeEmployee employee)
    {
        System.out.println(&quot;人力资源部访问兼职员工&quot;+employee.getName());
    }
}
</code></pre>
<p>对于不同的具体元素，不同的具体访问者有不同的处理方法，这里简单处理只是进行输出。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Employee fulltimeEmployee = new FulltimeEmployee(&quot;A&quot;);
    Employee parttimeEmployee = new ParttimeEmployee(&quot;B&quot;);
    EmployeeList list = new EmployeeList();
    list.add(fulltimeEmployee);
    list.add(parttimeEmployee);
    list.accept(new HRDepartment());
    list.accept(new FADepartment());
}
</code></pre>
<p>客户端针对抽象元素以及抽象访问者编程，创建具体元素后添加到对象结构中，接着将具体访问者作为参数传入对象结构的访问方法中。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200805033900393.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-分派">5 分派</h1>
<p>在访问者模式中涉及到了“伪动态双分派”的概念，首先看一下什么是分派。</p>
<h2 id="51-定义">5.1 定义</h2>
<p>变量被声明时的类型叫静态类型，变量所引用的类型叫实际类型。比如：</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>中，<code>list</code>的静态类型为<code>List</code>，实际类型为<code>ArrayList</code>。</p>
<p><strong>根据对象的类型对方法进行的选择，就是分派。</strong></p>
<p>分派按照分派的方式可以分为：</p>
<ul>
<li>静态分派</li>
<li>动态分派</li>
</ul>
<p>按照分派基于的宗量，可以分为：</p>
<ul>
<li>单分派</li>
<li>多分派</li>
</ul>
<p>先来看一下静/动态分派。</p>
<h2 id="52-静动态分派">5.2 静/动态分派</h2>
<h3 id="521-静态分派">5.2.1 静态分派</h3>
<p><strong>静态分派：发生在编译时期，分派根据静态类型信息发生，比如方法重载</strong>。</p>
<p>比如下面的例子：</p>
<pre><code class="language-java">public class Test 
{
    public static void main(String[] args) 
    {
        test(Integer.valueOf(1));
        test(&quot;1&quot;);
    }

    public static void test(String s)
    {
        System.out.println(&quot;String&quot;);
    }

    public static void test(Integer i)
    {
        System.out.println(&quot;Integer&quot;);
    }
}
</code></pre>
<p>对于<code>test</code>方法，会根据静态类型选择方法版本，依据<code>test</code>方法的参数类型和参数数量可以确定唯一一个重载方法版本。</p>
<h3 id="522-动态分派">5.2.2 动态分派</h3>
<p><strong>动态分派：发生在运行时期，动态置换掉某个方法，比如面向对象的多态特性</strong>。</p>
<p>与静态分派相反，动态分派在运行时确定具体方法，比如：</p>
<pre><code class="language-java">public class Test 
{
    public static void main(String[] args) 
    {
        A b = new B();
        A c = new C();
        b.test();
        c.test();
    }
}

interface A
{
    void test();
}

class B implements A
{
    @Override
    public void test()
    {
        System.out.println(&quot;B方法&quot;);
    }
}

class C implements A
{
    @Override
    public void test()
    {
        System.out.println(&quot;C方法&quot;);
    }
}
</code></pre>
<p>例子的<code>test</code>方法，无法根据对象的静态类型去判断，因为都是同一接口，而是在运行时判断，这就是动态分派，运行时获取到对象的具体引用类型，再确定具体的方法。</p>
<h2 id="53-单多分派">5.3 单/多分派</h2>
<p>在了解单/多分派之前，先了解一下宗量。</p>
<p><strong>一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称为方法的宗量。</strong></p>
<p>比如下面的<code>Test</code>类：</p>
<pre><code class="language-java">public class Test
{
	public void print(String str){}
}
</code></pre>
<p><code>print()</code>属于<code>Test</code>对象，所以接收者就是<code>Test</code>对象，<code>print()</code>有参数<code>str</code>，类型为<code>String</code>。所以<code>print</code>的宗量有两个：</p>
<ul>
<li>接收者<code>Test</code></li>
<li>参数<code>String str</code></li>
</ul>
<p>根据分派基于多少种宗量，可以将分派划分为单分派与多分派：</p>
<ul>
<li>单分派根据一个宗量的类型对方法进行选择</li>
<li>多分派根据多个宗量的类型对方法进行选择（双分派是多分派的一种形式，根据两个宗量的类型对方法进行选择）</li>
</ul>
<h2 id="54-java语言特性">5.4 Java语言特性</h2>
<p><strong>Java是静态多分派，动态单分派语言。</strong></p>
<p>理由如下：</p>
<ul>
<li>静态多分派：从上面方法重载的例子可以看到，静态时确定方法，而且选择方法的依据是多个宗量（方法接收者，方法参数，参数数量，参数顺序），因此可以说的静态多分派</li>
<li>动态单分派：从上面动态分派的例子可以知道，Java中动态分派仅仅考虑到方法的接收者，也就是只根据一个宗量（方法接收者）去选择方法，所以说是动态单分派</li>
</ul>
<h2 id="55-伪动态双分派">5.5 伪动态双分派</h2>
<p>一个方法根据两个宗量的类型来决定执行不同的代码，这就是双分派。<strong>Java是动态单分派语言，也就是不支持动态双分派。但是使用访问者模式可以达到一种“动态双分派”的效果。因为这不是真正的动态双分派，所以加上了一个“伪”，这种“伪动态双分派”其实是通过两次“动态单分派”来实现。</strong></p>
<p>访问者模式的双分派中，不仅要根据被访问者的运行时区别，还要根据访问者的运行时区别，在客户端中将具体访问者作为参数传递给被访问者（具体元素）：</p>
<pre><code class="language-java">@Override
public void accept(Department department)
{
    department.visit(this);
}
</code></pre>
<p>由于<code>department</code>是抽象访问者，运行时确定具体调用哪一个具体访问者的<code>visit</code>，这里完成第一次动态单分派。</p>
<p>另外<code>visit</code>接受抽象元素作为参数，把具体元素（<code>this</code>）作为参数传递，根据<code>方法接收者宗量</code>选择相应的<code>visit</code>方法，在这里完成第二次动态分派。</p>
<p><strong>也就是说，访问者模式是首先根据访问者的动态单分派，再根据具体元素（被访问者）的动态单分派，来达到“动态双分派”的效果，由于这不是真正的动态双分派，而且Java是动态单分派语言，因此这种机制也叫“伪动态双分派”。</strong></p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>新增访问操作方便：使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，符合开闭原则</li>
<li>集中访问行为：将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>新增元素类困难：访问者模式中每新增一个元素类以为着抽象访问者角色需要增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了开闭原则</li>
<li>破坏封装：访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>一个对象结构中包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而且需要避免让这些操作“污染”这些对象的类，也不希望在新增操作时修改这些类。访问者模式将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者者类所使用，将对象本身于对象的访问操作分离</li>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200805173507935.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十五）：模板方法模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-wu-mo-ban-fang-fa-mo-shi/">
        </link>
        <updated>2020-08-07T09:27:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
<li><a href="#15-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5 模板方法与基本方法</a>
<ul>
<li><a href="#151-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">1.5.1 模板方法</a></li>
<li><a href="#152-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">1.5.2 基本方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E7%B1%BB">2.2 抽象类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%AD%90%E7%B1%BB">2.3 具体子类</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">4 主要优点</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">5 主要缺点</a></li>
<li><a href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">6 适用场景</a></li>
<li><a href="#7-%E6%80%BB%E7%BB%93">7 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>模板方法模式是结构最简单的行为型设计模型，在其结构中只存在父类与之类之间的继承关系，通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</strong></p>
<p>模板方法模式是一种类行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804195920960.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>AbstractClass</code>（抽象类）：抽象类中定义了一系列基本操作，这些操作是具体的也可以是抽象的，每一个基本操作对应算法的一个步骤，在子类中可以重定义或实现这些步骤，同时抽象类实现了一个模板方法，定义一个算法的框架</strong></li>
<li><strong><code>ConcreteClass</code>（具体子类）：实现父类中的抽象基本方法，或者覆盖父类中具体基本操作</strong></li>
</ul>
<h2 id="15-模板方法与基本方法">1.5 模板方法与基本方法</h2>
<h3 id="151-模板方法">1.5.1 模板方法</h3>
<p>模板方法是在抽象类中定义的，把基本操作方法组合成一个总算法或总行为的方法。模板方法在抽象类中定义，并由子类不加以修改完全继承。模板方法是一个具体方法，给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。另外由于模板方法是具体方法，因此抽象层只能实现为抽象类而不能是接口。</p>
<h3 id="152-基本方法">1.5.2 基本方法</h3>
<p>基本方法是实现算法的各个步骤，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li>抽象方法：抽象方法就是在抽象类中声明并由子类实现的方法</li>
<li>具体方法：具体方法可以由抽象类实现，或者由子类覆盖实现</li>
<li>钩子方法：钩子方法可以由抽象类实现，子类可以加以扩展</li>
</ul>
<p>在模板方法模式中，钩子方法一般有两类：</p>
<ul>
<li>第一类钩子方法是可以与一些具体步骤挂钩，以实现在不同条件下执行模板方法的不同步骤，这类方法一般返回<code>boolean</code>，方法名一般为<code>isXXX</code></li>
<li>第二类钩子方法是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法</li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象类：声明模板方法以及基本方法</li>
<li>定义模板方法：模板方法是抽象类中的具体方法，按照实际需要将基本方法进行组合</li>
<li>定义基本方法：定义抽象方法，具体方法以及钩子方法，确定好哪些方法交由抽象类实现，哪些方法交由子类实现以及拥有哪些钩子方法</li>
<li>定义具体子类：实现抽象类的抽象方法，按照需要对钩子方法或者具体方法进行覆盖</li>
</ul>
<h2 id="22-抽象类">2.2 抽象类</h2>
<pre><code class="language-java">abstract class AbstractClass
{
    public void templateMethod()
    {
        primitiveOperation1();
        primitiveOperation2();
        if(primitiveOperation3())
            System.out.println(&quot;符合钩子方法条件&quot;);
        else
            System.out.println(&quot;不符合钩子方法条件&quot;);
        primitiveOperation4();
    }

    public void primitiveOperation1()
    {
        System.out.println(&quot;抽象类具体方法&quot;);
    }

    //抽象类抽象方法
    abstract public void primitiveOperation2();

    //第一类钩子方法
    public boolean primitiveOperation3()
    {
        return false;
    }
    
    //第二类钩子方法
    public void primitiveOperation4()
    {

    }
}
</code></pre>
<p>首先定义了模板方法，作为客户端操作的入口。模板方法中对基本方法进行了组合，这里声明了四个基本方法：</p>
<ul>
<li>第一个是抽象类的具体方法：这是所有子类都拥有的相同实现的方法，不应该被子类覆盖</li>
<li>第二个是抽象类的抽象方法：子类需要实现该方法以实现变化</li>
<li>第三个是第一类钩子方法：这类钩子方法返回一个<code>boolean</code>，可以用于控制是否执行某个步骤，子类可以通过这类钩子方法对模板方法的执行过程进行限制，比如如果不想执行某个步骤可以永远返回<code>false</code></li>
<li>第四个是第二类钩子方法：这类钩子方法中父类提供一个空实现，子类选择性进行覆盖</li>
</ul>
<h2 id="23-具体子类">2.3 具体子类</h2>
<pre><code class="language-java">class ConcreteClass extends AbstractClass
{
    public void primitiveOperation2()
    {
        System.out.println(&quot;子类具体方法&quot;);
    }

    public boolean primitiveOperation3()
    {
        return true;
        // 如果想钩子方法返回false可以不实现该方法
        // 因为父类默认返回false
        // return false;
    }

    public void primitiveOperation4()
    {
        System.out.println(&quot;子类覆盖父类第二类钩子方法&quot;);
    }
}
</code></pre>
<p>这里子类实现了抽象类的抽象方法，同时覆盖了两类钩子方法。</p>
<h2 id="24-客户端">2.4 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    AbstractClass class1 = new ConcreteClass();
    class1.templateMethod();
}
</code></pre>
<p>客户端调用很简单，创建一个具体类对象并执行其中的模板方法即可。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200805000357803.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>为银行业务开发一个利息计算模块，该计算模块拥有标准流程：系统验证用户信息，接着判断用户状态，正常状态用户能计算利息，受限制状态用户无法计算利息，最后显示利息，使用模板方法模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象类：<code>Account</code></li>
<li>具体方法：<code>validate(String name)</code></li>
<li>抽象方法：<code>calculate()</code></li>
<li>钩子方法：<code>canCalculate()</code>+<code>display()</code></li>
<li>具体子类：<code>NormalAccount</code>+<code>RestrictedAccount</code></li>
</ul>
<p>首先是抽象类的设计：</p>
<pre><code class="language-java">abstract class Account
{
    public void handle(String name)
    {
        if(validate(name))
        {
            if(canCalculate())
            {
                calculate();
            }
            display();
        }
        else
        {
            System.out.println(&quot;用户名非法&quot;);
        }
    }

    public boolean validate(String name)
    {
        return &quot;1&quot;.equals(name);
    }

    //抽象类抽象方法
    abstract public void calculate();

    //第一类钩子方法
    public boolean canCalculate()
    {
        return true;
    }
    
    //第二类钩子方法
    public void display()
    {

    }
}
</code></pre>
<p>首先通过<code>validate()</code>验证用户名，接着根据第一类钩子方法<code>canCalculate()</code>判断能否计算利息，然后调用抽象计算方法<code>calculate()</code>进行计算，最后无论能够计算利息都会调用第二类钩子方法<code>display()</code>。</p>
<p>具体子类代码如下：</p>
<pre><code class="language-java">class NormalAccount extends Account
{
    public void calculate()
    {
        System.out.println(&quot;正常状态用户计算利息&quot;);
    }

    public void display()
    {
        System.out.println(&quot;正常状态用户显示利息&quot;);
    }
}

class RestrictedAccount extends Account
{
    public boolean canCalculate()
    {
        return false;
    }

    public void calculate()
    {}

    public void display()
    {
        System.out.println(&quot;受限状态用户无法计算利息&quot;);
    }
}
</code></pre>
<p>正常状态用户中实现抽象方法<code>calculate()</code>，并覆盖第二类钩子方法<code>display()</code>，对于受限状态用户，覆盖了第一类钩子方法<code>canCalculate()</code>，永远返回<code>false</code>，同时对抽象方法<code>calculate</code>提供空实现，最后也对第二类钩子方法<code>display</code>进行了覆盖，提示<code>&quot;无法计算利息&quot;</code>。</p>
<h1 id="4-主要优点">4 主要优点</h1>
<ul>
<li>形式化算法：模板方法模式在父类中形式化地定义一个算法，而由子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li>
<li>代码复用：模板方法模式是一种代码复用技术，提取公共行为并放在父类中，通过子类实现不同的行为</li>
<li>实现反向控制：模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否执行</li>
<li>增加子类方便：模板方法模式中可通过子类覆盖父类的基本方法，不同子类可以提供基本方法的不同实现，更换以及增加新的子类很方便</li>
</ul>
<h1 id="5-主要缺点">5 主要缺点</h1>
<ul>
<li>子类数量多：模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
</ul>
<h1 id="6-适用场景">6 适用场景</h1>
<ul>
<li>对一些复杂算法进行分割，将其算法中固定不变的部分设计为模板方法和父类方法，而一些改变的细节由子类实现，也就是一次性实现算法中不变部分，并将可变部分交由子类实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>需要通过子类决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li>
</ul>
<h1 id="7-总结">7 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200805003325546.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十四）：策略模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-si-ce-lue-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-si-ce-lue-mo-shi/">
        </link>
        <updated>2020-08-07T09:27:03.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB">2.2 抽象策略类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E7%AD%96%E7%95%A5%E7%B1%BB">2.3 具体策略类</a></li>
<li><a href="#24-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.4 环境类</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-jdk%E4%B8%AD%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">4 JDK中的策略模式</a></li>
<li><a href="#5-%E4%B8%8E%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C">5 与状态模式的不同</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在外出旅游时，很多时候的出行方式都不止一条，通常根据实际情况，比如目的地，预算，旅游时间等确定最适合的出行方式。在软件开发中，也常常会遇到类似的情况，实现某一个功能有多种途径，每一条途径对应一个算法，这时可以使用一种叫做策略模式的设计模式来进行设计。在策略模式中，可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法。</p>
<p>这里<strong>每一个封装的算法可以被称之为一种策略</strong>，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类作为规则的定义，每种具体算法对应于一个具体策略类。</p>
<p>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合DIP（依赖倒转原则）。出现新算法时只需要定义一个新的具体策略类即可。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>策略模式：定义一系列算法类，将每一个算法封装起来，并让他们可以相互替换。</strong></p>
<p>策略模式也叫政策模式，是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804164612252.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Context</code>（环境类）：使用算法的角色，解决了某个问题时可以采用的多种策略，在环境类维持一个抽象策略类的引用实例，用于定义所采用的策略</strong></li>
<li><strong><code>Strategy</code>（抽象策略类）：为支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或具体类，也可以是接口，环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法</strong></li>
<li><strong><code>ConcreteStrategy</code>（具体策略类）：实现了抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象策略类：一般实现为接口，声明抽象算法</li>
<li>定义具体策略类：实现抽象策略类，实现其中的具体算法</li>
<li>定义环境类：维持一个对抽象策略类的引用，通过setter或构造函数注入具体策略类，调用时通过该抽象引用调用相应算法</li>
</ul>
<h2 id="22-抽象策略类">2.2 抽象策略类</h2>
<pre><code class="language-java">interface AbstarctStrategy
{
    void algorithm();
}
</code></pre>
<p>这里定义为一个接口，只有一个抽象算法方法。</p>
<h2 id="23-具体策略类">2.3 具体策略类</h2>
<pre><code class="language-java">class ConcreteStrategy1 implements AbstarctStrategy
{
    @Override
    public void algorithm()
    {
        System.out.println(&quot;具体策略1&quot;);
    }
}

class ConcreteStrategy2 implements AbstarctStrategy
{
    @Override
    public void algorithm()
    {
        System.out.println(&quot;具体策略2&quot;);
    }
}
</code></pre>
<p>定义两个具体策略类，分别表示不同的算法。</p>
<h2 id="24-环境类">2.4 环境类</h2>
<pre><code class="language-java">class Context
{
    private AbstarctStrategy strategy;
    public void setStrategy(AbstarctStrategy strategy)
    {
        this.strategy = strategy;
    }

    public void algorithm()
    {
        strategy.algorithm();
    }
}
</code></pre>
<p>通过setter注入具体策略类，在调用环境类的方法时通过抽象策略类调用其中的具体策略类的算法。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Context context = new Context();
    context.setStrategy(new ConcreteStrategy1());
    context.algorithm();
    context.setStrategy(new ConcreteStrategy2());
    context.algorithm();
}
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个电影票打折系统，有三种不同的打折方式：学生可以享受8折优惠，10周岁以下儿童可以享受减免10元优惠，VIP可以享受半价优惠，使用策略模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>MovieTicket</code></li>
<li>抽象策略类：<code>Discount</code></li>
<li>具体策略类：<code>StudentDiscount</code>+<code>VIPDiscount</code>+<code>ChildrenDiscount</code></li>
</ul>
<p>首先是抽象策略类：</p>
<pre><code class="language-java">interface Discount
{
    double calculate(double price);
}
</code></pre>
<p>包含一个计算折扣的方法，接着是具体策略类：</p>
<pre><code class="language-java">class StudenDiscount implements Discount
{
    @Override
    public double calculate(double price)
    {
        System.out.println(&quot;学生票&quot;);
        return price * 0.8;
    }
}

class ChildrenDiscount implements Discount
{
    @Override
    public double calculate(double price)
    {
        System.out.println(&quot;儿童票&quot;);
        return price - 10.0;
    }
}

class VIPDiscount implements Discount
{
    @Override
    public double calculate(double price)
    {
        System.out.println(&quot;VIP票&quot;);
        return price * 0.5;
    }
}
</code></pre>
<p>三个不同的具体策略类表示三种不同的计算折扣方式，根据需要返回对应的折扣价格。</p>
<p>最后是环境类：</p>
<pre><code class="language-java">class MovieTicket
{
    private Discount discount;
    private double originalPrice;

    public void setPrice(double price)
    {
        this.originalPrice = price;
    }

    public void setDiscount(Discount discount)
    {
        this.discount = discount;
    }

    public double getDicountPrice()
    {
        return discount.calculate(originalPrice);
    }
}
</code></pre>
<p>环境类通过<code>setPrice</code>设定电影票价格后，在通过<code>setDiscount</code>注入具体策略类，最后使用<code>getDiscountPrice</code>获取折扣后的价格。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    MovieTicket movieTicket = new MovieTicket();
    movieTicket.setPrice(100.0);
    movieTicket.setDiscount(new StudenDiscount());
    System.out.println(movieTicket.getDicountPrice());
    movieTicket.setDiscount(new VIPDiscount());
    System.out.println(movieTicket.getDicountPrice());
    movieTicket.setDiscount(new ChildrenDiscount());
    System.out.println(movieTicket.getDicountPrice());
}
</code></pre>
<p>客户端需要明确知道这三种折扣，也就是打折方式由客户端指定，输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200804170700583.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-jdk中的策略模式">4 JDK中的策略模式</h1>
<p>策略模式实用性强，扩展性好，是使用频率较高的设计模式，下面来看看JDK中的典型应用。</p>
<p>Java SE容器布局管理器就是策略模式的一个经典应用案例，基本结构如下：<br>
<img src="https://img-blog.csdnimg.cn/20200804171732649.png" alt="在这里插入图片描述" loading="lazy"><br>
JavaSE中用户需要对容器对象<code>Container</code>进行布局，在程序运行期间由客户端动态决定一个<code>Container</code>对象如何布局，Java提供了几种不同的布局方式：<code>BorderLayout</code>，<code>FlowLayout</code>，<code>GridLayout</code>，<code>GridBagLayout</code>，<code>CardLayout</code>。在上图结构中：</p>
<ul>
<li><code>Container</code>充当了环境角色<code>Context</code></li>
<li><code>LayoutManager</code>充当了抽象策略角色</li>
<li><code>LayoutManager</code>的各个子类充当了具体策略类</li>
</ul>
<p><code>Container</code>针对<code>LayoutManager</code>进行编程，无须关心具体布局是什么，这样的设计符合里氏替换原则。</p>
<h1 id="5-与状态模式的不同">5 与状态模式的不同</h1>
<p>状态模式与策略模式很像，下面是两者的结构图：<br>
<img src="https://img-blog.csdnimg.cn/20200804164612252.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200804023536851.png" alt="在这里插入图片描述" loading="lazy"><br>
两者的结构图很相似，但是实际上也有很多的不同：</p>
<ul>
<li>意图不同：策略模式让客户端指定更换具体策略算法，而状态模式是状态在满足一定条件自动切换，用户无法手动设置状态</li>
<li>负责范围不同：状态模式负责不同状态下对象行为的处理，而策略模式负责具体算法或策略的处理，对于算法来说都有一个明确的目标，都是在做一件事情，比如上面的电影票打折例子，无论选择何种策略，都是为了打折，但是状态模式在不同的状态下做的事情可能不同</li>
<li>封装内容不同：状态模式封装了对象的状态，而策略模式封装了具体的算法或策略</li>
<li>重用性不同：状态是跟对象密切相关的，不能重用，而策略模式的具体策略可以分离出来重用</li>
<li><code>Context</code>的使用不同：状态模式中每个状态持有<code>Context</code>引用，实现状态切换，但是每个策略不持有<code>Context</code>引用，策略只是被<code>Context</code>使用</li>
<li>客户端需要考虑的情况不同：对于状态模式来说，状态模式依赖于其内部状态的变化时内部的行为发生变化，状态是系统自身固有的，由系统本身控制，状态对客户端不透明，客户端不需要考虑系统的状态，也不能直接指定或改变系统的状态切换。但是对于策略模式来说，客户端需要知道所有的策略类，明确各种策略的利弊，对其进行权衡并选择策略，也就是策略需要对客户端透明，需要由客户端考虑使用何种策略</li>
</ul>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>完美支持OCP：策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为，也可以灵活提供新的算法或行为</li>
<li>易于管理和复用算法：策略模式提供了管理相关的算法族的办法，策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共代码移到抽象策略类中以简化代码，同时由于算法单独封装在具体策略类中，可以方便复用这些算法</li>
<li>替换继承：策略模式提供了一种替换继承关系的方法，不使用策略模式的话环境类可能有子类，造成算法的使用和定义混在一起，而且使用继承的话无法实现算法或行为在运行时动态切换</li>
<li>避免多重<code>else if</code>：多重选择语句不易维护，因为将选择算法的逻辑以及算法本事实现逻辑混在一起，硬编码在一个巨大的<code>if/else if</code>中，使用策略模式可以避免这种结构</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>策略类需要对客户端透明：客户端必须知道所有的策略类，并自行决定哪一个策略类，也就是客户端需要理解这些算法的区别以便选择适当的算法</li>
<li>策略类数量多：策略模式会造成系统产生很多具体策略类，任何细小的变化都会导致系统增加一个新的具体策略类</li>
<li>客户端无法使用多个策略类：客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩下的功能</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>一个系统需要动态在几种算法中选择一种，这些算法类均有统一的接口</li>
<li>一个对象有很多行为，使用策略模式可以将这些行为转移到相应具体策略类中</li>
<li>不希望客户端知道复杂的，与算法相关的数据结构，在具体策略类中对其进行封装</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200804183310775.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十三） 状态模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-san-zhuang-tai-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-san-zhuang-tai-mo-shi/">
        </link>
        <updated>2020-08-07T08:45:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.2 环境类</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E7%8A%B6%E6%80%81%E7%B1%BB">2.3 抽象状态类</a></li>
<li><a href="#24-%E5%85%B7%E4%BD%93%E7%8A%B6%E6%80%81%E7%B1%BB">2.4 具体状态类</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81">4 共享状态</a></li>
<li><a href="#5-%E7%8E%AF%E5%A2%83%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2">5 环境类实现状态切换</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。</p>
<p>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何处状态对象，客户端都可以一致性地处理。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类。</strong></p>
<p>状态模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200804023536851.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Context</code>（环境类）：环境类角色又称上下文类，是拥有多种状态的对象，环境类的状态存在多样性且在不同状态下对象的行为有所不同。在环境类中维护一个抽象状态类<code>State</code>的实例，定义当前状态，实现时将具体状态类注入其中</strong></li>
<li><strong><code>State</code>（抽象状态类）：声明各种不同状态对应的方法，封装具体状态类的共同方法</strong></li>
<li><strong><code>ConcreteState</code>（具体状态类）：抽象状态类的子类，实现其中的具体状态行为方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义环境类：环境类包含一个抽象状态成员，可以通过构造方法或者setter注入具体状态，同时包含业务方法，该业务方法会调用抽象状态类的处理状态方法</li>
<li>定义抽象状态类：声明状态处理方法，使用环境类作为参数</li>
<li>定义具体状态类：实现/继承抽象状态类，按实际需要实现其中的状态处理方法</li>
</ul>
<h2 id="22-环境类">2.2 环境类</h2>
<pre><code class="language-java">class Context
{
    private State state = new ConcreteState1();

    public void setState(State state)
    {
        this.state = state;
    }

    public void request()
    {
        state.handle(this);
    }
}
</code></pre>
<p>具有默认初始化状态，可以通过setter修改状态，<code>request</code>为环境类业务方法，其中调用了抽象状态类的状态处理方法。</p>
<h2 id="23-抽象状态类">2.3 抽象状态类</h2>
<pre><code class="language-java">interface State
{
    void handle(Context context);
}
</code></pre>
<p>这里设计为接口，使用环境类作为参数。</p>
<h2 id="24-具体状态类">2.4 具体状态类</h2>
<pre><code class="language-java">class ConcreteState1 implements State
{
    @Override
    public void handle(Context context)
    {
        System.out.println(&quot;具体状态1方法&quot;);
        context.setState(new ConcreteState2());
    }
}

class ConcreteState2 implements State
{
    @Override
    public void handle(Context context)
    {
        System.out.println(&quot;具体状态2方法&quot;);
        context.setState(new ConcreteState1());
    }
}
</code></pre>
<p>两个具体状态类，执行完具体状态类里面的代码后，通过环境类参数将环境类切换到另一个状态。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Context context = new Context();
    context.request();
    context.request();
}
</code></pre>
<p>客户端直接调用环境类业务方法，输出如下：<br>
<img src="https://img-blog.csdnimg.cn/2020080410270591.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个银行账户，账户允许不同的状态，余额大于0处于正常状态，余额大于-2000小于0处于透支状态，余额小于等于-2000处理受限状态。根据余额不同状态可发生转换，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Account</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>NormalState</code>+<code>OverdraftState</code>+<code>RestrictedState</code></li>
</ul>
<p>首先是环境类：</p>
<pre><code class="language-java">class Account
{
    private State state = new NormalState(this);
    private double balance = 0.0;

    public void setState(State state)
    {
        this.state = state;
    }

    public void deposit(double amount)
    {
        balance += amount;
        state.check();
    }

    public void withdraw(double amount)
    {
        balance -= amount;
        state.check();
    }

    public double getBalance()
    {
        return balance;
    }

    @Override
    public String toString()
    {
        return &quot;当前状态:&quot;+state;
    }

}
</code></pre>
<p>初始化为正常状态，余额为0，在存款/取款中调用抽象状态类的状态检查方法，也就是状态转换交由状态类处理。</p>
<p>接着是抽象状态类：</p>
<pre><code class="language-java">abstract class State
{
    protected Account account;
    public abstract void check();
}
</code></pre>
<p>拥有一个环境类的引用，以便使用环境类的<code>setState</code>改变状态方法。</p>
<p>最后是具体状态类：</p>
<pre><code class="language-java">class NormalState extends State
{
    public NormalState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
        else if(account.getBalance() &lt; -2000)
            account.setState(new RestrictedState(account));
    }

    @Override
    public String toString()
    {
        return &quot;正常状态&quot;;
    }
}

class OverdraftState extends State
{
    public OverdraftState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &lt; -2000)
            account.setState(new RestrictedState(account));
    }

    @Override
    public String toString()
    {
        return &quot;透支状态&quot;;
    }
}

class RestrictedState extends State
{
    public RestrictedState(Account account)
    {
        this.account = account;
    }

    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
    }

    @Override
    public String toString()
    {
        return &quot;受限状态&quot;;
    }
}
</code></pre>
<p>三个具体状态类分别表示三种不同状态，在其中的<code>check</code>方法中进行状态检查以及切换状态。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Account account = new Account();
    account.deposit(1000);
    System.out.println(account);        
    account.withdraw(2000);
    System.out.println(account);
    account.withdraw(2000);
    System.out.println(account);
    account.deposit(10000);
    System.out.println(account);
}
</code></pre>
<p>客户端不需要理会具体状态，按正常流程操作即可，下面是输出：<br>
<img src="https://img-blog.csdnimg.cn/20200804104938384.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-共享状态">4 共享状态</h1>
<p>有时候多个环境对象可能需要共享同一个状态，这时需要将状态对象定义为环境类的静态成员，例子如下：</p>
<blockquote>
<p>某个系统要求两个开关对象必须处于一样的状态，要么同时关，要么同时开，开关可以自由切换状态，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Switch</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>OffState</code>+<code>OnState</code></li>
</ul>
<p>环境类：</p>
<pre><code class="language-java">class Switch
{
    private State state;
    private static final State onState;
    private static final State offState;

    private String name;

    static
    {
        onState = new OnState();
        offState = new OffState();
    }

    public Switch(String name)
    {
        this.name = name;
        this.state = offState;
    }

    public String getName()
    {
        return name;
    }

    public void setState(State state)
    {
        this.state = state;
    }

    public static State getOnState()
    {
        return onState;
    }

    public static State getOffState()
    {
        return offState;
    }

    public void on()
    {
        state.on(this);
    }

    public void off()
    {
        state.off(this);
    }
}
</code></pre>
<p>环境类初始化两个静态的开与关状态，在<code>on</code>以及<code>off</code>中调用状态方法。</p>
<p>抽象状态：</p>
<pre><code class="language-java">interface State
{
    void on(Switch s);
    void off(Switch s);
}
</code></pre>
<p>具体状态：</p>
<pre><code class="language-java">class OnState implements State
{
    @Override
    public void on(Switch s)
    {
        System.out.println(&quot;开关&quot;+s.getName()+&quot;已经打开&quot;);
    }

    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;);
        s.setState(Switch.getOffState());
    }
}

class OffState implements State
{
    @Override
    public void on(Switch s)
    {
        System.out.println(&quot;开关&quot;+s.getName()+&quot;开启&quot;);
        s.setState(Switch.getOnState());
    }

    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;已经关闭&quot;);
    }
}
</code></pre>
<p>实现抽象状态的开关方法，处于关状态时调用<code>on</code>会切换到开状态，调用<code>off</code>则不处理，处于开状态同理。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Switch a = new Switch(&quot;A&quot;);
    Switch b = new Switch(&quot;B&quot;);
    a.on();
    b.on();
    a.off();
    b.off();
    a.on();
    b.on();
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/2020080411150944.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-环境类实现状态切换">5 环境类实现状态切换</h1>
<p>在上面的例子中，都是通过具体状态类进行状态切换，比如：</p>
<pre><code class="language-java">class RestrictedState extends State
{
    //...
    @Override
    public void check()
    {
        if(account.getBalance() &gt;= 0)
            account.setState(new NormalState(account));
        else if(account.getBalance() &gt;= -2000 &amp;&amp; account.getBalance() &lt; 0)
            account.setState(new OverdraftState(account));
    }
}
</code></pre>
<pre><code class="language-java">class OnState implements State
{
	//...   
    @Override
    public void off(Switch s)
    {        
        System.out.println(&quot;开关&quot;+s.getName()+&quot;关闭&quot;);
        s.setState(Switch.getOffState());
    }
}
</code></pre>
<p>状态切换也可以由环境类进行统一处理，但是如果增加新的状态类可能需要修改环境类代码。例子如下：</p>
<blockquote>
<p>设计一个放大镜工具，单击一次放大一倍，单击两次再放大一杯，第三次就恢复默认大小，使用状态模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：<code>Screen</code></li>
<li>抽象状态类：<code>State</code></li>
<li>具体状态类：<code>NormalState</code>+<code>LargerState</code>+<code>LargestState</code></li>
</ul>
<p>环境类：</p>
<pre><code class="language-java">class Screen
{
    private State state;
    private static final State normalState;
    private static final State largerState;
    private static final State largestState;

    static
    {
        normalState = new NormalState();
        largerState = new LargerState();
        largestState = new LargestState();
    }

    public Screen()
    {
        this.state = normalState;
    }

    public void onClick()
    {
        if(state == normalState)
            state = largerState;
        else if(state == largerState)
            state = largestState;
        else
            state = normalState;
        state.display();
    }
}
</code></pre>
<p>首先初始化各个状态，然后在<code>onClick()</code>中由环境类控制状态切换。</p>
<p>状态类：</p>
<pre><code class="language-java">interface State
{
    void display();
}

class NormalState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;正常大小&quot;);
    }
}

class LargerState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;两倍大小&quot;);
    }
}

class LargestState implements State
{
    @Override
    public void display()
    {
        System.out.println(&quot;四倍大小&quot;);
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Screen screen = new Screen();
    screen.onClick();
    screen.onClick();
    screen.onClick();
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200804112804218.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>封装转换规则：状态模式中可以将状态的转换代码封装在环境类或具体状态类中，可以将状态转换代码进行集中管理，而不是分散在一个个业务方法中</li>
<li>通过注入状态修改行为：将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境拥有不同的行为</li>
<li>状态转换逻辑与状态对象一体化：允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>增大运行开销：使用状态模式会增加系统中类和对象的个数</li>
<li>实现复杂：状态模式的程序结构实现复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计难度</li>
<li>对OCP支持不好：增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态，而且修改某个状态类的行为也需要修改对应的源代码</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>对象的行为依赖于它的状态，状态的改变会导致行为的变化</li>
<li>在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合度增强</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200804113352370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第51期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-51-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-51-qi/">
        </link>
        <updated>2020-08-07T08:43:05.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789842567.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第50期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-50-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-50-qi/">
        </link>
        <updated>2020-08-06T08:42:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789781282.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第49期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-49-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-49-qi/">
        </link>
        <updated>2020-08-05T08:41:48.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596789732981.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
</feed>