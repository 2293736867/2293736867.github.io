<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-07-25T17:29:22.926Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第38期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-38-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-38-qi/">
        </link>
        <updated>2020-07-25T17:15:43.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595697380266.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>以后要对女朋友好一点，毕竟她已经瞎了，不能再受伤害了。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>莫桑比克的蜂蜜狩猎人会用特殊的呼唤招募被称为“蜂蜜向导”的鸟类，这些鸟类会将人类带去蜂蜜的巢穴，并得到剩下的蜂蜡作为回报。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>来是空言去绝踪，月斜楼上五更钟。<br>
——李商隐《无题·来是空言去绝踪》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>为错误停驻是件可悲的事。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1382596189">嚣张-en</a></p>
</blockquote>
<blockquote>
<p>太多的<br>
太重的<br>
太残忍的话<br>
没纠缠<br>
是你的<br>
理由太假<br>
我觉得<br>
你大可不必说的天花乱坠<br>
是天使<br>
是魔鬼<br>
都没有绝对</p>
</blockquote>
<blockquote>
<p>没想的<br>
没说的<br>
都请收起吧<br>
你扮演<br>
的角色<br>
更可悲吗<br>
放弃的<br>
就大可不必再争辩是非<br>
放下的<br>
就请你<br>
烧得干脆</p>
</blockquote>
<blockquote>
<p>你的一字一句犹如刀疤划心上<br>
我的一举一动随你改变多荒唐<br>
任你肆意玩弄 从没去想<br>
你是有多嚣张<br>
我的心脏脉搏为你跳动为你狂<br>
你说我真的多余不如离开流浪<br>
都怪我<br>
没治愈我的伤</p>
</blockquote>
<blockquote>
<p>没想的<br>
没说的<br>
都请收起吧<br>
放弃的<br>
就大可不必再争辩是非<br>
放下的<br>
就请你<br>
烧的干脆</p>
</blockquote>
<blockquote>
<p>你的一字一句犹如刀疤划心上<br>
我的一举一动随你改变多荒唐<br>
任你肆意玩弄<br>
从没去想<br>
你是有多嚣张<br>
我的心脏脉搏为你跳动为你狂<br>
你说我真的多余不如离开流浪<br>
都怪我<br>
没治愈我的伤</p>
</blockquote>
<blockquote>
<p>你的一字一句犹如刀疤划心上<br>
我的一举一动随你改变多荒唐<br>
任你肆意玩弄<br>
从没去想<br>
你是有多嚣张<br>
我的心脏脉搏为你跳动为你狂<br>
你说我真的多余不如离开流浪<br>
都怪我没治愈我的伤</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十）：桥接模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qiao-jie-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qiao-jie-mo-shi/">
        </link>
        <updated>2020-07-25T17:01:21.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%9A%E4%B9%89">1 定义</a></li>
<li><a href="#2-%E6%A6%82%E8%BF%B0">2 概述</a></li>
<li><a href="#3-%E8%A7%92%E8%89%B2">3 角色</a></li>
<li><a href="#4-%E6%AD%A5%E9%AA%A4">4 步骤</a></li>
<li><a href="#5-%E5%AE%9E%E4%BE%8B">5 实例</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-定义">1 定义</h1>
<p><strong>桥接模式：将抽象部分与其实现部分分离，使它们都可以独立地变化。</strong><br>
它是一种对象结构型模式，又称为柄体模式或者接口模式。</p>
<h1 id="2-概述">2 概述</h1>
<p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统变得更加符合SRP。</p>
<p>比如，设计一个跨平台的图像浏览系统，支持的图片格式包括：</p>
<ul>
<li>PNG</li>
<li>BMP</li>
<li>JPG</li>
<li>GIF</li>
</ul>
<p>等等，而支持的系统包括：</p>
<ul>
<li>Windows</li>
<li>Unix</li>
<li>Linux</li>
</ul>
<p>等等，这样，系统与图片格式就是两个不同的维度，可以利用桥接模式将这两个维度分离，使得它们可以独立变化，增加新的图片格式或者新的系统时，都不会对另一个维度造成任何影响。</p>
<h1 id="3-角色">3 角色</h1>
<ul>
<li><code>Abstraction（抽象类）</code>：用于定义抽象类的接口，一般是抽象类而不是接口，具有一个<code>Implementor</code>的成员，与<code>Implementor</code>为关联关系，既可以包含抽象的业务方法，也可以包含具体业务方法</li>
<li><code>RefinedAbstraction（扩充抽象类）</code>：扩充由<code>Abstraction</code>定义的接口，通常为具体类，实现了在<code>Abstraction</code>中的抽象业务方法，同时可以调用<code>Implementor</code>中的业务方法</li>
<li><code>Implementor（实现类接口）</code>：实现类的接口，相比起<code>Abstractoin</code>提供的更多更复杂的操作，<code>Implementor</code>一般只提供基本操作，具体实现交由子类处理</li>
<li><code>ConcreteImplementor（具体实现类）</code>：具体实现<code>Implementor</code>接口，不同的<code>ConcreteImplementor</code>提供不同实现的基本操作</li>
</ul>
<p>结构图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200725072739377.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-步骤">4 步骤</h1>
<ul>
<li><strong>识别维度：首先识别出系统中两个独立变化的维度</strong></li>
<li><strong>继承：识别出维度后，将它们设计为两个独立的继承等级结构</strong>，比如上面的图片格式以及系统，将图片格式与系统设为抽象层，而BMP，GIF等继承图片格式抽象层，Windows等具体系统集成系统抽象层</li>
<li><strong>建立抽象耦合：在抽象层建立一个抽象关联</strong></li>
<li><strong>扩展：建立抽象耦合后，根据需要对两个维度进行独立扩展</strong>，比如增加新的图片格式WBEP，增加新的操作系统Mac等</li>
</ul>
<h1 id="5-实例">5 实例</h1>
<blockquote>
<p>跨平台的图片浏览系统，支持的图片格式包括PNG，JPG，BMP，GIF等，支持的系统包括Linux，Unix，Windows等，使用桥接模式设计。</p>
</blockquote>
<ul>
<li>图片维度：抽象类<code>Image</code>，BMP，GIF等继承<code>Image</code>，<code>Image</code>具有一个<code>ImageShow</code>的成员变量</li>
<li>系统维度：Linux，Unix，Windows实现图片显示接口<code>ImageShow</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Image image = new GIF();
        image.setImageShow(new Linux());
        image.show();
    }
}

//Image抽象类
abstract class Image
{
    protected ImageShow imageShow;
    public void setImageShow(ImageShow imageShow)
    {
        this.imageShow = imageShow;
    }
    public abstract show();
}

class BMP extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;BMP&quot;);
    }
}

class GIF extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;GIF&quot;);
    }
}

class PNG extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;PNG&quot;);
    }
}

class JPG extends Image
{
    @Override
    public void show()
    {
        imageShow.show(&quot;JPG&quot;);
    }
}

//图片显示接口
interface ImageShow
{
    void show(String name);
}

class Windows implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Windows show &quot;+name);
    }
}

class Linux implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Linux show &quot;+name);
    }
}

class Unix implements ImageShow
{
    @Override
    public void show(String name)
    {
        System.out.println(&quot;Unix show &quot;+name);
    }
}
</code></pre>
<p>更换图片格式只需要修改<code>Image</code>的父类：</p>
<pre><code class="language-java">Image image = new GIF();
Image image = new BMP();
Image image = new JPG();
Image image = new PNG();
</code></pre>
<p>而更换操作系统只需要修改传入setter的参数：</p>
<pre><code class="language-java">image.setImageShow(new Linux());
image.setImageShow(new Windows());
image.setImageShow(new Unix());
</code></pre>
<p>这样就可以把图片以及系统两个维度分离，并能够独立扩展，增加新的图片格式，只需要增加一个新的继承<code>Image</code>的类即可，增加新的系统只需实现<code>ImageShow</code>接口即可。<br>
由于例子简单使用反射进行简化代码并增加了新的系统以及图片格式，代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Image image = new WBEP();
        image.setImageShow(new Mac());
        image.show();
    }
}

abstract class Image
{
    protected ImageShow imageShow;
    public void setImageShow(ImageShow imageShow)
    {
        this.imageShow = imageShow;
    }
    public void show()
    {
        imageShow.show(getClass().getName());
    }
}

class BMP extends Image{}
class GIF extends Image{}
class PNG extends Image{}
class JPG extends Image{}
class WBEP extends Image{}

interface ImageShow
{
    void show(String name);
}

abstract class ImageSystem implements ImageShow
{
    public void show(String name)
    {
        System.out.println(getClass().getName()+&quot; show &quot;+name);
    }
}

class Windows extends ImageSystem{}
class Linux extends ImageSystem{}
class Unix extends ImageSystem{}
class Mac extends ImageSystem{}
</code></pre>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>低耦合：分离抽象接口及其实现部分，桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以按照各自的维度变化。也就是说，抽象和实现不再同一个继承层次中，而是让抽象作为父类，实现作为子类，这样就可以任意组合子类，从而获得多维度的组合对象</li>
<li>取代多重继承：很多情况下桥接模式可以取代多重继承，多重继承违反了SRP（单一权责原则），复用性差，而且类的个数多，桥接模式可以有效减少子类个数</li>
<li>提高扩展性：桥接模式提高了系统的扩展性，在两个维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>增加理解难度：桥接模式会增加系统的理解以及设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计以及编程</li>
<li>需要正确识别抽象层：桥接模式要求正确识别系统中两个独立变化的维度，因此适用范围有一定局限，正确识别独立维度需要一定经验积累</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>如果一个系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</li>
<li>抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象类子类的对象和一个实现类子类的对象进行动态组合</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展</li>
<li>对于不希望使用继承或因为多重继承导致系统类的个数急剧增加的系统</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200725081625928.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第37期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-37-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-37-qi/">
        </link>
        <updated>2020-07-25T15:25:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595696865103.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>诗和远方越远越脏，以梦为马越骑越傻。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>1996年，英格兰德文郡的一名男子花了一年时间向猫头鹰鸣叫，并记录下了他们的回应声，结果发现回应声是他的邻居所发出，而他邻居一直以为有猫头鹰对自己鸣叫。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>子规啼彻四更时，起时蚕稠怕叶稀。<br>
——谢枋得《蚕妇吟》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我为自己而死，并且，在最后的最后，为自己而活。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=441491828">水星记-郭顶</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1595697326125.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>着迷于你眼睛<br>
银河有迹可循<br>
穿过时间的缝隙<br>
它依然真实地<br>
吸引我轨迹</p>
</blockquote>
<blockquote>
<p>这瞬眼的光景<br>
最亲密的距离<br>
沿着你皮肤纹理<br>
走过曲折手臂<br>
做个梦给你<br>
做个梦给你<br>
等到看你银色满际<br>
等到分不清季节更替<br>
才敢说沉溺</p>
</blockquote>
<blockquote>
<p>还有多远才能进入你的新<br>
还要多久才能和你接近<br>
咫尺远近却无法靠近的那个人<br>
也等着和你相遇<br>
环游的行星<br>
怎么可以<br>
拥有你</p>
</blockquote>
<blockquote>
<p>这瞬眼的光景<br>
最亲密的距离<br>
沿着你皮肤纹理<br>
走过曲折手臂<br>
做个梦给你<br>
做个梦给你<br>
等到看你银色满际<br>
等到分不清季节更替<br>
才敢说沉溺</p>
</blockquote>
<blockquote>
<p>还有多久才能进入你的心<br>
还要多久才能和你接近<br>
咫尺远近却无法靠近的那个人<br>
也等着和你相遇<br>
环游的行星<br>
怎么可以<br>
拥有你</p>
</blockquote>
<blockquote>
<p>还要多远才能进入你的心<br>
还要多久才能和你接近<br>
咫尺远近却无法靠近的那个人<br>
要怎么探寻<br>
要多么幸运<br>
才敢让你发觉你并不孤寂<br>
当我还可以再跟你飞行<br>
环游是无趣<br>
至少可以<br>
陪着你</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（九）：适配器模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-jiu-gua-pei-qi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-jiu-gua-pei-qi-mo-shi/">
        </link>
        <updated>2020-07-24T15:26:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1 适配器模式</a>
<ul>
<li><a href="#11-%E5%AE%9A%E4%B9%89">1.1 定义</a></li>
<li><a href="#12-%E5%88%86%E7%B1%BB">1.2 分类</a>
<ul>
<li><a href="#121-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1.2.1 对象适配器模式</a></li>
<li><a href="#122-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1.2.2 类适配器模式</a></li>
</ul>
</li>
<li><a href="#13-%E8%A7%92%E8%89%B2">1.3 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%AE%9E%E4%BE%8B">2 实例</a>
<ul>
<li><a href="#21-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8">2.1 对象适配器</a></li>
<li><a href="#22-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8">2.2 类适配器</a></li>
<li><a href="#23-micro-usb%E4%B8%8Etype-c">2.3 Micro USB与Type-C</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8">3 双向适配器</a></li>
<li><a href="#4-%E7%BC%BA%E7%9C%81%E9%80%82%E9%85%8D%E5%99%A8">4 缺省适配器</a>
<ul>
<li><a href="#41-%E5%AE%9A%E4%B9%89">4.1 定义</a></li>
<li><a href="#42-%E7%BB%93%E6%9E%84%E5%9B%BE">4.2 结构图</a></li>
<li><a href="#43-%E8%A7%92%E8%89%B2">4.3 角色</a></li>
<li><a href="#44-%E5%AE%9E%E4%BE%8B">4.4 实例</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-适配器模式">1 适配器模式</h1>
<h2 id="11-定义">1.1 定义</h2>
<p><strong>将一个接口转换为客户希望的另一个接口，使接口不兼容的那些类可以一起工作，别名为包装器。</strong><br>
适配器中的接口是广义的接口，可以表示一个方法或者方法的集合。</p>
<p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<h2 id="12-分类">1.2 分类</h2>
<p>根据适配器与适配者类的关系不同，可以分为对象适配器模式以及类适配器模式。</p>
<h3 id="121-对象适配器模式">1.2.1 对象适配器模式</h3>
<p><strong>对象适配器模式就是适配器与适配者之间是关联关系</strong>。<br>
结构图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200724211913928.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="122-类适配器模式">1.2.2 类适配器模式</h3>
<p><strong>类适配器模式就是适配器与适配者之间是继承或实现关系。</strong><br>
结构图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200724212614271.png" alt="在这里插入图片描述" loading="lazy"><br>
由于语言特性的限制，比如Java，C#不支持多重继承，类适配器模式受到很多限制，例如Target如果不是接口而是一个类，就无法使用类适配器模式。此外如果适配者为<code>final</code>类也无法使用适配器模式，在Java等语言中大部分情况下使用对象适配器模式。</p>
<h2 id="13-角色">1.3 角色</h2>
<ul>
<li><strong>Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是一个具体类</strong></li>
<li><strong>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器类是适配器模式的核心，在对象适配器模式中，它通过继承Target并关联一个Adaptee对象使两者产生联系</strong></li>
<li><strong>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</strong></li>
</ul>
<h1 id="2-实例">2 实例</h1>
<h2 id="21-对象适配器">2.1 对象适配器</h2>
<p>Target类以及实现了Target的类：</p>
<pre><code class="language-java">interface Target
{
    void request();
}

class ConcreteTarget implements Target
{
    @Override
    public void request()
    {
        System.out.println(&quot;具体Target方法&quot;);
    }
}
</code></pre>
<p>适配者类：</p>
<pre><code class="language-java">class Adaptee
{
    public void specificRequest()
    {
        System.out.println(&quot;Adaptee方法&quot;);
    }
}
</code></pre>
<p>适配器类（实现了Target，适配者作为成员变量）：</p>
<pre><code class="language-java">class Adapter implements Target
{
    private Adaptee adaptee = new Adaptee();
    @Override
    public void request()
    {
        adaptee.specificRequest();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        Target target = new ConcreteTarget();
        target.request();
        Target adapter = new Adapter();
        adapter.request();
    }
}
</code></pre>
<h2 id="22-类适配器">2.2 类适配器</h2>
<p>在上述对象适配器的基础上，适配者与Target保持不变，适配器继承了适配者并实现了Target，同时取消了适配者作为成员变量，在方法内直接调用<code>super.xxx</code>，也就是适配者的方法：</p>
<pre><code class="language-java">class Adapter extends Adaptee implements Target
{
    @Override
    public void request()
    {
        super.specificRequest();
    }
}
</code></pre>
<h2 id="23-micro-usb与type-c">2.3 Micro USB与Type-C</h2>
<p>假设目前只有一条Micro USB线以及一台只有Type-C接口的手机，需要对其进行充电，这时候就需要一个转接头把Micro USB转为Type-C接口，才能给手机充电。<br>
这里的Target就是Type-C，适配者就是Micro USB，适配器就是转接头，简化实现代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        TypeC typeC = new MicroUSBToTypeC();
        typeC.chargeWithTypeC();
    }
}

//Target:给TypeC接口的手机充电
interface TypeC
{
    void chargeWithTypeC();
}

//Adaptee:适配者,MicroUSB线
class MicroUSB
{
    public void chargeWithMicroUSB()
    {
        System.out.println(&quot;MicroUSB充电&quot;);
    }
}

//Adapter:适配器,MicroUSB到TypeC的转接头
class MicroUSBToTypeC implements TypeC
{
    private MicroUSB microUSB = new MicroUSB();
    @Override
    public void chargeWithTypeC()
    {
        microUSB.chargeWithMicroUSB();
    }
}
</code></pre>
<h1 id="3-双向适配器">3 双向适配器</h1>
<p>在对象适配器的使用过程中，如果在适配器中同时包含对Target类和Adaptee类的引用，Adaptee类可以通过适配器调用Target类中的方法，Target类也可以通过适配器调用Adaptee类的方法，那么该适配器就是一个双向适配器。例子如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Adapter adapter = new Adapter();
        adapter.request();
        adapter.specificRequest();
    }
}

//适配者
interface Adaptee
{
    void specificRequest();
}

//Target类
interface Target
{
    void request();
}

//Target实现
class TargetImpl implements Target
{
    @Override
    public void request()
    {
        System.out.println(&quot;Target方法&quot;);
    }
}

//适配者实现
class AdapteeImpl implements Adaptee
{
    @Override
    public void specificRequest()
    {
        System.out.println(&quot;Adaptee方法&quot;);
    }
}

//适配器
class Adapter implements Adaptee,Target
{
    private Target target = new TargetImpl();
    private Adaptee adaptee = new AdapteeImpl();
    @Override
    public void request()
    {
    	//Target的方法调用适配者方法
        adaptee.specificRequest();
    }

    @Override
    public void specificRequest()
    {
    	//适配者方法调用Target的方法
        target.request();        
    }
}
</code></pre>
<h1 id="4-缺省适配器">4 缺省适配器</h1>
<h2 id="41-定义">4.1 定义</h2>
<p><strong>缺省适配器：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法都提供一个默认实现（空实现），那么该抽象类子类可以选择性覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中所有方法的情况，又叫单接口适配器模式。</strong></p>
<h2 id="42-结构图">4.2 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200724220658161.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-角色">4.3 角色</h2>
<ul>
<li><strong>ServiceInterface（适配者接口）：通常是一个声明了大量方法的接口</strong></li>
<li><strong>AbstractServiceClass（缺省适配器类）：缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法，通常定义为抽象类</strong></li>
<li><strong>ConcreteServiceClass（具体业务类）：是缺省适配器类的子类，只需要有选择性地覆盖适配器者中定义的方法，其他的方法在缺省适配器类中提供了空实现</strong></li>
</ul>
<h2 id="44-实例">4.4 实例</h2>
<p>Java AWT中一般可以通过两种方式来处理窗口事件：</p>
<ul>
<li>实现<code>WindowListener</code></li>
<li>继承<code>WindowAdapter</code></li>
</ul>
<p>其中<code>WindowAdapter</code>实现了<code>WindowListener</code>接口，但是都是提供了空实现，也就是说实现<code>WindowsListener</code>的话需要实现里面所有的方法，而继承<code>WindowAdapter</code>只需要选择性地覆盖方法即可，结构图：<br>
<img src="https://img-blog.csdnimg.cn/20200724222411465.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-主要优点">5 主要优点</h1>
<p>类适配器以及对象适配器的共同优点如下：</p>
<ul>
<li>解耦：将Target与Adaptee解耦，引入适配器来重用现有的适配者类，无须修改原有结构</li>
<li>提高复用性：将具体的业务实现过程封装在适配者类中，对于客户端而言是透明的，而且提高了适配者类的复用性，同一个适配者类可以在多个不同的系统复用</li>
<li>扩展性好：可以很方便地更换适配器，也可以在不修改代码的基础上增加了新的适配器类，完全符合开闭原则，扩展灵活</li>
</ul>
<p>类适配器的独有优点如下：</p>
<ul>
<li>由于适配器类是适配者的子类，因此在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li>
</ul>
<p>对象适配器的独有优点如下：</p>
<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个Target</li>
<li>可以适配一个适配者的子类，由于适配器与适配者之间是关联关系，根据LSP（里氏代换原则），适配者的子类也可以通过该适配器进行适配</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<p>类适配器缺点：</p>
<ul>
<li>对于Java，C#等不支持多重继承的语言，一次最多只能适配一个适配者类</li>
<li>适配者不能是“不能继承的类”，比如Java的<code>final</code>类，C#的<code>sealed</code>类</li>
<li>在Java，C#等Target只能是接口不能是类</li>
</ul>
<p>对象适配器缺点：</p>
<ul>
<li>置换麻烦：相比起类适配器，在适配器中置换适配者的某些方法比较麻烦，需要先创建一个适配者类的子类，在子类将适配者类的方法置换掉，再把适配者的子类作为真正的适配者类进行适配，实现较为复杂</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需求，甚至没有这些类的源代码</li>
<li>想创建一个可以重复使用的类，用于与彼此之间没有太大关联的类，包括可能在将来引进的类一起工作</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200724225754968.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习笔记（四）]]></title>
        <id>https://2293736867.github.io/post/vue-xue-xi-bi-ji-si/</id>
        <link href="https://2293736867.github.io/post/vue-xue-xi-bi-ji-si/">
        </link>
        <updated>2020-07-24T15:26:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-表单绑定">1 表单绑定</h1>
<p>可以利用<code>v-model</code>在表单控件元素上创建双向的数据绑定，<code>v-model</code>会根据控件类型自动选取正确的方法来更新元素。</p>
<h1 id="2-文本框">2 文本框</h1>
<p>文本框的绑定例子如下：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;p&gt;input&lt;/p&gt;
	&lt;input v-model=&quot;message&quot;&gt;
	&lt;p&gt;{{message}}&lt;/p&gt;
	
	&lt;p&gt;textarea&lt;/p&gt;
	&lt;textarea v-model=&quot;message2&quot;&gt;&lt;/textarea&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
	el:'#app',
	data:{
		message:'',
		message2:''
	}
})
</code></pre>
<h1 id="3-按钮">3 按钮</h1>
<h2 id="31-单选">3.1 单选</h2>
<p><code>data</code>中的值为<code>&lt;input&gt;</code>的<code>value</code>，如：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;radio&quot; value=&quot;Value1&quot; v-model=&quot;picked&quot;&gt;
    &lt;input type=&quot;radio&quot; value=&quot;Value2&quot; v-model=&quot;picked&quot;&gt;
    &lt;span&gt;选中的值为：{{picked}}&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
    el: '#app',
    data: {
        picked:'Value1'
    }
})
</code></pre>
<h2 id="32-多选">3.2 多选</h2>
<p>单个多选绑定的数据是一个布尔值，多个多选绑定的是一个数组：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    &lt;span&gt;是否选中：{{checked ? &quot;选中&quot; : &quot;不选中&quot;}}&lt;/span&gt;
	&lt;br&gt;
	
    &lt;input type=&quot;checkbox&quot; value=&quot;Value1&quot; id=&quot;box1&quot; v-model=&quot;checked2&quot;&gt;
    &lt;label for=&quot;box1&quot;&gt;Value1&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;Value2&quot; id=&quot;box2&quot; v-model=&quot;checked2&quot;&gt;
    &lt;label for=&quot;box2&quot;&gt;Value2&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;Value3&quot; id=&quot;box3&quot; v-model=&quot;checked2&quot;&gt;
    &lt;label for=&quot;box3&quot;&gt;Value3&lt;/label&gt;
    &lt;br&gt;
    &lt;span&gt;选中的值为：{{checked2}}&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
    el: '#app',
    data: {
        checked:'Value1',
        checked2:[]
    }
})
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200723153506792.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-列表">4 列表</h1>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;select name=&quot;fruit&quot; v-model=&quot;selected&quot;&gt;
        &lt;option value=&quot;&quot;&gt;请选择一个&lt;/option&gt;
        &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;
        &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;
    &lt;/select&gt; 

    &lt;div&gt;
        选择的水果是：{{selected}}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
    el: '#app',
    data: {
        selected:''
    }
})
</code></pre>
<h1 id="5-修饰符">5 修饰符</h1>
<ul>
<li><code>.lazy</code>：默认情况下，<code>v-model</code>在input事件中同步输入框的值与数据，但可以添加一个修饰符<code>.lazy</code>，从而转变为在<code>change</code>事件中同步数据，比如<code>&lt;input v-model.lazy=&quot;meesage&quot;&gt;</code></li>
<li><code>.number</code>：自动将用户的输入值转化为<code>Number</code>类型，如果原值的转换结果是<code>NaN</code>会返回原值，比如<code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></li>
<li><code>.trim</code>：自动过滤用户输入的首尾空格，比如<code>&lt;input v-model.trim=&quot;message&quot;&gt;</code></li>
</ul>
<p>修饰符可以混合使用，例子：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model.lazy=&quot;test&quot;&gt;
    &lt;br&gt;
    &lt;p&gt;{{test}}&lt;/p&gt;

    &lt;input type=&quot;text&quot; v-model.number.lazy=&quot;test2&quot;&gt;
    &lt;br&gt;
    &lt;p&gt;{{test2}}&lt;/p&gt;

    &lt;input type=&quot;text&quot; v-model.trim=&quot;test3&quot;&gt;
    &lt;br&gt;
    &lt;p&gt;{{test3}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h1 id="6-组件">6 组件</h1>
<p>组件可以扩展HTML元素，封装可重用的代码，组件系统可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树。<br>
注册一个全局组件语法如下：</p>
<pre><code class="language-js">Vue.component(tagName,options)
</code></pre>
<p>其中<code>tagName</code>为组件名，<code>options</code>为配置选项。注册后，按如下方式调用组件：</p>
<pre><code class="language-html">&lt;tagName&gt;&lt;/tagName&gt;
</code></pre>
<h1 id="7-全局组件">7 全局组件</h1>
<p>全局组件就是所有实例都能使用的组件，例如：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;test-title&gt;&lt;/test-title&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">Vue.component('test-title',{
    template:'&lt;h1&gt;Test Title&lt;/h1&gt;'
})
new Vue({el:'#app'})
</code></pre>
<p>注意标签名不能大写，比如写成：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;testTitle&gt;&lt;/testTitle&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">Vue.component('testTitle',{
    template:'&lt;h1&gt;Test Title&lt;/h1&gt;'
})
</code></pre>
<p>页面不会显示标题。</p>
<h1 id="8-局部组件">8 局部组件</h1>
<p>局部组件就是在本实例内使用的组件，比如：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;test-title&gt;&lt;/test-title&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
    el: '#app',
    components: {
        'test-title': {
            template:'&lt;h1&gt;Test Title&lt;/h1&gt;'
        }
    }
})
</code></pre>
<p>也可以把模板的内容分离出来成为一个变量：</p>
<pre><code class="language-js">var myTemplate = {
    template:'&lt;h1&gt;Test Title&lt;/h1&gt;'
}
new Vue({
    el: '#app',
    components: {
        'test-title': myTemplate
    }
})
</code></pre>
<h1 id="9-prop">9 <code>prop</code></h1>
<p><code>prop</code>是子组件来接受父组件传递过来的数据的一个自定义属性，父组件的数据需要通过<code>props</code>把数据传递给子组件，子组件需要显示地使用<code>props</code>选项声明<code>prop</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;test-title title=&quot;Test Title&quot;&gt;&lt;/test-title&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">Vue.component('test-title',{
    props:['title'],
    template:'&lt;h1&gt;{{title}}&lt;/h1&gt;'
    //template:'&lt;h1&gt;{{this.title}}&lt;/h1&gt;'
})
new Vue({el: '#app'})
</code></pre>
<h2 id="91-动态prop">9.1 动态<code>prop</code></h2>
<p>类似于<code>v-bind</code>绑定HTML特性到一个表达式，也可以利用<code>v-bind</code>动态绑定<code>props</code>值到父组件的数据中，每当父组件的数据变化时，该变化会传递给子组件：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input v-model=&quot;message&quot;&gt;
    &lt;br&gt;
    &lt;test-title v-bind:title=&quot;message&quot;&gt;&lt;/test-title&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js"> Vue.component('test-title',{
    props:['title'],
    template:'&lt;h1&gt;{{title}}&lt;/h1&gt;'
})
new Vue({
    el: '#app',
    data: {
        message:''
    }
})
</code></pre>
<p>首先当输入框内容发生变化时，更新父组件的<code>message</code>，再传递给子组件的<code>title</code>，最后更新<code>&lt;test-title&gt;</code>的内容。<br>
下面是一个绑定无序列表的例子：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;ol&gt;
        &lt;test-item v-for=&quot;i in items&quot; v-bind:val=&quot;i&quot;&gt;&lt;/test-item&gt;
    &lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">Vue.component('test-item',{
    props:['val'],
    template:'&lt;h1&gt;{{val.text}}&lt;/h1&gt;'
})
var vm = new Vue({
    el: '#app',
    data: {
        items:[
            {text:'111'},
            {text:'222'}
        ]
    }
})
</code></pre>
<p>注意<code>prop</code>是单向绑定的，当父组件属性变化时传导到子组件，但是不会反过来。</p>
<h2 id="92-子组件回传">9.2 子组件回传</h2>
<p>父组件使用<code>props</code>传递数据给子组件，如果子组件把数据传递回去需要使用自定义事件，可以在<code>v-on</code>绑定自定义事件，每个Vue实例都实现了事件接口，也就是：</p>
<ul>
<li>使用<code>$on(eventName)</code>监听事件</li>
<li>使用<code>$emit(eventName)</code>触发事件</li>
</ul>
<p>另外父组件可以在使用子组件的地方直接用<code>v-on</code>来监听子组件触发的事件，例子：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;总计：{{total}}&lt;/p&gt;
    &lt;test v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/test&gt;
    &lt;br&gt;&lt;br&gt;
    &lt;test v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/test&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">Vue.component('test',{
    template:'&lt;button v-on:click=&quot;incrementHandler&quot;&gt;点击增加，目前为{{counter}}&lt;/p&gt;',
    data:function(){
        return {
            counter:0
        }
    },
    methods:{
        incrementHandler:function(){
            this.counter += 1
            this.$emit('increment')
        }
    }
})
new Vue({
    el: '#app',
    data: {
        total:0
    },
    methods:{
        incrementTotal:function(){
            this.total += 1
        }
    }
})
</code></pre>
<p>效果：<br>
<img src="https://img-blog.csdnimg.cn/20200724072951726.png" alt="在这里插入图片描述" loading="lazy"><br>
当点击任意一个按钮增加时，更新子组件内的<code>counter</code>，同时使用<code>this.$emit</code>向父组件传值，这里没有参数，如果有参数的话在后面加上即可：<code>this.$emit(&quot;func&quot;,parm)</code>。</p>
<p>父组件中引用子组件的地方需要添加<code>v-on:func</code>，其中<code>v-on:func</code>中的<code>func</code>需要与<code>this.$emit(&quot;func&quot;)</code>中的<code>func</code>同名，接着在<code>v-on:func=&quot;func2&quot;</code>中修改<code>func2</code>为父组件的函数即可。简写方式为：</p>
<pre><code class="language-html">@func=&quot;func2&quot;
</code></pre>
<p>在某个组件的根元素上监听一个原生事件可以使用<code>.native</code>修饰<code>v-on</code>，比如：</p>
<pre><code class="language-html">&lt;test-title v-on:click.native=&quot;func&quot;&gt;&lt;/test-title&gt;
</code></pre>
<h2 id="93-关于子组件的data">9.3 关于子组件的<code>data</code></h2>
<p>上面的例子中<code>data</code>不是一个对象而是一个函数，如果<code>data</code>直接返回一个已有对象会影响其他实例，比如修改上面的<code>data</code>为：</p>
<pre><code class="language-js">var counter = {
    counter:0
}
//...
data:function(){
    return counter
}
</code></pre>
<p>效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200724074048258.gif" alt="在这里插入图片描述" loading="lazy"><br>
也就是子组件共享了数据，而修改为：</p>
<pre><code class="language-js">data:function(){
    return {
        counter:0
    }
}
</code></pre>
<p>效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200724080958742.gif" alt="在这里插入图片描述" loading="lazy"><br>
这是因为返回给每个实例一份独立的拷贝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第36期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi-36/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi-36/">
        </link>
        <updated>2020-07-24T15:24:41.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595605017154.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>早起的鸟儿有虫吃，可惜你是那条虫。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>虽然自1941年以来，烟花在美国佛罗里达州就已经完全违法，但该州数百家商店仍在将烟花卖给所有签署弃权书表示将烟花用于农业，目的是驱除鸟类以令其远离农作物的人。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>此花此叶常相映，翠减红衰愁杀人。<br>
——李商隐《赠荷花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>少年，别想你，那个人不是你。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="http://bd.kuwo.cn/play_detail/40900571">选择失忆-季彦琳</a></p>
</blockquote>
<blockquote>
<p>一杯烈酒倒入喉<br>
是你给的温柔<br>
想念翻滚如浪腾<br>
最后更痛<br>
最后的最后<br>
不过是一场梦<br>
心越来越痛<br>
如果回到最初</p>
</blockquote>
<blockquote>
<p>如何能选择忘记<br>
忘记每一段过去<br>
你的话语太伤心<br>
一点也没有余地<br>
可我还是会想你<br>
去想你 没忘记<br>
你刺痛我心<br>
或许一切都归零<br>
归零到最初记忆<br>
我一定选择<br>
不会继续爱你<br>
我的爱已经选择暂停<br>
选择了失忆</p>
</blockquote>
<blockquote>
<p>一杯烈酒倒入喉<br>
是你 给的温柔<br>
想念翻滚如浪腾<br>
最后更痛<br>
最后的最后<br>
不过是一场梦<br>
心越来越痛<br>
如果回到最初</p>
</blockquote>
<blockquote>
<p>如何能选择忘记<br>
忘记每一段过去<br>
你的话语太伤心<br>
一点也没有余地<br>
可我还是会想你<br>
去想你 没忘记<br>
你刺痛我心<br>
或许一切都归零<br>
归零到最初记忆<br>
我一定选择<br>
不会继续爱你<br>
我的爱已经选择暂停<br>
选择了失忆</p>
</blockquote>
<blockquote>
<p>如何能选择忘记<br>
忘记每一段过去<br>
你的话语太伤心<br>
一点也没有余地<br>
可我还是会想你<br>
去想你 没忘记<br>
你刺痛我心<br>
或许一切都归零<br>
归零到最初记忆<br>
我一定选择<br>
不会继续爱你<br>
我的爱已经选择暂停<br>
选择了失忆</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JetBrains系列IDE无法输入中文]]></title>
        <id>https://2293736867.github.io/post/jetbrains-xi-lie-ide-wu-fa-shu-ru-zhong-wen/</id>
        <link href="https://2293736867.github.io/post/jetbrains-xi-lie-ide-wu-fa-shu-ru-zhong-wen/">
        </link>
        <updated>2020-07-23T06:48:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境Linux+fcitx，JetBrains的IDE无法输入中文，包括IDEA，PyCharm，WebStorm，CLion等等。</p>
<h1 id="2-解决方案">2 解决方案</h1>
<p>Linux下一般使用fcitx进入中文输入，安装的时候教程一般都会提到以下三个环境变量：</p>
<pre><code class="language-bash">export XMODIFIERS=&quot;@im=fcitx&quot;
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
</code></pre>
<p>安装的时候一般在<code>~/.bashrc</code>或<code>~/.bash_profile</code>或<code>~/.xprofile</code>中输入以上三个环境变量，这样fcitx就能输入中文了。</p>
<p>但是对于JetBrains的IDE，需要进行全局环境变量的设置，也就是说需要在<code>/etc/profile</code>输入以上三个环境变量，这样就能输入中文了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第35期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi/">
        </link>
        <updated>2020-07-22T22:36:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457502173.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>黑夜从来不会亏待晚睡的人，它会赐予你黑眼圈，和即将猝死的身体。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其婴儿出生后，被大人拎着腌火腿一样在盐堆里滚几圈，直到浑身满盐才结束。当地人相信，这样可以赋予新生儿抵御疾病的力量。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1300885683">38度6-黑龙</a></p>
</blockquote>
<blockquote>
<p>逃不出你的左右<br>
像鱼在沙里游<br>
明知道没尽头<br>
却不怕头破血流<br>
爱你是海市蜃楼<br>
像泡沫般游走<br>
虚幻和无所求<br>
第一次我见你情难开口心跳在发抖</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森丽留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙像温度充满了电流<br>
在38度6</p>
</blockquote>
<blockquote>
<p>逃不出你的左右<br>
像鱼在沙里游<br>
明知道没尽头<br>
却不怕头破血流<br>
爱你是海市蜃楼<br>
像泡沫般游走<br>
虚幻和无所求<br>
第一次我见你情难开口 心跳在发抖</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森林留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙温度像充满了电流<br>
在38度6</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森林留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙温度像充满了电流<br>
拥抱到白了头 不放开你的手<br>
我卸下了等候和全部爱你的理由<br>
全世界跟我走 从黑夜到白昼<br>
我唯一的要求我们的爱永远停留<br>
在38度6</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第34期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-35-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-35-qi/">
        </link>
        <updated>2020-07-21T22:36:14.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457523821.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>年轻人不要老想着走捷径，父母强才是硬道理。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其的十二生肖，将龙换成了鳄鱼，其他相同。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=190072">黄昏-周传雄</a></p>
</blockquote>
<blockquote>
<p>过完整个夏天<br>
忧伤并没有好一些<br>
开车行驶在公路无际无边<br>
有离开自己的感觉</p>
</blockquote>
<blockquote>
<p>唱不完一首歌<br>
疲倦还剩下黑眼圈<br>
感情的世界伤害在所难免<br>
黄昏再美终要黑夜</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
<blockquote>
<p>唱不完一首歌<br>
疲倦还剩下黑眼圈<br>
感情的世界伤害在所难免<br>
黄昏再美终要黑夜</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第33期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-34-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-34-qi/">
        </link>
        <updated>2020-07-20T22:35:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457535932.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>明日复明日，明日何其多！既然这么多，不妨再拖拖。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其的英文Turkey，另一个意思是火鸡。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=545350530">有些爱情放不下-唐伯虎</a></p>
</blockquote>
<blockquote>
<p>你说着那些美丽的谎话<br>
在我的心上定格成伤疤<br>
你说的那些承诺未抵达<br>
热情就慢慢融化</p>
</blockquote>
<blockquote>
<p>走不进你描述的那个家<br>
却迷失我幻想的那幅画<br>
深夜里想着你心乱如麻<br>
我的爱旧伤复发</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做的太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
<blockquote>
<p>你说着那些美丽的谎话<br>
在我的心上定格成伤疤<br>
你说的那些承诺未抵达<br>
热情就慢慢融化</p>
</blockquote>
<blockquote>
<p>走不进你描述的那个家<br>
却迷失我幻想的那幅画<br>
深夜里想着你心乱如麻<br>
我的爱旧伤复发</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做得太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做得太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
]]></content>
    </entry>
</feed>