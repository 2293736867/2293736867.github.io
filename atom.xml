<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-06-15T18:13:10.672Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[单个java文件打成可执行jar包]]></title>
        <id>https://2293736867.github.io/post/dan-ge-java-wen-jian-da-cheng-ke-zhi-xing-jar-bao/</id>
        <link href="https://2293736867.github.io/post/dan-ge-java-wen-jian-da-cheng-ke-zhi-xing-jar-bao/">
        </link>
        <updated>2020-06-15T18:01:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>使用JDK自带的jar与java将单个java文件打成可执行jar包并运行。<br>
当然也可以使用IDE完成，使用Maven只需要一个简单的package，但是单个文件嘛，没必要这么“凶狠”。</p>
<h1 id="2-新建测试文件">2 新建测试文件</h1>
<p>著名的Hello World：</p>
<pre><code class="language-java">public class Main
{
	public static void main(String [] args)
	{
		System.out.println(&quot;Hello world.&quot;);
	}
}
</code></pre>
<h1 id="3-编译">3 编译</h1>
<p>生成jar包需要class文件，换句话说需要先编译，建议先创建一个临时文件夹存放class文件。</p>
<pre><code class="language-java">mkdir test &amp;&amp; mv Main.java test &amp;&amp; cd test;
javac Main.java
</code></pre>
<h1 id="4-打包">4 打包</h1>
<pre><code class="language-java">jar --create --verbose --file Main.jar --main-class Main *.class
</code></pre>
<p>说明一下各个参数：</p>
<ul>
<li><code>--create</code>：创建jar</li>
<li><code>--verbose</code>：打包时产生输出</li>
<li><code>--file</code>：打包的jar文件名</li>
<li><code>--main-class</code>：指定入口类</li>
<li><code>*.class</code>：打包所有的class文件，这里可以接受的参数可以是<code>*</code>，表示打包该目录下所有文件，也可以是目录名，打包指定目录下的所有文件</li>
</ul>
<p>这里使用默认的包，若是自定义包，使用</p>
<pre><code class="language-bash">--main-class com.xxx.xxx.Main
</code></pre>
<p>即可。</p>
<p>注意打包时网上有的教程使用简写：</p>
<pre><code class="language-java">jar -cvf Main.jar *.class
</code></pre>
<p>这样确实是能打包，但是直接运行的时候会提示：</p>
<pre><code class="language-bash">no main manifest attribute, in Main.jar
</code></pre>
<p>可以加上<code>--main-class</code>参数或者直接更新打包后里面的<code>MANIFEST.mf</code>文件，加上：</p>
<pre><code class="language-bash">Main-Class: Main
</code></pre>
<p>当然还是建议使用上述的方法一步打包到位。</p>
<h1 id="5-运行">5 运行</h1>
<pre><code class="language-java">java -jar Main.jar
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次使用IDEA中HTTP Client的经历]]></title>
        <id>https://2293736867.github.io/post/yi-ci-shi-yong-idea-zhong-http-client-de-jing-li/</id>
        <link href="https://2293736867.github.io/post/yi-ci-shi-yong-idea-zhong-http-client-de-jing-li/">
        </link>
        <updated>2020-06-12T14:00:59.000Z</updated>
        <content type="html"><![CDATA[<p><s>说好六月停更的。。。。</s><br>
<s>害。。。</s></p>
<h1 id="1-开端">1 开端</h1>
<p>HTTP Client是IDEA中自带的一个插件，用于代替原来的REST Client，打开<code>Tools-&gt;HTTP Client-&gt;Test RESTful Web Service</code>，会提示REST Client不推荐使用，推荐使用HTTP Client：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200612212834462.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>然后当然就点击使用啊，但是，问题来了，一个普通的GET请求都发送不出去？？？？</p>
<p><img src="https://img-blog.csdnimg.cn/20200612213023340.png" alt="在这里插入图片描述" loading="lazy"><br>
IDEA的东西估计没这么菜吧？？？</p>
<p>肯定不会这么菜的。。。</p>
<p>但是为什么就是发不出去？？？</p>
<h1 id="2-尝试">2 尝试</h1>
<p>GET请求对吧，浏览器也可以做，于是，使用了浏览器进行测试，一点问题都没有：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020061221324552.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>没理由啊，笔者在想，那为什么IDEA不行呢？？</p>
<p>接着使用了大名鼎鼎的Postman，也是一点问题也没有：</p>
<p><img src="https://img-blog.csdnimg.cn/20200612213409109.png" alt="在这里插入图片描述" loading="lazy"><br>
Postman也没问题啊，接着试试“情敌”Postwoman，问题来了！</p>
<p>发送不出去，查看了一下F12控制台，报错如下：<br>
<img src="https://img-blog.csdnimg.cn/2020061221413586.png" alt="在这里插入图片描述" loading="lazy"><br>
搜索了一下解决办法，是跨域资源请求的问题，在Controller类上加上</p>
<pre><code class="language-java">@CrossOrigin(value = &quot;http://localhost:3000&quot;)
</code></pre>
<p>即可，因为Postwoman默认运行的端口为3000。</p>
<p>这个注解还可以作用在方法上，起作用的就是对应的方法，这里是对整个Controller起作用。</p>
<p>另外这里只使用了最简单的参数，其他的参数还有<code>origins</code>（同<code>value</code>），<code>allowHeaders</code>，<code>exposedHeaders</code>，<code>methods</code>，<code>allowCredentials</code>，<code>maxAge</code>，具体使用不介绍，加上了以后Postwoman就能正常发送请求了：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200612214301201.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-再次尝试">3 再次尝试</h1>
<p>但是IDEA中的HTTP Client还是不行啊，就最最最普通的GET请求，还是返回500：</p>
<p><img src="https://img-blog.csdnimg.cn/20200612214433478.png" alt="在这里插入图片描述" loading="lazy"><br>
于是换了一种思路，想再用其他类似插件的方式测试。</p>
<p>所以就想到了VScode，里面有一个类似的扩展叫REST Client，安装以后写了一个普通的GET请求，完全没问题：</p>
<p><img src="https://img-blog.csdnimg.cn/20200612214557968.png" alt="在这里插入图片描述" loading="lazy"><br>
但还是想不到为什么IDEA还是不行啊？？？</p>
<p>还是500 。。。</p>
<p>。。。</p>
<p>但是，反过来想，可能是请求发送不出去，因为如果是接受到了请求的话，肯定会有日志记录的，但是没有，所以原因可能是请求发送不出去。。。</p>
<h1 id="4-最终答案">4 最终答案</h1>
<p>一个普通的GET请求为什么发送不出去？</p>
<p>到底是为什么会返回500？</p>
<p>最后，经过一番痛苦的思考，找到了问题所在：代理！</p>
<p><img src="https://img-blog.csdnimg.cn/2020061221491977.png?" alt="在这里插入图片描述" loading="lazy"><br>
发送不出去就是因为设置了本地代理，返回的500，是代理服务器返回的，不是Tomcat返回的。</p>
<p>终于，把代理去掉之后，HTTP Client就可以正常使用了：<br>
<img src="https://img-blog.csdnimg.cn/20200612215103984.png" alt="在这里插入图片描述" loading="lazy"><br>
没错，“真凶”就是代理。</p>
<p>最后终于打消了笔者的误解，为什么IDEA中的HTTP Client会这么“菜”，连一个普通的GET请求也发送不出去？？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6月停更]]></title>
        <id>https://2293736867.github.io/post/6-yue-ting-geng/</id>
        <link href="https://2293736867.github.io/post/6-yue-ting-geng/">
        </link>
        <updated>2020-06-08T07:32:49.000Z</updated>
        <content type="html"><![CDATA[<p>害。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat9配置HTTP/2]]></title>
        <id>https://2293736867.github.io/post/tomcat9-pei-zhi-http2/</id>
        <link href="https://2293736867.github.io/post/tomcat9-pei-zhi-http2/">
        </link>
        <updated>2020-06-08T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-http2%E7%89%B9%E6%80%A7">2 HTTP/2特性</a>
<ul>
<li><a href="#21-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7">2.1 二进制分帧</a></li>
<li><a href="#22-%E5%8E%8B%E7%BC%A9%E5%A4%B4%E9%83%A8">2.2 压缩头部</a></li>
<li><a href="#23-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">2.3 多路复用</a></li>
<li><a href="#24-%E6%B5%81%E4%BC%98%E5%85%88%E5%8F%8A%E6%B5%81%E6%8E%A7%E5%88%B6">2.4 流优先及流控制</a></li>
<li><a href="#25-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">2.5 服务器推送</a></li>
<li><a href="#26-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE">2.6 应用层协商协议</a></li>
</ul>
</li>
<li><a href="#3-%E4%BD%BF%E7%94%A8mkcert%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6">3 使用mkcert生成证书</a>
<ul>
<li><a href="#31-%E5%AE%89%E8%A3%85mkcert">3.1 安装mkcert</a>
<ul>
<li><a href="#311-macos">3.1.1 MacOS</a></li>
<li><a href="#312-linux">3.1.2 Linux</a></li>
<li><a href="#313-windows">3.1.3 Windows</a></li>
</ul>
</li>
<li><a href="#32-%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6">3.2 生成证书</a>
<ul>
<li><a href="#321-%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0ca%E8%AF%81%E4%B9%A6">3.2.1 安装本地CA证书</a></li>
<li><a href="#322-%E5%88%A9%E7%94%A8ca%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E6%9C%AC%E5%9C%B0%E8%AF%81%E4%B9%A6">3.2.2 利用CA证书签发本地证书</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E9%85%8D%E7%BD%AEtomcat">4 配置Tomcat</a>
<ul>
<li><a href="#41-%E4%BD%BF%E7%94%A8nio">4.1 使用Nio</a></li>
<li><a href="#42-%E4%BD%BF%E7%94%A8apr">4.2 使用APR</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>Tomcat从Tomcat8的一些较新版本就支持HTTP/2了，Tomcat9直接支持，本文首先讲述了相关HTTP/2的特性，接着利用一个简单的开源工具mkcert生成证书并利用该证书配置HTTP/2。</p>
<h1 id="2-http2特性">2 HTTP/2特性</h1>
<p>首先介绍一下HTTP/2特性，这也从另一方面解释了为什么需要使用HTTP/2。</p>
<h2 id="21-二进制分帧">2.1 二进制分帧</h2>
<p>HTTP/2在应用层与传输层增加了一个二进制分帧，能够达到“在不改动HTTP语义，HTTP方法，状态码，URI及首部字段的情况下，突破HTTP/1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。”</p>
<h2 id="22-压缩头部">2.2 压缩头部</h2>
<p>HTTP/2对消息头采用了HPACK进行压缩传输，能够节省消息头占用的网络流量，而HTTP/1.x每次请求都会携带大量的冗余头信息，浪费了很多带宽资源。</p>
<h2 id="23-多路复用">2.3 多路复用</h2>
<p>简单地说就是所有的请求都通过一个TCP连接并发完成。HTTP/1.x虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应，很容易导致后面的请求被阻塞。而HTTP/2做到了真正的并发请求。<br>
HTTP/2将消息分解为帧，为每帧分配一个流标识符，然后在一个TCP连接上独立发送，HTTP/2将请求帧与响应帧交织在一起，能够让所有请求与响应都在一个套接字上发生，所有请求或响应都无法相互阻塞，减少了延迟，提高了页面加载速度，消除了对HTTP/1.1工具的需求。</p>
<h2 id="24-流优先及流控制">2.4 流优先及流控制</h2>
<p>消息帧通过对流进行发送，每个流分配了一个优先级，用于确定处理顺序以及收到的资源量，优先级可以是0-256之间的数字，可以定义依赖关系，允许在一个资源之前加载另一个资源。<br>
流控制管理数据的传输，允许接收者停止或减少发送的数据量，比如观看视频暂停时，客户端会通知服务器停止发送视频数据。</p>
<h2 id="25-服务器推送">2.5 服务器推送</h2>
<p>一般情况下需要客户端请求服务器才会响应，HTTP/2中能够先于客户端检测将要请求的资源，提前通知客户端，但是不发送资源只发送URL，客户端收到后会进行验证缓存，发现需要则正式发起请求。</p>
<h2 id="26-应用层协商协议">2.6 应用层协商协议</h2>
<p>客户端与服务器都升级才能支持HTTP/2，但是有可能存在HTTP/1与HTTP/2并存的情况，如果都使用80端口，需要选择其中一个协议通信。<br>
APLN（Application Layer Protocol Negotiation）就是为了解决这个问题，通过协商选择协议：</p>
<ul>
<li>首先客户端发起请求，如果支持HTTP/2则带upgrade头部</li>
<li>若服务器不支持则拒绝升级通过HTTP/1.1返回响应</li>
<li>若服务器支持则接受升级，切换到新分帧使用HTTP/2通信</li>
</ul>
<p>更多请查看<a href="https://httpwg.org/specs/rfc7540.html">RFC7540 官方文档</a>。</p>
<h1 id="3-使用mkcert生成证书">3 使用mkcert生成证书</h1>
<p>网上大部分的教程都是使用OpenSSL生成根证书，客户端证书以及服务端证书的，一堆参数配置非常复杂，因此这里使用一个简单的一键生成本地证书的开源工具<a href="https://github.com/FiloSottile/mkcert">mkcert</a>，无需任何配置。</p>
<h2 id="31-安装mkcert">3.1 安装mkcert</h2>
<h3 id="311-macos">3.1.1 MacOS</h3>
<pre><code class="language-bash">brew install mkcert
brew install nss # 如果使用火狐
</code></pre>
<p>使用MacPorts：</p>
<pre><code class="language-bash">sudo port selftupdate
sudo port install mkcert
sudo port install css # 如果使用火狐
</code></pre>
<h3 id="312-linux">3.1.2 Linux</h3>
<p>需要先安装<code>certutil</code>：</p>
<pre><code class="language-bash">#Debian/Ubuntu
sudo apt install libnss3-tools
#Red Hat/Fedora/CentOS
sudo yum install nss-tools
#Arch/Manjaro
sudo pacman -S nss
#SUSE
sudo zypper install mozilla-nss-tools
</code></pre>
<p>使用<code>LinuxBrew</code>安装：</p>
<pre><code class="language-bash">brew install mkcert
</code></pre>
<p>安装<a href="https://docs.brew.sh/Homebrew-on-Linux">LinuxBrew</a>：</p>
<pre><code class="language-bash">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre>
<p>Arch/Manjaro可以使用pacman安装：</p>
<pre><code class="language-bash">sudo pacman -Syu mkcert
</code></pre>
<p>或者从源码安装（需要go环境）：</p>
<pre><code class="language-bash">git clone https://github.com/FiloSottile/mkcert &amp;&amp; cd mkcert
go build -ldflags &quot;-X main.Version=$(git describe --tags)&quot;
</code></pre>
<p>或者使用<a href="https://github.com/FiloSottile/mkcert/releases">已构建好的版本</a>。</p>
<h3 id="313-windows">3.1.3 Windows</h3>
<p>安装Chocolatey（以管理员运行PowerShell）：</p>
<pre><code class="language-bash">Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
</code></pre>
<p>或安装Scoop（管理员PowerShell）：</p>
<pre><code class="language-bash">Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
# 或
iwr -useb get.scoop.sh | iex
</code></pre>
<p>使用Chocolatey或Scoop安装：</p>
<pre><code class="language-bash">choco install mkcert
#或
scoop bucket add extras
scoop install mkcert
</code></pre>
<p>或者使用<a href="https://github.com/FiloSottile/mkcert/releases">已构建好的版本</a>。</p>
<h2 id="32-生成证书">3.2 生成证书</h2>
<p>mkcert的命令非常简单，可以使用<code>--help</code>查看帮助：</p>
<pre><code class="language-bash">mkcert --help
</code></pre>
<h3 id="321-安装本地ca证书">3.2.1 安装本地CA证书</h3>
<pre><code class="language-bash">mkcert -install
</code></pre>
<p>默认会在<code>~/.local/share/mkcert</code>生成CA证书。</p>
<h3 id="322-利用ca证书签发本地证书">3.2.2 利用CA证书签发本地证书</h3>
<pre><code class="language-bash">mkcert localhost
</code></pre>
<p>其中localhost表示签发本地证书，可以换成<code>example.com</code>，<code>*.example.com</code>，<code>example.test</code>，<code>127.0.0.1</code>，<code>::1</code>之类的域名或者ip。<br>
执行后会在当前文件夹下生成<code>localhost-key.pem</code>与<code>localhost.pem</code>，前者是私钥，后者是证书。</p>
<h1 id="4-配置tomcat">4 配置Tomcat</h1>
<p>Tomcat可以通过两种方式配置HTTP/2，一种是自带的Nio方式，另一种是使用额外库APR，APR-util与TC-Native的方式。</p>
<h2 id="41-使用nio">4.1 使用Nio</h2>
<p>通过Nio配置HTTP/2需要结合OpenSSL与keytool将证书转换为<code>pkcs#12</code>再转换为<code>jks</code>：</p>
<pre><code class="language-bash">openssl pkcs12 -export -inkey localhost-key.pem -in localhost.pem -out localhost.p12
</code></pre>
<p>会提示输入导出密码，需要记住，转换成<code>jks</code>时需要用到。<br>
<img src="https://img-blog.csdnimg.cn/20200608144240906.png" alt="在这里插入图片描述" loading="lazy"><br>
接着转换为<code>jks</code>：</p>
<pre><code class="language-bash">keytool -importkeystore -srckeystore localhost.p12 -srcstoretype pkcs12 -destkeystore localhost.jks
</code></pre>
<p>这里会提示输入目标keystore与源keystore的密码，目标keystore密码一会在修改<code>server.xml</code>时需要用到，源keystore密码就是上面的导出密码。<br>
<img src="https://img-blog.csdnimg.cn/20200608144851193.png" alt="在这里插入图片描述" loading="lazy"><br>
接着复制<code>localhost.jks</code>到Tomcat的<code>conf</code>下并修改<code>server.xml</code>：</p>
<pre><code class="language-xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt;
	&lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt;
    &lt;SSLHostConfig&gt;
        &lt;Certificate certificateKeystoreFile=&quot;conf/localhost.jks&quot;
       				 certificateKeystorePassword=&quot;111111&quot;
                     type=&quot;RSA&quot; /&gt;
    &lt;/SSLHostConfig&gt;
&lt;/Connector&gt;
</code></pre>
<p>添加了升级协议（默认HTTP/1.1）：</p>
<pre><code class="language-xml">&lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt;
</code></pre>
<p>另外<code>certificateKeystorePassword</code>是上一步的目标keystore的密码。<br>
完成后开启Tomcat并访问<code>https://localhost:8443</code>：<br>
<img src="https://img-blog.csdnimg.cn/20200608150201599.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200608150257547.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="42-使用apr">4.2 使用APR</h2>
<p>使用APR不需要对证书进行额外的转换，但是需要安装三个库：</p>
<ul>
<li><a href="https://apr.apache.org/">APR</a></li>
<li><a href="https://apr.apache.org/">APR-util</a></li>
<li><a href="https://tomcat.apache.org/native-doc/">TC-Native</a></li>
</ul>
<p>笔者的Manjaro可以直接包管理器安装：</p>
<pre><code class="language-bash">sudo pacman -S apr apr-util tomcat-native
</code></pre>
<p>其他系统请自行使用包管理器或者按上面的官网链接进行编译安装。<br>
复制<code>localhost-key.pem</code>与<code>localhost.pem</code>到Tomcat的<code>conf</code>目录下，并修改<code>server.xml</code>：</p>
<pre><code class="language-xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; &gt;
    &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt;
    &lt;SSLHostConfig&gt;
        &lt;Certificate certificateKeyFile=&quot;conf/localhost-key.pem&quot;
                     certificateFile=&quot;conf/localhost.pem&quot;
                     type=&quot;RSA&quot; /&gt;
    &lt;/SSLHostConfig&gt;
&lt;/Connector&gt;
</code></pre>
<p>开启Tomcat后就可以访问<code>https://localhost:8443</code>了：<br>
<img src="https://img-blog.csdnimg.cn/20200608143030125.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200608143333489.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[残酷游戏]]></title>
        <id>https://2293736867.github.io/post/can-ku-you-xi/</id>
        <link href="https://2293736867.github.io/post/can-ku-you-xi/">
        </link>
        <updated>2020-06-07T03:20:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>其实自命受苦都只因我能离不离<br>
看着对你爱得仿似爱情欲避不避<br>
若能耗尽力气  去捕捉你<br>
亦能剩下自己可挽救自己<br>
我也知越是幻想不准想你更记得起<br>
我在故意去将苦涩替代寂寞滋味<br>
用残酷游戏  制造卑微<br>
自由自在莫非惨过永远受气</p>
</blockquote>
<p>摊牌，<br>
哦豁，<br>
GG。<br>
历史总是惊人的相似，<br>
现实总是太多的无奈。<br>
注孤生。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFX+SpringBoot+验证码功能的小型薪酬管理系统]]></title>
        <id>https://2293736867.github.io/post/javafxspringbootyan-zheng-ma-gong-neng-de-xiao-xing-xin-chou-guan-li-xi-tong/</id>
        <link href="https://2293736867.github.io/post/javafxspringbootyan-zheng-ma-gong-neng-de-xiao-xing-xin-chou-guan-li-xi-tong/">
        </link>
        <updated>2020-06-06T06:56:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#20200615%E6%9C%80%E5%90%8E%E6%9B%B4%E6%96%B0">2020.06.15最后更新</a></li>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E7%AE%80%E4%BB%8B">1.1 简介</a></li>
<li><a href="#12-%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B">1.2 响应流程</a></li>
<li><a href="#13-%E6%BC%94%E7%A4%BA">1.3 演示</a></li>
</ul>
</li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a>
<ul>
<li><a href="#21-%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">2.1 本地开发环境</a></li>
<li><a href="#22-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83">2.2 服务器环境</a></li>
</ul>
</li>
<li><a href="#3-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86">3 前端代码部分</a>
<ul>
<li><a href="#31-%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0">3.1 前端概述</a></li>
<li><a href="#32-%E6%A6%82%E8%A7%88">3.2 概览</a>
<ul>
<li><a href="#321-%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E6%A0%91">3.2.1. 代码目录树</a></li>
<li><a href="#322-%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E6%A0%91">3.2.2 资源目录树</a></li>
<li><a href="#323-%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96">3.2.3 项目依赖</a></li>
</ul>
</li>
<li><a href="#33-%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%9D%97">3.3 常量模块</a></li>
<li><a href="#34-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9D%97">3.4 控制器模块</a>
<ul>
<li><a href="#341-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%95%8C%E9%9D%A2">3.4.1 登录注册界面</a></li>
<li><a href="#342-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">3.4.2 用户界面</a></li>
</ul>
</li>
<li><a href="#35-%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%A8%A1%E5%9D%97">3.5 实体类模块</a></li>
<li><a href="#36-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">3.6  日志模块</a></li>
<li><a href="#37-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97">3.7 网络模块</a>
<ul>
<li><a href="#371-request%E5%8C%85">3.7.1 request包</a></li>
<li><a href="#372-requestbuilder%E5%8C%85">3.7.2 requestBuilder包</a></li>
<li><a href="#373-okhttp">3.7.3 OKHTTP</a></li>
<li><a href="#374-https">3.7.4 HTTPS</a>
<ul>
<li><a href="#3741-okhttp%E9%85%8D%E7%BD%AE">3.7.4.1 OkHttp配置</a></li>
<li><a href="#3742-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E8%AF%81%E4%B9%A6">3.7.4.2 服务器设置证书</a></li>
</ul>
</li>
<li><a href="#375-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86">3.7.5 图片处理</a></li>
</ul>
</li>
<li><a href="#38-%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%9D%97">3.8 动画模块</a></li>
<li><a href="#39-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%A8%A1%E5%9D%97">3.9 工具类模块</a>
<ul>
<li><a href="#391-conversion">3.9.1 Conversion</a></li>
<li><a href="#392-utils">3.9.2 Utils</a></li>
</ul>
</li>
<li><a href="#310-%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9D%97">3.10 视图模块</a></li>
</ul>
</li>
<li><a href="#4-%E5%89%8D%E7%AB%AFui%E9%83%A8%E5%88%86">4 前端UI部分</a>
<ul>
<li><a href="#41-fxml">4.1 fxml</a></li>
<li><a href="#42-css">4.2 css</a></li>
<li><a href="#43-stage%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">4.3 Stage构建过程</a></li>
</ul>
</li>
<li><a href="#5-%E5%90%8E%E7%AB%AF%E9%83%A8%E5%88%86">5 后端部分</a>
<ul>
<li><a href="#51-%E5%90%8E%E7%AB%AF%E6%A6%82%E8%BF%B0">5.1 后端概述</a></li>
<li><a href="#52-%E6%A6%82%E8%A7%88">5.2 概览</a>
<ul>
<li><a href="#521-%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E6%A0%91">5.2.1 代码目录树</a></li>
<li><a href="#522-%E4%BE%9D%E8%B5%96">5.2.2 依赖</a></li>
</ul>
</li>
<li><a href="#53-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B1%82">5.3 控制器层</a></li>
<li><a href="#54-%E4%B8%9A%E5%8A%A1%E5%B1%82%E4%B8%8E%E6%8C%81%E4%B9%85%E5%B1%82">5.4 业务层与持久层</a></li>
<li><a href="#55-%E6%97%A5%E5%BF%97">5.5 日志</a></li>
<li><a href="#56-%E5%B7%A5%E5%85%B7%E7%B1%BB">5.6 工具类</a></li>
<li><a href="#57-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5.7 配置文件</a>
<ul>
<li><a href="#571-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB">5.7.1 配置文件分类</a></li>
<li><a href="#572-%E5%8A%A0%E5%AF%86">5.7.2 加密</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%93%E5%8C%85">6 部署与打包</a>
<ul>
<li><a href="#61-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85">6.1 前端打包</a>
<ul>
<li><a href="#611-idea%E4%B8%80%E6%AC%A1%E6%89%93%E5%8C%85">6.1.1 IDEA一次打包</a></li>
<li><a href="#612-exe4j%E4%BA%8C%E6%AC%A1%E6%89%93%E5%8C%85">6.1.2 exe4j二次打包</a>
<ul>
<li><a href="#6121-exe4j">6.1.2.1 exe4j</a></li>
<li><a href="#6122-%E7%94%9F%E6%88%90jre">6.1.2.2 生成jre</a></li>
<li><a href="#6123-exe4j%E6%89%93%E5%8C%85">6.1.2.3 exe4j打包</a></li>
</ul>
</li>
<li><a href="#613-enigma-virtual-box%E4%B8%89%E6%AC%A1%E6%89%93%E5%8C%85">6.1.3 Enigma Virtual Box三次打包</a></li>
</ul>
</li>
<li><a href="#62-%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2">6.2 后端部署</a></li>
</ul>
</li>
<li><a href="#7-%E8%BF%90%E8%A1%8C">7 运行</a></li>
<li><a href="#8-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">8 注意事项</a>
<ul>
<li><a href="#81-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">8.1 路径问题</a></li>
<li><a href="#82-https">8.2 HTTPS</a></li>
<li><a href="#83-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86">8.3 配置文件加密</a></li>
<li><a href="#84-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6">8.4 键盘事件</a></li>
<li><a href="#85-%E6%95%B0%E6%8D%AE%E5%BA%93">8.5 数据库</a></li>
<li><a href="#86-%E9%AA%8C%E8%AF%81%E7%A0%81">8.6 验证码</a></li>
</ul>
</li>
<li><a href="#9-%E6%BA%90%E7%A0%81">9 源码</a></li>
<li><a href="#10-%E5%8F%82%E8%80%83">10 参考</a></li>
</ul>
</p>
<h1 id="20200615最后更新">2020.06.15最后更新</h1>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-简介">1.1 简介</h2>
<p>一个简单的小型薪酬管理系统，前端JavaFX+后端Spring Boot，功能倒没多少，主要精力放在了UI和前端的一些逻辑上面，后端其实做得很简单。</p>
<p>主要功能：</p>
<ul>
<li>用户注册/登录</li>
<li>验证码找回密码</li>
<li>用户修改信息，修改头像</li>
<li>柱状图形式显示薪酬</li>
<li>管理员管理用户，录入工资</li>
</ul>
<h2 id="12-响应流程">1.2 响应流程</h2>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e498597a9fb?w=966&amp;h=917&amp;f=png&amp;s=65748" alt="" loading="lazy"></figure>
<h2 id="13-演示">1.3 演示</h2>
<p>登录界面：</p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d0793dbbe?w=961&amp;h=542&amp;f=png&amp;s=733207" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d0858f143?w=959&amp;h=540&amp;f=png&amp;s=720223" alt="在这里插入图片描述" loading="lazy"></figure>
<p>用户界面：</p>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d0cc51a6f?w=1015&amp;h=552&amp;f=gif&amp;s=2035651" alt="在这里插入图片描述" loading="lazy"></figure>
<p>管理员界面：</p>
<figure data-type="image" tabindex="5"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d0e3c94fe?w=1015&amp;h=552&amp;f=gif&amp;s=1983316" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="2-环境">2 环境</h1>
<h2 id="21-本地开发环境">2.1 本地开发环境</h2>
<ul>
<li>IDEA 2020.1</li>
<li>OpenJDK 11</li>
<li>OepnJFX 11</li>
<li>Spring Boot 2.3.0</li>
</ul>
<h2 id="22-服务器环境">2.2 服务器环境</h2>
<ul>
<li>OpenJDK 11</li>
<li>Tomcat 9.0.33</li>
<li>MySQL 8.0.17</li>
</ul>
<h1 id="3-前端代码部分">3 前端代码部分</h1>
<h2 id="31-前端概述">3.1 前端概述</h2>
<p>前端主要分为5个部分实现：控制器模块，视图模块，网络模块，动画模块还有工具类模块。</p>
<ul>
<li>控制器模块：负责交互事件</li>
<li>视图模块：负责更新UI</li>
<li>网络模块：向后台发送数据请求</li>
<li>动画模块：位移、缩放、淡入/淡出、旋转动画</li>
<li>工具类模块：加密，检查网路连通，居中界面等</li>
</ul>
<h2 id="32-概览">3.2 概览</h2>
<h3 id="321-代码目录树">3.2.1. 代码目录树</h3>
<figure data-type="image" tabindex="6"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d10c90770?w=214&amp;h=232&amp;f=png&amp;s=64332" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d11b568fe?w=275&amp;h=906&amp;f=png&amp;s=304170" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="322-资源目录树">3.2.2 资源目录树</h3>
<figure data-type="image" tabindex="8"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d31d73bd8?w=226&amp;h=182&amp;f=png&amp;s=40883" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d343bd96c?w=333&amp;h=883&amp;f=png&amp;s=358615" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>css</code>：界面所用到的样式</li>
<li><code>fxml</code>：一个特殊的xml文件，用于定义界面与绑定Controller中的函数，也就是绑定事件</li>
<li><code>image</code>：程序用到的默认图片</li>
<li><code>key</code>：证书文件，用于OkHttp中的HTTPS</li>
<li><code>properties</code>：项目一些常量属性</li>
</ul>
<h3 id="323-项目依赖">3.2.3 项目依赖</h3>
<p>主要依赖如下：</p>
<ul>
<li><a href="https://mvnrepository.com/search?q=gson">Gson</a>：用于在实体类以及Map与JSON字符串之间进行转换</li>
<li><a href="https://mvnrepository.com/search?q=log4j2">Log4j2</a>：日志</li>
<li><a href="https://mvnrepository.com/search?q=lombok">Lombok</a>：神器不解释，但是有一些声音说不要使用，可以参考<a href="https://www.v2ex.com/amp/t/562185/2">这里</a>或<a href="http://blog.itpub.net/69908877/viewspace-2676272/">这里</a>，看个人啦</li>
<li><a href="https://mvnrepository.com/search?q=okhttp">OkHttp3</a>：网路请求</li>
<li><a href="https://mvnrepository.com/search?q=apache%20commons">Apache Commons</a>：工具类</li>
<li><a href="https://gluonhq.com/products/javafx/">OpenJFX11</a>：OpenJFX核心</li>
</ul>
<h2 id="33-常量模块">3.3 常量模块</h2>
<figure data-type="image" tabindex="10"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d3a34725d?w=229&amp;h=232&amp;f=png&amp;s=71553" alt="在这里插入图片描述" loading="lazy"></figure>
<p>程序所需要的常量：</p>
<ul>
<li><code>CSSPath</code>：CSS路径，用于<code>scene.getStylesheets.add(path)</code></li>
<li><code>FXMLPath</code>：FXML路径，用于<code>FXMLLoader.load(getClass.getResource(path).openStream())</code></li>
<li><code>AllURL</code>：发送网络请求的路径</li>
<li><code>BuilderKeys</code>：OkHttp中的<code>FormBody.Builder</code>中使用的常量键名</li>
<li><code>PaneName</code>：Pane名字，用于在同一个Scene切换不同的Pane</li>
<li><code>ReturnCode</code>：后端返回码</li>
<li><code>ViewSize</code>：界面尺寸</li>
</ul>
<p>重点说一下路径问题，笔者的css与fxml文件都放在resources下：</p>
<figure data-type="image" tabindex="11"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d3c743c26?w=281&amp;h=272&amp;f=png&amp;s=99033" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其中fxml路径在项目中的用法如下：</p>
<pre><code class="language-java">URL url = getClass().getResource(FXMLPath.xxxx);
FXMLLoader loader = new FXMLLoader();
loader.setLocation(url);
loader.load(url.openStream());
</code></pre>
<p>获取路径从根路径获取，比如上图中的MessageBox.fxml：</p>
<pre><code class="language-java">private static final String FXML_PREFIX = &quot;/fxml/&quot;;
private static final String FXML_SUFFIX = &quot;.fxml&quot;;
public static final String MESSAGE_BOX = FXML_PREFIX + &quot;MessageBox&quot; + FXML_SUFFIX;
</code></pre>
<p>若fxml文件直接放在resources根目录下，可以使用：</p>
<pre><code class="language-java">getClass().getResource(&quot;/xxx.fxml&quot;);
</code></pre>
<p>直接获取。</p>
<p>css同理：</p>
<pre><code class="language-java">private static final String CSS_PREFIX = &quot;/css/&quot;;
private static final String CSS_SUFFIX = &quot;.css&quot;;
public static final String MESSAGE_BOX = CSS_PREFIX + &quot;MessageBox&quot; + CSS_SUFFIX;
</code></pre>
<p>网络请求的URL建议把路径写到配置文件中，比如这里的从配置文件读取：</p>
<pre><code class="language-java">Properties properties = Utils.getProperties();
if (properties != null)
{
    String baseUrl = properties.getProperty(&quot;baseurl&quot;) + properties.getProperty(&quot;port&quot;) + &quot;/&quot; + properties.getProperty(&quot;projectName&quot;);
    SIGN_IN_UP_URL = baseUrl + &quot;signInUp&quot;;
    //...
}
</code></pre>
<h2 id="34-控制器模块">3.4 控制器模块</h2>
<p>控制器模块用于处理用户的交互事件，分为三类：</p>
<ul>
<li>登录注册界面控制器（start）</li>
<li>用户界面控制器（worker）</li>
<li>管理员界面控制器（admin）</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d3df6bd13?w=195&amp;h=98&amp;f=png&amp;s=24900" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d47f6012b?w=304&amp;h=988&amp;f=png&amp;s=367554" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="341-登录注册界面">3.4.1 登录注册界面</h3>
<p>这是程序一开始进入的界面，会在这里绑定一些基本的关闭，最小化，标题栏拖拽事件：</p>
<pre><code class="language-java">public void onMousePressed(MouseEvent e)
{
    stageX = stage.getX();
    stageY = stage.getY();
    screexX = e.getScreenX();
    screenY = e.getScreenY();
}
public void onMouseDragged(MouseEvent e)
{
    stage.setX(e.getScreenX() - screexX + stageX);
    stage.setY(e.getScreenY() - screenY + stageY);
}
public void close()
{
    GUI.close();
}
public void minimize()
{
    GUI.minimize();
}
</code></pre>
<p>登录界面的控制器也很简单，就一个登录/注册功能加一个跳转到找回密码界面，代码就不贴了。</p>
<p>至于找回密码界面，需要做的比较多，首先需要判断用户输入的电话是否在后端数据库存在，另外还有检查两次输入的密码是否一致，还有判断短信是否发送成功与用户输入的验证码与后端返回的验证码是否一致（短信验证码部分其实不需要后端处理，原本是放在前端的，但是考虑到可能会泄漏一些重要的信息就放到后端处理了）。</p>
<h3 id="342-用户界面">3.4.2 用户界面</h3>
<p>接着是用户登录后进入的界面，加了渐隐与移动动画：</p>
<pre><code class="language-java">public void userEnter()
{
    new Transition()
    .add(new Move(userImage).x(-70))
    .add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))
    .add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
    .add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180))
    .play();
}

public void userExited()
{
    new Transition()
    .add(new Move(userImage).x(0))
    .add(new Fade(userLabel).fromTo(1,0)).add(new Move(userLabel).x(0))
    .add(new Scale(userPolygon).ratio(1)).add(new Move(userPolygon).x(0))
    .add(new Scale(queryPolygon).ratio(1)).add(new Move(queryPolygon).x(0))
    .play();
}
</code></pre>
<p>效果如下：</p>
<figure data-type="image" tabindex="14"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d5a6a5537?w=1015&amp;h=552&amp;f=gif&amp;s=392037" alt="在这里插入图片描述" loading="lazy"></figure>
<p>实际处理是把<code>&lt;Image&gt;</code>以及<code>&lt;Label&gt;</code>放进一个<code>&lt;AnchorPane&gt;</code>中，然后为这个<code>&lt;AnchorPane&gt;</code>添加鼠标移入与移出事件。从代码中可以知道图片加上了位移动画，文字同时加上了淡入与位移动画，多边形同时加上了缩放与位移动画。以左下的<code>&lt;AnchorPane&gt;</code>事件为例，当鼠标移入时，首先把图片左移：</p>
<pre><code class="language-java">.add(new Move(userImage).x(-70))
</code></pre>
<p>x表示横向位移。</p>
<p>接着是淡入与位移文字：</p>
<pre><code class="language-java">.add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))    
</code></pre>
<p>fromTo表示透明度的变化，从0到1，相当于淡入效果。</p>
<p>最后放大多边形1.8倍同时右移多边形：</p>
<pre><code class="language-java">.add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
</code></pre>
<p>ratio表示放大的倍率，这里是放大到原来的1.8倍。</p>
<p>右上的同样需要进行放大与移动：</p>
<pre><code class="language-java">.add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180))
</code></pre>
<p>其中用到的<code>Transition</code>，<code>Scale</code>，<code>Fade</code>是自定义的动画处理类，详情请看&quot;3.8 动画模块&quot;。</p>
<h2 id="35-实体类模块">3.5 实体类模块</h2>
<p>简单的一个Worker：</p>
<pre><code class="language-java">@Getter
@Setter
@NoArgsConstructor
public class Worker {
    private String cellphone;
    private String password;
    private String name = &quot;无姓名&quot;;
    private String department = &quot;无部门&quot;;
    private String position = &quot;无职位&quot;;
    private String timeAndSalary;

    public Worker(String cellphone,String password)
    {
        this.cellphone = cellphone;
        this.password = password;
    }
}
</code></pre>
<p>注解使用了Lombok，Lombok介绍请<a href="https://www.cnblogs.com/relucent/p/8992147.html">戳这里</a>，完整用法<a href="https://projectlombok.org/features/all">戳这里</a>。</p>
<p><code>timeAndSalary</code>是一个使用Gson转换为String的Map，键为对应的年月，值为工资。具体转换方法请到工具类模块查看。</p>
<h2 id="36-日志模块">3.6  日志模块</h2>
<p>日志模块使用了Log4j2，<code>resources</code>下的<code>log4j2.xml</code>如下：</p>
<pre><code class="language-xml">&lt;configuration status=&quot;OFF&quot;&gt;
    &lt;appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;Time:%d{HH:mm:ss}     Level:%-5level %nMessage:%msg%n&quot;/&gt;
        &lt;/Console&gt;
    &lt;/appenders&gt;
    &lt;loggers&gt;
        &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/logger&gt;
        &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<p>这是最一般的配置，<code>pattern</code>里面是输出格式，其中</p>
<ul>
<li><code>%d{HH:mm:ss}</code>：时间格式</li>
<li><code>level</code>：日志等级</li>
<li><code>n</code>：换行</li>
<li>msg：日志信息</li>
</ul>
<p>这里前端的日志进行了简化处理，需要更多配置请自行搜索。</p>
<h2 id="37-网络模块">3.7 网络模块</h2>
<p>网络模块的核心使用了OkHttp实现，主要分为两个包：</p>
<figure data-type="image" tabindex="15"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d60d3b2f5?w=223&amp;h=105&amp;f=png&amp;s=36331" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>request</code>：封装发送到后端的各种请求</li>
<li><code>requestBuilder</code>：创建request的Builder类</li>
<li><code>OKHTTP</code>：封装OkHttp的工具类，对外只有一个send方法，参数只有一个，request包中的类，使用requestBuilder生成，返回一个Object，至于Object怎么处理需要在用到OKHTTP的地方与返回方法对应</li>
</ul>
<h3 id="371-request包">3.7.1 request包</h3>
<p>封装了各种网络请求：</p>
<figure data-type="image" tabindex="16"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d60a2c8e5?w=300&amp;h=482&amp;f=png&amp;s=193649" alt="在这里插入图片描述" loading="lazy"></figure>
<p>所有请求继承自BaseRequest，BaseRequest的公有方法包括：</p>
<ul>
<li><code>setUrl</code>：设置发送的url</li>
<li><code>setCellphone</code>：添加cellphone参数</li>
<li><code>setPassword</code>：添加password参数，注意password经过前端的SHA512加密</li>
<li><code>setWorker</code>：添加Worker参数</li>
<li><code>setWorkers</code>：接受一个List&lt;Worker&gt;，管理员保存所有Worker时使用</li>
<li><code>setAvatar</code>：添加头像参数</li>
<li><code>setAvatars</code>：接受一个HashMap&lt;String,String&gt;，键为电话，标识唯一的Worker，值为图片经过Base64转换为的String</li>
</ul>
<p>唯一一个抽象方法是：</p>
<pre><code class="language-java">public abstract Object handleResult(ReturnCode code)：
</code></pre>
<p>根据不同的请求处理返回的结果，后端返回一个ReturnCode，其中封装了状态码，错误信息与返回值，由Gson转为String，前端得到String后经Gson转为ReturnCode，从里面获取状态码以及返回值。</p>
<p>其余的请求类继承自<code>BaseRequest</code>，并且实现不同的处理结果方法，以Get请求为例：</p>
<pre><code class="language-java">public class GetOneRequest extends BaseRequest {
    @Override
    public Object handleResult(ReturnCode code)
    {
        switch (code)
        {
            case EMPTY_CELLPHONE:
                MessageBox.emptyCellphone();
                return false;
            case INVALID_CELLPHONE:
                MessageBox.invalidCellphone();
                return false;
            case CELLPHONE_NOT_MATCH:
                MessageBox.show(&quot;获取失败，电话号码不匹配&quot;);
                return false;
            case EMPTY_WORKER:
                MessageBox.emptyWorker();
                return false;
            case GET_ONE_SUCCESS:
                return Conversion.JSONToWorker(code.body());
            default:
                MessageBox.unknownError(code.name());
                return false;
        }
    }
}
</code></pre>
<p>获取一个Worker，可能的返回值有（枚举值，在ReturnCode中定义，需要前后端统一）：</p>
<ul>
<li><code>EMPTY_CELLPHOE</code>：表示发送的get请求中电话为空</li>
<li><code>INVALID_CELLPHONE</code>：非法电话号码，判断的代码为：<code>String reg = &quot;^[1][358][0-9]{9}$&quot;;return !(Pattern.compile(reg).matcher(cellphone).matches());</code></li>
<li><code>CELLPHONE_NOT_MATCH</code>：电话号码不匹配，也就是数据库没有对应的Worker</li>
<li><code>EMPTY_WORKER</code>：数据库中存在这个Worker，但由于转换为String时后端处理失败，返回一个空的Worker</li>
<li><code>GET_ONE_SUCCESS</code>：获取成功，使用工具类转换String为Worker</li>
<li>默认：未知错误</li>
</ul>
<h3 id="372-requestbuilder包">3.7.2 requestBuilder包</h3>
<p>包含了对应与request的Builder：</p>
<figure data-type="image" tabindex="17"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d7871c65f?w=413&amp;h=430&amp;f=png&amp;s=260751" alt="在这里插入图片描述" loading="lazy"></figure>
<p>除了默认的构造方法与build方法外，只有set方法，比如：</p>
<pre><code class="language-java">public class GetOneRequestBuilder {
    private final GetOneRequest request = new GetOneRequest();
    public GetOneRequestBuilder()
    {
        request.setUrl(AllURL.GET_ONE_URL);
    }
    public GetOneRequestBuilder cellphone(String cellphone)
    {
        if(Check.isEmpty(cellphone))
        {
            MessageBox.emptyCellphone();
            return null;
        }
        request.setCellphone(cellphone);
        return this;
    }
    public GetOneRequest build()
    {
        return request;
    }
}
</code></pre>
<p>在默认构造方法里面设置了url，剩下就只需设置电话即可获取Worker。</p>
<h3 id="373-okhttp">3.7.3 OKHTTP</h3>
<p>这是一个封装了OkHttp的静态工具类，唯一一个公有静态方法如下：</p>
<pre><code class="language-java">public static Object send(BaseRequest content)
{
    Call call = client.newCall(new Request.Builder().url(content.getUrl()).post(content.getBody()).build());
    try
    {
        ResponseBody body = call.execute().body();
        if(body != null)
            return content.handleResult(Conversion.stringToReturnCode(body.string()));
    }
    catch (IOException e)
    {
        L.error(&quot;Reseponse body is null&quot;);
        MessageBox.show(&quot;服务器无法连通,响应为空&quot;);
    }
    return null;
}
</code></pre>
<p>采用同步post请求的方式，其中call中使用的url与body正是使用<code>BaseRequest</code>作为基类的原因，可以方便地获取url与body，若数据量大可以考虑异步请求。上面也提到后端返回的是经由Gson转换为String的ReturnCode，所以获取body后，先转换为ReturnCode再处理。</p>
<h3 id="374-https">3.7.4 HTTPS</h3>
<p>至于HTTPS，采用了war包部署，后端服务器Tomcat，需要在Tomcat里设置证书，同时也需要在OkHttp中设置三部分：</p>
<ul>
<li>sslSocketFactory：ssl套接字工厂</li>
<li>HostnameVerifier：验证主机名</li>
<li>X509TrustManager：证书信任器管理类</li>
</ul>
<h4 id="3741-okhttp配置">3.7.4.1 OkHttp配置</h4>
<p>上面提到了需要设置三部分，下面来看看最简单的一个验证主机名部分，利用的是HostnameVerifier接口：</p>
<figure data-type="image" tabindex="18"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d71a3160b?w=596&amp;h=144&amp;f=png&amp;s=112073" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-java">OkHttpClient client = new OkHttpClient.Builder()
.connectTimeout(1500, TimeUnit.MILLISECONDS)
.hostnameVerifier((hostname, sslSession) -&gt; {
    if (&quot;www.test.com&quot;.equals(hostname)) {
        return true;
    } else {
        HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();
        return verifier.verify(hostname, sslSession);
    }
}).build();
</code></pre>
<p>这里验证主机名为www.test.com就返回true（也可是使用公网ip验证），否则使用默认的HostnameVerifier。业务逻辑复杂的话可以结合配置中心，黑/白名单等进行动态校验。</p>
<p>接着是X509TrustManager的处理（来源<a href="https://www.programcreek.com/java-api-examples/?class=java.security.cert.CertificateFactory&amp;method=generateCertificates">Java Code Example</a>）：</p>
<pre><code class="language-java">private static X509TrustManager trustManagerForCertificates(InputStream in)
            throws GeneralSecurityException
{
    CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
    Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in);
    if (certificates.isEmpty()) {
        throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;);
    }
    char[] password = &quot;www.test.com&quot;.toCharArray(); // Any password will work.
    KeyStore keyStore = newEmptyKeyStore(password);
    int index = 0;
    for (Certificate certificate : certificates) {
        String certificateAlias = Integer.toString(index++);
        keyStore.setCertificateEntry(certificateAlias, certificate);
    }
    // Use it to build an X509 trust manager.
    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
    keyManagerFactory.init(keyStore, password);
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init(keyStore);
    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)){
        throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers));
    }
    return (X509TrustManager) trustManagers[0];
}
</code></pre>
<p>返回一个信任由输入流读取的证书的信任管理器，若证书没有被签名则抛出SSLHandsakeException，证书建议使用第三方签名的而不是自签名的（比如使用openssl生成），特别是在生产环境中，例子的注释也提到：</p>
<figure data-type="image" tabindex="19"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d630d7065?w=873&amp;h=520&amp;f=png&amp;s=124595" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后是ssl套接字工厂的处理：</p>
<pre><code class="language-java">private static SSLSocketFactory createSSLSocketFactory() {
    SSLSocketFactory ssfFactory = null;
    try {
        SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);
        sc.init(null, new TrustManager[]{trustManager}, new SecureRandom());
        ssfFactory = sc.getSocketFactory();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ssfFactory;
}
</code></pre>
<p>完整的OkHttpClient构造如下：</p>
<pre><code class="language-java">X509TrustManager trustManager = trustManagerForCertificates(OKHTTP.class.getResourceAsStream(&quot;/key/pem.pem&quot;));
OkHttpClient client = new OkHttpClient.Builder()
.connectTimeout(1500, TimeUnit.MILLISECONDS)
.sslSocketFactory(createSSLSocketFactory(), trustManager)
.hostnameVerifier((hostname, sslSession) -&gt; {
    if (&quot;www.test.com&quot;.equals(hostname)) {
        return true;
    } else {
        HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();
        return verifier.verify(hostname, sslSession);
    }
})
.readTimeout(10, TimeUnit.SECONDS).build();
</code></pre>
<p>其中<code>/key/pem.pem</code>为resources下的证书文件。</p>
<h4 id="3742-服务器设置证书">3.7.4.2 服务器设置证书</h4>
<p>使用war进行部署，jar部署的方式请自行搜索，服务器Tomcat，其他web服务器请自行搜索。</p>
<p>首先在Tomcat配置文件中的<code>conf/server.xml</code>修改域名：</p>
<figure data-type="image" tabindex="20"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d86d0e55e?w=1005&amp;h=380&amp;f=png&amp;s=694217" alt="在这里插入图片描述" loading="lazy"></figure>
<p>找到&lt;Host&gt;并复制，直接修改其中的name为对应域名：</p>
<figure data-type="image" tabindex="21"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d87babc6a?w=1027&amp;h=531&amp;f=png&amp;s=940112" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着从证书厂商下载文件（一般都带文档，建议查看文档），Tomcat的是两个文件，一个是pfx，一个是密码文件，继续修改server.xml，搜索8443， 找到如下位置：</p>
<figure data-type="image" tabindex="22"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d8d572dca?w=1050&amp;h=660&amp;f=png&amp;s=1183514" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其中上面的&lt;Connector&gt;是HTTP/1.1协议的，基于NIO实现，下面的&lt;Connector&gt;是HTTP/2的，基于APR实现。使用HTTP/1.1会比较简单一些，仅仅是修改server.xml即可，使用HTTP/2的话会麻烦一点，如果基于APR实现需要安装Apr，Apr-util以及Tomcat-Native，可以参考<a href="https://blog.csdn.net/qq_27525611/article/details/106557158">这里</a>，下面以HTTP/1.1的为例，修改如下：</p>
<pre><code class="language-xml">&lt;Connector port=&quot;8123&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
	maxThreads=&quot;200&quot; SSLEnabled=&quot;true&quot; 
	scheme=&quot;https&quot; secure=&quot;true&quot;
	keystoreFile=&quot;/xxx/xxx/xxx/xxx.pfx&quot; keystoreType=&quot;PKCS12&quot;
	keystorePass=&quot;YOUR PASSWORD&quot; clientAuth=&quot;false&quot;
	sslProtocol=&quot;TLS&quot;&gt;
&lt;/Connector&gt;
</code></pre>
<p>修改证书位置以及密码。如果想要更加安全的话可以指定使用某个TLS版本:</p>
<pre><code class="language-xml">&lt;Connector ...
sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1.2&quot;
&gt;
</code></pre>
<h3 id="375-图片处理">3.7.5 图片处理</h3>
<p>图片原本是想使用OkHttp的MultipartBody处理的，但是处理的图片都不太，貌似没有必要，而且实体类的数据都是以字符串的形式传输的，因此，笔者的想法是能不能统一都用字符串进行传输，于是找到了图片和String互转的函数，稍微改动，原来的函数需要外部依赖，现在改为了JDK自带的Base64：</p>
<pre><code class="language-java">public static String fileToString(String path)
{
    File file = new File(path);
    FileInputStream fis = null;
    StringBuilder content = new StringBuilder();
    try {
        fis = new FileInputStream(file);
        int length = 3 * 1024 * 1024;
        byte[] byteAttr = new byte[length];
        int byteLength;
        while ((byteLength = fis.read(byteAttr, 0, byteAttr.length)) != -1) {
            String encode;
            if (byteLength != byteAttr.length) {
                byte[] temp = new byte[byteLength];
                System.arraycopy(byteAttr, 0, temp, 0, byteLength);
                encode = Base64.getEncoder().encodeToString(temp);
                content.append(encode);
            } else {
                encode = Base64.getEncoder().encodeToString(byteAttr);
                content.append(encode);
            }
        }

    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            assert fis != null;
            fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return content.toString();
}

public static void stirngToFile(String base64Code, String targetPath) {
    byte[] buffer;
    FileOutputStream out = null;
    try {
        buffer = Base64.getDecoder().decode(base64Code);
        out = new FileOutputStream(targetPath);
        out.write(buffer);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (out != null) {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>Base64是一种基于64个可打印字符来表示二进制数据的方法，可以把二进制数据（图片/视频等）转为字符,或把对应的字符解码变为原来的二进制数据。</p>
<p>笔者实测这种方法转换速度不慢，只要有了正确的转换函数，服务器端可以轻松进行转换，但是对于大文件的支持不好：</p>
<figure data-type="image" tabindex="23"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3dae72eb92?w=806&amp;h=64&amp;f=png&amp;s=16467" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这种方法对一般的图片来说足够了，但是对于真正的文件还是建议使用MultipartBody进行处理。</p>
<h2 id="38-动画模块">3.8 动画模块</h2>
<figure data-type="image" tabindex="24"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d996f0b03?w=311&amp;h=179&amp;f=png&amp;s=59004" alt="在这里插入图片描述" loading="lazy"></figure>
<p>包含了四类动画：淡入/淡出，位移，缩放，旋转，这四个类都实现了<code>CustomTransitionOperation</code>接口：</p>
<pre><code class="language-java">import javafx.animation.Animation;

public interface CustomTransitionOperation {
    double defaultSeconds = 0.4;
    Animation build();
    void play();
}
</code></pre>
<p>其中defaultSeconds表示默认持续的秒数，build用于<code>Transition</code>中对各个动画类进行统一的生成操作，最后的play用于播放动画。四个动画类类似，以旋转动画类为例：</p>
<pre><code class="language-java">public class Rotate implements CustomTransitionOperation{
    private final RotateTransition transition = new RotateTransition(Duration.seconds(1));

    public Rotate(Node node)
    {
        transition.setNode(node);
    }

    public Rotate seconds(double seconds)
    {
        transition.setDuration(Duration.seconds(seconds));
        return this;
    }

    public Rotate to(double to)
    {
        transition.setToAngle(to);
        return this;
    }

    @Override
    public Animation build() {
        return transition;
    }

    @Override
    public void play() {
        transition.play();
    }
}
</code></pre>
<p>seconds设置秒数，to表示设置旋转的角度，所有动画类统一由<code>Transition</code>控制：</p>
<pre><code class="language-java">public class Transition {
    private final ArrayList&lt;Animation&gt; animations = new ArrayList&lt;&gt;();

    public Transition add(CustomTransitionOperation animation)
    {
        animations.add(animation.build());
        return this;
    }

    public void play()
    {
        animations.forEach(Animation::play);
    }
}
</code></pre>
<p>里面是一个动画类的集合，每次add操作时先生成对应的动画再添加进数组，最后统一播放，示例用法如下：</p>
<pre><code class="language-java">new Transition()
.add(new Move(userImage).x(-70))
.add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))
.add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
.add(new Scale(workloadPolygon).ratio(1.8)).add(new Move(workloadPolygon).x(180))
.play();
</code></pre>
<h2 id="39-工具类模块">3.9 工具类模块</h2>
<figure data-type="image" tabindex="25"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3d998f1b3c?w=225&amp;h=125&amp;f=png&amp;s=32739" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>AvatarUtils</code>：用于本地生成临时图片以及图片转换处理</li>
<li><code>Check</code>：检查是否为空，是否合法等</li>
<li><code>Conversion</code>：转换类，通过Gson在Worker/String，Map/String，List/String之间进行转换</li>
<li><code>Utils</code>：加密，设置运行环境，居中Stage，检查网络连通等</li>
</ul>
<p>这里说一下<code>Utils</code>与<code>Conversion</code>。</p>
<h3 id="391-conversion">3.9.1 Conversion</h3>
<p>转换类，利用Gson在String与List/Worker/Map之间进行转换，比如String转Map：</p>
<pre><code class="language-java">public static Map&lt;String,Double&gt; stringToMap(String str)
{
    if(Check.isEmpty(str))
        return null;
    Map&lt;?,?&gt; m = gson.fromJson(str,Map.class);
    Map&lt;String,Double&gt; map = new HashMap&lt;&gt;(m.size());
    m.forEach((k,v)-&gt;map.put((String)k,(Double)v));
    return map;
}
</code></pre>
<p>大部分的转换函数类似，首先判空，接着进行对应的类型转换，这里的Conversion与后端的基本一致，后端也需要使用Conversion类进行转换操作。</p>
<h3 id="392-utils">3.9.2 Utils</h3>
<p>获取属性文件方法如下：</p>
<pre><code class="language-java">//获取属性文件
public static Properties getProperties()
{
    Properties properties = new Properties();
    //项目属性文件分成了config_dev.properties,config_test.properties,config_prod.properties
    String fileName = &quot;properties/config_&quot;+ getEnv() +&quot;.properties&quot;;
    ClassLoader loader = Thread.currentThread().getContextClassLoader();
    try(InputStream inputStream = loader.getResourceAsStream(fileName))
    {
        if(inputStream != null)
        {
        	//防止乱码
            properties.load(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
            return properties;
        }
        L.error(&quot;Can not load properties properly.InputStream is null.&quot;);
        return null;
    }
    catch (IOException e)
    {
        L.error(&quot;Can not load properties properly.Message:&quot;+e.getMessage());
        return null;
    }
}
</code></pre>
<p>另一个是检查网路连通的方法：</p>
<pre><code class="language-java">public static boolean networkAvaliable()
{
    try(Socket socket = new Socket())
    {
        socket.connect(new InetSocketAddress(&quot;www.baidu.com&quot;,443));
        return true;
    }
    catch (IOException e)
    {
        L.error(&quot;Can not connect network.&quot;);
        e.printStackTrace();
    }
    return false;
}
</code></pre>
<p>采用socket进行判断，准确来说可以分两个方法检查网络，其中一个是检查网络连通，另一个是检查后端是否连通。</p>
<p>最后是居中Stage的方法，尽管Stage中自带了一个centerOnScreen，但是出来的效果并不好，笔者的实测是水平居中但是垂直偏上的，并不是垂直水平居中。</p>
<figure data-type="image" tabindex="26"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3db7ad207c?w=666&amp;h=189&amp;f=png&amp;s=73626" alt="在这里插入图片描述" loading="lazy"></figure>
<p>因此根据屏幕高宽以及Stage的大小手动设置Stage的x和y。</p>
<pre><code class="language-java">public static void centerMainStage()
{
    Rectangle2D screenRectangle = Screen.getPrimary().getBounds();
    double width = screenRectangle.getWidth();
	double height = screenRectangle.getHeight();
	
	Stage stage = GUI.getStage();
    stage.setX(width/2 - ViewSize.MAIN_WIDTH/2);
    stage.setY(height/2 - ViewSize.MAIN_HEIGHT/2);
}
</code></pre>
<h2 id="310-视图模块">3.10 视图模块</h2>
<figure data-type="image" tabindex="27"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3dbd2d6dc3?w=271&amp;h=101&amp;f=png&amp;s=32988" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>GUI</code>：全局变量共享以及以及控制Scene的切换</li>
<li><code>MainScene</code>：全局控制器，负责初始化以及绑定键盘事件</li>
<li><code>MessBox</code>：提示信息框，对外提供show()等的静态方法。</li>
</ul>
<p>GUI中的方法主要为<code>switchToXxx</code>，比如：</p>
<pre><code class="language-java">public static void switchToSignInUp()
{
    if(GUI.isUserInformation())
    {
        AvatarUtils.deletePathIfExists();
        GUI.getUserInformationController().reset();
    }
    mainParent.requestFocus();
    children.clear();
    children.add(signInUpParent.lookup(PaneName.SIGN_IN_UP));
    scene.getStylesheets().add(CSSPath.SIGN_IN_UP);
    Label minimize = (Label) (mainParent.lookup(&quot;#minimize&quot;));
    minimize.setText(&quot;-&quot;);
    minimize.setFont(new Font(&quot;System&quot;, 20));
    minimize.setOnMouseClicked(v-&gt;minimize());
}
</code></pre>
<p>跳转到登录注册，公有静态，首先判断是否为用户信息界面，如果是进行一些清理操作，接着是让Parent获取焦点（为了让键盘事件响应），然后将对应的<code>AnchorPane</code>添加到Children，并添加css，最后修改按钮文字与事件。</p>
<p>另外还在MainScene中加了一些键盘事件响应，比如Enter：</p>
<pre><code class="language-java">ObservableMap&lt;KeyCombination,Runnable&gt; keyEvent = GUI.getScene().getAcclerators();
keyEvent.put(new KeyCodeCombination(KeyCode.ENTER),()-&gt;
{
    if (GUI.isSignInUp())
        GUI.getSignInUpController().signInUp();
    else if (GUI.isRetrievePassword())
        GUI.getRetrievePasswordController().reset();
    else if(GUI.isWorker())
        GUI.switchToUserInformation();
    else if(GUI.isAdmin())
        GUI.switchToUserManagement();
    else if(GUI.isUserInformation())
    {
        UserInformationController controller = GUI.getUserInformationController();
        if(controller.isModifying())
            controller.saveInformation();
        else
            controller.modifyInformation();
    }
    else if(GUI.isSalaryEntry())
    {
        GUI.getSalaryEntryController().save();
    }
});
</code></pre>
<h1 id="4-前端ui部分">4 前端UI部分</h1>
<h2 id="41-fxml">4.1 fxml</h2>
<figure data-type="image" tabindex="28"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3dbd4ef943?w=326&amp;h=359&amp;f=png&amp;s=147205" alt="在这里插入图片描述" loading="lazy"></figure>
<p>界面基本上靠这些fxml文件控制，这部分没太多内容，基本上靠IDEA自带的Scene Builder设计，少部分靠代码控制，下面说几个注意事项：</p>
<ul>
<li>根节点为AnchorPane，每个fxml设置一个独立的<code>fx:id</code>以便切换</li>
<li>事件绑定在对应的控件中，比如在一个Label绑定鼠标进入事件，在这个Label上设置<code>onMouseEntered=&quot;#xxx&quot;</code>，其中里面的方法为对应的控制器（<code>fx:controller=&quot;xxx.xxx.xxx.xxxController&quot;</code>）中的方法</li>
<li><code>&lt;Image&gt;</code>中的url属性需要带上<code>@</code>，比如<code>&lt;Image url=&quot;@../../image/xxx.png&quot;&gt;</code></li>
</ul>
<h2 id="42-css">4.2 css</h2>
<p>JFX中集成了部分css的美化功能，比如：</p>
<pre><code class="language-css">-fx-background-radius: 25px;
-fx-background-color:#e2ff1f;
</code></pre>
<p>用法是需要先在fxml中设置id。</p>
<p>这里注意一下两个id的不同：</p>
<ul>
<li><code>fx:id</code></li>
<li><code>id</code></li>
</ul>
<p><code>fx:id</code>指的是控件的<code>fx:id</code>，通常配合Controller中的<code>@FXML</code>使用，比如一个Label设置了<code>fx:id</code>为label1</p>
<pre><code class="language-xml">&lt;Label fx:id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt;
   &lt;font&gt;
       &lt;Font size=&quot;18.0&quot; /&gt;
   &lt;/font&gt;
&lt;/Label&gt;
</code></pre>
<p>则可以在对应Controller中使用<code>@FXML</code>获取，名字与<code>fx:id</code>一致：</p>
<pre><code class="language-java">@FXML
private Label label1;
</code></pre>
<p>而<code>id</code>指的是css的<code>id</code>，用法是在css引用即可，比如上面的Label又同时设置了<code>id</code>（可以相同，也可不同）：</p>
<pre><code class="language-xml">&lt;Label fx:id=&quot;label1&quot; id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt;
   &lt;font&gt;
       &lt;Font size=&quot;18.0&quot; /&gt;
   &lt;/font&gt;
&lt;/Label&gt;
</code></pre>
<p>然后在css文件中像引用普通<code>id</code>一样引用：</p>
<pre><code class="language-css">#label1
{
    -fx-background-radius: 20px; /*圆角*/
}
</code></pre>
<p>同时JFX还支持css的伪类，比如下面的最小化与关闭的鼠标移入效果是使用伪类实现的：</p>
<figure data-type="image" tabindex="29"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3dbfabcaf6?w=254&amp;h=107&amp;f=gif&amp;s=53833" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-css">#minimize:hover
{
    -fx-opacity: 1;
    -fx-background-radius: 10px;
    -fx-background-color: #323232;
    -fx-text-fill: #ffffff;
}

#close:hover
{
    -fx-opacity: 1;
    -fx-background-radius: 10px;
    -fx-background-color: #dd2c00;
    -fx-text-fill: #ffffff;
}
</code></pre>
<p>当然一些比较复杂的是不支持的，笔者尝试过使用transition之类的，不支持。</p>
<p>最后需要在对应的Scene里面引入css：</p>
<pre><code class="language-java">Scene scene = new Scene();
scene.getStylesheets().add(&quot;xxx/xxx/xxx/xxx.css&quot;);
</code></pre>
<p>程序中的用法是：</p>
<pre><code class="language-java">scene.getStylesheets().add(CSSPath.SIGN_IN_UP);
</code></pre>
<h2 id="43-stage构建过程">4.3 Stage构建过程</h2>
<p>下面以提示框为例，说明Stage的构建过程。</p>
<pre><code class="language-java">try {
    Stage stage = new Stage();
    Parent root = FXMLLoader.load(getClass().getResource(FXMLPath.MESSAGE_BOX));
    Scene scene = new Scene(root, ViewSize.MESSAGE_BOX_WIDTH,ViewSize.MESSAGE_BOX_HEIGHT);
    scene.getStylesheets().add(CSSPath.MESSAGE_BOX);
    Button button = (Button)root.lookup(&quot;#button&quot;);
    button.setOnMouseClicked(v-&gt;stage.hide());
    Label label = (Label)root.lookup(&quot;#label&quot;);
    label.setText(message);
    stage.initStyle(StageStyle.TRANSPARENT);
    stage.setScene(scene);
    Utils.centerMessgeBoxStage(stage);
    stage.show();

    root.requestFocus();
    scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), stage::close);
    scene.getAccelerators().put(new KeyCodeCombination(KeyCode.BACK_SPACE), stage::close);
} catch (IOException e) {
	//...
}
</code></pre>
<p>首先新建一个Stage，接着利用FXMLLoader加载对应路径上的fxml文件，获取Parent后，利用该Parent生成Scene，再为Scene添加样式。</p>
<p>接着是控件的处理，这里的<code>lookup</code>类似Android中的<code>findViewById</code>，根据<code>fx:id</code>获取对应控件，注意需要加上<code>#</code>。处理好控件之后，居中并显示stage，同时，绑定键盘事件并让Parent获取焦点。</p>
<h1 id="5-后端部分">5 后端部分</h1>
<h2 id="51-后端概述">5.1 后端概述</h2>
<p>后端以Spring Boot框架为核心，部署方式为war，整体分为三层：</p>
<ul>
<li>控制器层：负责接受前端的请求并调用业务层方法</li>
<li>业务层：处理主要业务，如CRUD，图片处理等</li>
<li>持久层：数据持久化，使用Hibernate+Spring Data JPA</li>
</ul>
<p>总的来说没有用到什么高大上的东西，逻辑也比较简单。</p>
<h2 id="52-概览">5.2 概览</h2>
<h3 id="521-代码目录树">5.2.1 代码目录树</h3>
<figure data-type="image" tabindex="30"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3ddbdb8968?w=251&amp;h=658&amp;f=png&amp;s=204876" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-依赖">5.2.2 依赖</h3>
<p>主要依赖如下：</p>
<ul>
<li><a href="https://mvnrepository.com/search?q=spring%20boot%20start%20data%20jpa">Spring Boot Starter Data JPA</a>：数据持久化</li>
<li><a href="https://mvnrepository.com/search?q=guava">Guava</a>：工具类</li>
<li><a href="https://mvnrepository.com/search?q=lombok">Lombok</a>：同前端</li>
<li><a href="https://mvnrepository.com/search?q=gson">Gson</a>：工具类</li>
<li><a href="https://mvnrepository.com/search?q=Apache%20commons">Apache Commons</a>：工具类</li>
<li><a href="https://mvnrepository.com/search?q=tencentcloud-sdk-java">TencentCloud SDK Java</a>：短信验证码API</li>
<li><a href="https://mvnrepository.com/search?q=jasypt%20spring%20boot%20starter">Jasypt Spring Boot Starter</a>：加密配置文件</li>
</ul>
<h2 id="53-控制器层">5.3 控制器层</h2>
<p>控制器分为三类，一类处理图片，一类处理CRUD请求，一类处理短信发送请求，统一接受POST忽略GET请求。大概的处理流程是接收参数后首先进行判断操作，比如判空以及判断是否合法等等，接着调用业务层的方法并对返回结果进行封装，同时进行日志记录，最后利用Gson把返回结果转为字符串。代码大部分比较简单就不贴了，说一下短信验证码的部分。</p>
<p>验证码模块使用了腾讯云的功能，官网<a href="https://cloud.tencent.com/">这里</a>，搜索短信功能即可。</p>
<figure data-type="image" tabindex="31"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3ddce9af4b?w=484&amp;h=222&amp;f=png&amp;s=14733" alt="在这里插入图片描述" loading="lazy"></figure>
<p>新用户默认赠送100条短信：</p>
<figure data-type="image" tabindex="32"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3ddfa90187?w=1469&amp;h=696&amp;f=png&amp;s=84965" alt="在这里插入图片描述" loading="lazy"></figure>
<p>发送之前需要创建签名与正文模板，审核通过即可使用。</p>
<figure data-type="image" tabindex="33"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3de2121931?w=211&amp;h=190&amp;f=png&amp;s=8243" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以先根据快速开始试用一下短信功能，若能成功收到短信，可以<a href="https://github.com/TencentCloud/tencentcloud-sdk-java">戳这里</a>查看API（Java版）。</p>
<p>下面的例子由<a href="https://github.com/TencentCloud/tencentcloud-sdk-java/blob/master/examples/sms/v20190711/SendSms.java">文档例子</a>简化而来：</p>
<pre><code class="language-java">private void sendCode()
{
    try
    {
        SmsClient client = new SmsClient(new Credential(TencentSDK.id,TencentSDK.key),&quot;&quot;);
        SendSmsRequest request = new SendSmsRequest();
        request.setSmsSdkAppid(TencentSDK.appId);
        request.setSign(TencentSDK.sign);
        request.setTemplateID(TencentSDK.templateId);

        randomCode = RandomStringUtils.randomNumeric(6);
        String [] templateParamSet = {randomCode};
        request.setTemplateParamSet(templateParamSet);

        String [] phoneNumbers = {&quot;+86&quot;+cellphone.getText()};
        request.setPhoneNumberSet(phoneNumbers);
        response = client.SendSms(request);
    } catch (Exception e) {
        L.error(&quot;Not send code or send code failed&quot;);
        AlertView.show(&quot;验证码未发送或发送验证码失败&quot;);
    }
}
</code></pre>
<p>其中<code>TencentSDK.appId,TencentSDK.sign,TencentSDK.templateID</code>分别是读应的appid，签名id与正文模板id，申请通过之后会分配的，然后随机生成六位数字的验证码。</p>
<p>接着<code>request.setPhoneNumberSet()</code>的参数为需要发送的手机号码String数组，注意需要加上区号。发送成功的话手机会收到，失败的话请根据异常信息自行判断修改。</p>
<p>唯一要注意一下的是appid之类的数据通过配置文件配合<code>@Value</code>获取值，如：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/&quot;)
public class SmsController {
    @Value(&quot;${tencent.secret.id}&quot;)
    private String secretId;
    ...
}
</code></pre>
<p>但是由于sign部分含有中文，所以需要进行编码转换：</p>
<pre><code class="language-java">@Value(&quot;${tencent.sign}&quot;)
private String sign;

@PostConstruct
public void init()
{
    sign = new String(sign.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
}
</code></pre>
<h2 id="54-业务层与持久层">5.4 业务层与持久层</h2>
<p>由于程序中的业务层与持久层都比较简单就合并一起说了，比如业务层的saveOne方法，保存一个Worker，先利用Gson转换为Worker后直接利用<code>CrudRespository&lt;T,ID&gt;</code>提供的save方法保存：</p>
<pre><code class="language-java">public ReturnCode saveOne(String json) {
    ReturnCode s = ReturnCode.SAVE_ONE_SUCCESS;
    Worker worker = Conversion.JSONToWorker(json);
    if (Check.isEmpty(worker)) {
        L.emptyWorker();
        s = ReturnCode.EMPTY_WORKER;
    }
    else
        workerRepository.save(worker);
    return s;
}
</code></pre>
<p>另外由于<code>CurdRepository&lt;T,ID&gt;</code>的saveAll方法参数为<code>Iterable&lt;S&gt;</code>，因此可以直接保存<code>List&lt;S&gt;</code>，比如：</p>
<pre><code class="language-java">public ReturnCode saveAll(List&lt;Worker&gt; workers)
{
    workerRepository.saveAll(workers);
    return ReturnCode.SAVE_ALL_SUCCESS;
}
</code></pre>
<p>需要在控制层中把前端发送的String转换为<code>List&lt;S&gt;</code>。</p>
<h2 id="55-日志">5.5 日志</h2>
<p>日志用的是Spring Boot自带的日志系统，只是简单地配置了一下日志路径，除此之外，日志的格式自定义（因为追求整洁输出,感觉配置文件实现得不够好,因此自定义了一个工具类）。</p>
<p>比如日志截取如下：</p>
<figure data-type="image" tabindex="34"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3de2e8a23c?w=710&amp;h=200&amp;f=png&amp;s=252717" alt="在这里插入图片描述" loading="lazy"></figure>
<p>自定义了标题以及每行固定输出，前后加上了提示符，内容包括方法，级别，时间以及其他信息。</p>
<p>总的来说，除了格式化器外总共有7个类，其中L是主类，外部类只需要调用L的方法，里面都是静态方法，其余6个是L调用的类：</p>
<figure data-type="image" tabindex="35"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3df0df2af3?w=227&amp;h=221&amp;f=png&amp;s=69145" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如备份成功时调用：</p>
<pre><code class="language-java">public Success
{
	public static void backup()
	{
	    l.info(new FormatterBuilder().title(getTitle()).info().position().time().build());
	}
	//...
}
</code></pre>
<p>其中<code>FormatterBuilder</code>是格式化器，用来格式化输出的字符串，方法包括时间，位置，级别以及其他信息：</p>
<pre><code class="language-java">public FormatterBuilder info()
{
    return level(&quot;info&quot;);
}
public FormatterBuilder time()
{
    content(&quot;time&quot;,getCurrentTime());
    return this;
}
private FormatterBuilder level(String level)
{
    content(&quot;level&quot;,level);
    return this;
}
public FormatterBuilder cellphone(String cellphone)
{
    content(&quot;cellphone&quot;,cellphone);
    return this;
}
public FormatterBuilder message(String message)
{
    content(&quot;message&quot;,message);
    return this;
}
</code></pre>
<h2 id="56-工具类">5.6 工具类</h2>
<figure data-type="image" tabindex="36"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3dfc72c52a?w=210&amp;h=126&amp;f=png&amp;s=30211" alt="在这里插入图片描述" loading="lazy"></figure>
<p>四个：</p>
<ul>
<li>Backup：定时数据库备份</li>
<li>Check：检查合法性，是否为空等</li>
<li>Conversion：转换类，与前端的几乎一致，利用Gson在String与List/Map/Worker之间进行转换</li>
<li>ReturnCode：返回码枚举类</li>
</ul>
<p>重点说一下备份，代码不长就直接整个类贴出来了：</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class Backup {
    private static final long INTERVAL = 1000 * 3600 * 12;
    @Value(&quot;${backup.command}&quot;)
    private String command;
    @Value(&quot;${backup.path}&quot;)
    private String strPath;
    @Value(&quot;${spring.datasource.username}&quot;)
    private String username;
    @Value(&quot;${spring.datasource.password}&quot;)
    private String password;
    @Value(&quot;${spring.datasource.url}&quot;)
    private String url;
    @Value(&quot;${backup.dataTimeFormat}&quot;)
    private String dateTimeFormat;

    @Scheduled(fixedRate = INTERVAL)
    public void startBackup()
    {
        try
        {
            String[] commands = command.split(&quot;,&quot;);
            String dbname = url.substring(url.lastIndexOf(&quot;/&quot;)+1);
            commands[2] = commands[2] + username + &quot; --password=&quot; + password + &quot; &quot; + dbname + &quot; &gt; &quot; + strPath +
                    dbname + &quot;_&quot; + DateTimeFormatter.ofPattern(dateTimeFormat).format(LocalDateTime.now())+&quot;.sql&quot;;
            Path path = Paths.get(strPath);
            if(!Files.exists(path))
                Files.createDirectories(path);
            Process process = Runtime.getRuntime().exec(commands);
            process.waitFor();
            if(process.exitValue() != 0)
            {
                InputStream inputStream = process.getErrorStream();
                StringBuilder str = new StringBuilder();
                byte []b = new byte[2048];
                while(inputStream.read(b,0,2048) != -1)
                    str.append(new String(b));
                L.backupFailed(str.toString());
            }
            L.backupSuccess();
        }
        catch (IOException | InterruptedException e)
        {
            L.backupFailed(e.getMessage());
        }
    }
}
</code></pre>
<p>首先利用<code>@Value</code>获取配置文件中的值，接着在备份方法加上<code>@Scheduled</code>。<code>@Scheduled</code>是Spring Boot用于提供定时任务的注解，用于控制任务在某个指定时间执行或者每隔一段时间执行（这里是半天一次），主要有三种配置执行时间的方式：</p>
<ul>
<li>cron</li>
<li>fixedRate</li>
<li>fixedDelay</li>
</ul>
<p>这里不展开了，详细用法可以<a href="https://blog.csdn.net/qq_27525611/article/details/104083548">戳这里</a>。</p>
<p>另外在使用前需要在类上加上<code>@EnableScheduling</code>。备份的方法首先利用url获取数据库名，接着拼合备份命令，注意如果本地使用win开发备份命令会与linux不同：</p>
<pre><code class="language-java">//win
command[0]=cmd
command[1]=/c
command[2]=mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot;

//linux(本地Manjaro+服务器CentOS测试通过)
command[0]=/bin/sh
command[1]=-c
command[2]=/usr/bin/mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot;
</code></pre>
<p>再判断备份路径是否存在，接着利用Java自带的Process进行备份处理，若出错则利用其中的<code>getErrorStream()</code>获取错误信息并记录日志。</p>
<h2 id="57-配置文件">5.7 配置文件</h2>
<h3 id="571-配置文件分类">5.7.1 配置文件分类</h3>
<figure data-type="image" tabindex="37"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e02267dec?w=302&amp;h=178&amp;f=png&amp;s=58001" alt="在这里插入图片描述" loading="lazy"></figure>
<p>一个总的配置文件+三个是特定环境下（开发，测试，生产）的配置文件，可以使用<code>spring.profiles.active</code>切换配置文件，比如<code>spring.profiles.active=dev</code>，注意命名有规则，中间加一杠。另外自定义的配置需要在<code>additional-spring-configuration-metadata.json</code>中添加字段（非强制，只是IDE会提示），比如：</p>
<pre><code class="language-json">&quot;properties&quot;: [
    {
        &quot;name&quot;: &quot;backup.path&quot;,
        &quot;type&quot;: &quot;java.lang.String&quot;,
        &quot;defaultValue&quot;: &quot;null&quot;
    },
]
</code></pre>
<h3 id="572-加密">5.7.2 加密</h3>
<p>都2020年了，还在配置文件中使用明文密码就不太好吧？</p>
<p>该加密了。</p>
<p>使用的是Jasypt Spring Boot组件，官方github请<a href="https://github.com/ulisesbocchio/jasypt-spring-boot">戳这里</a>。</p>
<p>用法这里就不详细介绍了，详情看笔者的另一篇博客，<a href="https://www.cnblogs.com/6b7b5fc3/p/12791351.html">戳这里</a>。</p>
<p>但是笔者实测目前最新的3.0.2版本（本文写于2020.06.05，2020.05.31作者已更新3.0.3版本，但是笔者没有测试过）会有如下问题：</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.password' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>解决方案以及问题详细描述<a href="https://blog.csdn.net/qq_27525611/article/details/106450385">戳这里</a>。</p>
<h1 id="6-部署与打包">6 部署与打包</h1>
<h2 id="61-前端打包">6.1 前端打包</h2>
<p>先说一下前端的打包过程，简单地说打成jar即可跨平台运行，但是如果是特定平台的话比如win，想打成无需额外JDK环境的exe还是需要一些额外操作，这里简单介绍一下打包过程。</p>
<p>（如果是JDK8可以使用<code>mvn jfx:native</code>打包，这个可以很方便地直接打成dmg或者exe，但可惜JFX11行不通，反正笔者尝试失败了，如果有大神知道如何使用<code>JavaFX-Maven-Plugin</code>或者在IDEA中使用<code>artifact</code>直接打成exe或dmg欢迎留言补充）</p>
<h3 id="611-idea一次打包">6.1.1 IDEA一次打包</h3>
<p>打包需要用到Maven插件，常用的Maven打包插件如下：</p>
<ul>
<li>mave-jar-plugin：默认的打包jar插件，生成的jar很小，但是需要把lib放置与jar相同目录下，用来打普通的JAR包</li>
<li>maven-shade-plugin：提供了两大基本功能，将依赖的jar包打包到当前jar包，能对依赖的jar包进行重命名以及取舍过滤</li>
<li>maven-assembly-plugin：支持定制化的打包方式，更多的是对项目目录的重新组装</li>
</ul>
<p>本项目使用maven-shade-plugin打包。</p>
<p>需要先引入（引入之后可以把原来的Maven插件去掉），最新版本<a href="https://github.com/apache/maven-shade-plugin">戳这里</a>的官方github查看：</p>
<pre><code class="language-xml">&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
			&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2.4&lt;/version&gt;
	            &lt;executions&gt;
	            	&lt;execution&gt;
	                    &lt;phase&gt;package&lt;/phase&gt;
	                    &lt;goals&gt;
	                        &lt;goal&gt;shade&lt;/goal&gt;
	                    &lt;/goals&gt;
	                    &lt;configuration&gt;
	                        &lt;transformers&gt;
	                            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
	                                &lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt;
	                            &lt;/transformer&gt;
	                        &lt;/transformers&gt;
	                    &lt;/configuration&gt;
	                &lt;/execution&gt;
	            &lt;/executions&gt;
          &lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>只需要修改主类即可：</p>
<pre><code class="language-xml">&lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt;
</code></pre>
<p>接着就可以从IDEA右侧栏的Maven中一键打包：</p>
<figure data-type="image" tabindex="38"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e0653b768?w=357&amp;h=373&amp;f=png&amp;s=157939" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样在target下就有jar包了，可以跨平台运行，只需提供JDK环境。</p>
<pre><code class="language-bash">java -jar xxx.jar
</code></pre>
<p>下面的两步是使用exe4j与Enigma Virtual Box打成一个单一exe的方法，仅针对Win，使用Linux/Mac可以跳过或自行搜索其他方法。</p>
<h3 id="612-exe4j二次打包">6.1.2 exe4j二次打包</h3>
<h4 id="6121-exe4j">6.1.2.1 exe4j</h4>
<p>exe4j能集成Java应用程序到Win下的java可执行文件生成工具,无论是用于服务器还是用于GUI或者命令行的应用程序。简单地说，本项目用其将jar转换为exe。exe4j需要jre，从JDK9开始模块化，需要自行生成jre，因此，需要先生成jre再使用exe4j打包。</p>
<h4 id="6122-生成jre">6.1.2.2 生成jre</h4>
<p>各个模块的作用可以<a href="https://www.apiref.com/java11-zh/index.html">这里</a>查看：</p>
<figure data-type="image" tabindex="39"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e0665f1cd?w=1241&amp;h=876&amp;f=png&amp;s=96178" alt="在这里插入图片描述" loading="lazy"></figure>
<p>经测试本程序所需要的模块如下：</p>
<pre><code class="language-bash">java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management
</code></pre>
<p>切换到JDK目录下，使用jlink生成jre：</p>
<pre><code class="language-bash">jlink --module-path jmods --add-modules 
java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management
--output jre
</code></pre>
<p>由于OpenJDK11不自带JavaFX，需要<a href="https://gluonhq.com/products/javafx/">戳这里</a>自行下载Win平台的JFX jmods，并移动到JDK的jmods目录下。生成的jre大小为91M：</p>
<figure data-type="image" tabindex="40"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e23920ee9?w=337&amp;h=211&amp;f=png&amp;s=9711" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如果实在不清楚使用哪一些模块可以使用全部模块，但是不建议：</p>
<pre><code class="language-bash">jlink --module-path jmods --add-modules 
java.base,java.compiler,java.datatransfer,java.xml,java.prefs,java.desktop,java.instrument,java.logging,java.management,java.security.sasl,java.naming,java.rmi,java.management.rmi,java.net.http,java.scripting,java.security.jgss,java.transaction.xa,java.sql,java.sql.rowset,java.xml.crypto,java.se,java.smartcardio,jdk.accessibility,jdk.internal.vm.ci,jdk.management,jdk.unsupported,jdk.internal.vm.compiler,jdk.aot,jdk.internal.jvmstat,jdk.attach,jdk.charsets,jdk.compiler,jdk.crypto.ec,jdk.crypto.cryptoki,jdk.crypto.mscapi,jdk.dynalink,jdk.internal.ed,jdk.editpad,jdk.hotspot.agent,jdk.httpserver,jdk.internal.le,jdk.internal.opt,jdk.internal.vm.compiler.management,jdk.jartool,jdk.javadoc,jdk.jcmd,jdk.management.agent,jdk.jconsole,jdk.jdeps,jdk.jdwp.agent,jdk.jdi,jdk.jfr,jdk.jlink,jdk.jshell,jdk.jsobject,jdk.jstatd,jdk.localedata,jdk.management.jfr,jdk.naming.dns,jdk.naming.rmi,jdk.net,jdk.pack,jdk.rmic,jdk.scripting.nashorn,jdk.scripting.nashorn.shell,jdk.sctp,jdk.security.auth,jdk.security.jgss,jdk.unsupported.desktop,jdk.xml.dom,jdk.zipfs,javafx.web,javafx.swing,javafx.media,javafx.graphics,javafx.fxml,javafx.controls,javafx.base 
--output jre
</code></pre>
<p>大小为238M：</p>
<figure data-type="image" tabindex="41"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e25c02299?w=344&amp;h=191&amp;f=png&amp;s=9509" alt="在这里插入图片描述" loading="lazy"></figure>
<h4 id="6123-exe4j打包">6.1.2.3 exe4j打包</h4>
<p>exe4j使用参考<a href="https://zhuanlan.zhihu.com/p/82540739">这里</a>，首先一开始的界面应该是这样的：</p>
<figure data-type="image" tabindex="42"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e2a4f4c72?w=836&amp;h=642&amp;f=png&amp;s=51573" alt="在这里插入图片描述" loading="lazy"></figure>
<p>配置文件首次运行是没有的，next即可。</p>
<p>选择JAR in EXE mode：</p>
<figure data-type="image" tabindex="43"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e27428d73?w=850&amp;h=650&amp;f=png&amp;s=93037" alt="在这里插入图片描述" loading="lazy"></figure>
<p>填入名称与输出目录：</p>
<figure data-type="image" tabindex="44"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e2df66a1a?w=850&amp;h=650&amp;f=png&amp;s=83927" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这里的类型为GUI application，填上可执行文件的名称，选择图标路径，勾选允许单个应用实例运行：</p>
<figure data-type="image" tabindex="45"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e30344eca?w=850&amp;h=650&amp;f=png&amp;s=94906" alt="在这里插入图片描述" loading="lazy"></figure>
<p>重定向这里可以选择标准输出流与标准错误流的输出目录，不需要的话默认即可：</p>
<figure data-type="image" tabindex="46"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e433feaaa?w=850&amp;h=650&amp;f=png&amp;s=94198" alt="在这里插入图片描述" loading="lazy"></figure>
<p>64位Win需要勾选生成64位的可执行文件：</p>
<figure data-type="image" tabindex="47"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e460fae82?w=850&amp;h=650&amp;f=png&amp;s=89499" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着是Java类与JRE路径设置：</p>
<figure data-type="image" tabindex="48"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e4ca2b9cf?w=850&amp;h=650&amp;f=png&amp;s=117069" alt="在这里插入图片描述" loading="lazy"></figure>
<p>选择IDEA生成的jar，接着填上主类路径：</p>
<figure data-type="image" tabindex="49"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e50aa1966?w=680&amp;h=180&amp;f=png&amp;s=13355" alt="在这里插入图片描述" loading="lazy"></figure>
<p>设置jre的最低支持与最高支持版本：</p>
<figure data-type="image" tabindex="50"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e55dfce02?w=837&amp;h=642&amp;f=png&amp;s=46654" alt="在这里插入图片描述" loading="lazy"></figure>
<p>下一步是指定JRE搜索路径，首先把默认的三个位置删除：</p>
<figure data-type="image" tabindex="51"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e5c5d3a86?w=833&amp;h=638&amp;f=png&amp;s=48942" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着选择之前生成的jre，把jre放在与jar同一目录下，路径填上当前目录下的jre：</p>
<figure data-type="image" tabindex="52"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e695084cd?w=838&amp;h=639&amp;f=png&amp;s=65473" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接下来全next即可，完成后会提示exe4j has finished，直接运行测试一遍：</p>
<figure data-type="image" tabindex="53"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e6b038628?w=838&amp;h=637&amp;f=png&amp;s=57779" alt="在这里插入图片描述" loading="lazy"></figure>
<p>首先会提示一遍这是用exe4j生成的：</p>
<figure data-type="image" tabindex="54"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e6dab9683?w=398&amp;h=149&amp;f=png&amp;s=5133" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若没有缺少模块应该就可以正常启动了，有缺少模块的话会默认在当前exe路径生成一个error.log，查看并添加对应模块再次使用jlink生成jre，并使用exe4j再次打包。</p>
<h3 id="613-enigma-virtual-box三次打包">6.1.3 Enigma Virtual Box三次打包</h3>
<p>使用exe4j打包后，虽然是也可以直接运行了，但是jre太大，而且笔者这种有强迫症非得装进一个exe。所幸笔者之前用过Enigma Virtual Box这个打包工具，能把所有文件打包为一个独立的exe。</p>
<p>使用很简单，首先添加exe4j打包出来的exe：</p>
<figure data-type="image" tabindex="55"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e745dfd36?w=756&amp;h=350&amp;f=png&amp;s=23006" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着新建一个jre目录，添加上一步生成的jre：</p>
<figure data-type="image" tabindex="56"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e7db555dd?w=747&amp;h=318&amp;f=png&amp;s=12503" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="57"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e93572775?w=746&amp;h=321&amp;f=png&amp;s=14809" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="58"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e935325a3?w=742&amp;h=305&amp;f=png&amp;s=15085" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后选择压缩文件：</p>
<figure data-type="image" tabindex="59"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e979c8bd4?w=749&amp;h=318&amp;f=png&amp;s=18729" alt="在这里插入图片描述" loading="lazy"></figure>
<p>打包出来的单独exe大小为65M，相比起exe4j还要带上的89M的jre，已经节省了空间。</p>
<figure data-type="image" tabindex="60"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3e9c45dc32?w=333&amp;h=203&amp;f=png&amp;s=10533" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="62-后端部署">6.2 后端部署</h2>
<p>后端部署的方式也简单，采用war部署的方式，若项目为jar包打包可以自行转换为war包，具体转换方式不难请自行搜索。由于Web服务器为Tomcat，因此直接把war包放置于webapps下即可，其他Web服务器自请自行搜索。</p>
<p>当然也可以使用Docker部署，但需要使用jar而不是war，具体方式自行搜索。</p>
<h1 id="7-运行">7 运行</h1>
<p>本项目已经打包，前端包括jar与exe，后端包括jar与war，首先把后端运行（先开启数据库服务）：</p>
<p>使用jar：</p>
<pre><code class="language-bash">java -jar Backend.jar
</code></pre>
<p>使用war直接放到Tomcat的webapps下然后到bin下：</p>
<pre><code class="language-bash">./startup.sh
</code></pre>
<p>接着运行前端，Windows的话可以直接运行exe，当然也可以jar，Linux的话jar：</p>
<pre><code class="language-bash">java -jar Frontend.jar
</code></pre>
<p>若运行失败可以用IDEA打开项目直接在IDEA中运行或者自行打包运行。</p>
<h1 id="8-注意事项">8 注意事项</h1>
<h2 id="81-路径问题">8.1 路径问题</h2>
<p>对于资源文件千万千万不要直接使用什么相对路径或绝对路径，比如：</p>
<pre><code class="language-java">String path1 = &quot;/xxx/xxx/xxx/xx.png&quot;;
String path2 = &quot;xxx/xx.jpg&quot;;
</code></pre>
<p>这样会有很多问题，比如有可能在IDEA中直接运行与打成jar包运行的结果不一致，路径读取不了，另外还可能会出现平台问题，众所周知Linux的路径分隔符与Windows的不一致。所以，对于资源文件，统一使用如下方式获取：</p>
<pre><code class="language-java">String path = getClass().getResource(&quot;/image/xx.png&quot;);
</code></pre>
<p>其中<code>image</code>直接位于<code>resources</code>资源文件夹下。其他类似，也就是说这里的<code>/</code>代表在<code>resources</code>下。</p>
<h2 id="82-https">8.2 HTTPS</h2>
<p>默认没有提供HTTPS，证书文件没有摆上去，走的是本地8080端口。</p>
<p>如果需要自定义HTTPS请修改前端部分的</p>
<ul>
<li><code>com.test.network.OKHTTP</code></li>
<li><code>resources/key/pem.pem</code></li>
</ul>
<p>同时后端需要修改Tomcat的<code>server.xml</code>。</p>
<p>有关OkHttp使用HTTPS的文章有不少，但是大部分都是仅仅写了前端如何配置HTTPS的，没有提到后端如何部署，可以参考笔者的<a href="https://blog.csdn.net/qq_27525611/article/details/105184098">这篇文章</a>，包含Tomcat的配置教程。</p>
<h2 id="83-配置文件加密">8.3 配置文件加密</h2>
<p>配置文件使用了jasypt-spring-boot开源组件进行加密，设置口令可以有三种方式设置：</p>
<ul>
<li>命令行参数</li>
<li>应用环境变量</li>
<li>系统环境变量</li>
</ul>
<p>目前最新的版本为3.0.3（2020.05.31更新3.0.3 ，笔者之前使用3.0.2的版本进行加密时本地测试没问题，但是部署到服务器上老是提示找不到口令，无奈只好使用旧一点的2.x版本，但是新版本出了后笔者尝试过部署到本地Tomcat没有问题但是没有部署到服务器上），建议使用最新版本进行部署：</p>
<figure data-type="image" tabindex="61"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3ea240a04d?w=755&amp;h=300&amp;f=png&amp;s=42982" alt="在这里插入图片描述" loading="lazy"></figure>
<p>毕竟前后跨度挺大的，虽然说这是小的bug修复，但是还是建议试试，估计不会有3.0.2的问题了。</p>
<p>另外对于含有中文的字段记得进行编码转换：</p>
<pre><code class="language-java">str = new String(str.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);)
</code></pre>
<p>另外笔者已写好了测试文件，直接首先替换掉配置文件原来的密文，填上明文重新加密：<br>
<img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3eb2ed72d6?w=1746&amp;h=551&amp;f=png&amp;s=1313329" alt="在这里插入图片描述" loading="lazy"></p>
<p>注意如果没有在配置文件中设置<code>jasypt.encryptor.password</code>的话可以在运行配置中设置VM Options（建议不要把口令直接写在配置文件中，当然这个默认是使用PBE加密，非对称加密可以使用<code>jasypt.encryptor.private-key-string</code>或<code>jasypt.encryptor.private-key-location</code>）：</p>
<figure data-type="image" tabindex="62"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3eb47d60b2?w=1162&amp;h=798&amp;f=png&amp;s=249038" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="84-键盘事件">8.4 键盘事件</h2>
<p>添加键盘事件可以使用如下代码：</p>
<pre><code class="language-java">scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), ()-&gt;{xxx});
//getAccelerators返回ObservableMap&lt;KeyCombination, Runnable&gt;
</code></pre>
<p>响应之前需要让parent获取焦点：</p>
<pre><code class="language-java">parent.requestFocus();
</code></pre>
<h2 id="85-数据库">8.5 数据库</h2>
<p>默认使用的数据库名为<code>app_test</code>，用户名<code>test_user</code>，密码<code>test_password</code>，<code>resources</code>下有一个<code>init.sql</code>，直接使用MySQL导入即可。</p>
<figure data-type="image" tabindex="63"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3ebe65af42?w=1222&amp;h=240&amp;f=png&amp;s=356593" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="86-验证码">8.6 验证码</h2>
<p>默认没有自带验证码功能，由于涉及隐私问题故没有开放。</p>
<p>如果像笔者一样使用腾讯云的短信API，直接修改配置文件中的对应属性即可，建议加密。</p>
<p>如果使用其他API请自行对接，前端需要修改的部分包括：</p>
<ul>
<li><code>com.test.network.OKHTTP</code></li>
<li><code>com.test.network.request.SendSmsRequest</code></li>
<li><code>com.test.network.requestBuilder.SendSmsRequestBuilder</code></li>
<li><code>com.test.controller.start.RetrievePasswordController</code></li>
</ul>
<p>后端需要修改的部分：</p>
<ul>
<li><code>com.test.controller.SmsController</code></li>
</ul>
<p>需要的话可以参考笔者的腾讯云短信API使用或者自行搜索其他短信验证API。一些写在配置文件中的API需要的密钥等信息强烈</p>
<h1 id="9-源码">9 源码</h1>
<p>前后端完整代码以及打包程序：</p>
<ul>
<li><a href="https://github.com/2293736867/ASmallSalaryManagementSystem">github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/ASmallSalaryManagementSystem">码云</a></li>
</ul>
<h1 id="10-参考">10 参考</h1>
<p>1、<a href="https://blog.csdn.net/yangguosb/article/details/80619481">CSDN-maven-shade-plugin介绍及使用</a></p>
<p>2、<a href="https://blog.csdn.net/qq_32736999/article/details/93395246">CSDN-Maven3种打包方式之一maven-assembly-plugin的使用</a></p>
<p>3、<a href="https://zhuanlan.zhihu.com/p/82540739">知乎-制作包含Java 11和JavaFX的JRE</a></p>
<p>4、<a href="https://blog.csdn.net/zzzgd_666/article/details/80756430">CSDN-使用exe4j将java文件打成exe文件运行详细教程</a></p>
<p>5、<a href="https://github.com/ulisesbocchio/jasypt-spring-boot/issues/218">Github-jasypt-spring-boot issue</a></p>
<p>6、<a href="https://www.w3cschool.cn/java/javafx-line.html">w3cschool-JavaFX</a></p>
<p>7、<a href="https://www.jianshu.com/p/045f95c008a0">简书-Linux Tomcat+Openssl单向/双向认证</a></p>
<p>如果觉得文章好看，欢迎点赞。</p>
<p>同时欢迎关注微信公众号：氷泠之路。</p>
<figure data-type="image" tabindex="64"><img src="https://user-gold-cdn.xitu.io/2020/6/15/172b6e3eb723354b?w=344&amp;h=344&amp;f=jpeg&amp;s=9569" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JFX11+Maven+IDEA 发布跨平台应用的完美解决方案]]></title>
        <id>https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/</id>
        <link href="https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/">
        </link>
        <updated>2020-06-02T21:41:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>前几天写了两篇关于JFX+IDEA打包跨平台应用的文章，<a href="https://blog.csdn.net/qq_27525611/article/details/106444423">这篇</a>是使用IDEA自带功能打包的，<a href="https://blog.csdn.net/qq_27525611/article/details/106433723">这篇</a>是使用Maven进行打包的，但是效果不太满意，因为从JDK9开始实现模块化，同时JFX部分从JDK中独立出来了，也就是说需要默认JDK不再自带JFX。这意味着外部依赖需要手动处理module-info.java，这是一件非常麻烦的事情。</p>
<h2 id="11-不使用maven">1.1 不使用Maven</h2>
<p>其实不使用Maven也能打包发布跨平台JFX应用，但是没有使用Maven的话，虽然打包出来能直接运行无需jre环境，但是，管理依赖确实麻烦，在使用jlink打包一些外部的jar时，对于一些比较简单的jar还是比较舒服的，参照<a href="https://blog.csdn.net/weixin_44326589/article/details/86680972">这里</a>：<br>
<img src="https://img-blog.csdnimg.cn/2020060121462236.png" alt="在这里插入图片描述" loading="lazy"><br>
首先去下载jar，接着生成module-info.java，然后使用jdeps检查依赖，添加对应的jar到路径中，编译生成module-info.java接着更新原来的jar即可。看起来简单，但是笔者碰到了okhttp这种jar，依赖简直环环相扣导致笔者放弃了这种方式。</p>
<h2 id="12-使用maven">1.2 使用Maven</h2>
<p>使用Maven可以完美解决依赖问题，多亏与强大的pom.xml，几行&lt;dependency&gt;就可以解决依赖问题，但是，还是需要手动处理module-info.java，而且IDEA文档明确表明仅支持Java8的打包为jar：<br>
<img src="https://img-blog.csdnimg.cn/20200601220006821.png" alt="在这里插入图片描述" loading="lazy"><br>
因此，这篇文章采取一种最简单的方式利用Maven打包发布JFX11应用。</p>
<h1 id="2-新建maven工程">2 新建Maven工程</h1>
<p><img src="https://img-blog.csdnimg.cn/20200601220303299.png" alt="在这里插入图片描述" loading="lazy"><br>
默认即可，问题不大。<br>
<img src="https://img-blog.csdnimg.cn/20200601220333213.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-添加依赖">3 添加依赖</h1>
<pre><code class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>需要再哪个平台在classifier中指定即可。这里是linux与win。mac的话直接“mac”。<br>
同时指定编码与JDK：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
<p>否则会如此报错：<br>
<img src="https://img-blog.csdnimg.cn/20200601221410548.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-新建main">4 新建Main</h1>
<p>新建一个包再新建Main.java，Launcher.java以及Main.fxml：<br>
<img src="https://img-blog.csdnimg.cn/20200601221808669.png" alt="在这里插入图片描述" loading="lazy"><br>
Main.java：</p>
<pre><code class="language-java">package com.test;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {
    public void start(Stage stage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(&quot;/Main.fxml&quot;));
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle(&quot;Hello World&quot;);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>
<p>Launcher.java：</p>
<pre><code class="language-java">package com.test;

public class Launcher {
    public static void main(String[] args) {
        Main.main(args);
    }
}
</code></pre>
<p>Main.fxml：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;?import javafx.scene.control.*?&gt;
&lt;?import javafx.scene.layout.*?&gt;
&lt;?import javafx.scene.text.*?&gt;


&lt;AnchorPane prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/10.0.2-internal&quot;
            xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.test.Main&quot;&gt;
   &lt;Label layoutX=&quot;228.0&quot; layoutY=&quot;185.0&quot; text=&quot;Hello World&quot;&gt;
      &lt;font&gt;
         &lt;Font size=&quot;25.0&quot;/&gt;
      &lt;/font&gt;
   &lt;/Label&gt;
&lt;/AnchorPane&gt;
</code></pre>
<p>注意getResource中的fxml路径，Main.fxml文件放在resources下，直接通过根路径读取：</p>
<pre><code class="language-java">getResource(&quot;/Main.fxml&quot;);
</code></pre>
<h1 id="5-添加运行配置">5 添加运行配置</h1>
<p>此时应该是没有运行配置的状态，点击Add Configuration：<br>
<img src="https://img-blog.csdnimg.cn/20200601222437737.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Application：<br>
<img src="https://img-blog.csdnimg.cn/2020060122253724.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Launcher类作为Main class：<br>
<img src="https://img-blog.csdnimg.cn/20200601222831910.png" alt="在这里插入图片描述" loading="lazy"><br>
这时候run就没问题了：<br>
<img src="https://img-blog.csdnimg.cn/2020060122292722.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-使用默认maven打包">6 使用默认Maven打包</h1>
<p>虽然现在可以run了，但是，如果直接使用默认的Maven打包的话：<br>
<img src="https://img-blog.csdnimg.cn/20200601223021660.png" alt="在这里插入图片描述" loading="lazy"><br>
在target下有一个jar，直接右键运行：<br>
<img src="https://img-blog.csdnimg.cn/20200601223318755.png" alt="在这里插入图片描述" loading="lazy"><br>
会提示no main manifest attribute：<br>
<img src="https://img-blog.csdnimg.cn/20200601223400146.png" alt="在这里插入图片描述" loading="lazy"><br>
也就是找不到Manifest中入口类。<br>
jar实际上是一个class的压缩包，与zip的区别是jar包含了一个MANIFEST.MF，MANIFEST.MF在META-INF下，一个示例文件如下：<br>
<img src="https://img-blog.csdnimg.cn/20200601224154485.png" alt="在这里插入图片描述" loading="lazy"><br>
有点类似与键值对的格式，MANIFEST.MF包含了jar文件的内容描述，并在运行时向JVM提供应用程序信息。注意该文件有严格的格式限制，比如第一行不能为空，行与行之间不能存在空行。<br>
一个暴力的解决办法是直接解压jar并修改里面的MANIFEST.MF，添加</p>
<pre><code class="language-bash">Main-Class: com.test.Launcher
</code></pre>
<p>但是这样会报找不到Application类的异常：<br>
<img src="https://img-blog.csdnimg.cn/20200602015847355.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-添加新的打包插件">7 添加新的打包插件</h1>
<p>理论上来说，只需要jar包内的相同目录下提供了javafx的jar或者class文件就不会抛出异常了，但是，如果依赖很多需要一个一个添加，这是一个痛苦的过程。<br>
所以，为了优雅地解决这个问题，引入一个叫maven-shade-plugin的插件即可：</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;shade&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;transformers&gt;
                            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
                                &lt;mainClass&gt;com.test.Launcher&lt;/mainClass&gt;
                            &lt;/transformer&gt;
                        &lt;/transformers&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>最新版本请到<a href="https://github.com/apache/maven-shade-plugin">官方github</a>查看，使用时只需要修改：</p>
<pre><code class="language-xml">&lt;mainClass&gt;xxx.xxx.xxx&lt;/mainClass&gt;
</code></pre>
<p>修改为程序入口类。</p>
<h1 id="8-打包">8 打包</h1>
<p>此时再从右侧栏打包选中Maven，package即可：<br>
<img src="https://img-blog.csdnimg.cn/2020060202062726.png" alt="在这里插入图片描述" loading="lazy"><br>
但是会有警告：<br>
<img src="https://img-blog.csdnimg.cn/20200602020908608.png" alt="在这里插入图片描述" loading="lazy"><br>
因为一些class文件重复了，但是也提到了通常来说这是没有危害的并且可以跳过警告，或者修改pom.xml去手动排除某些依赖。</p>
<h1 id="9-运行">9 运行</h1>
<p>直接在IDEA中右键运行或者-jar运行，可以看到没有异常了：<br>
<img src="https://img-blog.csdnimg.cn/20200602021739342.png" alt="在这里插入图片描述" loading="lazy"><br>
相比起原来自带的Maven打包插件，主要是多了javafx的一些class以及对应平台所需要的一些动态库文件等，比如win上的.dll与linux上的.so文件。<br>
<img src="https://img-blog.csdnimg.cn/20200602022014735.png" alt="在这里插入图片描述" loading="lazy"><br>
这样一个跨平台的JFX jar包就制作好了，只需</p>
<pre><code class="language-bash">java -jar
</code></pre>
<p>即可跨平台运行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个开源的跨平台音乐播放与音乐下载器]]></title>
        <id>https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/</id>
        <link href="https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/">
        </link>
        <updated>2020-06-02T21:40:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="跨平台的音乐播放器">跨平台的音乐播放器</h1>
<p>目前国内的linux平台上的音乐播放器不多，除了网易云比较多人使用的。<br>
当然<a href="http://listen1.github.io/listen1/">Listen1</a>也是一个不错的选择，真正的跨平台，包括Android/Mac/Win/Linux以及Chrome插件，目前尚在维护：<br>
<img src="https://img-blog.csdnimg.cn/20200601210615418.png" alt="在这里插入图片描述" loading="lazy"><br>
Listen1其实非常不错，支持歌单功能，可以方便的播放，但美中不足的是没有下载功能。<br>
因此，这里推荐一个带下载以及播放功能的开源音乐软件：<a href="https://github.com/lyswhut/lx-music-desktop">洛雪音乐助手桌面版</a>。<br>
一个基于 Electron + Vue 开发的音乐软件。<br>
<img src="https://img-blog.csdnimg.cn/20200601211058633.png" alt="在这里插入图片描述" loading="lazy"><br>
UI：<br>
<img src="https://img-blog.csdnimg.cn/20200601211200149.png" alt="在这里插入图片描述" loading="lazy"><br>
推荐歌单列表：<br>
<img src="https://img-blog.csdnimg.cn/20200601211239373.png" alt="在这里插入图片描述" loading="lazy"><br>
排行榜：<br>
<img src="https://img-blog.csdnimg.cn/20200601211320388.png" alt="在这里插入图片描述" loading="lazy"><br>
下载功能：<br>
<img src="https://img-blog.csdnimg.cn/20200601211354966.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200601211433744.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFX获取屏幕尺寸]]></title>
        <id>https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/</id>
        <link href="https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/">
        </link>
        <updated>2020-06-02T21:40:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-awt">1 awt</h1>
<pre><code class="language-java">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
double width = screenSize.getWidth();
double height = screenSize.getHeight();
</code></pre>
<h1 id="2-javafx">2 javafx</h1>
<pre><code class="language-java">Rectangle2D screenRectangle = Screen.getPrimary().getBounds();
double width = screenRectangle.getWidth();
double height = screenRectangle.getHeight();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OkHttp:NoClassDefFoundError]]></title>
        <id>https://2293736867.github.io/post/okhttpnoclassdeffounderror/</id>
        <link href="https://2293736867.github.io/post/okhttpnoclassdeffounderror/">
        </link>
        <updated>2020-06-02T21:39:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>使用OkHttp时报错：</p>
<pre><code class="language-bash">Caused by: java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at okhttp3@4.7.2/okhttp3.FormBody$Builder.add(FormBody.kt)
</code></pre>
<h1 id="2-原因">2 原因</h1>
<p>由于OkHttp依赖于okio，目前OkHttp最新的版本为4.7.2，使用Maven/Gradle导入的话不会出现该问题，原因应该是只是单纯把OkHttp的jar导入，还需要把okio一并导入，但是需要知道OkHttp对应的okio版本，可以通过Maven导入查看，比如4.7.2对应的是2.6.0。<br>
<img src="https://img-blog.csdnimg.cn/20200531113523502.png" alt="在这里插入图片描述" loading="lazy"><br>
如果已经添加了okio则可以跳过，另外还需要添加kotlin-stdlib库，使用最新版本即可，目前最新版本为1.3.72。<br>
下载链接<a href="https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-stdlib">戳这里</a>。</p>
<h1 id="3-解决方案">3 解决方案</h1>
<p>把对应版本的okio以及kotlin-stdlib添加到依赖库即可。</p>
]]></content>
    </entry>
</feed>