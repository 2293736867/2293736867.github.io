<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-05-15T12:10:19.118Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（三）：类加载]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-san-lei-jia-zai/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-san-lei-jia-zai/">
        </link>
        <updated>2021-05-15T12:09:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第九、十、十一章</li>
</ul>
<p>本文这三章的笔记整理。</p>
<h1 id="2-类加载简介">2 类加载简介</h1>
<p>类加载的过程可以简单分为三个阶段：</p>
<ul>
<li>加载阶段：主要负责查找并且加载类的二进制数据文件</li>
<li>连接阶段：可以细分为验证、准备、解析三个阶段，验证就是确保类文件的正确性，准备就是为类的静态变量分配内存，并且为其初始化默认值，解析就是把类中的符号引用转换为直接引用</li>
<li>初始化阶段：为类的静态变量赋予正确的初始值</li>
</ul>
<h1 id="3-主动使用与被动使用">3 主动使用与被动使用</h1>
<p><code>JVM</code>规范规定了每个类或接口在首次主动使用的时候都需要进行初始化，规定了以下六种主动使用类的场景：</p>
<ul>
<li>通过<code>new</code>关键字会导致类的初始化</li>
<li>访问类的静态变量</li>
<li>访问类的静态方法</li>
<li>对某个类进行反射操作</li>
<li>初始化子类会导致父类初始化</li>
<li>启动类（就是包含<code>main()</code>的类）也会初始化</li>
</ul>
<p>除了以上六种情况外，其余的都叫被动使用，不会导致类的加载和初始化，比如引用类的静态常量不会导致类的初始化。</p>
<h1 id="4-类加载详解">4 类加载详解</h1>
<p>前面也说了类加载可以简单分为三个阶段：</p>
<ul>
<li>加载阶段</li>
<li>连接阶段</li>
<li>初始化阶段</li>
</ul>
<p>下面先来看一下加载阶段。</p>
<h2 id="41-加载阶段">4.1 加载阶段</h2>
<p>加载阶段就是将<code>class</code>文件中的二进制数据读取到内存之中，然后将该字节流代表的静态存储结构转换为方法区中运行时数据结构，并且在堆中生成一个该类的<code>java.lang.Class</code>对象，作为访问方法区数据结构的入口。</p>
<p>类加载的最终产物就是堆内存中的<code>class</code>对象，<code>JVM</code>规范中指出类加载是通过一个全限定名去获取二进制数据流，来源包括：</p>
<ul>
<li><code>class</code>文件：这是最常见的格式，就是加载<code>javac</code>编译后的字节码文件</li>
<li>运行时动态生成：比如<code>ASM</code>可以动态生成，或者可以通过动态代理<code>java.lang.Proxy</code>生成等</li>
<li>通过网络获取：比如<code>RMI</code></li>
<li>读取压缩文件：比如<code>JAR</code>、<code>WAR</code>包</li>
<li>从数据库读取：比如读取<code>MySQL</code>中的<code>BLOB</code>字段类型的数据</li>
<li>运行时生成<code>class</code>文件并且动态加载：比如<code>Thrift</code>、<code>Avro</code>等序列化框架，将某个<code>schema</code>生成若干个<code>class</code>文件并进行加载</li>
</ul>
<p>类加载阶段结束后，<code>JVM</code>会将这些二进制字节流按照<code>JVM</code>定义的格式存放在方法区中，形成特定的数据结构后再在堆内存中实例化一个<code>java.lang.Class</code>对象。</p>
<h2 id="42-连接阶段">4.2 连接阶段</h2>
<p>该阶段可以分为三个小阶段：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p>需要注意的是这三个小阶段其实不是顺序进行的，而是交叉着进行的，也就是解析的时候其实也会有验证的过程。</p>
<h3 id="421-验证">4.2.1 验证</h3>
<p>验证是为了确保字节流所包含的内容符合<code>JVM</code>规范，并且不会出现危害<code>JVM</code>自身安全的代码，当字节流信息不符合要求的时候，会抛出<code>VerifyError</code>这样的异常或其子异常，验证的信息包括：</p>
<ul>
<li>文件格式</li>
<li>元数据</li>
<li>字节码</li>
<li>符号引用</li>
</ul>
<h4 id="4211-验证文件格式">4.2.1.1 验证文件格式</h4>
<p>包括：</p>
<ul>
<li>魔数（<code>0xCAFEBABE</code>）</li>
<li>主次版本号</li>
<li>是否存在残缺或附加信息</li>
<li>常量池常量类型是否支持</li>
<li>常量池引用是否指向不存在常量或不支持类型常量</li>
<li>其他</li>
</ul>
<h4 id="4212-验证元数据">4.2.1.2 验证元数据</h4>
<p>元数据验证其实是进行语义分析的过程，语义分析是为了确保字节流符合<code>JVM</code>规范要求，包括：</p>
<ul>
<li>检查某个类是否存在父类，是否继承某个接口，这些父类或接口是否合法，或是否存在</li>
<li>检查是否继承了<code>final</code>的类</li>
<li>检查抽象类，检查是否实现了父类的抽象方法或接口方法</li>
<li>检查重载，比如相同的方法名称、相同的参数但是返回类型不同，这是不允许的</li>
</ul>
<h4 id="4213-验证字节码">4.2.1.3 验证字节码</h4>
<p>字节码验证主要是验证程序的控制流程，包括：</p>
<ul>
<li>保证当前线程在程序计数器中的指令不会跳转到不合法的字节码指令中去</li>
<li>保证类型的转换是合法的</li>
<li>保证任意时刻虚拟机栈中的操作栈类型与指令代码都能正确被执行</li>
<li>其他验证</li>
</ul>
<h4 id="4214-验证符号引用">4.2.1.4 验证符号引用</h4>
<p>验证符号引用转换为直接引用的合法性，保证解析动作的顺利执行，包括：</p>
<ul>
<li>通过符号引用描述的字符串全限定名称是否能够顺利找到相关的类</li>
<li>符号引用中的类、字段、方法是否对当前类可见</li>
<li>其他</li>
</ul>
<h3 id="422-准备">4.2.2 准备</h3>
<p>经过验证后，就开始了准备阶段，这阶段比较简单，就是对对象的静态变量分配内存并且设置初始值，类变量的内存会被分配到方法区中。设置初始值就是为相应的类变量给定一个相关类型在没有被设置时的默认值，比如<code>Int</code>的初始值为0，引用的初始值为<code>null</code>。</p>
<h3 id="423-解析">4.2.3 解析</h3>
<p>解析就是在常量池中寻找类、字段、接口和方法的符号引用，并且将这些符号引用替换成直接引用的过程。解析主要针对类接口、字段、类方法和接口方法进行的，包括：</p>
<ul>
<li>类接口解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ul>
<h2 id="43-初始化阶段">4.3 初始化阶段</h2>
<p>初始化阶段主要就是执行<code>&lt;clinit&gt;</code>方法的过程，该方法是编译阶段生成的，也就是说包含在字节码文件中，该方法包含了所有类变量的赋值动作和静态语句块的执行代码。另一方面，<code>&lt;clinit&gt;</code>与构造方法不同，不需要显式调用父类构造器，虚拟机会保证父类的<code>&lt;clinit&gt;</code>方法最先执行。</p>
<p>还需要注意的是<code>&lt;clinit&gt;</code>只能被虚拟机执行，虚拟机还会保证多线程下的安全性，因此，如果在静态代码块中如果包含了加载其他类的操作可能会引起死锁，例子可以看<a href="https://blog.csdn.net/qq_27525611/article/details/116362061#t8">这里</a>。</p>
<h1 id="5-类加载器">5 类加载器</h1>
<h2 id="51-jvm中的三类核心类加载器">5.1 <code>JVM</code>中的三类核心类加载器</h2>
<p><code>JVM</code>中有三类核心类加载器，分别是：</p>
<ul>
<li>启动类加载器：启动类加载器是最顶层的类加载器，没有父加载器，由<code>C++</code>编写，负责<code>JVM</code>核心类库的加载，比如加载整个<code>java.lang</code>包中的类</li>
<li>扩展类加载器：扩展类加载器的父加载器是启动类加载器，主要加载<code>jre/lib/ext</code>子目录下的类库，纯<code>Java</code>实现，是<code>URLClassLoader</code>的子类</li>
<li>应用类加载器：也叫系统类加载器，负责加载<code>classpath</code>下的类库，应用类加载器的父加载器为扩展类加载器，同时它也是自定义类加载器的默认父加载器</li>
</ul>
<h3 id="52-双亲委派机制">5.2 双亲委派机制</h3>
<p>一个类加载器加载一个类的时候，并不会尝试直接加载该类，而是先交给父加载器尝试加载，一直到顶层的父加载器（启动类加载器），如果父加载器加载失败，则会自己尝试加载，图示如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210515194415207.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-线程上下文类加载器">6 线程上下文类加载器</h1>
<p><code>JDK</code>中提供了很多<code>SPI</code>（<code>Service Provider Interface</code>），比如<code>JDBC</code>等，<code>JDBC</code>只规定了这些接口之间的逻辑关系，但不提供具体的实现，换句话说，<code>JDBC</code>完全透明了应用程序和第三方厂商数据库驱动的具体实现，应用程序只需要面向接口编程即可。但问题是：</p>
<ul>
<li><code>java.lang.sql</code>中的所有接口都是由<code>JDK</code>提供的，加载这些接口的类加载器是启动类加载器</li>
<li>第三方厂商的类库驱动由系统类加载器加载</li>
</ul>
<p>由于双亲委派机制，<code>Connections</code>、<code>Statement</code>等都是由启动类加载器加载，而第三方<code>JDBC</code>驱动包中的实现不会被加载。解决这个问题的关键，就是使用了线程上下文类加载器打破了双亲委派机制。</p>
<p>比如<code>MySQL</code>驱动的加载过程，就是通过线程上下文类加载器加载的，</p>
<pre><code class="language-java">private static Connection getConnection(String url, Properties info, Class&lt;?&gt; caller) throws SQLException {
        //...
        if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
            callerCL = Thread.currentThread().getContextClassLoader();
        }
		while(true) {
			//...
			if (isDriverAllowed(aDriver.driver, callerCL)) {
			}
		}
		//...
}
private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {
	//...
    try {
        aClass = Class.forName(driver.getClass().getName(), true, classLoader);
    } catch (Exception var5) {
        result = false;
    }
    //...
    return result;
}
</code></pre>
<p>通过线程上下文类加载器，就变成了启动类加载器去委托子类加载器去加载实现的方式，也就是<code>JDK</code>自己亲自打破了双亲委派机制这种方式，这种加载方式几乎涉及所有的<code>SPI</code>加载，包括<code>JAXB</code>、<code>JCE</code>、<code>JBI</code>等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第335期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-335-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-335-qi/">
        </link>
        <updated>2021-05-14T16:50:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>生活不会放弃你，但也不会放过你。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>正护月云轻，嫩冰犹薄。<br>
——辛弃疾《瑞鹤仙·赋梅》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>从一开始，我就不那么喜欢你。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621011032287.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>简单题直接判断各个字符了：</p>
<pre><code class="language-java">public class Solution {
    public int romanToInt(String s) {
        char [] ch = s.toCharArray();
        int sum = 0;
        for (int i = 0; i &lt; ch.length; i++) {
            if(ch[i] == 'M'){
                sum += 1000;
            }else if(ch[i] == 'D'){
                sum += 500;
            }else if(ch[i] == 'C'){
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'D') {
                        sum += 300;
                        ++i;
                    }else if(ch[i+1] == 'M'){
                        sum += 800;
                        ++i;
                    }
                }
                sum += 100;
            }else if(ch[i] == 'L'){
                sum += 50;
            }else if(ch[i] == 'X'){
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'L') {
                        sum += 30;
                        ++i;
                    }else if(ch[i+1] == 'C'){
                        sum += 80;
                        ++i;
                    }
                }
                sum += 10;
            }else if(ch[i] == 'V'){
                sum += 5;
            }else{
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'V') {
                        sum += 3;
                        ++i;
                    }else if(ch[i+1] == 'X'){
                        sum += 8;
                        ++i;
                    }
                }
                sum += 1;
            }
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621011059036.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第334期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-334-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-334-qi/">
        </link>
        <updated>2021-05-13T16:14:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>转角一般不会遇到爱，只会遇到乞丐。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>何当凯旋宴将士，三更雪压飞狐城！<br>
——陆游《长歌行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>萤火之光看起来比平常要更耀眼是错觉吗？今宵会成为永夜的吧。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620922670877.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接暴力：</p>
<pre><code class="language-java">import java.util.LinkedList;
import java.util.List;

public class Solution {
    public String intToRoman(int num) {
        StringBuilder builder = new StringBuilder();
        while (num &gt;= 1000){
            builder.append('M');
            num -= 1000;
        }
        if(num &gt;= 900){
            builder.append(&quot;CM&quot;);
            num -= 900;
        }
        if(num &gt;= 500){
            builder.append('D');
            num -= 500;
        }
        if(num &gt;= 400){
            builder.append(&quot;CD&quot;);
            num -= 400;
        }
        while(num &gt;= 100){
            builder.append('C');
            num -= 100;
        }
        if(num &gt;= 90){
            builder.append(&quot;XC&quot;);
            num -= 90;
        }
        if(num &gt;= 50){
            builder.append('L');
            num -= 50;
        }
        if(num &gt;= 40){
            builder.append(&quot;XL&quot;);
            num -= 40;
        }
        while (num &gt;= 10){
            builder.append('X');
            num -= 10;
        }
        if(num &gt;= 9){
            builder.append(&quot;IX&quot;);
            num -= 9;
        }
        if(num &gt;= 5){
            builder.append(&quot;V&quot;);
            num -= 5;
        }
        if(num &gt;= 4){
            builder.append(&quot;IV&quot;);
            num -= 4;
        }
        while (num &gt;= 1){
            builder.append('I');
            num -= 1;
        }
        return builder.toString();
    }
}
</code></pre>
<p>虽然不太优雅，快就行了：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620922731037.png" alt="" loading="lazy"></figure>
<h1 id="双100">双100</h1>
<p>记录一下今天的双100：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620971589553.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[] row = new int[9];
        int[] col = new int[9];
        int[] block = new int[9];

        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                if (board[i][j] != '.'){
                    int t = board[i][j] - 48;
                    if((col[j] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        col[j] |= 1 &lt;&lt; t;
                    }

                    if((row[i] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        row[i] |= 1 &lt;&lt; t;
                    }

                    int blockIndex = (i / 3) * 3 + j / 3;
                    if((block[blockIndex] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        block[blockIndex] |= 1 &lt;&lt; t;
                    }
                }
            }
        }
        return true;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1620971595878.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第333期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-333-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-333-qi/">
        </link>
        <updated>2021-05-12T16:45:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>冬天就是好，穷的时候，还有西北风喝。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>迎得一钩月到，送得三更月去，莺燕不相猜。<br>
——张惠言《水调歌头（五首选三）》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>愿时光能缓，愿故人不散！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620838100076.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>二维dp升级到的一维dp（其实是题解的答案，逃）：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numWays(int steps, int arrLen) {
        int maxColumn = Math.min(arrLen-1,steps);
        int [] dp = new int[maxColumn+1];
        dp[0] = 1;
        for (int i = 1; i &lt;= steps; i++) {
            int [] dpNext = new int[maxColumn+1];
            for (int j = 0; j &lt;= maxColumn; j++) {
                dpNext[j] = dp[j];
                if(j - 1 &gt;= 0){
                    dpNext[j] = (dpNext[j] + dp[j-1]) % MOD;
                }
                if(j + 1 &lt;= maxColumn){
                    dpNext[j] = (dpNext[j] + dp[j+1]) % MOD;
                }
            }
            dp = dpNext;
        }
        return dp[0];
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620838143565.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第332期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-332-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-332-qi/">
        </link>
        <updated>2021-05-12T03:15:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>56个民族，55个加分。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>抛尽榆钱，依然难买春光驻。<br>
——王鹏运《点绛唇·饯春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我觉得，我这辈子最灿烂的笑容，大概都奉献给我电脑屏幕了。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620789810031.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>第一次用的自以为很厉害的算法，三个前缀和数组加小区间优化：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int[] xorQueries(int[] arr, int[][] queries) {
        int n = arr.length;
        int m = queries.length;
        int [] result = new int [m];
        if(n &lt; 10){
            for(int i=0;i&lt;m;++i){
                int s1 = queries[i][0];
                int s2 = queries[i][1];
                int temp = arr[s1++];
                while(s1&lt;=s2){
                    temp ^= arr[s1++];
                }
                result[i] = temp;
            }
            return result;
        }
        int [] all = new int [n];
        int [] half1 = new int [n];
        int [] half2 = new int [n];

        all[0] = half1[0] = arr[0];
        half2[n/2] = arr[n/2];
        for(int i=1;i&lt;n;++i){
            if(i&lt;=n/2){
                half1[i] ^= half1[i-1] ^ arr[i];
            }else{
                half2[i] = half2[i-1] ^ arr[i];
            }
            all[i] = all[i-1] ^ arr[i];
        }
        for(int i=0;i&lt;m;++i){
            int s1 = queries[i][0];
            int s2 = queries[i][1];
            int temp;
            if(s2 - s1 &lt; 10){
                temp = arr[s1++];
                while(s1&lt;=s2){
                    temp ^= arr[s1++];
                }
            }else{
                if(s2 &lt;= n/2){
                    temp = half1[s2];
                    for(int j=0;j&lt;s1;++j){
                        temp ^= arr[j];
                    }
                }else if(s1 &gt; n/2){
                    temp = half2[s2];
                    for(int j=n/2;j&lt;s1;++j){
                        temp ^= arr[j];
                    }
                }else{
                    temp = all[s2];
                    for(int j=0;j&lt;s1;++j){
                        temp ^= arr[j];
                    }
                }
            }
            result[i] = temp;
        }
        return result;
    }
}
</code></pre>
<p>空间是好了，但时间烂的不想看：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620789428020.png" alt="" loading="lazy"></figure>
<p>看了题解才知道，这个才叫前缀和。。。。</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int[] xorQueries(int[] arr, int[][] queries) {
        int n = arr.length;
        int m = queries.length;
        int [] result = new int [m];
        int [] all = new int [n];

        all[0] = arr[0];
        for(int i=1;i&lt;n;++i){
            all[i] = all[i-1] ^ arr[i];
        }
        for(int i=0;i&lt;m;++i){
            if(queries[i][0] == 0){
                result[i] = all[queries[i][1]];
            }else{
                result[i] = all[queries[i][0]-1] ^ all[queries[i][1]];
            }
        }
        return result;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620789768949.png" alt="" loading="lazy"></figure>
<p>真正的<code>O(1)</code>求异或。</p>
<p><s>完犊子。。。</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第331期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-331-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-331-qi/">
        </link>
        <updated>2021-05-10T17:18:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>所有的故事都会有结局，只有生活跟你没完。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>诗随十里寻春路，愁在三更挂月村。<br>
——高启《咏梅九首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不会让你们碰那个人类一根手指的！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620667180065.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>通过“数学公式”确定了第一个，然后<code>O(n)</code>求剩下的就可以了：</p>
<pre><code class="language-java">public class Solution {
    public int[] decode(int[] encoded) {
        int n = encoded.length + 1;
        int [] r = new int[n];
        int all = 0;
        int temp;
        for (int i = 1; i &lt;= n; i++) {
            all ^= i;
            temp = (i&lt;&lt;1) - 1;
            if(temp &lt; n-1){
                all ^= encoded[temp];
            }
        }
        r[0] = all;

        for (int i = 0; i &lt; n-1; i++) {
            all ^= encoded[i];
            r[i+1] = all;
        }
        return r;
    }
}
</code></pre>
<p>不过很搞心态的是减少了一个<code>O(n)</code>循环居然还死活上不了2ms：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620667102785.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（二）：线程安全与ThreadGroup]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-er-xian-cheng-an-quan-yu-threadgroup/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-er-xian-cheng-an-quan-yu-threadgroup/">
        </link>
        <updated>2021-05-10T12:49:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第四、六章</li>
</ul>
<p>本文是两章的笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要讲述了<code>synchronized</code>以及<code>ThreadGroup</code>的基本用法。</p>
<h1 id="3-synchronized">3 <code>synchronized</code></h1>
<h2 id="31-简介">3.1 简介</h2>
<p><code>synchronized</code>可以防止线程干扰和内存一致性错误，具体表现如下：</p>
<ul>
<li><code>synchronized</code>提供了一种锁机制，能够确保共享变量的互斥访问，从而防止数据不一致的问题</li>
<li><code>synchronized</code>包括<code>monitor enter</code>和<code>monitor exit</code>两个<code>JVM</code>指令，能保证在任何时候任何线程执行到<code>monitor enter</code>成功之前都必须从主存获取数据，而不是从缓存中，在<code>monitor exit</code>运行成功之后，共享变量被更新后的值必须刷入主内存而不是仅仅在缓存中</li>
<li><code>synchronized</code>指令严格遵循<code>Happens-Beofre</code>规则，一个<code>monitor exit</code>指令之前必定要有一个<code>monitor enter</code></li>
</ul>
<h2 id="32-基本用法">3.2 基本用法</h2>
<p><code>synchronized</code>的基本用法可以用于对代码块或方法进行修饰，比如：</p>
<pre><code class="language-java">private final Object MUTEX = new Object();
    
public void sync1(){
    synchronized (MUTEX){
    }
}

public synchronized void sync2(){
}
</code></pre>
<h2 id="33-字节码简单分析">3.3 字节码简单分析</h2>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public class Main {
    private static final Object MUTEX = new Object();

    public static void main(String[] args) throws InterruptedException {
        final Main m = new Main();
        for (int i = 0; i &lt; 5; i++) {
            new Thread(m::access).start();
        }
    }

    public void access(){
        synchronized (MUTEX){
            try{
                TimeUnit.SECONDS.sleep(20);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>编译后查看字节码：</p>
<pre><code class="language-bash">javap -v -c -s -l Main.class
</code></pre>
<p><code>access()</code>字节码截取如下：</p>
<pre><code class="language-cpp">stack=3, locals=4, args_size=1
 0: getstatic     #9                  // Field MUTEX:Ljava/lang/Object;  获取MUTEX
 3: dup
 4: astore_1
 5: monitorenter					  // 执行monitor enter指令
 6: getstatic     #10                 // Field java/util/concurrent/TimeUnit.SECONDS:Ljava/util/concurrent/TimeUnit;
 9: ldc2_w        #11                 // long 20l
12: invokevirtual #13                 // Method java/util/concurrent/TimeUnit.sleep:(J)V
15: goto          23				  // 正常退出，跳转到字节码偏移量23的地方
18: astore_2
19: aload_2
20: invokevirtual #15                 // Method java/lang/InterruptedException.printStackTrace:()V
23: aload_1
24: monitorexit						  // monitor exit指令
25: goto          33
28: astore_3
29: aload_1
30: monitorexit
31: aload_3
32: athrow
33: return
</code></pre>
<p>关于<code>monitorenter</code>与<code>monitorexit</code>说明如下：</p>
<ul>
<li><code>monitorenter</code>：每一个对象与一个<code>monitor</code>相对应，一个线程尝试获取与对象关联的<code>monitor</code>的时候，如果<code>monitor</code>的计数器为0，会获得之后立即对计数器加1，如果一个已经拥有<code>monitor</code>所有权的线程重入，将导致计数器再次累加，而如果其他线程尝试获取时，会一直阻塞直到<code>monitor</code>的计数器变为0，才能再次尝试获取对<code>monitor</code>的所有权</li>
<li><code>monitorexit</code>：释放对<code>monitor</code>的所有权，将<code>monitor</code>的计数器减1，如果计数器为0，意味着该线程不再拥有对<code>monitor</code>的所有权</li>
</ul>
<h2 id="34-注意事项">3.4 注意事项</h2>
<h3 id="341-非空对象">3.4.1 非空对象</h3>
<p>与<code>monitor</code>关联的对象不能为空：</p>
<pre><code class="language-java">private Object MUTEX = null;
private void sync(){
    synchronized (MUTEX){

    }
}
</code></pre>
<p>会直接抛出空指针异常。</p>
<h3 id="342-作用域不当">3.4.2 作用域不当</h3>
<p>由于<code>synchronized</code>关键字存在排它性，作用域越大，往往意味着效率越低，甚至丧失并发优势，比如：</p>
<pre><code class="language-java">private synchronized void sync(){
    method1();
    syncMethod();
    method2();
}
</code></pre>
<p>其中只有第二个方法是并发操作，那么可以修改为</p>
<pre><code class="language-java">private Object MUTEX = new Object();
private void sync(){
    method1();
    synchronized (MUTEX){
        syncMethod();
    }
    method2();
}
</code></pre>
<h3 id="343-使用不同的对象">3.4.3 使用不同的对象</h3>
<p>因为一个对象与一个<code>monitor</code>相关联，如果使用不同的对象，这样就失去了同步的意义，例子如下：</p>
<pre><code class="language-java">public class Main {
    public static class Task implements Runnable{
        private final Object MUTEX = new Object();

        @Override
        public void run(){
            synchronized (MUTEX){
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &lt; 20; i++) {
            new Thread(new Task()).start();
        }
    }
}
</code></pre>
<p>每一个线程争夺的<code>monitor</code>都是互相独立的，这样就失去了同步的意义，起不到互斥的作用。</p>
<h2 id="35-死锁">3.5 死锁</h2>
<p>另外，使用<code>synchronized</code>还需要注意的是有可能造成死锁的问题，先来看一下造成死锁可能的原因。</p>
<h3 id="351-死锁成因">3.5.1 死锁成因</h3>
<ul>
<li>交叉锁导致程序死锁：比如线程A持有R1的锁等待R2的锁，线程B持有R2的锁等待R1的锁</li>
<li>内存不足：比如两个线程T1和T2，T1已获取10MB内存，T2获取了15MB内存，T1和T2都需要获取30MB内存才能工作，但是剩余可用的内存为10MB，这样两个线程都在等待彼此释放内存资源</li>
<li>一问一答式的数据交换：服务器开启某个端口，等待客户端访问，客户端发送请求后，服务器因某些原因错过了客户端请求，导致客户端等待服务器回应，而服务器等待客户端发送请求</li>
<li>死循环引起的死锁：比较常见，使用<code>jstack</code>等工具看不到死锁，但是程序不工作，<code>CPU</code>占有率高，这种死锁也叫系统假死，难以排查和重现</li>
</ul>
<h3 id="352-例子">3.5.2 例子</h3>
<pre><code class="language-java">public class Main {
    private final Object MUTEX_READ = new Object();
    private final Object MUTEX_WRITE = new Object();

    public void read(){
        synchronized (MUTEX_READ){
            synchronized (MUTEX_WRITE){
            }
        }
    }

    public void write(){
        synchronized (MUTEX_WRITE){
            synchronized (MUTEX_READ){
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        new Thread(()-&gt;{
            while (true){
                m.read();
            }
        }).start();
        new Thread(()-&gt;{
            while (true){
                m.write();
            }
        }).start();
    }
}
</code></pre>
<p>两个线程分别占有<code>MUTEX_READ</code>/<code>MUTEX_WRITE</code>，同时等待另一个线程释放<code>MUTEX_WRITE</code>/<code>MUTEX_READ</code>，这就是交叉锁造成的死锁。</p>
<h3 id="353-排查">3.5.3 排查</h3>
<p>使用<code>jps</code>找到进程后，通过<code>jstack</code>查看：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210509221644115.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到明确的提示找到了1个死锁，<code>Thread-0</code>等待被<code>Thread-1</code>占有的<code>monitor</code>，而<code>Thread-1</code>等待被<code>Thread-0</code>占有的<code>monitor</code>。</p>
<h2 id="36-两个特殊的monitor">3.6 两个特殊的<code>monitor</code></h2>
<p>这里介绍两个特殊的<code>monitor</code>：</p>
<ul>
<li><code>this monitor</code></li>
<li><code>class monitor</code></li>
</ul>
<h3 id="361-this-monitor">3.6.1 <code>this monitor</code></h3>
<p>先上一段代码：</p>
<pre><code class="language-java">public class Main {
    public synchronized void method1(){
        System.out.println(Thread.currentThread().getName()+&quot; method1&quot;);
        try{
            TimeUnit.MINUTES.sleep(5);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public synchronized void method2(){
        System.out.println(Thread.currentThread().getName()+&quot; method2&quot;);
        try{
            TimeUnit.MINUTES.sleep(5);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        new Thread(m::method1).start();
        new Thread(m::method2).start();
    }
}
</code></pre>
<p>运行之后可以发现，只有一行输出，也就是说，只是运行了其中一个方法，另一个方法根本没有执行，使用<code>jstack</code>可以发现：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210509222610580.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>一个线程处于休眠中，而另一个线程处于阻塞中。而如果将<code>method2()</code>修改如下：</p>
<pre><code class="language-java">public void method2(){
    synchronized (this) {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>效果是一样的。也就是说，在方法上使用<code>synchronized</code>，等价于<code>synchronized(this)</code>。</p>
<h3 id="362-class-monitor">3.6.2 <code>class monitor</code></h3>
<p>把上面的代码中的方法修改为静态方法：</p>
<pre><code class="language-java">public class Main {
    public static synchronized void method1() {
        System.out.println(Thread.currentThread().getName() + &quot; method1&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static synchronized void method2() {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(Main::method1).start();
        new Thread(Main::method2).start();
    }
}
</code></pre>
<p>运行之后可以发现输出还是只有一行，也就是说只运行了其中一个方法，<code>jstack</code>分析也类似：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210509223432245.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果将<code>method2()</code>修改如下：</p>
<pre><code class="language-java">public static void method2() {
    synchronized (Main.class) {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>可以发现输出还是一致，也就是说，在静态方法上的<code>synchronized</code>，等价于<code>synchronized(XXX.class)</code>。</p>
<h3 id="363-总结">3.6.3 总结</h3>
<ul>
<li><code>this monitor</code>：在成员方法上的<code>synchronized</code>，就是<code>this monitor</code>，等价于在方法中使用<code>synchronized(this)</code></li>
<li><code>class monitor</code>：在静态方法上的<code>synchronized</code>，就是<code>class monitor</code>，等价于在静态方法中使用<code>synchronized(XXX.class)</code></li>
</ul>
<h1 id="4-threadgroup">4 <code>ThreadGroup</code></h1>
<h2 id="41-简介">4.1 简介</h2>
<p>无论什么情况下，一个新创建的线程都会加入某个<code>ThreadGroup</code>中：</p>
<ul>
<li>如果新建线程没有指定<code>ThreadGroup</code>，默认就是<code>main</code>线程所在的<code>ThreadGroup</code></li>
<li>如果指定了<code>ThreadGroup</code>，那么就加入该<code>ThreadGroup</code>中</li>
</ul>
<p><code>ThreadGroup</code>中存在父子关系，一个<code>ThreadGroup</code>可以存在子<code>ThreadGroup</code>。</p>
<h2 id="42-创建">4.2 创建</h2>
<p>创建<code>ThreadGroup</code>可以直接通过构造方法创建，构造方法有两个，一个是直接指定名字（<code>ThreadGroup</code>为<code>main</code>线程的<code>ThreadGroup</code>），一个是带有父<code>ThreadGroup</code>与名字的构造方法：</p>
<pre><code class="language-java">ThreadGroup group1 = new ThreadGroup(&quot;name&quot;);
ThreadGroup group2 = new ThreadGroup(group1,&quot;name2&quot;);
</code></pre>
<p>完整例子：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadGroup group1 = new ThreadGroup(&quot;name&quot;);
    ThreadGroup group2 = new ThreadGroup(group1,&quot;name2&quot;);
    System.out.println(group2.getParent() == group1);
    System.out.println(group1.getParent().getName());
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-bash">true
main
</code></pre>
<h2 id="43-enumerate">4.3 <code>enumerate()</code></h2>
<p><code>enumerate()</code>可用于<code>Thread</code>和<code>ThreadGroup</code>的复制，因为一个<code>ThreadGroup</code>可以加入若干个<code>Thread</code>以及若干个子<code>ThreadGroup</code>，使用该方法可以方便地进行复制。方法描述如下：</p>
<ul>
<li><code>public int enumerate(Thread [] list)</code></li>
<li><code>public int enumerate(Thread [] list, boolean recurse)</code></li>
<li><code>public int enumerate(ThreadGroup [] list)</code></li>
<li><code>public int enumerate(ThreadGroup [] list, boolean recurse)</code></li>
</ul>
<p>上述方法会将<code>ThreadGroup</code>中的活跃线程/<code>ThreadGroup</code>复制到<code>Thread</code>/<code>ThreadGroup</code>数组中，布尔参数表示是否开启递归复制。</p>
<p>例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadGroup myGroup = new ThreadGroup(&quot;MyGroup&quot;);
    Thread thread = new Thread(myGroup,()-&gt;{
        while (true){
            try{
                TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    },&quot;MyThread&quot;);
    thread.start();
    TimeUnit.MILLISECONDS.sleep(1);
    ThreadGroup mainGroup = currentThread().getThreadGroup();
    Thread[] list = new Thread[mainGroup.activeCount()];
    int recurseSize = mainGroup.enumerate(list);
    System.out.println(recurseSize);
    recurseSize = mainGroup.enumerate(list,false);
    System.out.println(recurseSize);
}
</code></pre>
<p>后一个输出比前一个少1，因为不包含<code>myGroup</code>中的线程（递归设置为<code>false</code>）。需要注意的是，<code>enumerate()</code>获取的线程仅仅是一个预估值，并不能百分百地保证当前<code>group</code>的活跃线程，比如调用复制之后，某个线程结束了生命周期或者新的线程加入进来，都会导致数据不准确。另外，返回的<code>int</code>值相较起<code>Thread[]</code>的长度更为真实，因为<code>enumerate</code>仅仅将当前活跃的线程分别放进数组中，而返回值<code>int</code>代表的是真实的数量而不是数组的长度。</p>
<h2 id="44-其他api">4.4 其他<code>API</code></h2>
<ul>
<li><code>activeCount()</code>：获取<code>group</code>中活跃的线程，估计值</li>
<li><code>activeGroupCount()</code>：获取<code>group</code>中活跃的子<code>group</code>，也是一个近似值，会递归获取所有的子<code>group</code></li>
<li><code>getMaxPriority()</code>：用于获取<code>group</code>的优先级，默认情况下，<code>group</code>的优先级为10，且所有线程的优先级不得大于线程所在<code>group</code>的优先级</li>
<li><code>getName()</code>：获取<code>group</code>名字</li>
<li><code>getParent()</code>：获取父<code>group</code>，如果不存在返回<code>null</code></li>
<li><code>list()</code>：一个输出方法，递归输出所有活跃线程信息到控制台</li>
<li><code>parentOf(ThreadGroup g)</code>：判断当前<code>group</code>是不是给定<code>group</code>的父<code>group</code>，如果给定的<code>group</code>是自己本身，也会返回<code>true</code></li>
<li><code>setMaxPriority(int pri)</code>：指定<code>group</code>的最大优先级，设定后也会改变所有子<code>group</code>的最大优先级，另外，修改优先级后会出现线程优先级大于<code>group</code>优先级的情况，比如线程优先级为10，设置<code>group</code>优先级为5后，线程优先级就大于<code>group</code>优先级，但是新加入的线程优先级必须不能大于<code>group</code>优先级</li>
<li><code>interrupt()</code>：导致所有的活跃线程被中断，递归调用线程的<code>interrupt()</code></li>
<li><code>destroy()</code>：如果没有任何活跃线程，调用后在父<code>group</code>中将自己移除</li>
<li><code>setDaemon(boolean daemon)</code>：设置为守护<code>ThreadGroup</code>后，如果该<code>ThreadGroup</code>没有任何活跃线程，自动被销毁</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第330期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-330-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-330-qi/">
        </link>
        <updated>2021-05-09T17:47:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>减肥就是要向妈妈证明，不光胖找不到对象，瘦也找不到！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>寒随一夜去，春逐五更来。<br>
——史青《应诏赋得除夜》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我们的时代还没到来，有的人死后方生。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620664870513.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>用一个数组存，保存两次遍历的长度，比较即可：</p>
<pre><code class="language-java">public class Solution {
    private int [] arr = new int[201];
    private int len1 = 0;
    private int len2 = 0;

    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        f1(root1);
        f2(root2);
        return len1 == len2;
    }

    private void f1(TreeNode root){
        if(root != null){
            if(root.left == null &amp;&amp; root.right == null){
                arr[len1++] = root.val;
            }
            f1(root.left);
            f1(root.right);
        }
    }

    private void f2(TreeNode root){
        if(root != null){
            if(root.left == null &amp;&amp; root.right == null){
                if(arr[len2] == root.val){
                    ++len2;
                }else{
                    if(len2 == len1){
                        ++len2;
                    }
                    return;
                }
            }
            f2(root.left);
            f2(root.right);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620664885369.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第329期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-329-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-329-qi/">
        </link>
        <updated>2021-05-09T05:04:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>突然发现，起床第一件事是摸手机，睡前最后一件事是放下手机。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>有孙母未去，出入无完裙。<br>
——杜甫《石壕吏》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>幸福的家庭都是相似的，不幸的家庭各有各的不幸。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620536965623.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一开始直接暴力超时：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {

    private final PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;();
    private final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    private int m;
    private int k;

    public int minDays(int[] bloomDay, int m, int k) {
        this.m = m;
        this.k = k;
        int n = bloomDay.length;
        long target = (long) m * k;
        if (target &gt; n) {
            return -1;
        }
        for (int i = 0; i &lt; n; i++) {
            queue.add(new Node(bloomDay[i], i));
        }
        int bloomNum = 0;
        int day = -1;
        while (!queue.isEmpty()) {
            day = queue.peek().day;
            Node temp;
            while ((temp = queue.peek()) != null) {
                if (temp.day == day) {
                    list.add(temp.index);
                    queue.remove();
                    ++bloomNum;
                }else{
                    break;
                }
            }
            if (bloomNum &gt;= target) {
                if (check()) {
                    break;
                }
            }
        }
        return day;
    }

    private boolean check() {
        int bloomNum = 0;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(this.list);
        list.sort(Comparator.naturalOrder());
        for (int i = 0; i &lt; list.size(); i++) {
            int j;
            int cur = list.get(i);
            for (j = cur+1;j&lt;=cur+k-1 &amp;&amp; list.contains(j);++j){
            }
            if(j &gt; cur+k-1){
                ++bloomNum;
                for (j = cur;j&lt;=cur+k-1;++j){
                    list.remove((Object)j);
                }
                i = -1;
            }
            if(bloomNum == m){
                return true;
            }
        }

        return false;
    }

    private static class Node implements Comparable&lt;Node&gt; {
        int day;
        int index;

        public Node(int day, int index) {
            this.day = day;
            this.index = index;
        }

        @Override
        public int compareTo(Node node) {
            if (node == this) {
                return 0;
            }
            if (this.day &lt; node.day) {
                return -1;
            } else if (this.day &gt; node.day) {
                return 1;
            }
            return 0;
        }
    }
}
</code></pre>
<p>然后看了题解才知道用二分，加上自己的极致优化，成功打败了最快的12ms：</p>
<pre><code class="language-java">public class Solution {

    private int[] bloomDay;

    public int minDays(int[] bloomDay, int m, int k) {
        if (m * k &gt; (this.bloomDay = bloomDay).length) {
            return -1;
        }

        int low = 1;
        int high = 1;
        for (int day : bloomDay) {
            if (day &gt; high) {
                high = day;
            }
        }

        while (low &lt; high) {
            int mid = low + ((high - low) &gt;&gt; 1);
            if (check(mid, m, k)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }

    private boolean check(int day, int m, int k) {
        int flowers = 0;
        int[] bloomDay = this.bloomDay;
        int n = bloomDay.length;

        for (int i = 0; i &lt; n; ++i) {
            if (bloomDay[i] &lt;= day) {
                if (++flowers == k) {
                    if (--m == 0) {
                        return true;
                    }
                    flowers = 0;
                }
            } else {
                if (i + m * k &gt; n) {
                    return false;
                }
                flowers = 0;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620537021276.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620537057255.png" alt="" loading="lazy"></figure>
<h1 id="母亲节">母亲节</h1>
<p>今天是2021年5月9日，也就是五月的第二个周日，换句话说，是母亲节。</p>
<p>这里祝天底下的母亲节日快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决druid在OpenJDK11+Gradle中的依赖问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-druid-zai-openjdk11gradle-zhong-de-yi-lai-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-druid-zai-openjdk11gradle-zhong-de-yi-lai-wen-ti/">
        </link>
        <updated>2021-05-08T12:14:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境<code>OpenJDK 11</code>+<code>Gradle</code>，直接在<code>build.gradle</code>中引入<code>druid</code>的依赖，报错如下：</p>
<pre><code class="language-bash">'dependencies.dependency.systemPath' for com.sun:tools:jar must specify an absolute path but is ${project.basedir}/lib/openjdk-1.8-tools.jar in com.alibaba:druid:1.2.6
'dependencies.dependency.systemPath' for com.sun:jconsole:jar must specify an absolute path but is ${project.basedir}/lib/openjdk-1.8-jconsole.jar in com.alibaba:druid:1.2.6
</code></pre>
<h1 id="2-原因分析">2 原因分析</h1>
<p>具体原因的话在<a href="https://github.com/alibaba/druid/issues/3060">issue</a>中可以知道，其实就是没有兼容<code>JDK11</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210508191003854.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>既然运行没有问题，那么就手动解决编译问题好了。</p>
<h1 id="3-问题解决">3 问题解决</h1>
<p>根据<code>IDEA</code>的错误提示（具体因<code>druid</code>版本而异）：</p>
<pre><code class="language-bash">~/.gradle/caches/modules-2/files-2.1/com.alibaba/druid/1.2.6/c57198d77a31adf5bd36d35f9b12dc936b732587/druid-1.2.6.pom
</code></pre>
<p>修改提示中的<code>pom</code>文件：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210508191212686.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>把上面的两个包注释掉就可以了，在<code>1.2.6</code>版本的<code>druid</code>中，修改<code>pom</code>文件的第703行，添加注释即可：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210508191303886.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再次重新导入依赖可以看到没有问题了：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210508191408437.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>