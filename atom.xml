<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-03-11T03:09:25.318Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[软件测试笔记（一）：软件测试概论]]></title>
        <id>https://2293736867.github.io/post/ruan-jian-ce-shi-bi-ji-yi-ruan-jian-ce-shi-gai-lun/</id>
        <link href="https://2293736867.github.io/post/ruan-jian-ce-shi-bi-ji-yi-ruan-jian-ce-shi-gai-lun/">
        </link>
        <updated>2021-03-08T06:58:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-软件测试目的">1 软件测试目的</h1>
<p>测试的目的就是以最少的时间和人力找出软件中潜在的各种错误和缺陷，证明软件的功能和性能与需求说明相符，<code>Glenford J.Myers</code>曾提出以下观点：</p>
<ul>
<li>测试是为了证明程序有错，而不是证明程序无错误</li>
<li>一个好的测试用例能发现至今未发现的错误</li>
<li>一个成功的测试是发现了至今未发现的错误</li>
</ul>
<p>软件测试的目的往往包含以下内容：</p>
<ul>
<li>测试并不仅仅是为了找出错误，通过分析错误产生的原因和错误的发生趋势，可以帮助项目管理者发现当前软件开发过程中的缺陷，以便及时改进</li>
<li>测试帮助测试人员设计有针对性的测试方法，改善测试的效率和有效性</li>
<li>没有发现错误的测试也是有价值的，完整的测试是评定软件质量的一种方法</li>
</ul>
<h1 id="2-软件测试的原则">2 软件测试的原则</h1>
<ul>
<li>软件测试是证伪而非证真</li>
<li>尽早地和不断地进行软件测试</li>
<li>重视无效数据和非预期的测试</li>
<li>应当对每一个测试结果做全面检查</li>
<li>测试现场保护和资料归档</li>
<li>程序员应避免检查自己的程序</li>
<li>充分注意测试中的群集现象</li>
<li>用例要定期评审</li>
</ul>
<h1 id="3-软件测试分类">3 软件测试分类</h1>
<h2 id="31-按测试阶段划分">3.1 按测试阶段划分</h2>
<p>可以分为：</p>
<ul>
<li>单元测试：用于检验被测代码的一个很小的、明确的功能是否正确</li>
<li>集成测试：对经过单元测试的模块之间的依赖接口的关系图进行测试</li>
<li>确认测试：用于验证软件的有效性</li>
<li>系统测试：将整个软件系统与计算机硬件、外设、支持软件、数据、人员等其他系统元素结合起来进行测试</li>
<li>验收测试：最终用户参与测试的过程</li>
</ul>
<h2 id="32-按执行状态划分">3.2 按执行状态划分</h2>
<p>可以分为：</p>
<ul>
<li>动态测试：运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能，由“构造测试实例、执行程序和分析程序的输出结果”组成</li>
<li>静态测试：对被测程序进行特性分析方法的总成，是指计算机不运行被测试的程序，而对程序和文档进行分析和检查，包括走查、符号执行、需求确认等</li>
</ul>
<h2 id="33-按照测试技术划分">3.3 按照测试技术划分</h2>
<p>可以分为：</p>
<ul>
<li>黑盒测试：也叫功能测试或数据驱动测试，测试时把程序看做不能打开的黑盒，完全不考虑程序内部结构和特性，对程序接口测试，检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息，并且保持外部信息的完整性</li>
<li>白盒测试：又叫结构测试或逻辑驱动测试，用于检测产品内部的结构及检验程序中的每条通路能够按照预定要求正确工作</li>
<li>灰盒测试：介于白盒与黑盒测试之间，主要用于测试各个组件之间的逻辑关系是否正确，采用桩驱动把各个函数按照一定的逻辑串起来，达到在产品还没有界面的情况下的结果输出</li>
</ul>
<p>一般来说，单元测试采用白盒测试的方法，集成测试采用灰盒测试的方法，而系统测试和确认测试采用黑盒测试的方法，黑盒测试与白盒测试比较如下：</p>
<ul>
<li>规划方面：黑盒测试用于功能测试，而白盒测试用于结构测试</li>
<li>性质：黑盒测试是一种确认（<code>Validation</code>）技术，而白盒测试是一种验证（<code>Verification</code>）技术</li>
<li>优点：黑盒测试的优点包括从用户的角度出发、适用于各阶段测试、从产品功能角度测试、容易入手生成测试数据，而白盒测试的优点包括针对程序内部特定部分进行覆盖测试、可构成测试数据使特定程序部分得到测试、有一定充分性的度量手段、可获得较多工具的支持</li>
<li>缺点：黑盒测试的缺点包括无法测试程序内部特定部分、某些代码得不到测试、如果规格说明错误则无法发现、不易进行充分性的测试，白盒测试的缺点包括无法测试程序外部特性、通常不易生成测试数据、无法对未实现规格说明的部分进行测试、工作量大通常只用于单元测试</li>
<li>应用范围：黑盒测试的应用范围包括边界分析法、等价类划分法、决策表测试，白盒测试的应用范围包括：语句覆盖、判定覆盖、条件覆盖、路径覆盖等</li>
</ul>
<h2 id="34-按执行主体划分">3.4 按执行主体划分</h2>
<p>可以分为：</p>
<ul>
<li><code>Alpha</code>测试：也叫验收测试或开发方测试，开发者和用户共同去检测与证实软件的实现是否满足软件设计说明或软件需求规格说明的要求</li>
<li><code>Beta</code>测试：通常被认为是用户测试，通过用户大量使用来评价检查软件</li>
<li>第三方测试：也叫独立测试，由第三方机构来进行的测试</li>
</ul>
<h1 id="4-软件测试模型">4 软件测试模型</h1>
<p>软件测试模型用于指导软件测试的实践，常见的有：</p>
<ul>
<li><code>V模型</code></li>
<li><code>W模型</code></li>
<li><code>H模型</code></li>
<li><code>X模型</code></li>
<li><code>前置模型</code></li>
</ul>
<h2 id="41-v模型">4.1 <code>V模型</code></h2>
<p><code>V模型</code>反映了测试活动与开发活动间的关系，标明测试过程中存在的不同级别，并清楚描述测试的各个阶段和开发过程的各个阶段对应关系。</p>
<ul>
<li>左侧是开发阶段：从定义软件需求开始，把需求转换为概要设计和详细设计，最后形成程序代码</li>
<li>右侧是测试阶段：在代码编写完成后，从单元测试开始，依次进行集成测试、系统测试和客户验收测试</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210308093643375.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-w模型">4.2 <code>W模型</code></h2>
<p><code>W模型</code>相比起<code>V模型</code>，增加了软件各开发阶段中应同步进行的验证和确认活动。<code>W模型</code>强调：</p>
<ul>
<li>测试伴随整个软件周期</li>
<li>测试对象不仅是程序，需求、设计也要测试</li>
<li>测试与开发同步进行</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210308095334139.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-h模型">4.3 <code>H模型</code></h2>
<p><code>H模型</code>将测试活动完全独立出来，使得测试准备活动和测试执行活动清晰地体现出来，从而使得测试准备与测试执行分离，有利于资源调配，减低成本，提高效率。</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2021030810021469.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-x模型">4.4 <code>X模型</code></h2>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210308110543771.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>左边：描述的是针对单独程序片段进行的编码测试，此后将进行频繁的交接，通过集成最终成为可执行程序</li>
<li>右边：上方定位了已通过集成测试的成品进行封板并提交给用户，也可作为更大规模和范围内集成的一部分，下方定位了探索性测试</li>
</ul>
<h2 id="45-前置模型">4.5 前置模型</h2>
<p>前置模型将测试和开发紧密结合，优点如下：</p>
<ul>
<li>开发和测试相结合</li>
<li>对每一个交付内容进行测试</li>
<li>让验收测试和技术测试保持相互独立</li>
<li>反复交替的开发和测试</li>
<li>引入新的测试理念</li>
</ul>
<h2 id="46-测试模型各自特点">4.6 测试模型各自特点</h2>
<ul>
<li><code>V模型</code>：强调了整个软件项目开发中需要经历的若干个测试级别，每个级别都与一个开发阶段相对应，但它没有明确指出应该对需求、设计进行测试</li>
<li><code>W模型</code>：对<code>V模型</code>进行了补充，强调了测试计划等工作的先行和堆系统需求和软件设计的测试，但和<code>V模型</code>一样，没有专门针对软件测试的流程予以说明</li>
<li><code>H模型</code>：表现了测试是独立的，就每一个软件的测试细节来说，都有一个独立的操作流程，只要测试前提具备了，就可以开始进行测试</li>
<li><code>X模型</code>：体现出测试设计、测试回溯的过程，帮助有经验的测试人员在测试计划之外发现软件错误</li>
<li><code>前置模型</code>：前置模型将测试和开发紧密结合，反复交替第执行</li>
</ul>
<h1 id="5-测试用例">5 测试用例</h1>
<h2 id="51-定义">5.1 定义</h2>
<p>测试用例是指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略，内容包括：</p>
<ul>
<li>测试目标</li>
<li>测试环境</li>
<li>输入数据</li>
<li>预期结果</li>
<li>测试脚本</li>
</ul>
<p>等，最终形成文档。</p>
<p>一个测试用例具有以下属性：</p>
<ul>
<li>优先级次序</li>
<li>目标性</li>
<li>所属的范围</li>
<li>阶段性</li>
<li>状态性</li>
<li>时效性</li>
<li>所有者、日期等特性</li>
</ul>
<h2 id="52-测试用例的设计方法">5.2 测试用例的设计方法</h2>
<p>分为有白盒和黑盒测试相对应的设计方法，比如，黑盒测试的用例设计可以采用：</p>
<ul>
<li>等价类划分</li>
<li>因果图法</li>
<li>边值分析</li>
<li>用户界面测试</li>
<li>配置测试</li>
<li>安装选项验证</li>
</ul>
<p>等，而白盒测试用例的设计方法如下：</p>
<ul>
<li>采用逻辑覆盖等结构的测试用例设计方法</li>
<li>基于程序结构的域测试用例设计方法</li>
<li>根据对象状态或等待状态变化来设计测试用例</li>
<li>基于程序错误的变异来设计测试用例</li>
<li>基于代数运算符号测试的测试用例设计方法</li>
</ul>
<h2 id="53-测试用例设计误区">5.3 测试用例设计误区</h2>
<ul>
<li>把测试用例设计等同于测试输入数据的设计：测试用例中输入数据的确定只是测试用例设计的一个子集，测试用例设计还包括如何根据测试需求、设计规格说明书等文档设计用例的执行策略、执行步骤、预期结构、组织管理形式等问题</li>
<li>测试用例设计得越详细越好：编写过于详细的测试用例会耗费大量的资源，必须分析被测试软件的特征，运用有效的测试用例设计手段，尽量使用较少的测试用例，同时满足合理的测试覆盖</li>
<li>追求测试用例设计“一步到位”：任何软件项目的开发过程都处于不断变化的过程中，在测试过程中可能发现设计测试用例时考虑不周的地方，需要完善，也有可能用户对软件功能提出新的需求变更，需要根据软件变化对测试用例进行调整</li>
<li>将多个测试用例混在一个用例中：一个测试用例包含许多内容很容易引起混淆，从而使得测试结果很难记录</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java常用工具+类库合集]]></title>
        <id>https://2293736867.github.io/post/java-chang-yong-gong-ju-lei-ku-he-ji/</id>
        <link href="https://2293736867.github.io/post/java-chang-yong-gong-ju-lei-ku-he-ji/">
        </link>
        <updated>2021-03-07T11:49:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-常用工具">1 常用工具</h1>
<ul>
<li><code>JVisual vm</code>：可以直接通过软件包下载，支持本地以及远程<code>JVM</code>监控</li>
<li><code>JMH</code>：<code>Java Microbenchmark Harness</code>，测试基准组件，精度可达纳秒级</li>
<li><code>JITWatch</code>：<code>JIT</code>日志分析<code>GUI</code>工具</li>
</ul>
<h1 id="2-日志库">2 日志库</h1>
<h2 id="21-日志框架">2.1 日志框架</h2>
<ul>
<li><code>JUL</code>：<code>JDK</code>自带日志库，也就是<code>java.util.logging</code></li>
<li><code>Log4j</code>/<code>Log4j2</code>：<code>Apache</code>的一个开源项目，高度可配置</li>
<li><code>Logback</code>：开源日志组件</li>
</ul>
<h2 id="22-日志门面">2.2 日志门面</h2>
<ul>
<li><code>JCL</code>：<code>Jakarta Commons Logging</code>，<code>Apache</code>的一个开源项目</li>
<li><code>slf4j</code>：<code>Simple Logging Facade for Java</code>，常用的一个日志门面</li>
</ul>
<h1 id="3-json库">3 <code>JSON</code>库</h1>
<ul>
<li><code>Jackson</code>：<code>Spring</code>默认<code>JSON</code>库，使用广泛</li>
<li><code>Gson</code>：<code>Google</code>开发的功能最全的<code>JSON</code>库，无额外依赖</li>
<li><code>FastJson</code>：阿里出品的<code>JSON</code>库，速度最快，但是在某些复杂类转换上可能会出现问题</li>
<li><code>JSONP</code>：<code>Oracle</code>出品的<code>JSON</code>处理库</li>
</ul>
<h1 id="4-单元测试库">4 单元测试库</h1>
<ul>
<li><code>JUnit</code>：一个强大的单元测试库，基本上被所有主流<code>IDE</code>支持</li>
<li><code>Selenium</code>：<code>UI</code>测试工具</li>
<li><code>TestNG</code>：流行的单元测试框架</li>
<li><code>Mockito</code>：<code>Mock</code>框架之一，具有简单的<code>API</code>、优秀的文档以及大量示例</li>
<li><code>Cucumber</code>：一款自动化集成测试工具</li>
<li><code>DBUnit</code>：数据库单元测试工具</li>
</ul>
<h1 id="5-通用类库">5 通用类库</h1>
<ul>
<li><code>Apache Commons</code>：<code>Apache</code>开源的一款强大工具包，包括编解码算法、集合扩展、<code>IO</code>库、压缩库等</li>
<li><code>Google Guava</code>：<code>Google</code>开源的一个被<code>Google Java</code>项目广泛依赖的核心库，包括一些基本工具、集合扩展、缓存、并发工具包、字符串处理等</li>
</ul>
<h1 id="6-http库">6 <code>HTTP</code>库</h1>
<ul>
<li><code>HttpClient</code>：<code>Apache HttpComponents HttpClient</code>，一款特性丰富的<code>HTTP</code>库</li>
<li><code>okhttp</code>：一个高效的<code>HTTP</code>库，使用连接池减少请求延迟，<code>gzip</code>压缩减少响应数据大小，缓存响应内容</li>
<li><code>Retrofit</code>：一款类型安全的<code>HTTP</code>库</li>
</ul>
<h1 id="7-xml解析库">7 <code>XML</code>解析库</h1>
<ul>
<li><code>Xerces</code>：<code>Apache</code>开源的解析库</li>
<li><code>JAXB</code>：一项根据<code>XML Schema</code>生成<code>Java</code>类的技术</li>
<li><code>Dom4j</code>：一款灵活开源的<code>XML</code>框架</li>
<li><code>XStream</code>：一款<code>XML</code>序列化库</li>
</ul>
<h1 id="8-excel读写库">8 <code>Excel</code>读写库</h1>
<ul>
<li><code>Apache POI</code>：提供<code>API</code>对<code>Microsoft Office</code>系列的产品的读写功能，包括<code>Word、Excel、PowerPoint、Visio</code>等</li>
</ul>
<h1 id="9-字节码库">9 字节码库</h1>
<ul>
<li><code>BCEL</code>：<code>Byte Code Engineering Library</code>，<code>Apache</code>开发的字节码操作框架</li>
<li><code>ASM</code>：一个轻量级的字节码操作框架</li>
<li><code>CGLIB</code>：一个强大、高性能、高质量的生成类库</li>
<li><code>Javassist</code>：一个开源的分析、编辑和创建<code>Java</code>字节码的类库</li>
<li><code>ReflactASM</code>：通过代码生成来提供高性能的反射处理库，访问类使用字节码操作而不是反射技术</li>
</ul>
<h1 id="10-数据库连接池库">10 数据库连接池库</h1>
<ul>
<li><code>HikariCP</code>：高性能数据库连接池</li>
<li><code>Druid</code>：阿里开源的一款数据库连接池库，提供了强大的监控和扩展功能，可用于大数据实时查询和分析</li>
<li><code>DBCP2</code>：<code>Apache</code>开发的一款数据库连接池项目</li>
</ul>
<h1 id="11-pdf库">11 <code>PDF</code>库</h1>
<ul>
<li><code>Apache PDF Box</code>：<code>Apache</code>开源的<code>PDF</code>库</li>
<li><code>iText</code>：能够快速产生<code>PDF</code>文件的<code>PDF</code>库</li>
</ul>
<h1 id="12-日期时间库">12 日期时间库</h1>
<ul>
<li><code>JDK8</code>自带的<code>LocalDate</code>等</li>
<li><code>JodaTime</code>：一款专门处理日期时间的库</li>
</ul>
<h1 id="13-集合类库">13 集合类库</h1>
<ul>
<li><code>Apache Commons Collections</code>：<code>Apache Commons</code>组件之一，提供一些常用集合的实现以及<code>API</code>封装</li>
<li><code>Google Collections</code>：<code>Google</code>开发的一款强大的集合库</li>
<li><code>HPPC</code>：<code>High Performance Primitive Collections</code>，一款专注高性能和高存储效率优化的集合类库</li>
<li><code>Trove</code>：<code>GNU Trove</code>，一款快速轻量级的集合框架</li>
<li><code>FastUtil</code>：一款<code>Java</code>集合框架</li>
</ul>
<h1 id="14-加密库">14 加密库</h1>
<ul>
<li><code>Apache Commons Codec</code>：编解码以及加密处理库</li>
<li><code>BouncyCastle</code>：提供了很多哈希算法和加密算法的第三方库</li>
</ul>
<h1 id="15-html解析库">15 <code>HTML</code>解析库</h1>
<ul>
<li><code>jsoup</code>：<code>Java HTML</code>解析器，能够从<code>URL</code>、文件或字符串解析<code>HTML</code></li>
</ul>
<h1 id="16-邮件库">16 邮件库</h1>
<ul>
<li><code>Simple Java Mail</code>：一款使用强大且简洁<code>API</code>的邮件库</li>
<li><code>Apache Commons Mail</code>：建立在<code>Java Mail API</code>之上的邮件库</li>
</ul>
<h1 id="17-序列化库">17 序列化库</h1>
<ul>
<li><code>MessagePack</code>：一种二进制序列化格式，比<code>JSON</code>更为紧凑，编码更精简高效</li>
<li><code>Protobuf</code>：<code>Google</code>提供的多语言支持二进制序列化库</li>
<li><code>Apache Avro</code>：<code>Hadoop</code>的一个子项目，支持二进制序列化方式</li>
<li><code>kryo</code>：快速高效的二进制序列化框架</li>
</ul>
<h1 id="18-缓存库">18 缓存库</h1>
<ul>
<li><code>Caffeine</code>：高性能缓存工具，支持基于大小、基于时间、基于引用三种淘汰策略，同时拥有着高命中率的特点</li>
</ul>
<h1 id="19-其他库">19 其他库</h1>
<ul>
<li><code>Selma</code>：映射工具库，最常用的操作是用来复制对象</li>
<li><code>Beetl</code>：一款高性能、多功能的模板处理引擎</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java性能优化的十条小技巧]]></title>
        <id>https://2293736867.github.io/post/java-xing-neng-you-hua-de-shi-tiao-xiao-ji-qiao/</id>
        <link href="https://2293736867.github.io/post/java-xing-neng-you-hua-de-shi-tiao-xiao-ji-qiao/">
        </link>
        <updated>2021-03-07T11:47:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-systemnanotime">1 <code>System.nanoTime</code></h1>
<p>测试性能时，<code>System.nanoTime</code>比<code>System.currentTimeMills</code>更精确，前者使用纳秒计时，且对系统影响更小。</p>
<p>具体来说：</p>
<ul>
<li><code>System.currentTimeMills</code>返回自<code>1970年1月1日</code>以来经过的毫秒数，返回的精度与操作系统有关</li>
<li><code>System.nanoTime</code>：不是现实时间，是虚拟机提供的计时时间，精确到纳秒</li>
</ul>
<h1 id="2-threadlocalrandom">2 <code>ThreadLocalRandom</code></h1>
<p>通常生成随机数会使用<code>Random</code>类，<code>Random</code>是线程安全的，<code>Random</code>实例里面有一个原子性的种子变量来记录当前种子的值，当要生成新的随机数时，会根据当前种子计算新的种子并更新回原子变量。多线程下计算新种子，会竞争同一个原子变量的更新操作，会造成大量线程进行自旋测试，降低并发性能。</p>
<p>而<code>ThreadLocalRandom</code>在当前线程维护了一个种子，适合在多线程场景下提供高性能的伪随机数生成，使用如下：</p>
<pre><code class="language-java">ThreadLocalRandom random = ThreadLocalRandom.current();
random.nextInt(range);
</code></pre>
<h1 id="3-使用局部变量">3 使用局部变量</h1>
<p>理论上说，访问局部变量会快于类变量，因为局部变量保存在方法栈中，而类变量保存在堆中。如果在某个类方法中需要多次访问类变量，建议先创建一个局部变量并使其具有与类变量相同的值。</p>
<h1 id="4-关于正则表达式替换">4 关于正则表达式替换</h1>
<p>由于正则表达式替换时每次都需要编译正则表达式到一个中间结构，因此比常规的直接替换要慢，如果是固定的正则表达式替换，可以采用预编译的思想：</p>
<pre><code class="language-java">Pattern pattern = Pattern.compile(&quot;origin str&quot;);
public String replace(String str){
	return pattern.matcher(str).replaceAll(&quot;target str&quot;);
}
</code></pre>
<p>而不是采用：</p>
<pre><code class="language-java">public String replace(String str){
	return str.replace(&quot;origin str&quot;,&quot;target str&quot;);
}
</code></pre>
<h1 id="5-关于字符串拼接">5 关于字符串拼接</h1>
<p>尽可能使用如下形式：</p>
<pre><code class="language-java">String a = &quot;xxx&quot;;
String b = &quot;xxx&quot;;
String c = new StringBuilder().append(a).append(b).toString();
</code></pre>
<p>性能相对不好的是如下情形（得益于<code>JVM</code>默认开启字符串拼接优化）：</p>
<pre><code class="language-java">String c = a+b;
</code></pre>
<p>性能最差的是：</p>
<pre><code class="language-java">StringBuilder c = new StringBuilder();
c.append(a);
c.append(b);
String result = c.toString();
</code></pre>
<p>因为这样<code>JIT</code>不会优化。</p>
<p>另外，在无关线程安全的情况下，尽可能使用<code>StringBuilder</code>而不是<code>StringBuffer</code>。</p>
<h1 id="6-关于数字转字符串">6 关于数字转字符串</h1>
<p><code>int</code>转<code>String</code>是一个较为耗时的操作，尽量避免不必要的转化，如果确实需要，可以预先将一批<code>int</code>转为<code>String</code>，需要的时候直接取出：</p>
<pre><code class="language-java">public static class CommonUtil{
	static int cacheSize = 1024;
	static String [] caches = new String[cacheSize];
	static{
		for(int i=0;i&lt;cacheSize;++i){
			caches[i] = String.valueOf(i);
		}
	}
	public static String int2String(int data){
		if(data &lt; cacheSize){
			return caches[size];
		}else{
			return String.valueOf(data);
		}
	}
}
</code></pre>
<p>这样相比起直接使用</p>
<pre><code class="language-java">Stirng.valueOf(data)
</code></pre>
<p>性能会高一点。</p>
<h1 id="7-switchif">7 <code>switch</code>/<code>if</code></h1>
<p>少分支的情况下，建议使用<code>if</code>，多分支建议使用<code>switch</code>，常用的“少分支”标准是<code>2-5个</code>。</p>
<h1 id="8-采用返回码而不是抛异常">8 采用返回码而不是抛异常</h1>
<p>除非必要使用异常，应该避免把正常的返回错误结果使用异常来代替。抛异常会导致性能是因为构造异常对象时需要一个填写异常栈的过程，就是<code>Throwable</code>中的<code>fillInStackTrace</code>，这是一个<code>Native</code>方法，会填写异常栈，造成较为严重的耗时。</p>
<p>一种优化方法是，自定义异常，重写<code>fillInStackTrace()</code>：</p>
<pre><code class="language-java">public class MyException extends RuntimeException{
	...
	public synchronized Throwable fillInStackTrace(){
		this.setStackTrace(new StackTraceElement[0]);
		return this;
	}
}
</code></pre>
<p>另外，<code>JVM</code>会对频繁抛出的异常做<code>Fast Throw</code>优化，如果检测到代码中某一位置连续多次抛出同一类型的异常，则采用<code>Fast Throw</code>方式，异常栈信息不会被填写，这种异常抛出速度很快，因为不需要在堆里分配内存，也不需要构造完整的异常栈信息，默认对如下异常采用<code>Fast Throw</code>优化：</p>
<ul>
<li><code>NullPointerException</code></li>
<li><code>ArithmeticException</code></li>
<li><code>ArrayIndexOutOfBoundsExpcetion</code></li>
<li><code>ArrayStoreException</code></li>
<li><code>ClassCastException</code></li>
</ul>
<p>需要注意的是，<code>Fast Throw</code>虽然提高了性能，但是会导致异常栈消息，从而无法快速定位到错误代码，如果需要避免异常栈优化，可以使用参数：</p>
<pre><code class="language-java">-XX:-OmitStackTraceInFastThrow
</code></pre>
<h1 id="9-位运算">9 位运算</h1>
<p>可以通过位运算代替部分算术运算以提高性能，比如：</p>
<ul>
<li>判断奇数：<code>(a &amp; 1) == 1</code></li>
<li>判断偶数：<code>(a &amp; 1) == 0</code></li>
<li>除2：<code>a&gt;&gt;1</code></li>
<li>乘2：<code>a&lt;&lt;1</code></li>
</ul>
<h1 id="10-其他技巧">10 其他技巧</h1>
<ul>
<li>字符串搜索等需要搜索单个字符时，使用<code>String.indexOf(char)</code>而不是<code>String.indexOf(String)</code></li>
<li>对于判断一些特殊的<code>ID</code>，比如长度<code>9位</code>且以<code>11</code>开头，可以直接使用常数判断：<code>id&gt;=110_000_000 &amp;&amp; id&lt;=120_000_000</code>，而不需要通过<code>String.valueOf</code>转为字符串再通过<code>String.length</code>+<code>String.startWith</code>判断</li>
<li>在<code>switch</code>中，可以使用<code>int</code>去代替<code>String</code></li>
<li>日志输出可以直接使用字符串拼接而不是<code>模板+{}</code>，因为会有一个占位符<code>{}</code>替换成目标变量的耗时过程，被频繁调用的话建议直接字符串拼接</li>
<li>传输的实体类尽量避免使用<code>String</code>，因为其中涉及序列化、反序列化、字符串构造，而对于<code>byte[]</code>构造<code>String</code>的方法，内部会调用<code>StringCoding.decode</code>，相比起通过<code>char[]</code>/<code>Stirng</code>构造会造成更大的耗时</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第266期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-266-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-266-qi/">
        </link>
        <updated>2021-03-07T03:02:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>失败是成功之母，可惜成功六亲不认。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>那知自是，桃花结子，不因春瘦。<br>
——晁补之《水龙吟·次歆林圣予惜春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>爱你我也不再是那个幼稚的少年。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第265期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-265-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-265-qi/">
        </link>
        <updated>2021-03-06T11:35:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别太晚睡，熬夜很伤手机的。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>月上屏帏，冷透人衣袂。<br>
——苏轼《蝶恋花·昨夜秋风来万里》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>从一开始，我就不那么喜欢你。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（三）：JVM基本参数]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-san-jvm-ji-ben-can-shu/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-san-jvm-ji-ben-can-shu/">
        </link>
        <updated>2021-03-05T03:49:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-gc%E6%97%A5%E5%BF%97-xloggc">2 <code>GC</code>日志：<code>-Xlog:gc</code></a></li>
<li><a href="#3-%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E6%89%93%E5%8D%B0">3 系统参数打印</a></li>
<li><a href="#4-%E5%A0%86%E5%8F%82%E6%95%B0">4 堆参数</a>
<ul>
<li><a href="#41-%E6%9C%80%E5%A4%A7%E5%A0%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%A0%86%E5%8F%82%E6%95%B0">4.1 最大堆与初始堆参数</a></li>
<li><a href="#42-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8F%82%E6%95%B0">4.2 新生代参数</a></li>
<li><a href="#43-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86">4.3 堆溢出处理</a></li>
</ul>
</li>
<li><a href="#5-%E9%9D%9E%E5%A0%86%E5%8F%82%E6%95%B0">5 非堆参数</a>
<ul>
<li><a href="#51-%E6%96%B9%E6%B3%95%E5%8C%BA">5.1 方法区</a></li>
<li><a href="#52-%E6%A0%88">5.2 栈</a></li>
<li><a href="#53-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">5.3 直接内存</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第三章</li>
</ul>
<p>本文是第三章的一些笔记整理。</p>
<h1 id="2-gc日志-xloggc">2 <code>GC</code>日志：<code>-Xlog:gc</code></h1>
<p>要打印<code>GC</code>日志的话，可以加上<code>-Xlog:gc</code>参数（<code>JDK8</code>及以下请使用<code>-XX:+PrintGC</code>），开启<code>GC</code>打印后，每次<code>GC</code>就会打印如下的日志（<code>OpenJDK11 -Xlog:gc</code>）：</p>
<pre><code class="language-bash">[0.126s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 25M-&gt;0M(502M) 1.902ms
[0.205s][info][gc] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 4.174ms
[0.236s][info][gc] GC(2) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 2.067ms
[0.268s][info][gc] GC(3) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 2.362ms
</code></pre>
<p>其中开头的时间表示发生<code>GC</code>的时刻，<code>25M-&gt;0M(502M)</code>表示：</p>
<ul>
<li><code>GC</code>前，堆使用量为<code>25M</code></li>
<li><code>GC</code>后，堆使用量为<code>0M</code></li>
<li>堆空间总和约为<code>502M</code></li>
</ul>
<p>末尾的时间表示本次<code>GC</code>的耗时。</p>
<p>另外如果需要更加详细的参数，可以使用<code>-Xlog:gc*</code>（<code>JDK8</code>及以下请使用<code>-XX:+PrintGCDetails</code>），比如下面是一部分的<code>GC</code>日志（<code>-Xlog:gc*</code>）：</p>
<pre><code class="language-bash">[0.137s][info][gc,start     ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[0.138s][info][gc,task      ] GC(0) Using 10 workers of 10 for evacuation
[0.147s][info][gc,phases    ] GC(0)   Pre Evacuate Collection Set: 0.0ms
[0.147s][info][gc,phases    ] GC(0)   Evacuate Collection Set: 8.8ms
[0.147s][info][gc,phases    ] GC(0)   Post Evacuate Collection Set: 0.2ms
[0.147s][info][gc,phases    ] GC(0)   Other: 0.8ms
[0.147s][info][gc,heap      ] GC(0) Eden regions: 25-&gt;0(300)
[0.147s][info][gc,heap      ] GC(0) Survivor regions: 0-&gt;1(4)
[0.147s][info][gc,heap      ] GC(0) Old regions: 0-&gt;0
[0.147s][info][gc,heap      ] GC(0) Humongous regions: 0-&gt;0
[0.147s][info][gc,metaspace ] GC(0) Metaspace: 6633K-&gt;6633K(1056768K)
[0.147s][info][gc           ] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 25M-&gt;0M(502M) 9.878ms
[0.147s][info][gc,cpu       ] GC(0) User=0.05s Sys=0.00s Real=0.01s
</code></pre>
<ul>
<li>行首的时间：事件发生的时刻</li>
<li><code>GC(0)</code>：这是第1次<code>GC</code>，接着会有<code>GC(1)</code>、<code>GC(2)</code></li>
<li><code>Pause Young（Normal）</code>：这次<code>GC</code>回收了新生代</li>
<li><code>Using 10 workers</code>：使用10个工作线程</li>
<li><code>Pre Evacuate Collection Set</code>/<code>Evacuate Collection Set</code>/<code>Post Evacuate</code>/<code>Other</code>：表示<code>G1</code>垃圾回收标记，清除算法不同阶段所花费的时间</li>
<li><code>Eden/Survivor/Old/Humongous/Metaspace</code>：分别表示<code>eden区</code>、<code>存活区</code>、<code>老年区</code>、<code>巨型对象区</code>（就是很大很大的对象所在的区域）、<code>元数据区</code>在<code>GC</code>前后的大小</li>
<li><code>25M-0M(502M)</code>：<code>GC</code>前堆占用<code>25M</code>，<code>GC</code>后为<code>0M</code>，可用堆空间为<code>502M</code></li>
<li><code>User/Sys/Real</code>：分别表示<code>用户态CPU耗时</code>、<code>系统CPU耗时</code>、<code>GC真实经历时间</code></li>
</ul>
<p>如果想查看更全面的堆信息，可以使用<code>Visual VM</code>，将在后续文章中叙述。</p>
<p>另外如果需要将日志持久化，可以使用<code>-Xlog:gc:gc.log</code>。</p>
<h1 id="3-系统参数打印">3 系统参数打印</h1>
<p>参数<code>-XX:+PrintVMOptinos</code>可以打印运行时接收到的显式参数，而<code>-XX:+PrintCommandLineFlags</code>可以打印传递给<code>JVM</code>的隐式与显式参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210304094815957.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>另外一个参数是<code>-XX:+PrintFlagsFinal</code>，会打印所有系统参数的值（数量很多）：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210304094936823.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-堆参数">4 堆参数</h1>
<h2 id="41-最大堆与初始堆参数">4.1 最大堆与初始堆参数</h2>
<p><code>Java</code>进程启动时，虚拟机就会分配一块初始堆空间，可以使用参数<code>-Xms</code>指定这块空间的初始化大小。一般来说虚拟机会尽可能维持在初始堆空间范围内运行，但是如果初始堆空间耗尽，虚拟机会将堆空间进行扩展，扩展上限为最大堆空间，最大堆空间可以使用参数<code>-Xmx</code>指定。</p>
<p>来一段代码测试一下：</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args){
        printMemory();

        byte [] bytes = new byte[1*1024*1024];
        System.out.println(&quot;Allocate 1024 KB array&quot;);
        printMemory();

        bytes = new byte[4*1024*1024];
        System.out.println(&quot;Allocate 4096 KB array&quot;);
        printMemory();
    }

    public static void printMemory(){
        System.out.println();
        System.out.println(&quot;Max memory = &quot; + Runtime.getRuntime().maxMemory() / 1024+ &quot; KB&quot;);
        System.out.println(&quot;Free memory = &quot;+Runtime.getRuntime().freeMemory()/1024+ &quot; KB&quot;);
        System.out.println(&quot;Total memory = &quot; + Runtime.getRuntime().totalMemory()/ 1024+ &quot; KB&quot;);
        System.out.println();
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms5m
-XX:+PrintCommandLineFlags
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">-XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC 
[0.002s][info   ][gc] Using Serial
[0.002s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit

[0.110s][info   ][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.112s][info   ][gc,heap      ] GC(0) DefNew: 1664K-&gt;192K(1856K)
[0.112s][info   ][gc,heap      ] GC(0) Tenured: 0K-&gt;598K(4096K)
[0.112s][info   ][gc,metaspace ] GC(0) Metaspace: 6436K-&gt;6436K(1056768K)
[0.112s][info   ][gc           ] GC(0) Pause Young (Allocation Failure) 1M-&gt;0M(5M) 2.069ms
[0.112s][info   ][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.01s
Max memory = 19840 KB
Free memory = 4797 KB
Total memory = 5952 KB

Allocate 1024 KB array

Max memory = 19840 KB
Free memory = 3773 KB
Total memory = 5952 KB

[0.128s][info   ][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.129s][info   ][gc,start     ] GC(2) Pause Full (Allocation Failure)
[0.129s][info   ][gc,phases,start] GC(2) Phase 1: Mark live objects
[0.130s][info   ][gc,phases      ] GC(2) Phase 1: Mark live objects 1.366ms
[0.130s][info   ][gc,phases,start] GC(2) Phase 2: Compute new object addresses
[0.130s][info   ][gc,phases      ] GC(2) Phase 2: Compute new object addresses 0.235ms
[0.130s][info   ][gc,phases,start] GC(2) Phase 3: Adjust pointers
[0.131s][info   ][gc,phases      ] GC(2) Phase 3: Adjust pointers 0.624ms
[0.131s][info   ][gc,phases,start] GC(2) Phase 4: Move objects
[0.131s][info   ][gc,phases      ] GC(2) Phase 4: Move objects 0.042ms
[0.131s][info   ][gc             ] GC(2) Pause Full (Allocation Failure) 1M-&gt;1M(5M) 2.335ms
[0.131s][info   ][gc,heap        ] GC(1) DefNew: 1579K-&gt;0K(1856K)
[0.131s][info   ][gc,heap        ] GC(1) Tenured: 598K-&gt;1899K(4096K)
[0.131s][info   ][gc,metaspace   ] GC(1) Metaspace: 6624K-&gt;6624K(1056768K)
[0.131s][info   ][gc             ] GC(1) Pause Young (Allocation Failure) 2M-&gt;1M(5M) 3.636ms
[0.131s][info   ][gc,cpu         ] GC(1) User=0.00s Sys=0.01s Real=0.00s
Allocate 4096 KB array

Max memory = 19840 KB
Free memory = 4087 KB
Total memory = 10116 KB

[0.133s][info   ][gc,heap,exit   ] Heap
[0.133s][info   ][gc,heap,exit   ]  def new generation   total 1920K, used 44K [0x00000000fec00000, 0x00000000fee10000, 0x00000000ff2a0000)
[0.133s][info   ][gc,heap,exit   ]   eden space 1728K,   2% used [0x00000000fec00000, 0x00000000fec0b198, 0x00000000fedb0000)
[0.133s][info   ][gc,heap,exit   ]   from space 192K,   0% used [0x00000000fedb0000, 0x00000000fedb0000, 0x00000000fede0000)
[0.133s][info   ][gc,heap,exit   ]   to   space 192K,   0% used [0x00000000fede0000, 0x00000000fede0000, 0x00000000fee10000)
[0.133s][info   ][gc,heap,exit   ]  tenured generation   total 8196K, used 5995K [0x00000000ff2a0000, 0x00000000ffaa1000, 0x0000000100000000)
[0.133s][info   ][gc,heap,exit   ]    the space 8196K,  73% used [0x00000000ff2a0000, 0x00000000ff87aed0, 0x00000000ff87b000, 0x00000000ffaa1000)
[0.133s][info   ][gc,heap,exit   ]  Metaspace       used 6640K, capacity 6723K, committed 7040K, reserved 1056768K
[0.133s][info   ][gc,heap,exit   ]   class space    used 590K, capacity 623K, committed 640K, reserved 1048576K
</code></pre>
<p>最大内存由<code>-XX:MaxHeapSize</code>指定，该值为<code>-Xmx</code>的值，也就是<code>20 * 1024 * 1024</code>，而打印的最大可用内存为<code>20316160</code>，比设定的值少，这是因为分配给堆的内存空间与实际可用的内存空间并不是同一个概念，由于<code>GC</code>的需要，虚拟机会对堆空间进行分区管理，不同的区会采用不同的回收算法，一些算法会使用空间换时间的策略，因此会存在损失，最终的结果是实际可用内存会浪费大小等于<code>from</code>/<code>to</code>的空间，从输出可以知道：</p>
<pre><code class="language-bash">[0.139s][info][gc,heap,exit   ]   from space 192K,   0% used [0x00000000fedb0000, 0x00000000fedb0000, 0x00000000fede0000)
</code></pre>
<p><code>from</code>的大小为<code>192k</code>，但是实际情况是最大可用内存<code>19840k</code>+<code>from</code>的<code>192k</code>=<code>20032k</code>，并不是分配的内存<code>20480k</code>，这是因为虚拟机会对<code>from</code>/<code>to</code>进行对齐，将最大可用内存加上对齐后的<code>from</code>/<code>to</code>即得到分配的内存大小。</p>
<p>另外，打印显示，初始运行空闲内存<code>4797k</code>，分配一个<code>1024k</code>数组后，空闲内存为<code>3773k</code>，正好符合，接着分配<code>4096k</code>，因为内存不足，对堆空间进行扩展后再分配，扩展后的堆大小为<code>10116k</code>。</p>
<p>在实际工作中，可以将<code>-Xms</code>与<code>-Xmx</code>设置为相同，这样可以减少运行时的<code>GC</code>次数，提高性能。</p>
<h2 id="42-新生代参数">4.2 新生代参数</h2>
<p><code>-Xmn</code>可以设置新生代的大小，设置一个较大的新生代会减小老年代的大小，这个参数堆<code>GC</code>有很大影响，一般设置为堆空间的<code>1/3-1/4</code>。参数<code>-XX:SurvivorRatio</code>，也就是幸存区比例，可用来设置<code>eden区</code>与<code>from/to区</code>的比例，相当于：</p>
<pre><code class="language-bash">-XX:SurvivorRatio=eden/from=eden/to
</code></pre>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    byte [] b = null;
    for (int i = 0; i &lt; 10; i++) {
        b = new byte[1*1024*1024] ;
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms20m
-Xmn1m
-XX:SurvivorRatio=2
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">[0.002s][info][gc] Using Serial
[0.002s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.042s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.044s][info][gc,heap      ] GC(0) DefNew: 512K-&gt;256K(768K)
[0.044s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;172K(19456K)
[0.044s][info][gc,metaspace ] GC(0) Metaspace: 3871K-&gt;3871K(1056768K)
[0.044s][info][gc           ] GC(0) Pause Young (Allocation Failure) 0M-&gt;0M(19M) 1.617ms
[0.044s][info][gc,cpu       ] GC(0) User=0.01s Sys=0.00s Real=0.00s
[0.064s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.065s][info][gc,heap      ] GC(1) DefNew: 767K-&gt;76K(768K)
[0.065s][info][gc,heap      ] GC(1) Tenured: 172K-&gt;425K(19456K)
[0.065s][info][gc,metaspace ] GC(1) Metaspace: 4518K-&gt;4518K(1056768K)
[0.065s][info][gc           ] GC(1) Pause Young (Allocation Failure) 0M-&gt;0M(19M) 0.870ms
[0.065s][info][gc,cpu       ] GC(1) User=0.00s Sys=0.00s Real=0.00s
[0.093s][info][gc,heap,exit ] Heap
[0.093s][info][gc,heap,exit ]  def new generation   total 768K, used 562K [0x00000000fec00000, 0x00000000fed00000, 0x00000000fed00000)
[0.093s][info][gc,heap,exit ]   eden space 512K,  94% used [0x00000000fec00000, 0x00000000fec79730, 0x00000000fec80000)
[0.093s][info][gc,heap,exit ]   from space 256K,  29% used [0x00000000fec80000, 0x00000000fec93260, 0x00000000fecc0000)
[0.093s][info][gc,heap,exit ]   to   space 256K,   0% used [0x00000000fecc0000, 0x00000000fecc0000, 0x00000000fed00000)
[0.093s][info][gc,heap,exit ]  tenured generation   total 19456K, used 10665K [0x00000000fed00000, 0x0000000100000000, 0x0000000100000000)
[0.093s][info][gc,heap,exit ]    the space 19456K,  54% used [0x00000000fed00000, 0x00000000ff76a630, 0x00000000ff76a800, 0x0000000100000000)
[0.093s][info][gc,heap,exit ]  Metaspace       used 6190K, capacity 6251K, committed 6528K, reserved 1056768K
[0.093s][info][gc,heap,exit ]   class space    used 535K, capacity 570K, committed 640K, reserved 1048576K
</code></pre>
<p><code>eden区</code>与<code>from区</code>的比值为<code>2:1</code>，因此<code>eden区</code>为<code>512K</code>，总可用新生代大小为<code>512K+256K=768K</code>，新生代总大小为<code>512K+256K+256K=1M</code>，由于<code>eden</code>区无法容纳分配<code>1MB</code>数组，因此触发了新生代<code>GC</code>，所有数组分配在了老年代。</p>
<p>而如果使用<code>-Xmn7m</code>（其他参数保持不变），输出如下：</p>
<pre><code class="language-bash">[0.003s][info][gc] Using Serial
[0.003s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.096s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.097s][info][gc,heap      ] GC(0) DefNew: 2684K-&gt;1752K(5376K)
[0.097s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;0K(13312K)
[0.097s][info][gc,metaspace ] GC(0) Metaspace: 5929K-&gt;5929K(1056768K)
[0.097s][info][gc           ] GC(0) Pause Young (Allocation Failure) 2M-&gt;1M(18M) 1.350ms
[0.097s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.00s
[0.098s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(1) DefNew: 4928K-&gt;1024K(5376K)
[0.099s][info][gc,heap      ] GC(1) Tenured: 0K-&gt;727K(13312K)
[0.099s][info][gc,metaspace ] GC(1) Metaspace: 5996K-&gt;5996K(1056768K)
[0.099s][info][gc           ] GC(1) Pause Young (Allocation Failure) 4M-&gt;1M(18M) 1.142ms
[0.099s][info][gc,cpu       ] GC(1) User=0.01s Sys=0.00s Real=0.00s
[0.100s][info][gc,start     ] GC(2) Pause Young (Allocation Failure)
[0.100s][info][gc,heap      ] GC(2) DefNew: 4180K-&gt;1024K(5376K)
[0.100s][info][gc,heap      ] GC(2) Tenured: 727K-&gt;728K(13312K)
[0.100s][info][gc,metaspace ] GC(2) Metaspace: 6008K-&gt;6008K(1056768K)
[0.100s][info][gc           ] GC(2) Pause Young (Allocation Failure) 4M-&gt;1M(18M) 0.190ms
[0.100s][info][gc,cpu       ] GC(2) User=0.00s Sys=0.00s Real=0.00s
[0.100s][info][gc,heap,exit ] Heap
[0.100s][info][gc,heap,exit ]  def new generation   total 5376K, used 4211K [0x00000000fec00000, 0x00000000ff300000, 0x00000000ff300000)
[0.100s][info][gc,heap,exit ]   eden space 3584K,  88% used [0x00000000fec00000, 0x00000000fef1cc00, 0x00000000fef80000)
[0.100s][info][gc,heap,exit ]   from space 1792K,  57% used [0x00000000ff140000, 0x00000000ff2402a0, 0x00000000ff300000)
[0.100s][info][gc,heap,exit ]   to   space 1792K,   0% used [0x00000000fef80000, 0x00000000fef80000, 0x00000000ff140000)
[0.100s][info][gc,heap,exit ]  tenured generation   total 13312K, used 728K [0x00000000ff300000, 0x0000000100000000, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]    the space 13312K,   5% used [0x00000000ff300000, 0x00000000ff3b61f8, 0x00000000ff3b6200, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]  Metaspace       used 6034K, capacity 6091K, committed 6272K, reserved 1056768K
[0.100s][info][gc,heap,exit ]   class space    used 518K, capacity 538K, committed 640K, reserved 1048576K
</code></pre>
<p>此参数下，<code>eden区</code>有足够的空间，所有数组分配在<code>eden</code>区，但是不足以预留<code>10M</code>空间，因此产生了<code>GC</code>，每次申请空间也废弃了上一次申请的空间，在新生代<code>GC</code>中有效回收了这些内存，最后的结果是所有内存分配都在新生代进行，只是在<code>GC</code>过程中部分新生代对象晋升到了老年代。</p>
<p>再次增大新生代，使用<code>-Xmn15m -XX:SurvivorRatio=8</code>（其他参数不变），输出如下：</p>
<pre><code class="language-bash">[0.003s][info][gc] Using Serial
[0.003s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
start
[0.097s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(0) DefNew: 11416K-&gt;1471K(13696K)
[0.099s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;294K(5312K)
[0.099s][info][gc,metaspace ] GC(0) Metaspace: 6103K-&gt;6103K(1056768K)
[0.099s][info][gc           ] GC(0) Pause Young (Allocation Failure) 11M-&gt;1M(18M) 2.322ms
[0.099s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.01s
end
[0.099s][info][gc,heap,exit ] Heap
[0.099s][info][gc,heap,exit ]  def new generation   total 13696K, used 2934K [0x00000000fec00000, 0x00000000ffad0000, 0x00000000ffad0000)
[0.099s][info][gc,heap,exit ]   eden space 12224K,  11% used [0x00000000fec00000, 0x00000000fed6d908, 0x00000000ff7f0000)
[0.099s][info][gc,heap,exit ]   from space 1472K,  99% used [0x00000000ff960000, 0x00000000ffacfff8, 0x00000000ffad0000)
[0.099s][info][gc,heap,exit ]   to   space 1472K,   0% used [0x00000000ff7f0000, 0x00000000ff7f0000, 0x00000000ff960000)
[0.099s][info][gc,heap,exit ]  tenured generation   total 5312K, used 294K [0x00000000ffad0000, 0x0000000100000000, 0x0000000100000000)
[0.099s][info][gc,heap,exit ]    the space 5312K,   5% used [0x00000000ffad0000, 0x00000000ffb19960, 0x00000000ffb19a00, 0x0000000100000000)
[0.099s][info][gc,heap,exit ]  Metaspace       used 6164K, capacity 6251K, committed 6528K, reserved 1056768K
[0.099s][info][gc,heap,exit ]   class space    used 532K, capacity 570K, committed 640K, reserved 1048576K
</code></pre>
<p>可以看到新生代使用<code>15M</code>空间，<code>eden区</code>占了<code>12288K</code>，完全满足了<code>10MB</code>需要，并没有发生<code>GC</code>（日志的<code>GC</code>只是在<code>for</code>循环结束后产生的，一次性回收了<code>10M</code>）。</p>
<p>实际工作中，应根据系统的特点，做合理的设置，基本策略是：</p>
<ul>
<li>尽可能将对象预留在新生代</li>
<li>减少老年代<code>GC</code>次数</li>
</ul>
<p>另外，可以使用<code>-XX:NewRatio=老年代/新生代</code>指定新生代和老年代的比例，比如使用参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms20m
-XX:NewRatio=2
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">[0.005s][info][gc] Using Serial
[0.005s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.096s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.097s][info][gc,heap      ] GC(0) DefNew: 4852K-&gt;639K(6144K)
[0.097s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;1112K(13696K)
[0.097s][info][gc,metaspace ] GC(0) Metaspace: 5905K-&gt;5905K(1056768K)
[0.097s][info][gc           ] GC(0) Pause Young (Allocation Failure) 4M-&gt;1M(19M) 1.413ms
[0.097s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.00s
[0.098s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(1) DefNew: 5920K-&gt;0K(6144K)
[0.099s][info][gc,heap      ] GC(1) Tenured: 1112K-&gt;2776K(13696K)
[0.099s][info][gc,metaspace ] GC(1) Metaspace: 5970K-&gt;5970K(1056768K)
[0.099s][info][gc           ] GC(1) Pause Young (Allocation Failure) 6M-&gt;2M(19M) 1.129ms
[0.099s][info][gc,cpu       ] GC(1) User=0.00s Sys=0.01s Real=0.00s
[0.100s][info][gc,heap,exit ] Heap
[0.100s][info][gc,heap,exit ]  def new generation   total 6144K, used 2238K [0x00000000fec00000, 0x00000000ff2a0000, 0x00000000ff2a0000)
[0.100s][info][gc,heap,exit ]   eden space 5504K,  40% used [0x00000000fec00000, 0x00000000fee2f690, 0x00000000ff160000)
[0.100s][info][gc,heap,exit ]   from space 640K,   0% used [0x00000000ff160000, 0x00000000ff160398, 0x00000000ff200000)
[0.100s][info][gc,heap,exit ]   to   space 640K,   0% used [0x00000000ff200000, 0x00000000ff200000, 0x00000000ff2a0000)
[0.100s][info][gc,heap,exit ]  tenured generation   total 13696K, used 2776K [0x00000000ff2a0000, 0x0000000100000000, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]    the space 13696K,  20% used [0x00000000ff2a0000, 0x00000000ff556250, 0x00000000ff556400, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]  Metaspace       used 5998K, capacity 6091K, committed 6272K, reserved 1056768K
[0.100s][info][gc,heap,exit ]   class space    used 517K, capacity 538K, committed 640K, reserved 1048576K
</code></pre>
<p>堆大小为<code>20M</code>，新生代和老年代的比为<code>1:2</code>，因此新生代大小约为<code>7M</code>，老年代为<code>13M</code>，分配<code>1M</code>时，由于<code>from/to</code>空间不足，导致两个<code>1MB</code>的数组进入了老年代。</p>
<h2 id="43-堆溢出处理">4.3 堆溢出处理</h2>
<p>如果在<code>Java</code>程序运行过程中，堆空间不足，会抛出内存溢出错误，也就是常见的<code>OOM</code>。想要分析原因，可以使用参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>，可以在内存溢出时导出整个堆的信息，配合使用的还有<code>-XX:HeapDumpPath</code>，指定导出堆的存放路径，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 25; i++) {
        list.add(new byte[1*1024*1024]);
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms5m
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=out.dump
</code></pre>
<p>例子分配了<code>25M</code>的内存，但是堆只有<code>20M</code>，会抛出<code>OOM</code>，并且文件保存到<code>out.dump</code>中，注意该文件是二进制文件，需要使用专业的工具（如<code>MAT</code>等）查看。</p>
<h1 id="5-非堆参数">5 非堆参数</h1>
<h2 id="51-方法区">5.1 方法区</h2>
<p>从<code>JDK8</code>开始，永久区被移除，使用了新的元数据区来存放类的元数据，默认情况下，元数据区受系统可用内存的限制，但是仍然可以使用<code>-XX:MaxMetaspaceSize</code>指定永久区的最大可用值。</p>
<h2 id="52-栈">5.2 栈</h2>
<p>栈是每个线程私有的空间，可以使用<code>-Xss</code>指定线程的栈大小，具体在<a href="https://blog.csdn.net/qq_27525611/article/details/114308179?spm=1001.2014.3001.5501">笔者之前的文章中</a>。</p>
<h2 id="53-直接内存">5.3 直接内存</h2>
<p>直接内存跳过了<code>Java堆</code>，可以使得程序直接访问原生堆空间，在一定程度上加快了内存空间的访问速度。最大可用直接内存可以使用<code>-XX:MaxDirectMemorySize</code>设置，如果不设置，默认为最大堆空间，即<code>-Xmx</code>的值，当直接内存使用量到达最大值时，会触发<code>GC</code>，如果<code>GC</code>后不能有效释放足够的空间，直接内存依然会引起系统的<code>OOM</code>。</p>
<p>下面测试一下直接内存与堆的速度：</p>
<pre><code class="language-java">public class Main {

    public static final int count = 1000000;

    public static void directAccess(){
        long start = System.currentTimeMillis();
        ByteBuffer b = ByteBuffer.allocateDirect(500);
        for(int i=0;i&lt;count;++i){
            for (int j = 0; j &lt; 99; j++) {
                b.putInt(j) ;
            }
            b.flip();
            for (int j = 0; j &lt; 99; j++) {
                b.getInt();
            }
            b.clear();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Direct access: &quot;+(end-start)+&quot; ms&quot;);
    }

    public static void bufferAccess(){
        long start = System.currentTimeMillis();
        ByteBuffer b = ByteBuffer.allocate(500);
        for(int i=0;i&lt;count;++i){
            for (int j = 0; j &lt; 99; j++) {
                b.putInt(j) ;
            }
            b.flip();
            for (int j = 0; j &lt; 99; j++) {
                b.getInt();
            }
            b.clear();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Buffer access: &quot;+(end-start)+&quot; ms&quot;);
    }


    public static void main(String[] args){
        directAccess();
        bufferAccess();

        directAccess();
        bufferAccess();
    }
}
</code></pre>
<p>输出（不带任何参数）：</p>
<pre><code class="language-bash">Direct access: 167 ms
Buffer access: 70 ms
Direct access: 176 ms
Buffer access: 67 ms
</code></pre>
<p>直接内存的访问速度要快于堆内存，但是有一个缺点就是申请的时候速度慢：</p>
<pre><code class="language-java">public static void directAllocate(){
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; count; i++) {
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1000);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Direct allocate: &quot;+(end-start)+&quot; ms&quot;);
}

public static void bufferAllocate(){
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; count; i++) {
        ByteBuffer byteBuffer = ByteBuffer.allocate(1000);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Buffer allocate: &quot;+(end-start)+&quot; ms&quot;);
}


public static void main(String[] args){
    directAllocate();
    bufferAllocate();

    directAllocate();
    bufferAllocate();
}
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Direct allocate: 867 ms
Buffer allocate: 287 ms
Direct allocate: 676 ms
Buffer allocate: 208 ms
</code></pre>
<p>简单来说，直接内存适合申请次数较少、访问较频繁的场合，如果需要频繁申请内存空间，并不适合使用直接内存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第264期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-264-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-264-qi/">
        </link>
        <updated>2021-03-05T03:46:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>穷不要紧，抬头挺胸让大家看看，你不仅穷还丑还矮。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>斜风细雨作春寒，对尊前，忆前欢。<br>
——朱淑真《江城子·赏春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果不被畏惧，神又何以为神。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节面试流程概览]]></title>
        <id>https://2293736867.github.io/post/zi-jie-mian-shi-liu-cheng-gai-lan/</id>
        <link href="https://2293736867.github.io/post/zi-jie-mian-shi-liu-cheng-gai-lan/">
        </link>
        <updated>2021-03-04T00:24:52.000Z</updated>
        <content type="html"><![CDATA[<p><s>很水的一篇，勿喷。。。。</s></p>
<h1 id="1-流程">1 流程</h1>
<ul>
<li>网申</li>
<li>网测</li>
<li>面试</li>
<li>入职</li>
</ul>
<h1 id="2-网申">2 网申</h1>
<p>先头先筛，建议早点投但不用太早。</p>
<p>至于内推，本质上是没有什么区别，也是需要经历面试等阶段，只是企业的一种多渠道招人手段。</p>
<p>网申选岗阶段，可以选两个岗位，彼此独立，不限制投递时间。</p>
<p>可以根据不同的岗位准备不同的简历。</p>
<h1 id="3-网测">3 网测</h1>
<p>技术岗位的网测包括：</p>
<ul>
<li>编程题</li>
<li>单选题</li>
<li>多选题</li>
</ul>
<p>建议的策略是提前了解题型，掌握解题思路，针对性练习。</p>
<h1 id="4-面试">4 面试</h1>
<p>面试分为单面与群面。</p>
<h2 id="41-单面">4.1 单面</h2>
<p>一般3轮：</p>
<ul>
<li>部门经理：考察岗位胜任力（也就是技术）以及是否招人喜欢（面试技巧）</li>
<li>部门总监：岗位胜任力（深层），以及是否招人喜欢（面试技巧）</li>
<li><code>HR</code>：动机、忠诚度</li>
</ul>
<p>建议策略：</p>
<ul>
<li>经历提炼（写好简历）</li>
<li>提前准备</li>
<li>面试必考问题提前准备，不断打磨优化</li>
</ul>
<p>难点：</p>
<ul>
<li>经历讲不明白</li>
<li>讲的经历面试官不感兴趣</li>
</ul>
<p>总结：</p>
<ul>
<li>不准备：99%挂</li>
<li>准备了：未必能过，因为有可能别人比你准备得更好，与分数线同一个道理，你的分数比人低，自然上不去</li>
</ul>
<h2 id="42-群面">4.2 群面</h2>
<p>群面就是把一群面试者组成一个团队去进行面试。</p>
<p>群面不一定要当<code>Leader</code>，<a href="https://www.zhihu.com/question/339135205/answer/781010654">参考</a>。</p>
<p>群面需要找准自己的定位，如果你认为自己适合当<code>Leader</code>，那就争取<code>Leader</code>的角色。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第263期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-263-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-263-qi/">
        </link>
        <updated>2021-03-03T23:14:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>据说到2021年，要消灭贫困人口，我还不想死。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>晓日压重檐，头帐春寒起来忺。<br>
——孙道绚《南乡子·春闺》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>人总是害怕死亡，却殊不知有出生之时必有死亡之日。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（二）：JVM基本结构]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/">
        </link>
        <updated>2021-03-03T09:17:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-jvm%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></a></li>
<li><a href="#3-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">3 <code>JVM</code>基本结构</a></li>
<li><a href="#4-java%E5%A0%86">4 <code>Java堆</code></a></li>
<li><a href="#5-java%E6%A0%88">5 <code>Java栈</code></a>
<ul>
<li><a href="#51-%E7%AE%80%E4%BB%8B">5.1 简介</a></li>
<li><a href="#52-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">5.2 局部变量表</a>
<ul>
<li><a href="#521-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%AF%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.1 参数数量对局部变量表的影响</a></li>
<li><a href="#522-%E6%A7%BD%E4%BD%8D%E5%A4%8D%E7%94%A8">5.2.2 槽位复用</a></li>
<li><a href="#523-%E5%AF%B9gc%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.3 对<code>GC</code>的影响</a></li>
</ul>
</li>
<li><a href="#53-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%BA">5.3 操作数栈与帧数据区</a></li>
<li><a href="#54-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">5.4 栈上分配</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA">6 <code>方法区</code></a></li>
<li><a href="#7-java%E5%A0%86-java%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</a></li>
<li><a href="#8-%E5%B0%8F%E7%BB%93">8 小结</a></li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第二章</li>
</ul>
<p>本文是第二章的一些笔记整理。</p>
<h1 id="2-jvm基本参数-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></h1>
<p><code>java</code>命令的一般形式如下：</p>
<pre><code class="language-bash">java [-options] class [args..]
</code></pre>
<p>其中<code>-options</code>表示<code>JVM</code>启动参数，<code>class</code>为带有<code>main()</code>的<code>Java</code>类，<code>args</code>表示传递给<code>main()</code>的参数，也就是<code>main(String [] args)</code>中的参数。</p>
<p>一般设置参数在<code>-optinos</code>处设置，先看一段简单的代码：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        for(int i=0;i&lt;args.length;++i) {
            System.out.println(&quot;argument &quot;+(i+1)+&quot; : &quot;+args[i]);
        }
        System.out.println(&quot;-Xmx &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot; M&quot;);
    }
}
</code></pre>
<p>设置应用程序参数以及<code>JVM</code>参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2021030313324746.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输出：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210303133306902.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到<code>-Xmx32m</code>传递给<code>JVM</code>，使得最大可用堆空间为<code>32MB</code>，参数<code>a</code>作为应用程序参数，传递给<code>main()</code>，此时<code>args.length</code>的值为1。</p>
<h1 id="3-jvm基本结构">3 <code>JVM</code>基本结构</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210303134417147.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>各部分介绍如下：</p>
<ul>
<li><code>类加载子系统</code>：负责从文件系统或者网络中加载<code>Class</code>信息，加载的类信息存放在一个叫<code>方法区</code>的内存空间中</li>
<li><code>方法区</code>：除了包含加载的类信息之外，还包含运行时常量池信息，包括字符串字面量以及数字常量</li>
<li><code>Java堆</code>：在虚拟机启动时建立，是最主要的内存工作区域，几乎所有的<code>Java</code>对象实例都存在于<code>Java堆</code>中，<strong>堆空间是所有线程共享的</strong></li>
<li><code>直接内存</code>：是在<code>Java堆</code>外的，直接向系统申请的内存区域。<code>NIO</code>库允许<code>Java</code>程序使用<code>直接内存</code>，通常<code>直接内存</code>的访问速度要优于<code>Java堆</code>。另外由于<code>直接内存</code>在堆外，大小不会受限于<code>-Xmx</code>指定的堆大小，但是会受到操作系统总内存大小的限制</li>
<li><code>垃圾回收系统</code>：可以对<code>方法区</code>、<code>Java堆</code>和<code>直接内存</code>进行回收，<code>Java堆</code>是垃圾收集器的工作重点。对于不再使用的垃圾对象，<code>垃圾回收系统</code>会在后台默默工作、默默查找，标识并释放垃圾对象</li>
<li><code>Java栈</code>：每个<code>JVM</code>线程都有一个私有的<code>Java栈</code>，一个线程的<code>Java栈</code>在线程创建时被创建，保存着帧信息、局部变量、方法参数等</li>
<li><code>本地方法栈</code>：与<code>Java栈</code>类似，不同的是<code>Java栈</code>用于<code>Java</code>方法调用，<code>本地方法栈</code>用于本地方法（<code>native method</code>）调用，<code>JVM</code>允许<code>Java</code>直接调用本地方法</li>
<li><code>PC寄存器</code>：每个线程私有的空间，<code>JVM</code>会为每个线程创建<code>PC寄存器</code>，在任意时刻一个<code>Java</code>线程总是执行一个叫做<code>当前方法</code>的方法，如果<code>当前方法</code>不是本地方法，<code>PC</code>寄存器就会指向当前正在被执行的指令，如果<code>当前方法</code>是本地方法，那么<code>PC寄存器</code>的值就是<code>undefined</code></li>
<li><code>执行引擎</code>：负责执行<code>JVM</code>的字节码，现代<code>JVM</code>为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行</li>
</ul>
<p>下面重点说三部分：<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>。</p>
<h1 id="4-java堆">4 <code>Java堆</code></h1>
<p>几乎所有的对象都存在<code>Java堆</code>中，根据垃圾回收机制的不同，<code>Java堆</code>可能拥有不同的结构，最常见的一种是将整个<code>Java堆</code>分为<code>新生代</code>和<code>老年代</code>：</p>
<ul>
<li><code>新生代</code>：存放新生对象或年龄不大的对象，有可能分为<code>eden</code>、<code>s0</code>、<code>s1</code>，其中<code>s0</code>和<code>s1</code>分别被称为<code>from</code>和<code>to</code>区域，它们是两块大小相等、可以互换角色的内存空间</li>
<li><code>老年代</code>：存放老年对象，绝大多数情况下，对象首先在<code>eden</code>分配，在一次新生代回收后，如果对象还存活，会进入<code>s0</code>或<code>s1</code>，之后每经过一次新生代回收，如果对象存活则年龄加1。当对象年龄到达一定条件后，会被认为是老年对象，就会进入老年代</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210303134441993.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-java栈">5 <code>Java栈</code></h1>
<h2 id="51-简介">5.1 简介</h2>
<p><code>Java栈</code>是一块线程私有的内存空间，如果是<code>Java堆</code>与程序数据密切相关，那么<code>Java栈</code>和线程执行密切相关，线程执行的基本行为是函数调用，每次函数调用都是通过<code>Java栈</code>传递的。</p>
<p><code>Java栈</code>与数据结构中的<code>栈</code>类似，有<code>FIFO</code>的特点，在<code>Java</code>栈中保存的主要内容为<strong>栈帧</strong>，每次函数调用都会有一个对应的<code>栈帧</code>入栈，每次调用结束就有一个对应的<code>栈帧</code>出栈。栈顶总是当前的帧（当前执行的函数所对应的帧）。栈帧保存着<code>局部变量表</code>、<code>操作数栈</code>、<code>帧数据</code>等。</p>
<p>这里说一下题外话，相信很多读者对<code>StackOverflowError</code>不陌生，这是因为函数调用过多造成的，因为每次函数调用都会生成对应的栈帧，会占用一定的栈空间，如果栈空间不足，函数调用就无法进行，当请求栈深度大于最大可用栈深度时，就会抛出<code>StackOverflowError</code>。</p>
<p><code>JVM</code>提供了<code>-Xss</code>来指定线程的最大栈空间。</p>
<p>比如，下面这个递归调用的程序：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
            recursion();
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
        }
    }
}
</code></pre>
<p>指定<code>-Xss1m</code>，结果：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210303141441656.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss2m</code>：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210303141344772.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss3m</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210303141413662.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到调用深度随着<code>-Xss</code>的增加而增加。</p>
<h2 id="52-局部变量表">5.2 局部变量表</h2>
<p>局部变量表是栈帧的重要组成部分之一，用于保存函数的参数及局部变量。局部变量表中的变量只在当前函数调用中有效，函数调用结束后，函数栈帧销毁，局部变量表也会随之销毁。</p>
<h3 id="521-参数数量对局部变量表的影响">5.2.1 参数数量对局部变量表的影响</h3>
<p>由于局部变量表在栈帧中，如果函数的参数和局部变量表较多，会使局部变量表膨胀，导致栈帧会占用更多的栈空间，最终减少了函数嵌套调用次数。</p>
<p>比如：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(long a,long b,long c){
        long e=1,f=2,g=3,h=4,i=5,k=6,q=7;

        count++;
        recursion(a,b,c);
    }

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
//            recursion();
            recursion(0L,1L,2L);
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
            count = 0;
        }
    }
}
</code></pre>
<p>无参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210303145401403.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>带参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210303145451827.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到次数明显减少了，原因正是因为局部变量表变大，导致栈帧变大，从而次数减少。</p>
<p>下面使用<code>jclasslib</code>进一步查看，先在<code>IDEA</code>安装如下插件：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210303145242291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装后使用插件查看情况：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20210303145931511.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第一个函数是带参数的，可以看到最大局部变量表的大小为<code>20字</code>（注意不是字节），<code>Long</code>在局部变量表中需要占用2字。而相比之下不带参数的函数最大局部变量表大小为0：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210303150723100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-槽位复用">5.2.2 槽位复用</h3>
<p>局部变量表中的槽位是可以复用的，如果一个局部变量超过了其作用域，则在其作用域之后的局部变量就有可能复用该变量的槽位，这样能够节省资源，比如：</p>
<pre><code class="language-java">public static void localVar1(){
    int a = 0;
    System.out.println(a);
    int b = 0;
}

public static void localVar2(){
    {
        int a = 0;
        System.out.println(a);
    }
    int b = 0;
}
</code></pre>
<p>同样使用<code>jclasslib</code>查看：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210303151315773.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210303151328196.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到少了<code>localVar2</code>的最大局部变量大小为1字，相比<code>localVar1</code>少了1字，继续分析，<code>localVar1</code>第0个槽位为变量a，第1个槽位为变量b：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210303151544872.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而<code>localVar2</code>中的b复用了a的槽位，因此最大变量大小为1字，节约了空间。</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210303151611143.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="523-对gc的影响">5.2.3 对<code>GC</code>的影响</h3>
<p>下面再来看一下局部变量表对垃圾回收的影响，示例：</p>
<pre><code class="language-java">public class Main {
    public static void localGC1(){
        byte [] a = new byte[6*1024*1024];
        System.gc();
    }

    public static void localGC2(){
        byte [] a = new byte[6*1024*1024];
        a = null;
        System.gc();
    }

    public static void localGC3(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        System.gc();
    }

    public static void localGC4(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        int c = 10;
        System.gc();
    }

    public static void localGC5(){
        localGC1();
        System.gc();
    }

    public static void main(String[] args) {
        System.out.println(&quot;-------------localGC1------------&quot;);
        localGC1();
        System.out.println();
        System.out.println(&quot;-------------localGC2------------&quot;);
        localGC2();
        System.out.println();
        System.out.println(&quot;-------------localGC3------------&quot;);
        localGC3();
        System.out.println();
        System.out.println(&quot;-------------localGC4------------&quot;);
        localGC4();
        System.out.println();
        System.out.println(&quot;-------------localGC5------------&quot;);
        localGC5();
        System.out.println();
    }
}
</code></pre>
<p>输出（请加上<code>-Xlog:gc</code>参数）：</p>
<pre><code class="language-bash">[0.004s][info][gc] Using G1
-------------localGC1------------
[0.128s][info][gc] GC(0) Pause Full (System.gc()) 10M-&gt;8M(40M) 12.081ms

-------------localGC2------------
[0.128s][info][gc] GC(1) Pause Young (Concurrent Start) (G1 Humongous Allocation) 9M-&gt;8M(40M) 0.264ms
[0.128s][info][gc] GC(2) Concurrent Cycle
[0.133s][info][gc] GC(3) Pause Full (System.gc()) 16M-&gt;0M(14M) 2.799ms
[0.133s][info][gc] GC(2) Concurrent Cycle 4.701ms

-------------localGC3------------
[0.133s][info][gc] GC(4) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(14M) 0.203ms
[0.133s][info][gc] GC(5) Concurrent Cycle
[0.135s][info][gc] GC(5) Pause Remark 8M-&gt;8M(22M) 0.499ms
[0.138s][info][gc] GC(6) Pause Full (System.gc()) 8M-&gt;8M(22M) 2.510ms
[0.138s][info][gc] GC(5) Concurrent Cycle 4.823ms

-------------localGC4------------
[0.138s][info][gc] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation) 8M-&gt;8M(22M) 0.202ms
[0.138s][info][gc] GC(8) Concurrent Cycle
[0.142s][info][gc] GC(9) Pause Full (System.gc()) 16M-&gt;0M(8M) 2.861ms
[0.142s][info][gc] GC(8) Concurrent Cycle 3.953ms

-------------localGC5------------
[0.143s][info][gc] GC(10) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(8M) 0.324ms
[0.143s][info][gc] GC(11) Concurrent Cycle
[0.145s][info][gc] GC(11) Pause Remark 8M-&gt;8M(16M) 0.316ms
[0.147s][info][gc] GC(12) Pause Full (System.gc()) 8M-&gt;8M(18M) 2.402ms
[0.149s][info][gc] GC(13) Pause Full (System.gc()) 8M-&gt;0M(8M) 2.462ms
[0.149s][info][gc] GC(11) Concurrent Cycle 6.843ms
</code></pre>
<p>首行输出表示使用<code>G1</code>，下面逐个进行分析：</p>
<ul>
<li><code>localGC1</code>：并没有回收内存，因为此时<code>byte</code>数组被变量<code>a</code>引用，因此无法回收</li>
<li><code>localGC2</code>：回收了内存，因为<code>a</code>被设置为了<code>null</code>，<code>byte</code>数组失去强引用</li>
<li><code>localGC3</code>：没有回收内存，虽然此时<code>a</code>变量已经失效，但是仍然存在于局部变量表中，并且指向<code>byte</code>数组，因此无法回收</li>
<li><code>localGC4</code>：回收了内存，因为声明了变量<code>c</code>，复用了<code>a</code>的槽位，导致<code>byte</code>数组失去引用，顺利回收</li>
<li><code>localGC5</code>：回收了内存，虽然<code>localGC1</code>中没有释放内存，但是返回到<code>localGC5</code>后，<code>localGC1</code>的栈帧被销毁，也包括其中的<code>byte</code>数组失去了引用，因此在<code>localGC5</code>中被回收</li>
</ul>
<h2 id="53-操作数栈与帧数据区">5.3 操作数栈与帧数据区</h2>
<p>操作数栈也是栈帧的重要内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，也是一个<code>FIFO</code>的数据结构。</p>
<p>而帧数据区则保存着常量池指针，方便程序访问常量池，此外，帧数据区也保存着异常处理表，以便在出现异常后，找到处理异常的代码。</p>
<h2 id="54-栈上分配">5.4 栈上分配</h2>
<p>栈上分配是<code>JVM</code>提供的一项优化技术，基本思想是，将线程私有的对象打散分配到栈上，好处是函数调用结束后可以自动销毁，而不需要垃圾回收器的介入，从而提高系统性能。</p>
<p>栈上分配的一个技术基础是逃逸分析，逃逸分析目的是判断对象的作用域是否会逃逸出函数体，例子如下：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
    }

    public static void alloc(){
        User user = new User();
        user.id = 5;
        user.name = &quot;test&quot;;
    }

    public static void main(String[] args) {
        long b = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000000; i++) {
            alloc();
        }
        long e = System.currentTimeMillis();
        System.out.println(e-b);
    }
}
</code></pre>
<p>启动参数：</p>
<pre><code class="language-bash">-server # 开启Server模式，此模式下才能开启逃逸分析
-Xmx10m # 最大堆内存
-Xms10m # 初始化堆内存
-XX:+DoEscapeAnalysis # 开启逃逸分析
-Xlog:gc # GC日志
-XX:-UseTLAB # 关闭TLAB
-XX:+EliminateAllocations # 开启标量替换，默认打开，允许将对象打散分配在栈上
</code></pre>
<p>输出如下，没有<code>GC</code>日志：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210303161826251.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果关闭了标量替换，也就是添加<code>-XX:-EliminateAllocations</code>，就可以看到会频繁触发<code>GC</code>，因为这时候对象存放在堆上而不是栈上，堆只有10m空间，会频繁进行<code>GC</code>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210303161747610.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-方法区">6 <code>方法区</code></h1>
<p>与<code>Java堆</code>一样，<code>方法区</code>是所有线程共享的内存区域，用于保存系统的类信息，比如类字段、方法、常量池等，<code>方法区</code>的大小决定了系统可以保存多少个类，如果定义了过多的类，会导致<code>方法区</code>溢出，会直接<code>OOM</code>。</p>
<p>在<code>JDK6/7</code>中<code>方法区</code>可以理解成<code>永久区</code>，<code>JDK8</code>后，<code>永久区</code>被移除，取而代之的是<code>元数据区</code>，可以使用<code>-XX:MaxMetaspaceSize</code>指定，这是一块堆外的直接内存，如果不指定大小，默认情况下<code>JVM</code>会耗尽所有可用的系统内存。</p>
<p>如果<code>元数据区</code>发生溢出，<code>JVM</code>会抛出<code>OOM</code>。</p>
<h1 id="7-java堆-java栈以及方法区的关系">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</h1>
<p>看完了<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>，最后来一段代码来简单分析一下它们的关系：</p>
<pre><code class="language-java">class SimpleHeap{
    private int id;
    public SimpleHeap(int id){
        this.id = id;
    }

    public void show(){
        System.out.println(&quot;id is &quot;+id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
        s1.show();
        s2.show();
    }
}
</code></pre>
<p><code>main</code>中创建了两个局部变量<code>s1</code>、<code>s2</code>，则这两个局部变量存放在<code>Java栈</code>中。同时这两个局部变量是<code>SimpleHeap</code>的实例，这两个实例存放在<code>Java堆</code>中，而其中的<code>show</code>方法，则存放在<code>方法区</code>中，图示如下：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210303135915895.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="8-小结">8 小结</h1>
<p>本文主要讲述了<code>JVM</code>的基本结构以及一些基础参数，基本结构可以分成三部分：</p>
<ul>
<li>第一部分：<code>类加载子系统</code>、<code>Java堆</code>、<code>方法区</code>、<code>直接内存</code></li>
<li>第二部分：<code>Java栈</code>、<code>本地方法栈</code>、<code>PC寄存器</code></li>
<li>第三部分：执行引擎</li>
</ul>
<p>而重点讲了三部分：</p>
<ul>
<li><code>Java堆</code>：常见的结构为<code>新生代</code>+<code>老年代</code>结构，其中新生代可分为<code>edsn</code>、<code>s0</code>、<code>s1</code></li>
<li><code>Java栈</code>：包括局部变量表、操作数栈与帧数据区，还提到了一个<code>JVM</code>优化技术栈上分配，可以通过<code>-XX:+EliminateAllocation</code>开启（默认开启）</li>
<li><code>方法区</code>：所有线程共享区域，用于保存类信息，比如类字段、方法、常量等</li>
</ul>
]]></content>
    </entry>
</feed>