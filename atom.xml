<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-08-02T03:32:44.569Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第46期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-46-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-46-qi/">
        </link>
        <updated>2020-08-03T02:31:22.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596335502108.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你要相信明天，一定会更好的，更好的把你虐成狗。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>当德国连锁超市ALDI的首席执行官西奥·阿尔布雷希特被绑架后，他不但向绑架者给自己的赎金砍了假，还在获释后在法庭上宣称这笔款项为可抵税商务开支。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>荷花五寸荷花娇，贴波不碍画船摇。<br>
——石涛《荷花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>因为痛苦太有价值，因为回忆太珍贵，所以我们更要继续往前走。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1359663981">это ли счастье? - Rauf &amp; Faik</a></p>
</blockquote>
<blockquote>
<p>В мире не осталось искренних чувств<br>
Я теперь иду и тут каждую боюсь<br>
Это ли счастье?<br>
Тут все погасло<br>
Это не счастье<br>
Не счастье<br>
Не счастье<br>
Это ли счастье?<br>
Тут все погасло<br>
Это не счастье<br>
Не счастье</p>
</blockquote>
<blockquote>
<p>Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги<br>
Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда<br>
В мире не осталось искренних чувств<br>
Я теперь иду и тут каждую боюсь<br>
Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги</p>
</blockquote>
<blockquote>
<p>Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда<br>
Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги<br>
Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда</p>
</blockquote>
<blockquote>
<p>Не возвращайся сюда<br>
Не возвращайся сюда<br>
Не возвращайся сюда<br>
Не возвращайся сюда</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第45期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-45-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-45-qi/">
        </link>
        <updated>2020-08-02T02:30:33.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596335472787.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>条条大路通罗马，每条都有收费站。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>美国的阿拉斯加州，亚利桑那州，印第安纳州，肯塔基州，宾夕法尼亚州，田纳西州，犹他州和西维吉尼亚州都拥有自己的官方州枪，分别从淡动式左轮手枪到半自动狙击步枪不一。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>但满目京尘，东风竟日吹露桃。<br>
——周邦彦《忆旧游·记愁横浅黛》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我不要你忘记他，我只要你记得我。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.hifini.com/thread-38828.htm">树藤-林欣彤</a></p>
</blockquote>
<blockquote>
<p>优雅的眼妆沿十条裂纹在割下<br>
我听见指甲尖在额头磨灭计划<br>
绝望能绝吗 愿望难道能望吗<br>
三千青丝一刹变白<br>
我不信天国一到海会枯顽石会烂<br>
我只信心瘾一到便亡命投入劫难<br>
若罪名是贪 但树藤何曾未贪<br>
高攀不起孤立亦难</p>
</blockquote>
<blockquote>
<p>Take on me<br>
this misery<br>
私有得彻底 情愿吸干你一切<br>
La la la la la la la la la la<br>
Cry for me<br>
and I'm sorry<br>
死结捆到底 情愿烧光我躯体<br>
飞灰撒下烂泥才高贵</p>
</blockquote>
<blockquote>
<p>舍弃一切换不到美丽<br>
得到安慰变不出地位<br>
我像蝼蚁<br>
不知道千秋更替蔷薇藏后世<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
<blockquote>
<p>凄美的血丝沿十条泪痕在抹下<br>
脑中有千个天使在扬善提示放下<br>
道别能别吗<br>
独活难道能活吗<br>
一堆枯骨飞不出一刹那<br>
我不信天国一到海会枯顽石会烂<br>
我只信心瘾一到便亡命投入劫难<br>
若罪名是贪<br>
但树藤何曾未贪<br>
Da la la la la la la la</p>
</blockquote>
<blockquote>
<p>Take on me<br>
this misery<br>
私有得彻底<br>
情愿吸干你一切<br>
La la la la la la la la la la<br>
Cry for me<br>
say I'm sorry<br>
死结捆到底<br>
情愿烧光我躯体<br>
飞灰撒下烂泥才高贵</p>
</blockquote>
<blockquote>
<p>舍弃一切换不到美丽<br>
得到安慰变不出地位<br>
我像蝼蚁<br>
不知道千秋更替蔷薇藏后世<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
<blockquote>
<p>任由萤火将我净化带着你牵挂<br>
或能尘归土种下世花<br>
不顾一切什么都美丽<br>
给你刻上最深的毒誓<br>
我像蝼蚁<br>
不知道千秋更替明媚留不低<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十九）：迭代器模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/">
        </link>
        <updated>2020-08-02T02:30:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8">2.2 抽象迭代器</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%81%9A%E5%90%88%E7%B1%BB">2.3 抽象聚合类</a></li>
<li><a href="#24-%E5%85%B7%E4%BD%93%E8%81%9A%E5%90%88%E7%B1%BB">2.4 具体聚合类</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E8%BF%AD%E4%BB%A3%E5%99%A8">2.5 具体迭代器</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0">4 内部类实现</a></li>
<li><a href="#5-jdk%E8%BF%AD%E4%BB%A3%E5%99%A8">5 JDK迭代器</a>
<ul>
<li><a href="#51-iterator">5.1 <code>Iterator</code></a></li>
<li><a href="#52-listiterator">5.2 <code>ListIterator</code></a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在软件开发中，有一些类可以存储多个成员对象（元素），这些类通常称为聚合类，对应的对象称为聚合对象。聚合对象拥有两个职责，一个是存储数据，一个是遍历数据，前者是聚合对象的基本职责，后者是可以变化以及分离的，因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，又迭代器来提供遍历聚合对象内部数据的行为。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>迭代器模式：提供一种方法来访问对象，而不用暴露这个对象的内部表示，别名叫游标。</strong></p>
<p>迭代器模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801013759371.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Iterator</code>（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，比如<code>first</code>（获取第一个元素），<code>next</code>（获取下一个元素），<code>hasNext</code>（判断是否有下一个元素），<code>currentItem</code>（获取当前元素）</strong></li>
<li><strong><code>ConcreteIterator</code>（具体迭代器）：实现了抽象迭代器，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录聚合对象中所处的当前位置，通常游标是一个非负整数</strong></li>
<li><strong><code>Aggregate</code>（抽象聚合类）：用于存储和管理元素对象，声明一个<code>createIterator</code>方法创建一个迭代器对象，充当抽象迭代器的工厂角色</strong></li>
<li><strong><code>ConcreteAggregate</code>（具体聚合类）：实现了抽象聚合类中的<code>createIterator</code>方法，返回一个具体迭代器实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象迭代器：一般为接口，声明具体迭代器的方法</li>
<li>定义抽象聚合类：一般为接口，包含管理聚合元素的方法以及创建抽象迭代器的方法</li>
<li>定义具体聚合类：内部创建集合存储聚合元素，在创建迭代器方法中将集合作为构造方法参数注入到具体迭代器中并返回该具体迭代器</li>
<li>定义具体迭代器类：实现抽象迭代器的方法，一般包含一个来自具体聚合类的集合引用以及一个表示元素位置的整型的游标</li>
</ul>
<h2 id="22-抽象迭代器">2.2 抽象迭代器</h2>
<pre><code class="language-java">interface Iterator
{
    String first();
    String next();
    boolean hasNext();
    String currentItem();
}
</code></pre>
<h2 id="23-抽象聚合类">2.3 抽象聚合类</h2>
<pre><code class="language-java">interface Aggregate
{
    Iterator createIterator();
    void add(String s);
}
</code></pre>
<p>创建迭代器通过<code>createIterator</code>，<code>add</code>用于增添元素。</p>
<h2 id="24-具体聚合类">2.4 具体聚合类</h2>
<pre><code class="language-java">class ConcreteAggregate implements Aggregate
{
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator createIterator()
    {
        return new ConcreteIterator(list);
    }
    @Override
    public void add(String s)
    {
        list.add(s);
    }
}
</code></pre>
<p>在创建迭代器方法中，通过构造方法把集合对象注入到具体迭代器中。</p>
<h2 id="25-具体迭代器">2.5 具体迭代器</h2>
<pre><code class="language-java">class ConcreteIterator implements Iterator
{
    private int cursor;
    private List&lt;String&gt; list;
    public ConcreteIterator(List&lt;String&gt; list)
    {
        this.list = list;
        this.cursor = -1;
    }

    @Override
    public String first()
    {
        return list.size() &gt; 0 ?
        list.get(cursor = 0) :
        null;
    }

    @Override
    public String next()
    {
        return list.get(
            cursor + 1 &lt; list.size() ? ++cursor : cursor
        );
    }

    @Override
    public boolean hasNext()
    {
        return cursor+1 &lt; list.size();
    }

    @Override
    public String currentItem()
    {
        return list.get(cursor);
    }
}
</code></pre>
<p>具体迭代器中包含了一个游标，用于记录当前访问的位置。构造方法中将游标初始化为-1而不是初始化为0，这样第一次使用<code>next</code>时便会访问第一个元素。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Aggregate aggregate = new ConcreteAggregate();
    aggregate.add(&quot;111&quot;);
    aggregate.add(&quot;222&quot;);
    aggregate.add(&quot;jksdfjksdjkfk&quot;);
    aggregate.add(&quot;m,xcvm,xcm,v&quot;);
    Iterator iterator = aggregate.createIterator();
    while(iterator.hasNext())
    {
        System.out.println(iterator.next());
    }
}
</code></pre>
<p>客户端针对抽象聚合类以及抽象迭代器编程，通过聚合对象创建迭代器后，首先使用<code>haxNext</code>判断，接着使用<code>next</code>获取其中元素。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个系统对客户数据以及商品数据进行遍历，使用迭代器模式进行设计。</p>
</blockquote>
<p>这个例子和上面的其实差不多，不过是反向迭代器方法，另外为了更贴近实际环境使用，抽象迭代器以及聚合类都使用了泛型设计：</p>
<ul>
<li>抽象迭代器：<code>Iterator&lt;T&gt;</code></li>
<li>抽象聚合类：<code>AbstarctList&lt;T&gt;</code></li>
<li>具体聚合类：<code>ObjectList&lt;T&gt;</code></li>
<li>具体迭代器：<code>ObjectIterator&lt;T&gt;</code></li>
<li>模拟产品以及顾客类：<code>Product</code>+<code>Customer</code></li>
</ul>
<p>首先设计抽象迭代器：</p>
<pre><code class="language-java">interface Iterator&lt;T&gt;
{
    T next();
    boolean hasNext();
    String nextName() throws UnsupportedOperationException;
    boolean hasNextName() throws UnsupportedOperationException;
    void setProduct();
}
</code></pre>
<p><code>nextName()</code>以及<code>hasNextName()</code>方法是对<code>Customer</code>类型生效的，对于<code>Product</code>会抛出异常。<code>setProduct()</code>表示设置聚合元素的类型为<code>Product</code>。</p>
<p>接着是抽象聚合类的设计：</p>
<pre><code class="language-java">interface AbstractList&lt;T&gt;
{
    Iterator&lt;T&gt; iterator();
    Iterator&lt;T&gt; reversedIterator();
    void add(T s);
}
</code></pre>
<p>添加了一个反向迭代器实现。</p>
<p>然后是具体聚合类的设计：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator&lt;T&gt;(list,false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator&lt;T&gt;(list,true);
    }
}
</code></pre>
<p>内部还有一个<code>List</code>存储聚合元素，<code>iterator</code>返回正向迭代器，构造方法里面的布尔值表示是否为反向迭代器，<code>reversedIterator</code>表示返回一个单向迭代器，与正向的唯一不同就是传入具体迭代器的构造方法中的布尔值。<code>true</code>表示是反向迭代器，否则是正向。</p>
<p>最后是具体迭代器类：</p>
<pre><code class="language-java">class ObjectIterator&lt;T&gt; implements Iterator&lt;T&gt;
{
    private int cursor;
    private List&lt;T&gt; list;
    private boolean reversed;
    private boolean isProduct = false;
    public ObjectIterator(List&lt;T&gt; list,boolean reversed)
    {
        this.list = list;
        this.reversed = reversed;
        this.cursor = (reversed ? list.size() : -1);
    }

    @Override
    public void setProduct()
    {
        isProduct = true;
    }

    @Override
    public T next()
    {
        return list.get(
            reversed ? 
            ( cursor - 1 &gt;= 0 ? --cursor : cursor ) :
            ( cursor + 1 &lt; list.size() ? ++cursor : cursor )
        );
    }

    @Override
    public boolean hasNext()
    {
        return reversed ?
        cursor-1 &gt;= 0 :
        cursor+1 &lt; list.size();
    }

    @Override
    public String nextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return ((Customer)next()).getName();
    }

    @Override
    public boolean hasNextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return hasNext();
    }
}
</code></pre>
<p>构造方法中初始化聚合元素以及一个布尔值<code>reversed</code>，表示是否为反向迭代器，游标根据<code>reversed</code>设置为<code>-1</code>或<code>list.size()</code>。对于<code>next</code>以及<code>hasNext</code>方法，都需要判断是否为反向迭代器，返回对应的结果。对于<code>nextName</code>以及<code>hasNextName</code>，由于这两个方法仅对<code>Customer</code>类生效，因此如果是<code>Product</code>类直接抛出异常。</p>
<p>其他：</p>
<pre><code class="language-java">class Product
{
    private String id;
    private int num;

    public Product(){}

    public Product(String id,int num) {
        this.id = id;
        this.num = num;
    }

    public String getId() {
        return this.id;
    }

    public int getNum() {
        return this.num;
    }

    @Override
    public String toString()
    {
        return &quot;商品id:&quot;+id+&quot;\t商品数量:&quot;+num;
    }
}

class Customer
{
    private String id;
    private String name;

    public Customer(String id,String name)
    {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    @Override
    public String toString()
    {
        return &quot;顾客id:&quot;+id+&quot;\t顾客名字:&quot;+name;
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Customer customer1 = new Customer(&quot;id1&quot;,&quot;name1&quot;);
    Customer customer2 = new Customer(&quot;id2&quot;,&quot;name2&quot;);
    Customer customer3 = new Customer(&quot;id3&quot;,&quot;name3&quot;);
    AbstractList&lt;Customer&gt; customerList = new ObjectList&lt;&gt;();
    customerList.add(customer1);
    customerList.add(customer2);
    customerList.add(customer3);

    Iterator&lt;Customer&gt; customerIterator = customerList.iterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    System.out.println();

    customerIterator = customerList.iterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    System.out.println();
        
    Product product1 = new Product(&quot;product id 1&quot;,1);
    Product product2 = new Product(&quot;product id 2&quot;,2);
    Product product3 = new Product(&quot;product id 3&quot;,3);
    AbstractList&lt;Product&gt; productList = new ObjectList&lt;&gt;();
    productList.add(product1);
    productList.add(product2);
    productList.add(product3);

    Iterator&lt;Product&gt; productIterator = productList.iterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    productIterator = productList.reversedIterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    System.out.println();
    try
    {
        productIterator = productList.iterator();
        productIterator.setProduct();
        while(productIterator.hasNextName())
            System.out.println(productIterator.nextName());
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}
</code></pre>
<p>首先创建了三个<code>Customer</code>，接着添加到<code>customerList</code>中，从<code>customerList</code>中的<code>iterator</code>获取正向迭代器以及从<code>reversedIterator</code>获取正向迭代器，两种遍历方式的迭代器可以使用同样的语句实现遍历：</p>
<pre><code class="language-java">while(customerIterator.hasNext())
	System.out.println(customerIterator.next());
</code></pre>
<p>对于<code>Product</code>，由于<code>hasNextName</code>以及<code>nextName</code>声明了抛出异常，因此测试输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801135447573.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-内部类实现">4 内部类实现</h1>
<p>上面的例子可以看到在具体聚合类以及具体迭代器之间存在关联关系，具体迭代器需要维持一个对具体聚合对象（或里面的集合）的引用，除了使用关联关系外，还可以将迭代器设计为聚合类的内部类，比如JDK中的<code>AbstractList</code>：</p>
<pre><code class="language-java">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {
	//...
	private class Itr implements Iterator&lt;E&gt; {
		//...
	}
	//...
}
</code></pre>
<p>使用类似的方式重新设计上面的例子：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator(false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator(true);
    }

    private class ObjectIterator implements Iterator&lt;T&gt;
    {
        private int cursor;
        private boolean reversed;
        private boolean isProduct = false;
        public ObjectIterator(boolean reversed)
        {
            this.reversed = reversed;
            this.cursor = (reversed ? list.size() : -1);
        }
        //...
    }
}
</code></pre>
<p>改变的就是具体迭代器的构造方法，不需要注入聚合对象了，另外也取消了泛型的声明。</p>
<h1 id="5-jdk迭代器">5 JDK迭代器</h1>
<h2 id="51-iterator">5.1 <code>Iterator</code></h2>
<p>JDK（OpenJDK11.0.2）中的<code>Collection</code>方法摘录如下：</p>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
	//...
	Iterator&lt;E&gt; iterator();
	//...
}
</code></pre>
<p>该方法用于返回一个迭代器，以便遍历聚合类中的元素，其中<code>Iterator</code>定于如下：</p>
<pre><code class="language-java">public interface Iterator&lt;E&gt; {
	boolean hasNext();
	E next();
	default void remove() {
		//...
	}
	default void forEachRemaining(Consumer&lt;? super E&gt; action) {
		//...
	}
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>hasNext</code>：用于判断聚合对象是否存在下一个元素，需要在调用<code>next</code>之前调用</li>
<li><code>next</code>：将下标移至下一个元素，并返回游标所越过的那个元素的引用，也就是获取下一个元素</li>
<li><code>remove</code>：删除上一次<code>next</code>的返回的元素</li>
<li><code>forEachRemaining</code>：用于对剩余元素进行的操作，比如一个集合有10个元素，使用迭代器遍历了前5个，则使用该方法会遍历剩下的元素，也就是后5个</li>
</ul>
<p>Java迭代器原理如图：<br>
<img src="https://img-blog.csdnimg.cn/2020080115523623.png" alt="在这里插入图片描述" loading="lazy"><br>
第一个<code>next</code>被调用时，迭代器游标由0号位置移到1号位置，也就是移动到元素1以及元素2之间，接着返回游标越过的元素，也就是元素1。下一次调用<code>next</code>时，游标继续移动，从1号位置移动到2号位置，并返回越过的元素，也就是元素2。对于<code>remove</code>来说，删除上一次<code>next</code>返回的元素，也就是如果此时调用<code>remove</code>会删除元素2。</p>
<p>也就是在调用<code>remove</code>之前至少需要调用一次<code>next</code>，如果不调用<code>next</code>的话，会抛出异常：<br>
<img src="https://img-blog.csdnimg.cn/20200801155359430.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-listiterator">5.2 <code>ListIterator</code></h2>
<p>JDK中的<code>List</code>接口除了继承<code>Collection</code>接口的<code>iterator</code>外，还增加一个<code>listIterator</code>，专门用于创建<code>ListIterator</code>类型的迭代器。用于遍历集合已经有了<code>Iterator</code>，但是这个迭代器只能用于正向遍历，而<code>ListIterator</code>的出现能解决逆向遍历的问题，因为其中提供了<code>hasPrevious</code>以及<code>previous</code>等方法。例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;String&gt; s = new ArrayList&lt;&gt;();
    s.add(&quot;1111&quot;);
    s.add(&quot;2222&quot;);
    s.add(&quot;3333&quot;);
    ListIterator&lt;String&gt; it = s.listIterator();
    while(it.hasNext())
        System.out.println(it.next());
    System.out.println();
    while(it.hasPrevious())
        System.out.println(it.previous());
}
</code></pre>
<p>实现完整的逆向遍历时，需要先将游标移动到末尾，也就是不断调用<code>next</code>直到末尾，才能实现调用<code>previous</code>进行逆向遍历。</p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>多种遍历方式：支持以不同方式遍历聚合对象，在同一聚合对象上可以定义多种遍历方法，只需要用一个不同的聚合器替换原来的迭代器即可改变遍历算法</li>
<li>简化聚合类：原有的聚合对象不需要再自行提供数据遍历方法</li>
<li>满足OCP：由于引入了抽象层，增加新的聚合类以及迭代器类都很方便，无须修改源码</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>复杂度增加：迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，增加了复杂性</li>
<li>抽象迭代器较难设计：考虑到以后的扩展，抽象迭代器的设计难度可能非常大，比如JDK的内置迭代器<code>Iterator</code>就无法实现逆向遍历，设计一个考虑全面的抽象迭代器并不是一件容易的事</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据存储分离，使得访问聚合对象时无须了解内部实现细节</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020080116201951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十八）：解释器模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/">
        </link>
        <updated>2020-08-02T02:30:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">1.2 相关术语</a>
<ul>
<li><a href="#121-%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99">1.2.1 文法规则</a></li>
<li><a href="#122-bnf%E7%AC%A6%E5%8F%B7">1.2.2 BNF符号</a></li>
<li><a href="#123-%E7%BB%88%E7%BB%93%E7%AC%A6%E4%B8%8E%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6">1.2.3 终结符与非终结符</a></li>
<li><a href="#124-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91">1.2.4 抽象语法树</a></li>
</ul>
</li>
<li><a href="#13-%E5%AE%9A%E4%B9%89">1.3 定义</a></li>
<li><a href="#14-%E7%BB%93%E6%9E%84%E5%9B%BE">1.4 结构图</a></li>
<li><a href="#15-%E8%A7%92%E8%89%B2">1.5 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.2 环境类</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.3 抽象表达式</a></li>
<li><a href="#24-%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.4 终结符表达式</a></li>
<li><a href="#25-%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.5 非终结符表达式</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95">4 扩展</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>解释器模式是一种使用频率较低但是学习难度较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。某些情况下可能需要自定义一个新语言，这种语言具有自己的文法规则，这时可以使用解释器模式进行设计，比如模拟机器人的控制程序，每一条指令对应一个动作，通过解释输入的指令来实现对机器人的控制。下面先来看一些术语定义。</p>
<h2 id="12-相关术语">1.2 相关术语</h2>
<h3 id="121-文法规则">1.2.1 文法规则</h3>
<p>文法规则是用于描述语言的语法的规则，比如，汉语中一个句子的文法规则为：</p>
<pre><code class="language-bash">主 谓 宾
</code></pre>
<p>这就是句子的文法规则，同样计算机语言也有自己的文法规则。</p>
<h3 id="122-bnf符号">1.2.2 BNF符号</h3>
<p>BNF是<code>Backus-Naur Form</code>的缩写，是由<code>John Backus</code>以及<code>Peter Naur</code>首次引入的一种形式化符号来描述给定语言的语法，BNF中定义的部分符号如下：</p>
<ul>
<li><code>::=</code>：表示<code>定义为</code>，左边的语言单位可以通过右边进行说明和定义</li>
<li><code>|</code>：表示<code>或者</code></li>
<li><code>&quot;</code>或<code>'</code>：双引号或单引号里面的字符串表示字符串本身</li>
</ul>
<h3 id="123-终结符与非终结符">1.2.3 终结符与非终结符</h3>
<p>在以下的模拟描述机器人移动的文法规则中：</p>
<pre><code class="language-bash">expression ::= direction action distance | composite   //表达式
composite ::= expression 'and' expression              //复合表达式
direction ::= 'up' | 'down' | 'left'| 'right'          //移动方向
action ::= 'move' | 'run'                              //移动方式
distance ::= an integer                                //移动距离
</code></pre>
<p>定义了5条文法规则，对应5个语言单位，这些语言单位可以分为：</p>
<ul>
<li>终结符（也叫终结符表达式）：语言的最小组成单位，不能再拆分，比如上面的<code>direction</code>或<code>action</code></li>
<li>非终结符（也叫非终结符表达式）：一个完整的句子，包含一些列终结符或非终结符</li>
</ul>
<h3 id="124-抽象语法树">1.2.4 抽象语法树</h3>
<p>除了使用文法规则定义一个语言外，还能使用一种叫抽象语法树的直观方式表示，例如表达式：</p>
<pre><code class="language-bash">1 / 2 * 3 - 4 + 1
</code></pre>
<p>可以通过如下抽象语法树定义：<br>
<img src="https://img-blog.csdnimg.cn/20200801165057650.png" alt="在这里插入图片描述" loading="lazy"><br>
在该抽象语法树中，可以通过终结符<code>value</code>以及非终结符<code>operation</code>组成复杂的语句，终结符作为抽象语法树的叶子，非终结符作为非叶子节点，可以将终结符或者包含终结符与非终结符的节点作为子节点。</p>
<h2 id="13-定义">1.3 定义</h2>
<p><strong>解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。</strong></p>
<p>这里的语言指的是使用规定格式以及语法的代码。解释器模式是一种类行为型模式。</p>
<h2 id="14-结构图">1.4 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801195332936.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="15-角色">1.5 角色</h2>
<ul>
<li><strong><code>AbstractExpression</code>（抽象表达式）：声明了抽象的解释操作，是所有终结符表达式以及非终结符表达式的父类</strong></li>
<li><strong><code>TerminalExpression</code>（终结符表达式）：抽象表达式的子类，实现了与文法规则中的终结符相关联的解释操作，句子中的每一个终结符都是该类的一个实例，通常只有少数几个终结符表达式类</strong></li>
<li><strong><code>NonterminalExpression</code>（非终结符表达式）：也是抽象表达式的子类，实现了文法规则中非终结符的解释操作，由于非终结符表达式可以包含非终结符表达式以及终结符表达式，因此一般通过递归方式完成解释</strong></li>
<li><strong><code>Context</code>（环境类）：用于存储解释器之外的一些全局信息，通常它临时存储需要解释的语句</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>（可选）定义环境类：首先对环境类进行定义，使用集合存储相关的全局或公共信息，用于在具体解释时获取，如果无须全局信息则环境类可以省略</li>
<li>定义抽象表达式类：接口/抽象类，声明抽象解释操作</li>
<li>定义终结符表达式类：继承/实现抽象表达式，定义终结符的解释操作</li>
<li>定义非终结符表达式类：继承/实现抽象表达式，定义非终结符解释操作，一般通过递归处理</li>
</ul>
<h2 id="22-环境类">2.2 环境类</h2>
<p>这里暂时不需要环境类，为了兼容定义一个空类：</p>
<pre><code class="language-java">class Context{}
</code></pre>
<h2 id="23-抽象表达式">2.3 抽象表达式</h2>
<p>包含抽象解释操作方法：</p>
<pre><code class="language-java">interface AbstractExpression
{
    void interpret(Context context);
}
</code></pre>
<h2 id="24-终结符表达式">2.4 终结符表达式</h2>
<p>解释终结符表达式：</p>
<pre><code class="language-java">class TerminalExpression implements AbstractExpression
{
    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;终结符解析&quot;);
    }
}
</code></pre>
<h2 id="25-非终结符表达式">2.5 非终结符表达式</h2>
<pre><code class="language-java">class NonterminalExpression implements AbstractExpression
{
    private AbstractExpression left;
    private AbstractExpression right;

    public NonterminalExpression(AbstractExpression left,AbstractExpression right)
    {
        this.left = left;
        this.right = right;
    }

    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;非终结符解析&quot;);
        if(left != null)
            left.interpret(context);
        if(right != null)
            right.interpret(context);
    }
}
</code></pre>
<p>解释非终结符时一般需要递归处理，这里模拟了非终结符左右两边的表达式操作。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractExpression expression1 = new TerminalExpression();
    AbstractExpression expression2 = new TerminalExpression();
    AbstractExpression expression3 = new NonterminalExpression(expression1,expression2);
    expression3.interpret(null);
}
</code></pre>
<p>定义两个终结符表达式与一个非终结符表达式，最后对非终结符表达式进行解释。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>对机器人移动指令进行解释，移动的语法表达如下：方向 方式 距离，方向包括上下左右四个方向，方式包括跑以及一般移动，距离为一个整数，一条移动指令可以组合多条子移动指令，使用解释器模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：这里为空</li>
<li>抽象表达式类：<code>AbstractNode</code></li>
<li>终结符表达式类：<code>DirectionNode</code>+<code>ActionNode</code>+<code>DistanceNode</code></li>
<li>非终结符表达式类：<code>AndNode</code>+<code>SentenceNode</code></li>
</ul>
<p>抽象表达式类如下：</p>
<pre><code class="language-java">interface AbstractNode
{
    String interpret(String str);
}
</code></pre>
<p>终结符表达式类：</p>
<pre><code class="language-java">class DirectionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;up&quot;, &quot;向上&quot;);
        strs.put(&quot;down&quot;, &quot;向下&quot;);
        strs.put(&quot;left&quot;, &quot;向左&quot;);
        strs.put(&quot;right&quot;, &quot;向右&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class ActionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;move&quot;, &quot;移动&quot;);
        strs.put(&quot;run&quot;, &quot;快速移动&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class DistanceNode implements AbstractNode
{
    @Override
    public String interpret(String str)
    {
        return str;
    }
}
</code></pre>
<p>根据对应的字符串返回相应的字符串即可。</p>
<p>非终结符表达式类：</p>
<pre><code class="language-java">class SentenceNode implements AbstractNode
{
    private final AbstractNode direction = new DirectionNode();
    private final AbstractNode action = new ActionNode();
    private final AbstractNode distance = new DistanceNode();
    @Override
    public String interpret(String s)
    {
        String [] str = s.split(&quot; &quot;);
        return direction.interpret(str[0])+action.interpret(str[1])+distance.interpret(str[2]);
    }
}

class AndNode implements AbstractNode
{
    @Override
    public String interpret(String s)
    {
        if(s.contains(&quot;and&quot;))
        {
            int index = s.indexOf(&quot;and&quot;);
            String leftStr = s.substring(0, index-1);
            String rightStr = s.substring(index+4);
            AbstractNode left = (leftStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            AbstractNode right = (rightStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            return left.interpret(leftStr) + &quot; 再 &quot; + right.interpret(rightStr);
        }
        return new SentenceNode().interpret(s);
    }
}
</code></pre>
<p>其中<code>AndNode</code>采取了递归进行解释操作，如果分割后的字符串还含有<code>and</code>则赋值为<code>AndNode</code>，否则为<code>SentenceNode</code>。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractNode node = new AndNode();
    System.out.println(node.interpret(&quot;up move 5 and down run 10 and down move 10 and left run -9&quot;));
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200802015840189.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-扩展">4 扩展</h1>
<p>如果项目中需要对数据表达式进行分析与计算，可以直接使用现有的库，比如：</p>
<ul>
<li>Expression4J</li>
<li>MESP</li>
<li>Jep</li>
<li>Fel</li>
</ul>
<p>等等，下面以Jep为例演示该库的使用方法。Jep是<code>Java expression parser</code>的简称，即Java表达式分析器，它是一个用来转换和计算数学表达式的Java库，用户可以以字符串形式输入一个任意公式，然后快速计算出结果。Jep支持用户自定义变量，常量，函数，包括很多常用的数学函数以及常量。</p>
<p>首先<a href="http://www.singularsys.com/jep/download-trial.php">下载</a>JAR包依赖，例子如下：</p>
<pre><code class="language-java">import com.singularsys.jep.*;

public class Test
{
    public static void main(String[] args) throws Exception
    {
        Jep jep=new Jep();
        //定义要计算的数据表达式
        String interestOnDeposit=&quot;本金*利率*时间&quot;;
        //给相关变量赋值
        jep.addVariable(&quot;本金&quot;,10000);
        jep.addVariable(&quot;利率&quot;,0.038);
        jep.addVariable(&quot;时间&quot;,2);
        jep.parse(interestOnDeposit);     //解析表达式
        Object accrual=jep.evaluate();    //计算
        System.out.println(&quot;存款利息：&quot;+accrual);
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>扩展性好：由于解释器中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>便于实现语言：每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</li>
<li>实现文法容易：抽象语法树中每一个表达式节点类的实现方式都是类似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码</li>
<li>增加解释表达式方便：如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式，原有表达式类无须修改</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>复杂文法难以维护：在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则会导致类个数急增，导致系统难以管理和维护，可以考虑使用语法分析程序来取代解释器模式</li>
<li>执行效率低：由于解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时速度很慢，而且代码的调试过程也比较麻烦</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来描述</li>
<li>一个语言的文法较为简单</li>
<li>执行效率不是关键问题</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200802081552906.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十七）：命令模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/">
        </link>
        <updated>2020-08-02T02:28:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%91%BD%E4%BB%A4%E7%B1%BB">2.2 抽象命令类</a></li>
<li><a href="#23-%E8%B0%83%E7%94%A8%E8%80%85">2.3 调用者</a></li>
<li><a href="#24-%E6%8E%A5%E6%94%B6%E8%80%85">2.4 接收者</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%91%BD%E4%BB%A4%E7%B1%BB">2.5 具体命令类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97">4 命令队列</a></li>
<li><a href="#5-%E6%92%A4%E9%94%80%E4%B8%8E%E9%87%8D%E5%81%9A">5 撤销与重做</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>日常生活中，可以通过开关控制一些电器的开启和关闭，比如电灯和排气扇。可以将开关理解成一个请求发送者，电灯是请求的最红接收者以及处理者，开关与电灯之间不存在直接的耦合关系，两者通过电线连接在一起，使不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）既可对应不同的接收者（电器）。</p>
<p>软件开发中经常需要向某些对象发送请求，但是并不知道具体的接收者是谁，也不知道被请求的操作是哪个，此时希望以一种松耦合的方式来设计软件，使得请求发送者与请求接收者之间能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作，此时可以使用命令模式进行设计。</p>
<p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<h2 id="12-定义">1.2 定义</h2>
<p>命令模式：将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p>命令模式是一种对象行为型模式，别名为动作模式或者事务模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200731194318933.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Command</code>（抽象命令类）：抽象命令类一般是一个抽象类或者接口，在其中声明了用于执行请求的<code>execute()</code>方法，通过这些方法可以调用请求接收者的相关操作</strong></li>
<li><strong><code>ConcreteCommand</code>（具体命令类）：实现了抽象命令类中声明的方法，对应具体的接收者对象，将接收者对象的动作绑定其中，在实现<code>execute()</code>方法时，将调用接收者对象的相关操作</strong></li>
<li><strong><code>Invoker</code>（调用者）：调用者即请求发送者，通过命令对象来执行请求。一个调用者并不需要设计时确定接收者，因此它只与抽象命令类之间存在关联关系。程序运行时将具体命令对象注入，并调用其中的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作</strong></li>
<li><strong><code>Receiver</code>（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象命令类：定义执行请求的方法</li>
<li>定义调用者：在调用方法里面包含对具体命令的调用，同时需要包含一个对抽象命令的引用</li>
<li>定义接收者：定义接收请求的业务方法</li>
<li>定义具体命令类：继承/实现抽象命令类，实现其中执行请求方法，转发到接收者的接收方法</li>
</ul>
<h2 id="22-抽象命令类">2.2 抽象命令类</h2>
<p>这里实现为一个接口：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<h2 id="23-调用者">2.3 调用者</h2>
<pre><code class="language-java">class Invoker
{
    private Command command;

    public Invoker(Command command)
    {
        this.command = command;
    }

    public void call()
    {
        System.out.println(&quot;调用者操作&quot;);
        command.execute();
    }
}
</code></pre>
<p>调用者可以通过构造方法或者setter注入具体命令，对外提供一个调用方法<code>call</code>，当调用此方法时调用具体命令的<code>execute</code>。</p>
<h2 id="24-接收者">2.4 接收者</h2>
<pre><code class="language-java">class Receiver
{
    public void action()
    {
        System.out.println(&quot;接收者操作&quot;);
    }
}
</code></pre>
<p>这里的接收者只有一个<code>action</code>，表示接收方法。</p>
<h2 id="25-具体命令类">2.5 具体命令类</h2>
<pre><code class="language-java">class ConcreteCommand implements Command
{
    private Receiver receiver = new Receiver();
    @Override
    public void execute()
    {
        receiver.action();
    }
}
</code></pre>
<p>具体命令类中需要包含一个对接收者的引用，以便在<code>execute</code>中调用接收者。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Invoker invoker = new Invoker(new ConcreteCommand());
    invoker.call();
}
</code></pre>
<p>通过构造方法注入具体命令到调用者中，接着直接调用即可。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200731202157394.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>自定义功能键的设置，对于一个按钮，可以根据需要由用户设置为最小化/最大化/关闭功能，使用命令模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Button</code></li>
<li>接收者：<code>MinimizeHandler</code>+<code>MaximizeHandler</code>+<code>CloseHandler</code></li>
<li>具体命令类：<code>MinimizeCommand</code>+<code>MaximizeCommand</code>+<code>CloseCommand</code></li>
</ul>
<p>首先设计抽象命令类，实现为一个接口，仅包含<code>execute</code>方法：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<p>接着是调用者类，包含一个抽象命令的引用：</p>
<pre><code class="language-java">class Button
{
    private Command command;
    public Button(Command command)
    {
        this.command = command;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        command.execute();
    }
}
</code></pre>
<p>然后是接收者类：</p>
<pre><code class="language-java">class MinimizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最小化&quot;);
    }
}

class MaximizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最大化&quot;);
    }
}

class CloseHandler
{
    public void handle()
    {
        System.out.println(&quot;关闭&quot;);
    }
}
</code></pre>
<p>最后是具体命令类，对应包含一个接收者成员即可，实现其中的<code>execute</code>并转发到接收者的方法：</p>
<pre><code class="language-java">class MinimizeCommand implements Command
{
    private MinimizeHandler handler = new MinimizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class MaximizeCommand implements Command
{
    private MaximizeHandler handler = new MaximizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class CloseCommand implements Command
{
    private CloseHandler handler = new CloseHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Button button = new Button(new MinimizeCommand());
    button.onClick();

    button = new Button(new MaximizeCommand());
    button.onClick();

    button = new Button(new CloseCommand());
    button.onClick();
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/2020080100022354.png" alt="在这里插入图片描述" loading="lazy"><br>
如果需要新增一个命令，只需要命令接收者以及实现了<code>Command</code>的具体命令类，客户端再将具体命令注入请求发送者（<code>Button</code>），无须直接操作请求接收者。</p>
<h1 id="4-命令队列">4 命令队列</h1>
<p>有时候需要将多个请求排队，当一个请求发送者发送完成一个请求后，不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法完成对请求的处理。这种形式可以通过命令队列实现，实现命令队列很简单，一般是增加一个叫<code>CommandQueue</code>的类，由该类负责存储多个命令对象，不同的命令对象可以对应不同的请求接收者，比如在上面的例子中增加<code>CommandQueue</code>命令队列类：</p>
<pre><code class="language-java">class CommandQueue
{
    private ArrayList&lt;Command&gt; commands = new ArrayList&lt;&gt;();
    public void add(Command command)
    {
        commands.add(command);
    }

    public void remove(Command command)
    {
        commands.remove(command);
    }

    public void execute()
    {
        System.out.println(&quot;批量执行命令&quot;);
        commands.forEach(Command::execute);
    }
}
</code></pre>
<p>接着修改调用者类<code>Button</code>（只需将原来的<code>Command</code>改为<code>CommandQueue</code>）：</p>
<pre><code class="language-java">class Button
{
    private CommandQueue queue;
    public Button(CommandQueue queue)
    {
        this.queue = queue;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        queue.execute();
    }
}
</code></pre>
<p>最后是客户端定义命令队列并作为参数传入调用者的构造方法或者setter中，最后由调用者执行方法：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    CommandQueue queue = new CommandQueue();
    queue.add(new MinimizeCommand());
    queue.add(new MaximizeCommand());
    queue.add(new CloseCommand());
    Button button = new Button(queue);
    button.onClick();
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200801001917143.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-撤销与重做">5 撤销与重做</h1>
<blockquote>
<p>设计一个简易计算器，实现加法功能，还能够实现撤销以及重做功能，使用命令模式实现。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Calculator</code></li>
<li>接收者：<code>Adder</code></li>
<li>具体命令类：<code>AddCommand</code></li>
</ul>
<p>首先先不实现撤销以及重做功能：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        Calculator calculator = new Calculator(new AddCommand());
        calculator.add(3);
        calculator.add(9);
    }
}

interface Command
{
    int execute(int value);
}

class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }
}

class Adder
{
    private int num = 0;
    public int add(int value)
    {
        return num += value;
    }
}

class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }
}
</code></pre>
<p>代码与上面的实例类似，就不解释了。</p>
<p>这里关键的问题是如何实现撤销以及重做功能，撤销能够恢复到进行加法之前的状态，而重做能恢复到进行了加法之后的状态，而且这是有固定顺序的，因此可以联想到数组，使用下标表示当前状态，下标左移表示撤销，下标右移表示重做：<br>
<img src="https://img-blog.csdnimg.cn/2020080100442690.png" alt="在这里插入图片描述" loading="lazy"><br>
使用一个状态数组存储每次进行加法的状态，用下标表示当前状态，当撤销时，使下标左移，当重做时，使下标右移。</p>
<p>首先需要修改抽象命令类，添加撤销以及重做方法：</p>
<pre><code class="language-java">interface Command
{
    int execute(int value);
    int undo();
    int redo();
}
</code></pre>
<p>接着修改调用者类，添加撤销以及重做方法：</p>
<pre><code class="language-java">class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }

    public void undo()
    {
        System.out.println(command.undo());
    }

    public void redo()
    {
        System.out.println(command.redo());
    }
}
</code></pre>
<p>核心的实现位于接收者类<code>Adder</code>，使用了<code>List&lt;Integer&gt;</code>存储了状态，<code>index</code>表示下标，在撤销或重做之前首先判断下标位置是否合法，合法则进行下一步操作：</p>
<pre><code class="language-java">class Adder
{
    private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    private int index = 0;
    public Adder()
    {
        nums.add(0);
    }

    public int add(int value)
    {
        int result = nums.get(index)+value;
        nums.add(result);
        ++index;
        return result;
    }

    public int redo()
    {
        if(index + 1 &lt; nums.size())
            return nums.get(++index);
        return nums.get(index);
    }

    public int undo()
    {
        if(index - 1 &gt;= 0)
            return nums.get(--index);
        return nums.get(index);
    }
}
</code></pre>
<p>最后具体命令类简单添加撤销以及重做方法即可：</p>
<pre><code class="language-java">class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }

    @Override
    public int undo()
    {
        return adder.undo();
    }

    @Override
    public int redo()
    {
        return adder.redo();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Calculator calculator = new Calculator(new AddCommand());
    calculator.add(3);
    calculator.add(9);
    
    calculator.undo();
    calculator.undo();
    calculator.undo();
    calculator.undo();
    
    calculator.redo();
    calculator.redo();
    calculator.redo();
    calculator.redo();
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801005520961.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>降低耦合度：由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求可以对应不同的接收者，同样相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性</li>
<li>满足OCP：新的命令可以很容易添加到系统中，由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，满足OCP的要求</li>
<li>撤销+中作：为请求的撤销以及重做提供了一种设计和实现方案</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>过多具体命令类：使用命令模式可能会导致系统有过多的具体命令类，因为针对每一个请求接收者的调用操作都需要设计一个具体工具类，因此在某些系统中可能需要提供大量的具体命令类</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>系统需要将请求调用者和请求接受者解耦，使得调用者和接收者不直接交互，请求调用者无须知道接收者的存在，也无需知道接收者是谁，接收者也无须关心何时被调用</li>
<li>系统需要在不同时间指定请求，将请求排队和执行请求</li>
<li>系统需要支持撤销以及恢复操作</li>
<li>系统需要将一组操作组合一起形成宏命令，使用命令队列实现</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200801012404628.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第44期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/">
        </link>
        <updated>2020-08-01T14:44:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596034407830.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>现在的时代不是属于00后，是属于厚脸皮的！</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>据估计，野生动物贩卖每年市值约100亿美元，是仅次于毒品和武器的第三大最有价值的非法贸易。其中鸟类是最为常见的违禁品，每年走私的野生鸟类有200万到500万只。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>白发渔樵江渚上，惯看秋月春风。<br>
——杨慎《临江仙·滚滚长江东逝水》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>每一个人都应该明确自己的方向和位置。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=444267766">尽头-赵方婧</a></p>
</blockquote>
<blockquote>
<p>觥筹交错<br>
时光如梭<br>
迷失自我<br>
享受折磨<br>
这是你要的<br>
物质生活</p>
</blockquote>
<blockquote>
<p>一身污浊<br>
自得其乐<br>
谁的命运<br>
谁又能把握<br>
这是种孤独<br>
没有结果</p>
</blockquote>
<blockquote>
<p>精神虚伪的寄托<br>
不择手段的<br>
迷离恍惚的假想<br>
推翻不假思索<br>
如果换作是我<br>
又是何得的<br>
变作无趣的枷锁<br>
肉体诚实的反驳<br>
不合时宜的<br>
消散太快的热度<br>
假装不食烟火<br>
不由分说的我<br>
换个身份变作<br>
有趣的恶魔</p>
</blockquote>
<blockquote>
<p>觥筹交错<br>
时光如梭<br>
迷失自我<br>
享受折磨<br>
这是你要的<br>
物质生活</p>
</blockquote>
<blockquote>
<p>一身污浊<br>
自得其乐<br>
谁的命运<br>
谁又能把握<br>
这是种孤独<br>
没有结果</p>
</blockquote>
<blockquote>
<p>精神虚伪的寄托<br>
不择手段的<br>
迷离恍惚的假想<br>
推翻不假思索<br>
如果换作是我<br>
又是何得的<br>
变作无趣的枷锁<br>
肉体诚实的反驳<br>
不合时宜的<br>
消散太快的热度<br>
假装不食烟火<br>
不由分说的我<br>
换个身份变作<br>
有趣的恶魔</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第43期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-43-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-43-qi/">
        </link>
        <updated>2020-07-31T14:41:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596034395741.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>无毒的身躯抗下有毒的疫苗，你是教育我从小就要坚强！</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>现代手术之父威廉·斯图尔特·霍尔斯特博士通过向自己注射可卡因开创了使用麻醉药的先例。他最终对可卡因成瘾，之后是吗啡，但即便如此，他始终都在促进医学培训现代化。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>金陵风景好，豪事集新亭。<br>
——李白《金陵新亭》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>即便你忘记了我，我也不回遗忘你。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=5256770">明知做戏-吴雨霏</a></p>
</blockquote>
<blockquote>
<p>等你的汽水喝一半给你加片薄冰<br>
等你的桌面满些我总会打理重整<br>
不想纯情<br>
不够聪明<br>
你未发现我的身影</p>
</blockquote>
<blockquote>
<p>得我帮你依照编码整理家里电影<br>
只会得我一个帮你选购喜爱铃声<br>
天天如常<br>
估你心情<br>
等一个眼神求证<br>
一闪擦过如流星</p>
</blockquote>
<blockquote>
<p>怎么我为我做过的感到惊怕<br>
就像爱吗我也不肯定恐怕<br>
我以为存在吗<br>
千变万化<br>
从来不肯开口可相信吗<br>
离谱吗</p>
</blockquote>
<blockquote>
<p>请你不要阻我喜欢你<br>
明明是爱但你未说话扮作闪避<br>
这个沉默冷静的你毫无办法处理<br>
其实我亦怕是错摸心理<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过仍然害羞的你<br>
还是顾忌太不争气<br>
明知做戏</p>
</blockquote>
<blockquote>
<p>即使你未在意不感到惊讶<br>
现在要说爱你请准备招架<br>
勇气还存在吗<br>
不要害怕<br>
随时真的胆敢亲手送花<br>
离谱吗</p>
</blockquote>
<blockquote>
<p>请你不要阻我喜欢你<br>
明明是爱但你未说话扮作闪避<br>
这个沉默冷静的你毫无办法处理<br>
其实我亦怕是错摸心理<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过仍然害羞的你<br>
还是顾忌太不争气<br>
明知做戏</p>
</blockquote>
<blockquote>
<p>不过不要阻我紧张你<br>
如令你不愉快让我办妥为你准备<br>
喜爱沉默冷静的你还是自信的你<br>
仍愿意为你造一些惊喜<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过途人目光不理<br>
期待贴着你的手臂<br>
无须做戏</p>
</blockquote>
<blockquote>
<p>等你喜爱等你不爱就凭摘毫验证<br>
想爱不爱偏爱不理亦同样难划清<br>
天天如常<br>
估你心情<br>
不想扑索来求证<br>
争取过趁还年轻<br>
终于你下定决定来答应<br>
太动听</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十六）：职责链模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-liu-zhi-ze-lian-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-liu-zhi-ze-lian-mo-shi/">
        </link>
        <updated>2020-07-31T13:20:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%A4%84%E7%90%86%E8%80%85">2.2 抽象处理者</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%A4%84%E7%90%86%E8%80%85">2.3 具体处理者</a></li>
<li><a href="#24-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.4 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%88%86%E7%B1%BB">4 分类</a>
<ul>
<li><a href="#41-%E7%BA%AF%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">4.1 纯的职责链模式</a></li>
<li><a href="#42-%E4%B8%8D%E7%BA%AF%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F">4.2 不纯的职责链模式</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>很多情况下，一个软件系统中可以处理某个请求的对象不知一个，比如采购单的审批，主任，副董事长，董事长，董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就叫职责链。</p>
<p>职责链可以是一条直线，一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行处理，客户端无须关系请求的处理细节以及具体的传递，只需要将请求发送到链上即可，实现请求发送者以及请求处理者的解耦。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>职责链模式：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</strong></p>
<p>职责链模式是一种行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200731111207364.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Handler</code>（抽象处理者）：定义一个处理请求的接口，一般为抽象类。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者的对象作为对下一个处理者的引用，通过该引用，处理者可以连成一条链</strong></li>
<li><strong><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，实现具体处理方法，在处理前需要判断是否具有处理权限，如果拥有权限则处理，没有则转发到下一个处理者</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象处理者：定义处理请求接口以及定义一个抽象处理者成员，作为下一个处理者的引用，一般为了让具体处理者方便调用，定义为<code>protected</code></li>
<li>定义具体处理者：处理/转发请求，处理请求前先判断是否具有权限 ，拥有则处理请求，否则转发请求</li>
<li>客户端创建职责链：职责链模式并不创建职责链，职责链交由客户端创建，根据实际需要定义职责链顺序</li>
</ul>
<h2 id="22-抽象处理者">2.2 抽象处理者</h2>
<pre><code class="language-java">abstract class Handler
{
    protected Handler successor;
    public void setSuccessor(Handler successor)
    {
        this.successor = successor;
    }

    public abstract void handleRequest(int num);
}
</code></pre>
<p>拥有一个设置下一处理者的对象，可以通过setter注入，同时声明抽象处理方法。</p>
<h2 id="23-具体处理者">2.3 具体处理者</h2>
<pre><code class="language-java">class ConcreteHandler1 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 10)
        {
            System.out.println(&quot;处理小于10的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}

class ConcreteHandler2 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 20)
        {
            System.out.println(&quot;处理大于等于10且小于20的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}

class ConcreteHandler3 extends Handler
{
    @Override    
    public void handleRequest(int num)
    {
        if(num &lt; 30)
        {
            System.out.println(&quot;处理大于等于20且小于30的数字:&quot;+num);
        }
        else
            successor.handleRequest(num);
    }
}
</code></pre>
<p>继承抽象处理者，首先判断是否拥有权限处理（这里是一个简单的if判断），如果有就处理，没有的话通过<code>protected</code>对象，也就是转发给下一个处理者处理。</p>
<h2 id="24-客户端">2.4 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Handler handler = new ConcreteHandler1();
    Handler handler2 = new ConcreteHandler2();
    Handler handler3 = new ConcreteHandler3();
    handler.setSuccessor(handler2);
    handler2.setSuccessor(handler3);

    handler.handleRequest(3);
    handler.handleRequest(15);
    handler.handleRequest(22);
}
</code></pre>
<p>客户端针对抽象处理者编程，需要创建每一个具体处理者对象，并且自定义职责链：</p>
<pre><code class="language-java">handler.setSuccessor(handler2);
handler2.setSuccessor(handler3);
</code></pre>
<p>接着调用对应的处理者处理即可。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个采购单审批系统，分级进行，根据金额不同由不同层次的人员审批，主任可以审批5w以下的采购单，副董事长可以审批5w-10w，董事长可以审批10w-50w，50w以上需要由董事会审批，使用职责链模式设计该系统。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象处理者：<code>Approver</code></li>
<li>具体处理者：<code>Director</code>+<code>VicePresident</code>+<code>President</code>+<code>Congress</code></li>
<li>采购单请求类：<code>PurchaseRequest</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">//抽象处理者
abstract class Approver
{
    protected Approver successor;

    public void setSuccessor(Approver successor) {
        this.successor = successor;
    }

    public abstract void processRequest(PurchaseRequest request);
}

//具体处理者:主任
class Director extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 50000)
            System.out.println(&quot;主任审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:副董事长
class VicePresident extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 100000)
            System.out.println(&quot;副董事长审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:董事长
class President extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        if(request.getAmount() &lt; 500000)
            System.out.println(&quot;董事长审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
        else
            successor.processRequest(request);
    }
}

//具体处理者:董事会
class Congress extends Approver
{
    @Override
    public void processRequest(PurchaseRequest request)
    {
        System.out.println(&quot;董事会审批一笔\n金额为&quot;+request.getAmount()+&quot;\nid为&quot;+request.getId()+&quot;\n的采购单\n&quot;);
    }
}

//请求类:采购单
class PurchaseRequest
{
    private double amount;
    private String id;
    private static final String STR = &quot;xcnvj232cvm&quot;;
    private static final Random random = new Random();

    public PurchaseRequest(double amount)
    {
        this.amount = amount;
        //简易的随机字符串
        this.id = STR.substring(0,random.nextInt(STR.length()-1)+1).repeat(random.nextInt(3)+2);
    }

    public double getAmount() {
        return this.amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Approver director = new Director();
    Approver vicePresident = new VicePresident();
    Approver president = new President();
    Approver congress = new Congress();

    director.setSuccessor(vicePresident);
    vicePresident.setSuccessor(president);
    president.setSuccessor(congress);

    director.processRequest(new PurchaseRequest(12345));
    director.processRequest(new PurchaseRequest(54321));
    director.processRequest(new PurchaseRequest(123456));
    director.processRequest(new PurchaseRequest(654321));
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200731134901882.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-分类">4 分类</h1>
<p>职责链模式可以分为纯的职责链模式与不纯的职责链模式。</p>
<h2 id="41-纯的职责链模式">4.1 纯的职责链模式</h2>
<p>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个，要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。</p>
<p>而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象接收，不能出现某个请求未被任何一个处理者对象处理的情况，比如前面的采购单例子。</p>
<h2 id="42-不纯的职责链模式">4.2 不纯的职责链模式</h2>
<p>在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其猴戏处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</p>
<p>在Java AWT 1.0中的事件处理模型应用就是不纯的职责链模式，基本原理如下：由于窗口组件一般位于容器组件中，当事件发生在窗口组件上时，先通过组件对象的<code>handleEvent()</code>方法传递给相应的事件处理方法，该事件处理方法将处理该事件，然后决定是否将该事件向上一级容器组件传播，上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，直到顶层容器组件为止。如果一直都没有处理方法则不处理该事件。</p>
<p>这种事件处理机制又叫事件浮升机制，JDK1.1后使用观察者模式来代理职责链模式处理事件。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>降低耦合：职责链模式使得一个对象无须知道是其他哪一个对象处理请求，对象仅需知道请求会被处理即可，接收者和发送者都没有对方明确信息，且链中对象不需要知道链的结构，由客户端负责链的创建，降低了系统耦合度</li>
<li>简化对象连接：请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有候选处理者的引用，可简化对象的相互连接</li>
<li>灵活的职责链：可以在运行时对链进行动态增加或者修改</li>
<li>符合OCP：系统增加一个新的具体处理者时无须修改源码，只需要客户端重建职责链，符合OCP</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>请求可能得不到处理：由于一个请求没有明确的接收者，因此请求不一定会被处理，也有可能因为职责链配置错误而得不到处理</li>
<li>性能受到影响：对于较长的职责链，请求的处理可能涉及多个处理对象，系统性能会受到一定影响，而且代码调试时可能不方便</li>
<li>死循环：如果职责链不当，可能会导致死循环调用</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理请求以及处理者之间的先后次序</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020073115020561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十五）：代理模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-wu-dai-li-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-wu-dai-li-mo-shi/">
        </link>
        <updated>2020-07-31T13:19:07.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
<li><a href="#15-%E5%88%86%E7%B1%BB">1.5 分类</a></li>
<li><a href="#16-%E4%B8%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E5%90%8C">1.6 与装饰模式的不同</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">2.2 抽象主题角色</a></li>
<li><a href="#23-%E7%9C%9F%E5%AE%9E%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">2.3 真实主题角色</a></li>
<li><a href="#24-%E4%BB%A3%E7%90%86%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">2.4 代理主题角色</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%8A%A8%E6%80%81%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">4 动态与静态代理</a>
<ul>
<li><a href="#41-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">4.1 静态代理</a></li>
<li><a href="#42-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">4.2 动态代理</a>
<ul>
<li><a href="#421-proxy">4.2.1 <code>Proxy</code></a></li>
<li><a href="#422-invocationhandler">4.2.2 <code>InvocationHandler</code></a></li>
<li><a href="#423-%E5%AE%9E%E4%BE%8B">4.2.3 实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86">5 远程代理</a>
<ul>
<li><a href="#51-%E6%A6%82%E8%BF%B0">5.1 概述</a></li>
<li><a href="#52-rmi%E7%AE%80%E4%BE%8B">5.2 RMI简例</a></li>
</ul>
</li>
<li><a href="#6-%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86">6 虚拟代理</a>
<ul>
<li><a href="#61-%E6%A6%82%E8%BF%B0">6.1 概述</a></li>
<li><a href="#62-%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5">6.2 适用情况</a></li>
<li><a href="#63-%E4%BC%98%E7%BC%BA%E7%82%B9">6.3 优缺点</a></li>
<li><a href="#64-%E7%AE%80%E4%BE%8B">6.4 简例</a></li>
</ul>
</li>
<li><a href="#7-%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86">7 缓存代理</a>
<ul>
<li><a href="#71-%E6%8A%BD%E8%B1%A1%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">7.1 抽象主题角色</a></li>
<li><a href="#72-%E7%9C%9F%E5%AE%9E%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">7.2 真实主题角色</a></li>
<li><a href="#73-%E4%BB%A3%E7%90%86%E4%B8%BB%E9%A2%98%E8%A7%92%E8%89%B2">7.3 代理主题角色</a></li>
<li><a href="#74-%E5%85%B6%E4%BB%96">7.4 其他</a></li>
<li><a href="#75-%E6%B5%8B%E8%AF%95">7.5 测试</a></li>
</ul>
</li>
<li><a href="#8-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">8 主要优点</a></li>
<li><a href="#9-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">9 主要缺点</a></li>
<li><a href="#10-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">10 适用场景</a></li>
<li><a href="#11-%E6%80%BB%E7%BB%93">11 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>所谓代购，就是找人帮忙购买自己需要的商品，代购包括两种类型，一种是在当地买不到商品，或者因为当地该商品价格较高，因此托人在其他地区或者国外购买，另一种类型是消费者对想要购买的商品消息缺乏，只能委托中介或者中间商购买。</p>
<p>在软件开发中，有时也需要提供与代购类似的功能，由于某些原因，客户端不想或不能直接访问对象，此时可通过一种叫代理的第三者来实现间接访问，这种方案对应的设计模式称为代理模式。</p>
<p>代理模式是一种应用很广泛的结构型设计模式，而且变化很多。在代理模式中引入了一个新的代理对象，代理对象可以在客户端对象和目标对象之间起到中介的作用，去掉客户不能看到的内容或者增添客户需要的额外服务。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</strong></p>
<p>代理模式是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200730065334739.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Subject</code>（抽象主题角色）：声明了真实主题和代理主题的共同接口，客户端通常需要针对抽象主题角色编程</strong></li>
<li><strong><code>Proxy</code>（代理主题角色）：内部包含了对真实主题的引用，从而可以操作真实主题对象。代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理角色还可以控制对真实主题的使用，在需要的时候创建或删除真实主题对象，并对真实主题的使用加以约束。通常在代理主题角色中，客户端调用之前或之后都需要执行特定操作，比如图中的<code>preRequest</code>以及<code>postRequest</code></strong></li>
<li><strong><code>RealSubject</code>（真实主题角色）：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理角色间接调用真实主题角色中的操作</strong></li>
</ul>
<h2 id="15-分类">1.5 分类</h2>
<p>代理模式根据目的以及实现方式可以分成很多类，常见的几种如下：</p>
<ul>
<li>远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以不在同一台主机中。远程代理又叫“大使”（Ambassador）</li>
<li>虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建</li>
<li>保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</li>
<li>缓存代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</li>
<li>智能引用代理：当一个对象被引用时，提供一些额外的操作，比如将对象被调用的次数记录下来等</li>
</ul>
<h2 id="16-与装饰模式的不同">1.6 与装饰模式的不同</h2>
<p>代理模式和装饰模式在实现时类似，主要区别如下：</p>
<ul>
<li>增加的职责范围问题域不同：代理模式以及装饰模式都能动态地增加职责，但是代理模式增加的是一些全新的职责，比如权限控制，缓存处理，智能引用，远程访问等，这些职责与原有职责不属于同一个问题域。对于装饰模式，为具体构件类增加一些相关的职责，是原有职责的扩展，这些职责属于同一个问题域</li>
<li>目的不同：代理模式的目的是控制对对象的访问，而装饰模式是为对象动态增加功能</li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象主题角色：定义为抽象类/接口，声明抽象业务方法</li>
<li>定义真实主题角色：继承/实现抽象主题角色，实现真实业务操作</li>
<li>定义代理主题角色：继承/实现抽象主题角色，将客户端的请求转发到真实主题角色进行调用，同时根据需要进行调用前/后的一些相关操作</li>
</ul>
<h2 id="22-抽象主题角色">2.2 抽象主题角色</h2>
<p>这里简单实现为一个接口：</p>
<pre><code class="language-java">interface Subject
{
    void request();
}
</code></pre>
<h2 id="23-真实主题角色">2.3 真实主题角色</h2>
<p>实现抽象主题接口，执行真正的业务操作：</p>
<pre><code class="language-java">class RealSubject implements Subject
{
    public void request()
    {
        System.out.println(&quot;真实主题角色方法&quot;);
    }
}
</code></pre>
<h2 id="24-代理主题角色">2.4 代理主题角色</h2>
<p>同样实现抽象主题接口，一般来说在调用真正的业务方法之前或之后会有相关操作：</p>
<pre><code class="language-java">class Proxy implements Subject
{
    private RealSubject subject = new RealSubject();
    public void pre()
    {
        System.out.println(&quot;代理前操作&quot;);
    }

    public void request()
    {
        pre();
        subject.request();
        post();
    }

    public void post()
    {
        System.out.println(&quot;代理后操作&quot;);
    }
}
</code></pre>
<h2 id="25-客户端">2.5 客户端</h2>
<p>客户端针对抽象主题角色进行编程即可，如果不需要代理，则实例化真实主题角色，如果需要代理则实例化代理主题角色：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Subject subject = new RealSubject();
    subject.request();
    System.out.println(&quot;\n使用代理:\n&quot;);
    subject = new Proxy();
    subject.request();
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200730140727727.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>一个已具有搜索功能的系统，需要为搜索添加身份认证以及日志记录功能，使用代理模式设计该系统。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象主题角色：<code>Searcher</code></li>
<li>真实主题角色：<code>RealSearcher</code></li>
<li>代理主题角色：<code>ProxySearcher</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        Searcher subject = new ProxySearcher();
        subject.search();
    }
}

interface Searcher
{
    void search();
}

class RealSearcher implements Searcher
{
    public void search()
    {
        System.out.println(&quot;搜索&quot;);
    }
}

class ProxySearcher implements Searcher
{
    private RealSearcher subject = new RealSearcher();
    public void validate()
    {
        System.out.println(&quot;身份验证&quot;);
    }

    public void search()
    {
        validate();
        subject.search();
        log();
    }

    public void log()
    {
        System.out.println(&quot;日志记录,查询次数+1&quot;);
    }
}
</code></pre>
<p>进行搜索之前，先验证用户，接着进行搜索，搜索完成后进行日志记录，这是保护代理以及智能引用代理的例子。</p>
<h1 id="4-动态与静态代理">4 动态与静态代理</h1>
<h2 id="41-静态代理">4.1 静态代理</h2>
<p>通常情况下，每一个代理类编译之后都会生成一个字节码文件，代理所实现的接口和所代理的方法都固定，这种代理称为静态代理。</p>
<p>静态代理中，客户端通过<code>Proxy</code>调用<code>RealSubject</code>的<code>request</code>方法，同时封装其他方法（代理前/代理后操作），比如上面的查询验证以及日志记录功能。</p>
<p>静态代理的优点是实现简单，但是，代理类以及真实主题类都需要事先存在，代理类的接口以及代理方法都明确指定，但是如果需要：</p>
<ul>
<li>代理不同的真实主题类</li>
<li>代理一个真实主题类的不同方法</li>
</ul>
<p>需要增加新的代理类，这会导致系统中类的个数大大增加。</p>
<p>这是静态代理最大的缺点，为了减少系统中类的个数，可以采用动态代理。</p>
<h2 id="42-动态代理">4.2 动态代理</h2>
<p>动态代理可以让系统根据实际需要动态创建代理类，同一个代理类可以代理多个不同的真实主题类，而且可以代理不同方法，在Java中实现动态代理需要<code>Proxy</code>类以及<code>InvocationHandler</code>接口。</p>
<h3 id="421-proxy">4.2.1 <code>Proxy</code></h3>
<p><code>Proxy</code>类提供了用于创建动态代理类和实例对象的方法，最常用的方法包括：</p>
<ul>
<li><code>public static Class&lt;?&gt; getProxy(ClassLoader loader,Class&lt;?&gt; ... interfaces)</code>：该方法返回一个<code>Class</code>类型的代理类，在参数中需要提供类加载器并指定代理的接口数组，这个数组应该与真实主题类的接口列表一致</li>
<li><code>public staitc Object newProxyInstance(ClassLoader loader,Class&lt;?&gt; [] interfaces,InvocationHandler h)</code>：返回一个动态创建的代理类实例，第一个参数是类加载器，第二个参数表示代理类实现的接口列表，同理与真实主题的接口列表一致，第三个参数表示<code>h</code>所指派的调用处理程序类</li>
</ul>
<h3 id="422-invocationhandler">4.2.2 <code>InvocationHandler</code></h3>
<p><code>InvocationHandler</code>接口是代理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用者（也就是实现了<code>InvocationHandler</code>的类），该接口中声明以下方法：</p>
<ul>
<li><code>public Object invoke(Object proxy,Method method,Object [] args)</code>：该方法用于处理对代理类实例的方法调用并返回相应结果，当一个代理实例中的业务方法被调用时自动调用该方法。第一个参数表示代理类的实例，第二个参数表示需要代理的方法，第三个参数表示方法的参数数组</li>
</ul>
<p>动态代理类需要在运行时指定所代理的真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会自动转发到<code>InvocationHandler</code>的<code>invoke</code>方法，由<code>invoke</code>实现对请求的统一处理。</p>
<h3 id="423-实例">4.2.3 实例</h3>
<blockquote>
<p>为一个数据访问Dao层增加方法调用日志，记录每一个方法被调用的时间和结果，使用动态代理模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象主题角色：<code>AbstractUserDao</code></li>
<li>真实主题角色：<code>UserDao1</code>+<code>UserDao2</code></li>
<li>请求处理角色：<code>DAOLogHandler</code></li>
<li>代理主题角色：无需手动定义，由<code>Proxy.newInstance()</code>生成</li>
</ul>
<p>首先设计抽象主题角色：</p>
<pre><code class="language-java">interface AbstarctUserDao
{
    void findUserById(String id);
}
</code></pre>
<p>接着创建两个具体类实现该接口：</p>
<pre><code class="language-java">class UserDao1 implements AbstarctUserDao
{
    public void findUserById(String id)
    {
        System.out.println(&quot;1号数据库中查找id&quot; + 
            (&quot;1&quot;.equals(id) ? &quot;成功&quot; : &quot;失败&quot;));
    }
}


class UserDao2 implements AbstarctUserDao
{
    public void findUserById(String id)
    {
        System.out.println(&quot;2号数据库中查找id&quot; + 
            (&quot;2&quot;.equals(id) ? &quot;成功&quot; : &quot;失败&quot;));
    }
}
</code></pre>
<p>接着定义请求处理角色：</p>
<pre><code class="language-java">class DAOLogHandler implements InvocationHandler
{
    private Object object;
    public DAOLogHandler(Object object)
    {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy,Method method,Object [] args) throws Throwable
    {
        beforeInvoke();
        Object result = method.invoke(object, args);
        postInvoke();
        return result;
    }

    private void beforeInvoke()
    {
        System.out.println(&quot;记录时间&quot;);
    }

    private void postInvoke()
    {
        System.out.println(&quot;记录结果&quot;);
    }
}
</code></pre>
<p>核心是实现了<code>InvocationHandler</code>的<code>invoke</code>方法，该方法在调用抽象主题角色中的方法时自动转发到该方法处理。</p>
<p>也就是说，假设抽象主题角色有<code>A(),B(),C()</code>三个方法，当调用<code>A()</code>时，将调用<code>A()</code>替换掉里面的<code>Object result = method.invoke(object.args)</code>，也就是实际上相当调用如下函数：</p>
<pre><code class="language-java">@Override
public Object invoke(Object proxy,Method method,Object [] args) throws Throwable
{
    beforeInvoke();
    Object result = A(args);
    postInvoke();
    return result;
}
</code></pre>
<p>当调用<code>B()</code>时，相当于调用以下函数：</p>
<pre><code class="language-java">@Override
public Object invoke(Object proxy,Method method,Object [] args) throws Throwable
{
    beforeInvoke();
    Object result = B(args);
    postInvoke();
    return result;
}
</code></pre>
<p>下面是测试客户端的代码：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstarctUserDao userDao1 = new UserDao1();
    AbstarctUserDao proxy = null;
    InvocationHandler handler = new DAOLogHandler(userDao1);
    proxy = AbstarctUserDao.class.cast(
        Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(), new Class[]{AbstarctUserDao.class}, handler)
    );
    proxy.findUserById(&quot;2&quot;);

    AbstarctUserDao userDao2 = new UserDao2();
    handler = new DAOLogHandler(userDao2);
    proxy = AbstarctUserDao.class.cast(
        Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(),new Class[]{AbstarctUserDao.class},handler)
    );
    proxy.findUserById(&quot;2&quot;);
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200730155711471.png" alt="在这里插入图片描述" loading="lazy"><br>
在测试代码中，代理主题角色由以下语句生成：</p>
<pre><code class="language-java">proxy = AbstarctUserDao.class.cast(
    Proxy.newProxyInstance(AbstarctUserDao.class.getClassLoader(), new Class[]{AbstarctUserDao.class}, handler)
);
</code></pre>
<p>其中<code>cast()</code>方法相当于是对强制类型转换进行了包装，转换前进行了安全检查。</p>
<p><strong>在<code>Proxy.newInstance()</code>中，第一个参数是抽象主题角色的类加载器，第二个参数表示抽象主题角色的所有方法都转发请求到第三个参数中的<code>invoke</code>方法处理。第三个参数是自定义的<code>InvocationHandler</code>，通过构造方法注入抽象主题角色，目的是提供一个抽象主题角色的引用，调用代理方法时自动调用抽象主题角色的方法。</strong></p>
<h1 id="5-远程代理">5 远程代理</h1>
<h2 id="51-概述">5.1 概述</h2>
<p>远程代理是一种常见的代理模式，使得客户端程序可以访问在远程主机（或另一个JVM）上的对象，远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是本地的而不是远程的，远程代理对象承担了大部分的网络通信工作，并负责对远程业务的方法调用。</p>
<p>远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端而言是透明的。客户端无须关心实现的具体业务是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。</p>
<p>在Java中可以通过<code>RMI(Remote Method Invocation,远程方法调用)</code>机制来实现远程代理，它能够实现一个JVM中的对象调用另一个JVM中的对象，下面看一个简单的例子。</p>
<h2 id="52-rmi简例">5.2 RMI简例</h2>
<p>这个简单的例子有以下四个类：</p>
<ul>
<li>接口：<code>Hello</code></li>
<li>接口实现类：<code>HelloImpl</code></li>
<li>服务端：<code>HelloServer</code></li>
<li>客户端：<code>HelloClient</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">interface Hello extends Remote
{
    String sayHello(String name) throws RemoteException;
}
</code></pre>
<p>一个简单的<code>sayHello</code>方法，注意里面的方法需要声明为抛出<code>RemoteException</code>。</p>
<p>接着是接口实现类：</p>
<pre><code class="language-java">public class HelloImpl extends UnicastRemoteObject implements Hello{
    public HelloImpl() throws RemoteException
    {
        super();
    }
    public String sayHello(String name) throws RemoteException
    {
        System.out.println(&quot;Hello&quot;);
        return &quot;Hello&quot;+name;
    }
}
</code></pre>
<p>实现<code>sayHello</code>方法。</p>
<p>接下来是服务端：</p>
<pre><code class="language-java">public class HelloServer {
    public static void main(String[] args) {
        try {
            Hello hello = new HelloImpl();
            LocateRegistry.createRegistry(8888);
            System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;127.0.0.1&quot;);
            Naming.bind(&quot;rmi://localhost:8888/hello&quot;, hello);
            System.out.println(&quot;远程绑定对象成功&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>服务端中首先注册了一个本地端口<code>8888</code>，接着设置系统属性rmi服务的主机名为本地地址，也就是<code>127.0.0.1</code>，如果是部署在服务器上修改对应ip即可。下一步是通过<code>Naming</code>的静态方法<code>bind</code>绑定该URL到RMI服务器上，并命名为<code>hello</code>。其中<code>rmi:</code>（RMI协议）可以省略。</p>
<p>最后是客户端：</p>
<pre><code class="language-java">public class HelloClient {
    public static void main(String[] args) {
        try
        {
            Hello hello = Hello.class.cast(
                Naming.lookup(&quot;rmi://127.0.0.1:8888/hello&quot;)
            );
            System.out.println(hello.sayHello(&quot;111&quot;));
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>客户端通过<code>Naming</code>的<code>lookup</code>查找参数URL中对应的远程服务对象<code>hello</code>，找到后返回并强制转换为<code>Hello</code>，接着即可调用远程对象的方法<code>sayHello</code>。</p>
<p>首先运行服务端：<br>
<img src="https://img-blog.csdnimg.cn/20200730170610622.png" alt="在这里插入图片描述" loading="lazy"><br>
接着启动客户端：<br>
<img src="https://img-blog.csdnimg.cn/20200730170843890.png" alt="在这里插入图片描述" loading="lazy"><br>
可以看到来自服务端的结果。</p>
<p>再查看服务端：<br>
<img src="https://img-blog.csdnimg.cn/20200730170953974.png" alt="在这里插入图片描述" loading="lazy"><br>
可以看到这是调用了<code>sayHello</code>的结果。</p>
<h1 id="6-虚拟代理">6 虚拟代理</h1>
<h2 id="61-概述">6.1 概述</h2>
<p>对于一直占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮<br>
演真实对象的替身，当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。</p>
<h2 id="62-适用情况">6.2 适用情况</h2>
<p>以下两种情况可以考虑使用虚拟代理：</p>
<ul>
<li>由于对象本身复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象</li>
<li>当一个对象的加载十分消耗系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用到它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象</li>
</ul>
<h2 id="63-优缺点">6.3 优缺点</h2>
<ul>
<li>优点：由于应用程序启动时由于不需要创建和装载所有的对象，因此加速了应用程序的启动</li>
<li>缺点：不能保证特定的应用程序对象被创建，在访问这个对象的任何地方都需要提前进行判空操作</li>
</ul>
<h2 id="64-简例">6.4 简例</h2>
<blockquote>
<p>有一批人找老板谈事情，谈事情之前需要先通过老板的助手进行预约，预约这件事只需要助手完成，真正执行预约列表里面的任务时才需要老板出现，使用虚拟代理模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象主题角色：<code>Approvable</code></li>
<li>真实主题角色：<code>Boss</code></li>
<li>代理主题角色：<code>Assistant</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">//抽象主题角色
interface Approvable
{
    void approve();
}
</code></pre>
<p>下一步定义真实主题角色<code>Boss</code>：</p>
<pre><code class="language-java">class Boss implements Approvable
{
    private List&lt;String&gt; orders = new LinkedList&lt;&gt;();
    
    static
    {
        System.out.println(&quot;\n老板来处理了\n&quot;);
    }

    public Boss(List&lt;String&gt; orders)
    {
        this.orders = orders;
    }

    public void addOrder(String order)
    {
        orders.add(order);
    }

    @Override
    public void approve()
    {
        while(orders.size() &gt; 0)
        {
            System.out.println(&quot;老板处理了&lt;&quot;+orders.remove(0)+&quot;&gt;&quot;);
        }
    }
}
</code></pre>
<p>使用<code>List</code>存储待处理的事件，<code>approve</code>表示处理所有的事件。</p>
<p>代理主题角色如下：</p>
<pre><code class="language-java">class Assistant implements Approvable
{
    private List&lt;String&gt; orders = new LinkedList&lt;&gt;();
    private volatile Boss boss;

    public void addOrder(String order)
    {
        if(boss != null)
        {
            System.out.println(&quot;老板将&lt;&quot;+order+&quot;&gt;添加到预约列表&quot;);
            boss.addOrder(order);
        }
        else
        {
            System.out.println(&quot;助手将&lt;&quot;+order+&quot;&gt;添加到预约列表&quot;);
            orders.add(order);
        }
    }

    @Override
    public void approve()
    {
        if(boss == null)
        {
            synchronized(this)
            {
                if(boss == null)
                {
                    boss = new Boss(orders);
                }
            }
        }
        boss.approve();       
    }
}
</code></pre>
<p>在添加事件（<code>addOrder</code>）函数中，首先判断<code>boss</code>是否为<code>null</code>，如果为<code>null</code>表示还没创建<code>老板</code>对象，这时让助手添加到预约列表中去，如果不为<code>null</code>表示已经存在<code>老板</code>对象，直接交由老板加入预约列表。</p>
<p>对于<code>approve</code>方法，首先判断<code>boss</code>是否为<code>null</code>，不为<code>null</code>表示老板能直接处理所有事件。为<code>null</code>表示<code>老板</code>对象还没有创建，新建一个<code>Boss</code>并将待处理的事件作为参数注入<code>boss</code>中。</p>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Assistant assistant = new Assistant();
    assistant.addOrder(&quot;找老板面试&quot;);
    assistant.addOrder(&quot;找老板借钱&quot;);
    assistant.addOrder(&quot;找老板聊天&quot;);
    assistant.approve();

    assistant.addOrder(&quot;找老板吃饭&quot;);
    assistant.addOrder(&quot;找老板喝酒&quot;);
    assistant.approve();
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200731094308630.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="7-缓存代理">7 缓存代理</h1>
<p>缓存代理为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果，在这里使用缓存代理模式模拟YouTube对使用集成的第三方库下载进行缓存。</p>
<p>设计如下：</p>
<ul>
<li>模拟第三方库：<code>ThirdPartyYouTubeLib</code>+<code>ThirdPartyYouTubeClass</code></li>
<li>模拟视频文件：<code>Video</code></li>
<li>模拟缓存代理：<code>YouTubeCacheProxy</code></li>
<li>模拟下载器：<code>YouTubeDownloader</code></li>
</ul>
<p>首先是第三方类库，通常情况下是没有源码实现的，其中<code>ThirdPartyYouTubeLib</code>是一个接口，并且<code>ThirdPartyYouTubeClass</code>以及<code>YouTubeCacheProxy</code>实现了它，也就是说：</p>
<ul>
<li><code>ThirdPartyYouTubeLib</code>是抽象主题角色</li>
<li><code>ThirdPartyYouTubeClass</code>是真实主题角色</li>
<li><code>YouTubeCacheProxy</code>是代理主题角色</li>
</ul>
<h2 id="71-抽象主题角色">7.1 抽象主题角色</h2>
<p>首先定义抽象主题角色：</p>
<pre><code class="language-java">interface ThirdPartyYouTubeLib
{
    HashMap&lt;String,Video&gt; popularVideos();
    Video getVideo(String videoId);
}
</code></pre>
<p>一个是获取热门视频的方法，一个是根据id获取具体视频的方法。</p>
<h2 id="72-真实主题角色">7.2 真实主题角色</h2>
<pre><code class="language-java">class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib
{
    private static final String URL = &quot;https://www.youtube.com&quot;;
    @Override
    public HashMap&lt;String,Video&gt; popularVideos()
    {
        connectToServer(URL);
        return getRandomVideos();
    }

    @Override
    public Video getVideo(String id)
    {
        connectToServer(URL+id);
        return getSomeVideo(id);
    }

    private int random(int min,int max)
    {
        return min+(int)(Math.random()*((max-min)+1));
    }

    private void experienceNetworkLatency()
    {
        int randomLatency = random(5, 10);
        for(int i=0;i&lt;randomLatency;++i)
        {
            try
            {
                Thread.sleep(100);
            } 
            catch(InterruptedException e)
            {
                e.printStackTrace();
            }
        }
    }

    private void connectToServer(String url)
    {
        System.out.println(&quot;连接到 &quot; + url + &quot; ...&quot;);
        experienceNetworkLatency();
        System.out.println(&quot;连接成功!\n&quot;);
    }

    private HashMap&lt;String,Video&gt; getRandomVideos()
    {
        System.out.println(&quot;正在下载热门视频&quot;);
        experienceNetworkLatency();
        HashMap&lt;String,Video&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;1111111&quot;,new Video(&quot;1111&quot;,&quot;1111.mp4&quot;));
        map.put(&quot;2222222&quot;,new Video(&quot;2222&quot;,&quot;2222.avi&quot;));
        map.put(&quot;3333333&quot;,new Video(&quot;3333&quot;,&quot;3333.mov&quot;));
        map.put(&quot;4444444&quot;,new Video(&quot;4444&quot;,&quot;4444.mkv&quot;));
        System.out.println(&quot;下载完成!\n&quot;);
        return map;
    }

    private Video getSomeVideo(String id)
    {
        System.out.println(&quot;正在下载id为&quot;+id+&quot;的视频&quot;);
        experienceNetworkLatency();
        System.out.println(&quot;下载完成!\n&quot;);
        return new Video(id,&quot;title&quot;);
    }
}
</code></pre>
<p>获取热门视频或者某一个视频时，进行了一个模拟连接到服务器的操作，首先输出提示<code>连接到xxx</code>，接着模拟了网络延迟，最后提示下载完成并返回相应的视频。</p>
<h2 id="73-代理主题角色">7.3 代理主题角色</h2>
<pre><code class="language-java">class YouTubeCacheProxy implements ThirdPartyYouTubeLib
{
    private ThirdPartyYouTubeLib youtubeService = new ThirdPartyYouTubeClass();

    private HashMap&lt;String,Video&gt; cachePopular = new HashMap&lt;&gt;();
    private HashMap&lt;String,Video&gt; cacheAll = new HashMap&lt;&gt;();

    @Override
    public HashMap&lt;String,Video&gt; popularVideos()
    {
        if(cachePopular.isEmpty())
        {
            cachePopular = youtubeService.popularVideos();
        }
        else
        {
            System.out.println(&quot;从缓存检索中热门视频&quot;);            
        }
        return cachePopular;
    }

    @Override
    public Video getVideo(String id)
    {
        Video video = cacheAll.get(id);
        if(video == null)
        {
            video = youtubeService.getVideo(id);
            cacheAll.put(id,video);
        }
        else
        {
            System.out.println(&quot;从缓存中检索id为&quot;+id+&quot;的视频&quot;);
        }
        return video;
    }

    public void reset()
    {
        cachePopular.clear();
        cacheAll.clear();
    }
}
</code></pre>
<p>这里的缓存代理角色其实就是在调用真实主题角色的获取视频方法之前，首先判断是否存在缓存，存在的话直接从缓存中获取，不存在的话首先调用获取视频方法并存储在缓存中，下次获取时从缓存中获取。</p>
<h2 id="74-其他">7.4 其他</h2>
<pre><code class="language-java">class Video
{
    private String id;
    private String title;
    private String data;
    public Video(String id,String title)
    {
        this.id = id;
        this.title = title;
    }
    //getter+setter...
}

class YouTubeDownloader
{
    private ThirdPartyYouTubeLib api;

    public YouTubeDownloader(ThirdPartyYouTubeLib api)
    {
        this.api = api;
    }

    public boolean useCacheProxy()
    {
        return api instanceof YouTubeCacheProxy;
    }

    public void renderVideoPage(String id)
    {
        Video video = api.getVideo(id);
        System.out.println(&quot;\n-------------------------------------------&quot;);
        System.out.println(&quot;ID:&quot;+video.getId());
        System.out.println(&quot;标题:&quot;+video.getTitle());
        System.out.println(&quot;数据:&quot;+video.getData());
        System.out.println(&quot;\n-------------------------------------------&quot;);
    }

    public void renderPopularVideos()
    {
        HashMap&lt;String,Video&gt; list = api.popularVideos();
        System.out.println(&quot;\n-------------------------------------------&quot;);
        System.out.println(&quot;热门视频&quot;);
        list.forEach((k,v)-&gt;System.out.println(&quot;ID:&quot;+v.getId()+&quot;\t标题:&quot;+v.getTitle()));
        System.out.println(&quot;\n-------------------------------------------&quot;);
    }
}
</code></pre>
<h2 id="75-测试">7.5 测试</h2>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass());
        YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy());

        long navie = test(naiveDownloader);
        long smart = test(smartDownloader);
        System.out.println(&quot;缓存代理节约的时间:&quot;+(navie-smart)+&quot;ms&quot;);
    }

    private static long test(YouTubeDownloader downloader)
    {
        long startTime = System.currentTimeMillis();
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;1111&quot;);
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;2222&quot;);
        downloader.renderVideoPage(&quot;3333&quot;);
        downloader.renderVideoPage(&quot;4444&quot;);
        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.println(downloader.useCacheProxy() ? &quot;使用缓存运行时间:&quot; : &quot;不使用缓存运行时间:&quot;);
        System.out.println(estimatedTime+&quot;ms\n&quot;);
        return estimatedTime;
    }
}
</code></pre>
<p>模拟了两个下载器，一个使用原生下载，一个使用缓存代理下载，输出如下：</p>
<pre><code class="language-bash">连接到 https://www.youtube.com ...
连接成功!

正在下载热门视频
下载完成!


-------------------------------------------
热门视频
ID:4444 标题:4444.mkv
ID:2222 标题:2222.avi
ID:3333 标题:3333.mov
ID:1111 标题:1111.mp4

-------------------------------------------
连接到 https://www.youtube.com1111 ...
连接成功!

正在下载id为1111的视频
下载完成!


-------------------------------------------
ID:1111
标题:title
数据:null

-------------------------------------------
连接到 https://www.youtube.com ...
连接成功!

正在下载热门视频
下载完成!


-------------------------------------------
热门视频
ID:4444 标题:4444.mkv
ID:2222 标题:2222.avi
ID:3333 标题:3333.mov
ID:1111 标题:1111.mp4

-------------------------------------------
连接到 https://www.youtube.com2222 ...     
连接成功!

正在下载id为2222的视频
下载完成!


-------------------------------------------
ID:2222
标题:title
数据:null

-------------------------------------------
连接到 https://www.youtube.com3333 ...     
连接成功!

正在下载id为3333的视频
下载完成!


-------------------------------------------
ID:3333
标题:title
数据:null

-------------------------------------------
连接到 https://www.youtube.com4444 ...     
连接成功!

正在下载id为4444的视频
下载完成!


-------------------------------------------
ID:4444
标题:title
数据:null

-------------------------------------------
不使用缓存运行时间:
9312ms

连接到 https://www.youtube.com ...
连接成功!

正在下载热门视频
下载完成!


-------------------------------------------
热门视频
ID:4444 标题:4444.mkv
ID:2222 标题:2222.avi
ID:3333 标题:3333.mov
ID:1111 标题:1111.mp4

-------------------------------------------
连接到 https://www.youtube.com1111 ...
连接成功!

正在下载id为1111的视频
下载完成!


-------------------------------------------
ID:1111
标题:title
数据:null

-------------------------------------------
从缓存检索中热门视频

-------------------------------------------
热门视频
ID:4444 标题:4444.mkv
ID:2222 标题:2222.avi
ID:3333 标题:3333.mov
ID:1111 标题:1111.mp4

-------------------------------------------
连接到 https://www.youtube.com2222 ...
连接成功!

正在下载id为2222的视频
下载完成!


-------------------------------------------
ID:2222
标题:title
数据:null

-------------------------------------------
连接到 https://www.youtube.com3333 ...
连接成功!

正在下载id为3333的视频
下载完成!


-------------------------------------------
ID:3333
标题:title
数据:null

-------------------------------------------
连接到 https://www.youtube.com4444 ...
连接成功!

正在下载id为4444的视频
下载完成!


-------------------------------------------
ID:4444
标题:title
数据:null

-------------------------------------------
使用缓存运行时间:
7611ms

缓存代理节约的时间:1701ms
</code></pre>
<p>可以看到缓存代理是能节省时间的，除了第一次获取视频外，随后的获取视频都是从缓存中直接提取。</p>
<h1 id="8-主要优点">8 主要优点</h1>
<ul>
<li>降低耦合度：代理模式能够协调调用者以及被调用者，一定程度上降低了系统的耦合度</li>
<li>灵活可扩展：客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源码，符合OCP，系统具有较好的灵活性和可扩展性</li>
<li>提高整体效率（远程代理）：远程代理为位于两个不同的地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统整体运行效率</li>
<li>节约开销（虚拟代理）：虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li>
<li>控制权限（保护代理）：保护代理可以控制一个对象的访问权限，为不同用户提供不同级别的使用权限</li>
</ul>
<h1 id="9-主要缺点">9 主要缺点</h1>
<ul>
<li>速度变慢：由于在客户端以及真实主题之间增加了代理对象，因此可能会造成处理速度变慢，比如保护代理</li>
<li>实现复杂：实现代理模式需要额外的操作，有些代理模式其实很复杂，比如远程代理</li>
</ul>
<h1 id="10-适用场景">10 适用场景</h1>
<ul>
<li>客户端需要访问远程主机中的对象，使用远程代理</li>
<li>需要一个消耗资源较少的对象来代表资源较多的对象时，使用虚拟代理</li>
<li>需要控制访问权限，使用保护代理</li>
<li>需要为一个频繁访问的操作结果提供临时存储空间，使用缓存代理</li>
<li>需要为一个对象的访问（引用）提供额外的操作时，使用智能引用代理</li>
</ul>
<h1 id="11-总结">11 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200731145441730.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第42期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-42-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-42-qi/">
        </link>
        <updated>2020-07-30T15:24:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595863733090.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我是一条酸菜鱼，又酸又菜，还多余。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>《吉尼斯世界纪录》这本书持有在公共图书馆内最经常被盗的书这一记录。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>一番荷芰生池沼，槛前风送馨香。<br>
——尹鹗《临江仙·一番荷芰生池沼》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>世间本无公平可言，除非公平掌握在自己手中。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=174956">坏女孩-徐良/小凌</a></p>
</blockquote>
<blockquote>
<p>I miss you<br>
Now<br>
don't you love me<br>
Sorry I'm so sorry</p>
</blockquote>
<blockquote>
<p>那时我放开了你的手<br>
转过身只剩了保重<br>
你话都没说却哭了很久很久<br>
我喜欢坏坏的女友<br>
我喜欢刺激的感受<br>
你单纯太过多余了那些温柔</p>
</blockquote>
<blockquote>
<p>你消失在无名大街<br>
从此就没有再见面<br>
好长的时间再没有你的来电<br>
在后来酒吧的房间<br>
舞池里跳动着音乐<br>
熟悉的侧脸喂</p>
</blockquote>
<blockquote>
<p>迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
<blockquote>
<p>那时我放开了你的手<br>
转过身只剩了保重<br>
你话都没说却哭了很久很久<br>
我喜欢坏坏的女友<br>
我喜欢刺激的感受<br>
你单纯太过多余了那些温柔</p>
</blockquote>
<blockquote>
<p>你消失在无名大街<br>
从此就没有再见面<br>
好长的时间再没有你的来电<br>
在后来酒吧的房间<br>
舞池里跳动着音乐<br>
熟悉的侧脸喂</p>
</blockquote>
<blockquote>
<p>迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
<blockquote>
<p>然后我安静的发现<br>
两个人已经没有任何语言<br>
曾经你纯真的永远<br>
让我不顾一切开始怀念<br>
迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
]]></content>
    </entry>
</feed>