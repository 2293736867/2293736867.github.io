<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-04-26T14:22:07.196Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（四）：GC算法与四种引用]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-si-gc-suan-fa-yu-si-chong-yin-yong/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-si-gc-suan-fa-yu-si-chong-yin-yong/">
        </link>
        <updated>2021-04-26T14:11:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第四章</li>
</ul>
<p>本文是第四章的一些笔记整理。</p>
<h1 id="2-gc算法">2 <code>GC</code>算法</h1>
<p>常见的<code>GC</code>算法包括：</p>
<ul>
<li>引用计数法</li>
<li>标记清除法</li>
<li>复制算法</li>
<li>标记压缩法</li>
<li>分代算法</li>
<li>分区算法</li>
</ul>
<h2 id="21-引用计数法">2.1 引用计数法</h2>
<p>实现原理：</p>
<ul>
<li>对于一个对象A</li>
<li>只要有任何一个对象引用A，A的引用计数器就加1</li>
<li>引用失效时，引用计数器就减1</li>
<li>只要对象A的引用计数器的值为0，对象A就不会再被使用，等待被回收</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法处理循环引用，比如A引用B，B引用A，但是并没有其他对象引用两者，此时A和B的引用计数都不为0，这样就无法被回收</li>
<li>引用计数器要求每次引用产生和消除的时候，伴随一个加法操作和一个减法操作，对系统性能会有一定的影响</li>
</ul>
<p>由于引用计数法上述的缺点，<code>Java</code>中并未采用作为<code>GC</code>算法。</p>
<h2 id="22-标记清除法">2.2 标记清除法</h2>
<p>标记清除法将垃圾回收分为两个阶段：</p>
<ul>
<li>标记阶段：通过根节点标记所有从根节点开始的可达对象，未被标记的就是垃圾对象</li>
<li>清除阶段：清除所有未被标记的对象</li>
</ul>
<p>标记阶段：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210426201921525.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>清除后：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210426173623187.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>缺点很明显，就是回收后的空间是不连续的，工作效率会低于连续的内存空间。</p>
<h2 id="23-复制算法">2.3 复制算法</h2>
<p>核心思想：</p>
<ul>
<li>内存空间分为相等的两块</li>
<li>每次只使用其中一块</li>
<li>回收的时候将存活对象移到另一块中，然后清除正在使用的内存块中所有对象</li>
<li>交换两个内存块的角色</li>
</ul>
<p>优点是回收后的内存空间是没有碎片的，而缺点是如果存在大量的对象，需要花费大量的时间复制，并且内存只有原来的一半。</p>
<p>比如下图中的A、B两块相同的内存空间，A在垃圾回收的时候，将存活对象复制到B中，B在复制后保持连续：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210426204108976.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>复制完成后，A会被清空，并将B设置为当前使用的空间。</p>
<p>在<code>Java</code>的新生代串行垃圾回收器中，使用了复制算法，新生代分为<code>eden</code>区、<code>from</code>区以及<code>to</code>区。其中<code>from</code>和<code>to</code>区是两块内存相同的空间，也叫<code>survivor</code>区，也就是幸存者空间。在垃圾回收的时候，<code>eden</code>区以及<code>from</code>区存活的对象会被复制到<code>to</code>区，然后清空<code>from</code>区与<code>eden</code>区，接着<code>from</code>和<code>to</code>区的角色将会交换，也就是下一次垃圾回收的时候，会从原来的<code>to</code>区（新的<code>from</code>区）复制到原来的<code>from</code>区（新的<code>to</code>区）。</p>
<h2 id="24-标记压缩法">2.4 标记压缩法</h2>
<p>标记压缩法是一种老年代算法，在标记清除法的基础上做了一些优化，和标记清除法一样，首先也需要从根节点开始，对所有可达对象做一次标记，然后将所有存活对象压缩到内存的一端，接着清理边界外的所有空间，图示如下：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210426205832537.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>标记压缩法的优点是可以避免碎片的产生，又不需要两块相同的内存空间。</p>
<h2 id="25-分代算法">2.5 分代算法</h2>
<p>分代算法并不是一种具体的垃圾回收算法，分代算法其实是一种根据每块内存空间的特点使用不同回收算法以提高效率的算法。比如：</p>
<ul>
<li>在新生代中：会有大量的新建对象很快被回收，因此新生代比较适合使用复制算法</li>
<li>在老年代中：采用标记压缩法或标记清除法</li>
</ul>
<h2 id="26-分区算法">2.6 分区算法</h2>
<p>分区算法将整个堆空间划分成连续的不同小区间，每个小区间都独立使用，独立回收，如图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210426210811452.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-四种引用">3 四种引用</h1>
<p><code>Java</code>里面提供了4个级别的引用：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<p>下面分别来看一下。</p>
<h2 id="31-强引用">3.1 强引用</h2>
<p>强引用就是代码中一般使用的引用类型，强引用的对象是可触及的，不会被回收，比如：</p>
<pre><code class="language-java">StringBuffer str = new StringBuffer(&quot;a&quot;);
</code></pre>
<p>如果上面的代码运行在方法体内，那么局部变量<code>str</code>会被分配在栈上，而对象<code>StringBuffer</code>实例会被分配在堆上，<code>str</code>指向的是<code>StringBuffer</code>实例所在的堆空间，通过<code>str</code>可以操作该实例，<code>str</code>就是<code>StringBuffer</code>实例的强引用。</p>
<p>又比如执行了以下代码：</p>
<pre><code class="language-java">StringBuffer str1 = str;
</code></pre>
<p>那么<code>str1</code>也会指向<code>str</code>指向的对象，也就是它们都指向同一个<code>StringBuffer</code>实例，此时<code>str1==str</code>的值为真，因为两个指向的是同一个堆空间地址。</p>
<p>强引用的特点如下：</p>
<ul>
<li>可以直接访问目标对象</li>
<li>强引用指向的对象不会被系统回收，<code>JVM</code>宁愿抛出<code>OOM</code>也不会回收强引用指向的对象</li>
<li>强引用可能会导致内存泄漏</li>
</ul>
<h2 id="32-软引用">3.2 软引用</h2>
<p>软引用是被强引用弱一点的引用类型，如果一个对象只持有软引用，那么当堆空间不足的时候，就会被回收，软引用可以使用<code>SoftReference</code>类实现，比如下面的代码：</p>
<pre><code class="language-java">public static void main(String[] args){
    Byte[] b = new Byte[1024*1024*8];
    SoftReference&lt;Byte[]&gt; softReference = new SoftReference&lt;&gt;(b);
    b = null;
    System.out.println(softReference.get());
    System.gc();
    System.out.println(&quot;After GC&quot;);
    System.out.println(softReference.get());
    b = new Byte[1024*1024*8];
    System.gc();
    System.out.println(softReference.get());
}
</code></pre>
<p>在<code>OpenJDK 11.0.10</code>上，加上<code>-Xmx40m</code>的输出如下：</p>
<pre><code class="language-bash">[Ljava.lang.Byte;@1fbc7afb
After GC
[Ljava.lang.Byte;@1fbc7afb
null
</code></pre>
<p>可以看到，当垃圾回收的时候，未必会回收软引用对象，但当内存紧张时，会回收软引用对象。</p>
<h2 id="33-弱引用">3.3 弱引用</h2>
<p>弱引用是比软引用弱的引用类型，在垃圾回收的时候，只要发现弱引用，不管系统空间使用情况如何，都会将对象进行回收。但是由于垃圾回收器的线程通常优先级不高，并不一定能很快发现弱引用对象，这种情况下弱引用对象可以存在较长时间。弱引用例子如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    Byte[] b = new Byte[1024*1024*8];
    WeakReference&lt;Byte[]&gt; softReference = new WeakReference&lt;&gt;(b);
    b = null;
    System.out.println(softReference.get());
    System.gc();
    System.out.println(&quot;After GC&quot;);
    System.out.println(softReference.get());
}
</code></pre>
<p>输出（<code>-Xmx40m</code>）：</p>
<pre><code class="language-bash">[Ljava.lang.Byte;@1fbc7afb
After GC
null
</code></pre>
<p>可以看到在<code>GC</code>后，弱引用对象会被立即回收。</p>
<p>软引用、弱引用的一个常见使用场景是保存可有可无的缓存数据，当系统内存不足时，这些内存数据会被回收，不会导致<code>OOM</code>，而内存充足时，这些缓存数据又可以存在相当长的时间，从而起到让系统加速的作用。</p>
<h2 id="34-虚引用">3.4 虚引用</h2>
<p>虚引用是所有引用类型中最弱的一个，一个持有虚引用的对象和没有引用几乎是一样的，随时都可能被垃圾回收器回收。另外，试图使用虚引用的<code>get()</code>方法获取强引用的时候，总是会失败，并且虚引用需要和引用队列一起使用，作用在与跟踪垃圾回收过程。</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();
    PhantomReference&lt;String&gt; reference = new PhantomReference&lt;&gt;(new String(&quot;test&quot;),queue);
    System.out.println(reference.get());
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-bash">null
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第316期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-316-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-316-qi/">
        </link>
        <updated>2021-04-26T00:07:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>做事一定要考虑别人的感受，千万不能让他们太开心了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>四月南风大麦黄，枣花未落桐叶长。<br>
——李颀《送陈章甫》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>今天的风儿有些喧嚣啊。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619397056830.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>暴力大法好：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int shipWithinDays(int[] weights, int D) {
        int n = weights.length;
        if (D == 1) {
            int sum = 0;
            for (int i = 0; i &lt; n; i++) {
                sum += weights[i];
            }
            return sum;
        }

        int max = Arrays.stream(weights).max().getAsInt();
        for (int ans = max; ; ++ans) {
            int day = 0;
            int temp = 0;
            for (int i = 0; i &lt; n; i++) {
                if (temp + weights[i] &lt;= ans) {
                    temp += weights[i];
                } else {
                    temp = weights[i];
                    ++day;
                }

                if (temp == ans) {
                    if(i != n-1){
                        temp = 0;
                    }
                    ++day;
                }
            }
            if(temp &lt; ans){
                ++day;
            }
            if (day &lt;= D) {
                return ans;
            }
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619397088069.png" alt="" loading="lazy"></figure>
<p>二分优化（左边界为数组的最大值，右边界为数组的和）：</p>
<pre><code class="language-java">public class Solution {
    public int shipWithinDays(int[] weights, int D) {
        int n = weights.length;
        int sum = 0;
        int max = 0;
        for (int i = 0; i &lt; n; i++) {
            sum += weights[i];
            if(weights[i] &gt; max){
                max = weights[i];
            }
        }
        if (D == 1) {
            return sum;
        }

        int ans = (max+sum)/2;
        while (max &lt; sum){
            int day = 0;
            int temp = 0;
            for (int i = 0; i &lt; n; i++) {
                if (temp + weights[i] &lt;= ans) {
                    temp += weights[i];
                } else {
                    temp = weights[i];
                    ++day;
                }

                if (temp == ans) {
                    if(i != n-1){
                        temp = 0;
                    }
                    ++day;
                }
            }
            if(temp &lt; ans){
                ++day;
            }
            if (day &lt;= D) {
                sum = ans;
            }else{
                max = ans+1;
            }
            ans = (max+sum)/2;
        }
        return max;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1619397527442.png" alt="" loading="lazy"></figure>
<p>极限优化，优化点包括：</p>
<ul>
<li>判断<code>D==1</code>与<code>D==n</code></li>
<li>计算二分的<code>mid</code>时使用右移代替除法</li>
<li>优化计算天数的函数，采用相减而不是相加</li>
</ul>
<pre><code class="language-java">public class Solution {
    private int [] weights;
    private int D;
    public int shipWithinDays(int[] weights, int D) {
        this.weights = weights;
        this.D = D;
        int n = weights.length;
        int right = 0;
        int left = 0;
        for (int i = 0; i &lt; n; i++) {
            right += weights[i];
            if(weights[i] &gt; left){
                left = weights[i];
            }
        }
        if (D == 1) {
            return right;
        }else if(D == n){
            return left;
        }

        while (left &lt;= right){
            int mid = (left+right) &gt;&gt; 1;
            if(canShip(mid)){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        return left;
    }

    private boolean canShip(int mid){
        int day = 1;
        int cur = mid;
        for (int weight:weights){
            if(weight &gt; cur){
                ++day;
                cur = mid;
            }
            cur -= weight;
        }
        return day &lt;= D;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1619397976229.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 线程池详解]]></title>
        <id>https://2293736867.github.io/post/java-xian-cheng-chi-xiang-jie/</id>
        <link href="https://2293736867.github.io/post/java-xian-cheng-chi-xiang-jie/">
        </link>
        <updated>2021-04-25T12:27:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>本文主要讲解了<code>Java</code>里面线程池的接口以及实现类，以及它们的基本使用方法，内容包括：</p>
<ul>
<li><code>Executor</code>/<code>Executors</code></li>
<li><code>ExecutorService</code></li>
<li><code>ThreadPoolExecutor</code></li>
<li><code>ScheduledThreadPoolExecutor</code></li>
</ul>
<h1 id="2-两个重要的接口executorexecutorservice">2 两个重要的接口：<code>Executor</code>+<code>ExecutorService</code></h1>
<p><code>Executor</code>是一个接口，里面只是定义了一个简单的任务提交方法：</p>
<pre><code class="language-java">//Executor
package java.util.concurrent;

public interface Executor {
    void execute(Runnable var1);
}
</code></pre>
<p>而<code>ExecutorService</code>也是一个接口，继承了<code>Executor</code>，并且提供了更多用于任务提交和管理的一些方法，比如停止任务的执行等：</p>
<pre><code class="language-java">//ExecutorService
package java.util.concurrent;

import java.util.Collection;
import java.util.List;

public interface ExecutorService extends Executor {
    void shutdown();

    List&lt;Runnable&gt; shutdownNow();

    boolean isShutdown();

    boolean isTerminated();

    boolean awaitTermination(long var1, TimeUnit var3) throws InterruptedException;

    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; var1);

    &lt;T&gt; Future&lt;T&gt; submit(Runnable var1, T var2);

    Future&lt;?&gt; submit(Runnable var1);

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, long var2, TimeUnit var4) throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) throws InterruptedException, ExecutionException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, long var2, TimeUnit var4) throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>下面将详细讲述<code>ExecutorService</code>的两个重要实现：</p>
<ul>
<li><code>ThreadPoolExecutor</code></li>
<li><code>ScheduledThreadPoolExecutor</code></li>
</ul>
<h1 id="3-threadpoolexecutor">3 <code>ThreadPoolExecutor</code></h1>
<p>这就是通常所说的线程池类，通常来说，一个线程池有如下特征：</p>
<ul>
<li>线程池有一定数量的工作线程</li>
<li>线程数量以及任务数量会受到一定的控制和管理</li>
<li>任务的执行以异步的方式进行</li>
<li>线程池会负责执行任务的信息统计</li>
</ul>
<h2 id="31-一个简单的例子">3.1 一个简单的例子</h2>
<p>先来看一个简单的例子：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws Exception {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
        //执行没有返回值的任务
        executor.execute(()-&gt; System.out.println(&quot; Execute the runnable task.&quot;));
        //执行带返回值的任务，用到了Future泛型类
        Future&lt;String&gt; future = executor.submit(()-&gt;&quot; Execute the callable task and this is the result.&quot;);
        //通过get()获取任务结果，get()会在任务未完成时一直阻塞
        System.out.println(future.get());
   		//手动关闭线程池
        executor.shutdown();
    }
}
</code></pre>
<p>从这个简单的例子可以看到，线程池可以执行带返回值以及不带返回值的任务，带返回值的话需要使用<code>get()</code>方法阻塞获取。另外，运行完毕后需要手动关闭线程池，否则<code>JVM</code>不会退出，因为线程池中有指定数量的活跃线程数量，而<code>JVM</code>正常退出的条件是<code>JVM</code>进程中不存在任何运行着的非守护进程。</p>
<h2 id="32-构造方法">3.2 构造方法</h2>
<p>构造方法的源码如下：</p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 

public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 

public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 

public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, 
TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
</code></pre>
<p>虽然提供了四个构造方法，但本质上调用的是最后一个构造方法，该构造方法带有7个参数，分别是：</p>
<ul>
<li><code>corePoolSize</code>：核心线程数量，即使当线程池中的核心线程不工作，核心线程的数量也不会减少。该参数的最小值为0，且小于等于<code>maximumPoolSize</code></li>
<li><code>maximumPoolSize</code>：用于设置线程池中允许的线程数量的最大值</li>
<li><code>keepAliveTime</code>：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将会回收一部分线程让出系统资源，该参数可用于设置超过<code>corePoolSize</code>数量的线程在多长时间后被回收，与后一个表示时间单位的参数<code>unit</code>配合使用</li>
<li><code>unit</code>：用于设定<code>keepAliveTime</code>的时间单位</li>
<li><code>workQueure</code>：用于存放已提交至线程池但未被执行的任务</li>
<li><code>threadFactory</code>：用于创建线程的工厂，开发者可以自定义<code>ThreadFactory</code>来创建线程</li>
<li><code>handler</code>：拒绝策略，当任务超过阻塞队列的边界时，线程池会拒绝新增的任务，主要用于设置拒绝策略</li>
</ul>
<h2 id="33-任务执行流程">3.3 任务执行流程</h2>
<p>线程池被成功创建后，内部的运行线程并不会被立即创建，<code>ThreadPoolExecutor</code>会采用一种<code>Lazy</code>的方式去创建并且运行。首次调用执行任务方法时才会创建线程，比如：</p>
<pre><code class="language-java">ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
assert executor.getActiveCount() == 0;
assert executor.getMaximumPoolSize() == 4;
assert executor.getCorePoolSize() == 2;
executor.execute(()-&gt; System.out.println(&quot; Execute the runnable task.&quot;));
assert executor.getActiveCount() == 1;
assert executor.getMaximumPoolSize() == 4;
assert executor.getCorePoolSize() == 2;
</code></pre>
<p>（运行的时候请加上<code>-ea</code>参数）</p>
<p>下面看一下任务的具体执行流程：</p>
<ul>
<li>如果运行中线程数少于核心线程数，创建新线程并立即执行任务</li>
<li>如果运行中的线程大于等于核心线程数，且任务队列未满时，会将任务先放进任务队列，直到运行中的线程数执行完成自己的任务后，再去轮询任务队列以获取任务运行</li>
<li>如果任务队列已满，且运行中的线程数量小于最大线程数量时，线程池会创建线程执行任务，创建的线程数量会少于最大线程数</li>
<li>如果任务队列已满且运行中的线程数量已到达最大线程数量，并且此刻没有空闲的运行线程，会执行任务拒绝策略，取决于<code>RejectedEcecutionHandler</code></li>
<li>若线程池中的线程是空闲的，且空闲时间到达<code>keepAliveTime</code>指定时间，会回收线程，直到保留<code>corePoolSize</code>个核心线程为止（不过核心线程也可以设置被超时回收，默认不开启核心线程超时）</li>
</ul>
<h2 id="34-线程工厂">3.4 线程工厂</h2>
<p>线程工厂<code>ThreadFactory</code>是一个接口：</p>
<pre><code class="language-java">package java.util.concurrent;

public interface ThreadFactory {
    Thread newThread(Runnable var1);
}
</code></pre>
<p>使用线程工厂可以在创建线程时加入自定义配置，比如指定名字、优先级、是否为守护线程等，比如下面是线程工厂的一个简单实现：</p>
<pre><code class="language-java">public class TestThreadFactory implements ThreadFactory {
    private final static String PREFIX = &quot;Test thread[&quot;;
    private final static String SUFFIX = &quot;]&quot;;
    private final static AtomicInteger THREAD_NUM = new AtomicInteger();
    @Override
    public Thread newThread(Runnable runnable) {
        ThreadGroup group = new ThreadGroup(&quot;My pool&quot;);
        Thread thread = new Thread(group,runnable,PREFIX+THREAD_NUM.getAndIncrement()+SUFFIX);
        thread.setPriority(5);
        return thread;
    }
}
</code></pre>
<h2 id="35-拒绝策略">3.5 拒绝策略</h2>
<p>默认情况下，<code>ThreadPoolExecutor</code>提供了四种拒绝策略：</p>
<ul>
<li><code>DiscardPolicy</code>：丢弃策略，直接丢弃任务</li>
<li><code>AbortPolicy</code>：终止策略，抛出<code>RejectedExecutionException</code></li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最老任务的策略（严格意义来说需要根据任务队列去选择，因为不是所有的队列都是<code>FIFO</code>的）</li>
<li><code>CallerRunsPolicy</code>：调用者线程执行策略，任务会在当前线程中阻塞执行</li>
</ul>
<p>当然，如果不能满足需要，可以实现<code>RejectedExecutionHandler</code>接口去自定义策略：</p>
<pre><code class="language-java">public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable var1, ThreadPoolExecutor var2);
}
</code></pre>
<h2 id="36-关闭线程池">3.6 关闭线程池</h2>
<p>如果不需要线程池，那么需要手动对线程池关闭。线程池提供了如下三种方式：</p>
<ul>
<li>有序关闭：<code>shutdown()</code></li>
<li>立即关闭：<code>shutdownNow()</code></li>
<li>组合关闭：<code>shutdown()+shutdownNow()</code></li>
</ul>
<h3 id="361-有序关闭">3.6.1 有序关闭</h3>
<p><code>shutdown()</code>提供了一种有序关闭的方式去关闭线程池，调用该方法后，会等待当前执行的任务全部执行完成然后关闭，同时新提交任务将会被拒绝。注意该方法是非阻塞，立即返回的。如果需要查看关闭状态，可以使用：</p>
<ul>
<li><code>isShutdown()</code>：返回是否调用了<code>shutdown()</code>的结果</li>
<li><code>isTerminating()</code>：返回是否正在结束中</li>
<li><code>isTerminated()</code>：返回是否已经结束</li>
</ul>
<h3 id="362-立即关闭">3.6.2 立即关闭</h3>
<p><code>shutdownNow()</code>方法首先将线程池状态修改为<code>shutdown</code>状态，然后将未被执行的任务挂起，接着将尝试中断运行中的线程，最后返回未执行的任务：</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), new TestThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
    IntStream.range(0,10).forEach(i-&gt; executor.execute(()-&gt; {
        try{
            TimeUnit.SECONDS.sleep(5);
        }catch (Exception e){
            e.printStackTrace();
        }
    }));
    List&lt;Runnable&gt; runnables = executor.shutdownNow();
    System.out.println(runnables.size());
}
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">8

BUILD SUCCESSFUL in 326ms
2 actionable tasks: 2 executed
java.lang.InterruptedException: sleep interrupted
	at java.base/java.lang.Thread.sleep(Native Method)
	at java.base/java.lang.Thread.sleep(Thread.java:339)
	at java.base/java.util.concurrent.TimeUnit.sleep(TimeUnit.java:446)
	at com.company.Main.lambda$main$0(Main.java:29)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
java.lang.InterruptedException: sleep interrupted
	at java.base/java.lang.Thread.sleep(Native Method)
	at java.base/java.lang.Thread.sleep(Thread.java:339)
	at java.base/java.util.concurrent.TimeUnit.sleep(TimeUnit.java:446)
	at com.company.Main.lambda$main$0(Main.java:29)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
3:14:36 AM: Task execution finished 'Main.main()'.
</code></pre>
<h3 id="363-组合关闭">3.6.3 组合关闭</h3>
<p>为了确保安全关闭线程池，一般会使用组合方式关闭，确保正在运行的任务被正常执行的同时又能提高线程池被关闭的成功率，例子如下：</p>
<pre><code class="language-java"> ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), new TestThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
IntStream.range(0,10).forEach(i-&gt; executor.execute(()-&gt; {
    try{
        TimeUnit.SECONDS.sleep(5);
    }catch (Exception e){
        e.printStackTrace();
    }
}));

//首先调用shutdown()尝试关闭
executor.shutdown();
try{
	//如果等待一段时间后还没关闭
    if(!executor.awaitTermination(10,TimeUnit.SECONDS)){
    	//强制关闭
        executor.shutdownNow();
        //如果强制关闭失败，比如运行的线程异常耗时且不能被中断
        if(!executor.awaitTermination(10,TimeUnit.SECONDS)){
        	//其他处理，这里只是输出中断失败的信息
            System.out.println(&quot;Terminate failed.&quot;);
        }
    }
}catch (InterruptedException e){
	//如果当前线程被中断，并且捕获了异常，执行立即关闭方法
    executor.shutdownNow();
    //重新抛出中断信号
    Thread.currentThread().interrupt();
}
</code></pre>
<h1 id="4-scheduledthreadpoolexecutor">4 <code>ScheduledThreadPoolExecutor</code></h1>
<p><code>ScheduledExecutorService</code>继承了<code>ExecutorService</code>，并且提供了任务被定时执行的特性，可以使用<code>ScheduledThreadPoolExecutor</code>去实现某些特殊的任务执行。当然实现固定任务的方法或者框架有很多，有原生的<code>shell</code>实现，老式的<code>Timer/TimerTask</code>实现，或者专门的框架<code>Quartz</code>实现，这里要说的是<code>JDK</code>内部的实现<code>ScheduledThreadPoolExecutor</code>。</p>
<p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，除了具备<code>ThreadPoolExecutor</code>的所有方法外，还定义了4个与<code>schedule</code>有关的方法：</p>
<ul>
<li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：一个<code>one-shot</code>（只执行一次）的方法， 任务（<code>callable</code>）会在单位时间（<code>delay</code>）后被执行，并且立即返回<code>ScheduledFuture</code></li>
<li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code>：也是一个<code>one-shot</code>方法，任务会在单位时间后被执行，与第一个方法不同的是返回的<code>ScheduledFuture</code>不包含任何执行结果，但是可以通过返回的<code>ScheduledFuture</code>判断任务是否执行结束</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：任务会根据固定的速率在<code>initialDelay</code>后不断被执行</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：任务将以固定延迟单位时间的方式执行任务</li>
</ul>
<p>关于后两者的区别如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(2);
    Runnable runnable = ()-&gt;{
        long startTimestamp = System.currentTimeMillis();
        System.out.println(&quot;current timestamp: &quot;+startTimestamp);
        try{
            TimeUnit.MILLISECONDS.sleep(current().nextInt(100));
        }catch (Exception e){
            e.printStackTrace();
        }
        System.out.println(&quot;elapsed time: &quot;+(System.currentTimeMillis() - startTimestamp));
    };

    executor.scheduleAtFixedRate(runnable,10,1000,TimeUnit.MILLISECONDS);
//        executor.scheduleWithFixedDelay(runnable,10,1000,TimeUnit.MILLISECONDS);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">current timestamp: 1619351675438
elapsed time: 97
current timestamp: 1619351676438
elapsed time: 85
current timestamp: 1619351677438
elapsed time: 1
current timestamp: 1619351678438
elapsed time: 1
current timestamp: 1619351679438
elapsed time: 68
current timestamp: 1619351680438
elapsed time: 99
</code></pre>
<p>可以看到任务始终以一种固定的速率运行，每次运行的开始时间始终相隔<code>1000ms</code>。</p>
<p>而使用<code>FixedDelay</code>的输出如下：</p>
<pre><code class="language-bash">current timestamp: 1619351754890
elapsed time: 53
current timestamp: 1619351755944
elapsed time: 30
current timestamp: 1619351756974
elapsed time: 13
current timestamp: 1619351757987
elapsed time: 80
current timestamp: 1619351759068
elapsed time: 94
current timestamp: 1619351760162
elapsed time: 29
</code></pre>
<p>每次开始的时间为上一次执行完成后的时间再加上时间间隔（<code>1000ms</code>）。</p>
<h1 id="5-executors中的线程池">5 <code>Executors</code>中的线程池</h1>
<p><code>Executors</code>类提供了六种创建线程池的静态方法：</p>
<ul>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li><code>CachedThreadPool</code></li>
<li><code>ScheduledThreadPool</code></li>
<li><code>SingleThreadScheduledExecutor</code></li>
<li><code>WorkStealingPool</code></li>
</ul>
<p>下面分别来看一下。</p>
<h2 id="51-fixedthreadpool">5.1 <code>FixedThreadPool</code></h2>
<p>源码如下：</p>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
}

public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), threadFactory);
}
</code></pre>
<p><code>FixedThreadPool</code>底层调用的是<code>ThreadPoolExecutor</code>，默认创建的核心线程数与最大线程数相等，任务队列为无边界的<code>LinkedBlockingQueue</code>。</p>
<h2 id="52-singlethreadexecutor">5.2 <code>SingleThreadExecutor</code></h2>
<p>相关源码如下：</p>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), threadFactory));
}

private static class FinalizableDelegatedExecutorService extends Executors.DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
    }

    protected void finalize() {
        super.shutdown();
    }
}
</code></pre>
<p>可以看到<code>SingleThreadPool</code>实际上是内部类<code>FinalizableDelegatedExecutorService</code>的包装，核心线程与最大线程数均为1，任务队列为无边界的<code>LinkedBlockingQueue</code>。发生<code>GC</code>的时候，会调用<code>shutdown()</code>方法。</p>
<h2 id="53-cachedthreadpool">5.3 <code>CachedThreadPool</code></h2>
<p>源码如下：</p>
<pre><code class="language-java">public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), threadFactory);
}
</code></pre>
<p><code>CachedThreadPool</code>会根据需要创建新线程，通常用于执行量大的，耗时较短的异步任务。未被使用且空闲时间超过<code>60s</code>的线程会被回收。</p>
<h2 id="54-scheduledthreadpool">5.4 <code>ScheduledThreadPool</code></h2>
<p>源码如下：</p>
<pre><code class="language-java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
</code></pre>
<p>创建指定核心数<code>ScheduledThreadPoolExecutor</code>。</p>
<h2 id="55-singlethreadscheduledexecutor">5.5 <code>SingleThreadScheduledExecutor</code></h2>
<p>源码如下：</p>
<pre><code class="language-java">public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new Executors.DelegatedScheduledExecutorService(new ScheduledThreadPoolExecutor(1));
}

public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {
    return new Executors.DelegatedScheduledExecutorService(new ScheduledThreadPoolExecutor(1, threadFactory));
}

private static class DelegatedScheduledExecutorService extends Executors.DelegatedExecutorService implements ScheduledExecutorService {
    private final ScheduledExecutorService e;

    DelegatedScheduledExecutorService(ScheduledExecutorService executor) {
        super(executor);
        this.e = executor;
    }

    public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) {
        return this.e.schedule(command, delay, unit);
    }

    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) {
        return this.e.schedule(callable, delay, unit);
    }

    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return this.e.scheduleAtFixedRate(command, initialDelay, period, unit);
    }

    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return this.e.scheduleWithFixedDelay(command, initialDelay, delay, unit);
    }
}
</code></pre>
<p>其实就是<code>SingelThreadPool</code>+<code>ScheduledThreadPool</code>。</p>
<h2 id="56-workstealingpool">5.6 <code>WorkStealingPool</code></h2>
<p>源码如下：</p>
<pre><code class="language-java">public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool(parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, (UncaughtExceptionHandler)null, true);
}

public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool(Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, (UncaughtExceptionHandler)null, true);
}
</code></pre>
<p><code>WorkStealingPool</code>是<code>JDK8</code>引入的线程池，返回的是<code>ForkJoinPool</code>。在<code>WorkStealingPool</code>中，如果每个线程处理的任务执行比较耗时，那么它负责的任务会被其他线程“窃取”，进而提高并发处理的效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第315期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-315-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-315-qi/">
        </link>
        <updated>2021-04-25T00:48:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你和学霸的区别就是，你所有的灵光一闪，都是他的基本题型。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>草色青青柳色黄，桃花历乱李花香。<br>
——贾至《春思二首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>时光一逝永不回，往事只能回味。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619311735438.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>中序遍历，然后最后一个右节点取<code>null</code>：</p>
<pre><code class="language-java">public class Solution {
    private TreeNode newRoot = new TreeNode();
    private TreeNode temp = newRoot;
    private TreeNode preTemp = temp;
    public TreeNode increasingBST(TreeNode root) {
        inorder(root);
        preTemp.right = null;
        return newRoot;
    }

    private void inorder(TreeNode root){
        if(root != null){
            inorder(root.left);
            temp.val = root.val;
            preTemp = temp;
            temp.right = new TreeNode();
            temp = temp.right;
            inorder(root.right);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619311785567.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第314期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-314-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-314-qi/">
        </link>
        <updated>2021-04-24T02:41:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>回首过去，我居然没有，走过一次直路。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>春雨断桥人不渡，小舟撑出柳阴来。<br>
——徐俯《春游湖》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>在你最冷的时候，有人不顾自己寒冷抱着你，这就是幸福。。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619232322619.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<pre><code class="language-java">public class Solution {
    public int combinationSum4(int[] nums, int target) {
        if(target == 999){
            return 1;
        }
        int [] dp = new int[target+1];
        dp[0] = 1;
        for (int i = 1; i &lt;= target; i++) {
            for (int num:nums){
                if(num &lt;= i){
                    dp[i] += dp[i-num];
                }
            }
        }
        return dp[target];
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619232335053.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第313期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-313-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-313-qi/">
        </link>
        <updated>2021-04-23T00:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你家住海边吗？这么浪。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>日高烟敛，更看今日晴未。<br>
——李清照《念奴娇·春情》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你为了你的正义，我为了我的正义。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619136581446.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>动态规划，注意几个点：</p>
<ul>
<li><code>dp</code>数组可以从1开始计算，<code>dp[0] = 1</code></li>
<li>遍历<code>j</code>的时候可以使用<code>nums[j]</code>与<code>nums[i]</code>的关系遍历，而不是单纯使用<code>j&lt;i</code></li>
<li><code>dp</code>数组每次只自增1，因此可以放在<code>j</code>循环的外层，而不是每次都用<code>dp[j]+1 &gt; temp</code>比较</li>
<li>遍历完<code>dp</code>数组后可以记录最后一次最大数值出现的位置，这样倒序还原结果的时候相比起从末尾开始可以更快</li>
<li>还原结果的时候注意判断整除</li>
</ul>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return List.of(nums[0]);
        }
        Arrays.sort(nums);
        int [] dp = new int[n];
        dp[0] = 1;
        int max = 1;
        int last = 0;
        for (int i = 1; i &lt; n; i++) {
            for (int j = 0; nums[j]*2L &lt;= nums[i]; j++) {
                if(nums[i] % nums[j] == 0){
                    dp[i] = Math.max(dp[i],dp[j]);
                }
            }
            ++dp[i];
            if(dp[i] &gt; max){
                max = dp[i];
                last = i;
            }
        }
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(max);
        for (int i = last; i &gt;= 0; --i) {
            if(dp[i] == max &amp;&amp; nums[last] % nums[i] == 0){
                ans.add(nums[i]);
                --max;
                last = i;
            }
        }
        return ans;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619139871165.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第312期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-312-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-312-qi/">
        </link>
        <updated>2021-04-22T00:34:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619051735799.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>菜鸡只配用暴力。</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int n1 = matrix.length;
        int n2 = matrix[0].length;
        int[][] sum = new int[n1 + 1][n2 + 1];
        for (int i = 1; i &lt;= n1; i++) {
            for (int j = 1; j &lt;= n2; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }

        int ans = -1000000;

        for (int i = 1; i &lt;= n1; i++) {
            for (int j = 1; j &lt;= n2; j++) {
                for (int p = i; p &lt;= n1; p++) {
                    for (int q = j; q &lt;= n2; q++) {
                        int temp = sum[p][q] - sum[i - 1][q] - sum[p][j - 1] + sum[i - 1][j - 1];
                        if (temp &lt;= k) {
                            ans = Math.max(ans, temp);
                            if(ans == k){
                                return ans;
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619051695239.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CountDownLatch与CyclicBarrier的基本使用]]></title>
        <id>https://2293736867.github.io/post/countdownlatch-yu-cyclicbarrier-de-ji-ben-shi-yong/</id>
        <link href="https://2293736867.github.io/post/countdownlatch-yu-cyclicbarrier-de-ji-ben-shi-yong/">
        </link>
        <updated>2021-04-21T04:16:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p><code>CountDownLatch</code>以及<code>CyclicBarrier</code>都是<code>Java</code>里面的同步工具之一，本文介绍了两者的基本原理以及基本使用方法。</p>
<h1 id="2-countdownlatch">2 <code>CountDownLatch</code></h1>
<p><code>CountDownLatch</code>是一个同步工具类，常见的使用场景包括：</p>
<ul>
<li>允许一个或多个线程等待一系列的其他线程结束</li>
<li>在串行化任务中需要进行并行化处理，并等待所有并行化任务结束，串行化任务才能继续进行</li>
</ul>
<p>比如考虑这样一个场景，在一个电商网站中，用户点击了首页，需要一部分的商品，同时显示它们的价格，那么，调用的流程应该是：</p>
<ul>
<li>获取商品</li>
<li>计算售价</li>
<li>返回所有商品的最终售价</li>
</ul>
<p>解决这样的问题可以使用串行化或并行化操作，串行化就是逐一计算商品的售价，并返回，并行化就是获取商品后，并行计算每一个商品的售价，最后返回，显然后一种方案要比前一种要好，那么这时候就可以用上<code>CountDownLatch</code>了。</p>
<p>一份简单的模拟代码如下：</p>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import static java.util.concurrent.ThreadLocalRandom.current;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException{
        List&lt;Price&gt; list = IntStream.rangeClosed(1,10).mapToObj(Price::new).collect(Collectors.toList());
        //计数器大小为商品列表的长度
        final CountDownLatch latch = new CountDownLatch(list.size());
        //线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,2, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        list.forEach(p-&gt; executor.execute(()-&gt;{
            System.out.println(&quot;Product &quot;+p.id+&quot; start calculate price &quot;);
            try{
            	//随机休眠模拟业务操作耗时
                TimeUnit.SECONDS.sleep(current().nextInt(10));
                p.setPrice(p.getPrice()*((p.getId() &amp; 1) == 1 ? 0.9 : 0.7));
                System.out.println(&quot;Product &quot;+p.id+&quot; calculate price completed&quot;);
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
            	//每完成计算一个商品，将计数器减1，注意需要放在finally中
                latch.countDown();
            }
        }));
        //主线程阻塞直到所有的计数器为0，也就是等待所有的子任务计算价格完毕
        latch.await();
        System.out.println(&quot;All of prices calculate finished&quot;);
        //手动终止，不然不会结束运行
        executor.shutdown();
    }

    private static class Price{
        private final int id;
        private double price;

        public Price(int id) {
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public double getPrice() {
            return price;
        }

        public void setPrice(double price) {
            this.price = price;
        }
    }
}
</code></pre>
<p>输出：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210421104604159.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码比较简单，关键地方用上了注释，可以看到代码执行顺序如下：</p>
<ul>
<li>创建多个任务计算商品的价格</li>
<li>主线程阻塞</li>
<li>计算完成后，将计数器减1</li>
<li>当计数器为0时，主线程退出阻塞状态</li>
</ul>
<p>值得注意的是计数器减1的操作需要放在<code>finally</code>中，因为有可能会出现异常，如果出现异常导致计数器不能减少，那么主线程会一直阻塞。</p>
<p>另外，<code>CountDownLatch</code>还有一个<code>await(long timeout,TimeUnit unit)</code>方法，是带有超时参数的，也就是说，如果在超时时间内，计数器的值还是大于0（还有任务没执行完成），会使得当前线程退出阻塞状态。</p>
<h1 id="3-cyclicbarrier">3 <code>CyclicBarrier</code></h1>
<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>有很多类似的地方，也是一个同步工具类，允许多个线程在执行完相应的操作之后彼此等待到达同一个<code>barrier point</code>（屏障点）。<code>CyclicBarrier</code>也适合某个串行化的任务被拆分为多个并行化任务，这点与<code>CountDownLatch</code>类似，但是<code>CyclicBarrier</code>具备的一个更强大的功能是，<code>CyclicBarrier</code>可以被重复使用。</p>
<h2 id="31-等待完成">3.1 等待完成</h2>
<p>先简单说一下<code>CyclicBarrier</code>的实现原理：</p>
<ul>
<li>初始化<code>CyclicBarrier</code>，传入一个<code>int</code>参数，表示分片（<code>parites</code>），通常意义上来说分片数就是任务的数量</li>
<li>同时串行化执行多个任务</li>
<li>任务执行完成后，调用<code>await()</code>，等待其他线程也到达<code>barrier point</code></li>
<li>当所有线程到达后，继续以串行化方式运行任务</li>
</ul>
<p>常见的使用方法是设置分片数为任务数+1，这样，可以在主线程中执行<code>await()</code>，等待所有子任务完成。比如下面是使用<code>CyclicBarrier</code>实现同样功能的模拟代码：</p>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import static java.util.concurrent.ThreadLocalRandom.current;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException,BrokenBarrierException{
        List&lt;Price&gt; list = IntStream.rangeClosed(1,10).mapToObj(Price::new).collect(Collectors.toList());
        final CyclicBarrier barrier = new CyclicBarrier(11);
        ThreadPoolExecutor executor = new ThreadPoolExecutor(10,10,2, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        list.forEach(p-&gt; executor.execute(()-&gt;{
            System.out.println(&quot;Product &quot;+p.id+&quot; start calculate price &quot;);
            try{
                TimeUnit.SECONDS.sleep(current().nextInt(10));
                p.setPrice(p.getPrice()*((p.getId() &amp; 1) == 1 ? 0.9 : 0.7));
                System.out.println(&quot;Product &quot;+p.id+&quot; calculate price completed&quot;);
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
                try{
                    barrier.await();
                }catch (InterruptedException | BrokenBarrierException e){
                    e.printStackTrace();
                }
            }
        }));
        barrier.await();
        System.out.println(&quot;All of prices calculate finished&quot;);
        executor.shutdown();
    }

    private static class Price{
        private final int id;
        private double price;

        public Price(int id) {
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public double getPrice() {
            return price;
        }

        public void setPrice(double price) {
            this.price = price;
        }
    }
}
</code></pre>
<p>输出相同，代码大部分相似，不同的地方有：</p>
<ul>
<li><code>latch.countDown()</code>替换成了<code>barrier.await()</code></li>
<li><code>latch.await()</code>替换成了<code>barrier.await()</code></li>
<li>线程池的核心线程数替换成了<code>10</code></li>
</ul>
<p><code>await()</code>方法会等待所有的线程到达<code>barrier point</code>，上面代码执行流程简述如下：</p>
<ul>
<li>初始化<code>CyclicBarrier</code>，分片数为11（子线程数+1）</li>
<li>主线程调用<code>await()</code>，等待子线程执行完成</li>
<li>子线程各自进行商品价格的计算，计算完成后，调用<code>await()</code>，等待其他线程也到达<code>barrier point</code></li>
<li>当所有子线程计算完成后，由于没有后续操作，所以子线程运行结束，同时由于主线程还有后续操作，会先输出提示信息再终止线程池</li>
</ul>
<p>注意一个很大的不同就是这里的线程池核心线程数目改成了 10，那么，为什么需要10？</p>
<p>因为如果是设置一个小于10的核心线程个数，由于线程池是会先创建核心线程来执行任务，核心线程满了之后，放进任务队列中，而假设只有5个核心线程，那么：</p>
<ul>
<li>5个线程进行计算价格</li>
<li>另外5个任务放在任务队列中</li>
</ul>
<p>这样的话，会出现死锁，因为计算中的线程需要队列中的任务到达<code>barrier point</code>才能结束，而队列中的任务需要核心线程计算完毕后，才能调度出来计算，这样死锁就出现了。</p>
<h2 id="32-重复使用">3.2 重复使用</h2>
<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>的一个最大不同是，<code>CyclicBarrier</code>可以被重复使用，原理上来说，<code>await()</code>会将内部计数器减1，当计数器减为0时，会自动进行计数器（分片数）重置。比如，在上面的代码中，由于遇上促销活动，需要对商品的价格再次进行计算：</p>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import static java.util.concurrent.ThreadLocalRandom.current;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException,BrokenBarrierException{
        List&lt;Price&gt; list = IntStream.rangeClosed(1,10).mapToObj(Price::new).collect(Collectors.toList());
        final CyclicBarrier barrier = new CyclicBarrier(11);
        ThreadPoolExecutor executor = new ThreadPoolExecutor(10,10,2, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        list.forEach(p-&gt; executor.execute(()-&gt;{
            System.out.println(&quot;Product &quot;+p.id+&quot; start calculate price.&quot;);
            try{
                TimeUnit.SECONDS.sleep(current().nextInt(10));
                p.setPrice(p.getPrice()*((p.getId() &amp; 1) == 1 ? 0.9 : 0.7));
                System.out.println(&quot;Product &quot;+p.id+&quot; calculate price completed.&quot;);
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
                try{
                    barrier.await();
                }catch (InterruptedException | BrokenBarrierException e){
                    e.printStackTrace();
                }
            }
        }));
        barrier.await();
        System.out.println(&quot;All of prices calculate finished.&quot;);
		
		//复制的一段相同代码
        list.forEach(p-&gt; executor.execute(()-&gt;{
            System.out.println(&quot;Product &quot;+p.id+&quot; start calculate price again.&quot;);
            try{
                TimeUnit.SECONDS.sleep(current().nextInt(10));
                p.setPrice(p.getPrice()*((p.getId() &amp; 1) == 1 ? 0.9 : 0.7));
                System.out.println(&quot;Product &quot;+p.id+&quot; calculate price completed.&quot;);
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
                try{
                    barrier.await();
                }catch (InterruptedException | BrokenBarrierException e){
                    e.printStackTrace();
                }
            }
        }));
        barrier.await();
        System.out.println(&quot;All of prices calculate finished again.&quot;);
        executor.shutdown();
    }

    private static class Price{
        private final int id;
        private double price;

        public Price(int id) {
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public double getPrice() {
            return price;
        }

        public void setPrice(double price) {
            this.price = price;
        }
    }
}
</code></pre>
<p>将计算价格的代码复制一遍，其中没有手动修改计数器，只是调用<code>await()</code>，输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210421110421819.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到，并没有对<code>CycliBarrier</code>进行类似<code>reset</code>之类的操作，但是依然能按正常逻辑运行，这是因为<code>await()</code>内部会维护一个计数器，当计数器为0的时候，会自动进行重置，下面是<code>await()</code>在<code>OpenJDK 11</code>下的源码：</p>
<pre><code class="language-java">public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return this.dowait(false, 0L);
    } catch (TimeoutException var2) {
        throw new Error(var2);
    }
}
    
private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException {
    ReentrantLock lock = this.lock;
    lock.lock();

    byte var9;
    try {
        //...
        int index = --this.count;
        if (index != 0) {
            //计数器不为0的情况
            //....
        }

        boolean ranAction = false;

        try {
            Runnable command = this.barrierCommand;
            if (command != null) {
                command.run();
            }

            ranAction = true;
            
            this.nextGeneration();
            var9 = 0;
        } finally {
            if (!ranAction) {
                this.breakBarrier();
            }

        }
    } finally {
        lock.unlock();
    }

    return var9;
}

private void nextGeneration() {
    this.trip.signalAll();
    this.count = this.parties;
    this.generation = new CyclicBarrier.Generation();
}
</code></pre>
<p>当计数器为0时，会生成新的<code>Generation</code>，并将<code>var9</code>置为0，最后返回<code>var9</code>（在这个方法中<code>var9</code>只有一处赋值，就是代码中的<code>var9=0</code>，可以理解成直接返回0）。</p>
<h2 id="33-cyclicbarrier其他的一些常用方法">3.3 <code>CyclicBarrier</code>其他的一些常用方法</h2>
<ul>
<li><code>CyclicBarrier(int parties,Runnable barrierAction)</code>：构造的时候传入一个<code>Runnable</code>，表示所有线程到达<code>barrier point</code>时，会调用该<code>Runnable</code></li>
<li><code>await(long timeout,TimeUnit unit)</code>：与无参的<code>await()</code>类似，底层调用的是相同的<code>doWait()</code>，不过增加了超时功能</li>
<li><code>isBroken()</code>：返回<code>broken</code>状态，某个线程由于执行<code>await</code>而进入阻塞，此时如果执行了中断操作（比如<code>interrupt</code>），那么<code>isBroken()</code>会返回<code>true</code>。需要注意，处于<code>broken</code>状态的<code>CyclicBarrier</code>不能被直接使用，需要调用<code>reset()</code>进行重置</li>
</ul>
<h1 id="4-总结">4 总结</h1>
<p>下面是<code>CountDownLatch</code>与<code>CyclicBarrier</code>的一些简单比较，相同点如下：</p>
<ul>
<li>都是<code>java.util.concurrent</code>包下的线程同步工具类</li>
<li>都可以用于“主线程阻塞一直等待，直到子任务完成，主线程才继续执行”的情况</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>CountDownLatch</code>的<code>await()</code>方法会等待计数器归0，而<code>CyclicBarrier</code>的<code>await()</code>会等待其他线程到达<code>barrier point</code></li>
<li><code>CyclicBarrier</code>内部的计数器是可以被重置的，但是<code>CountDownLatch</code>不可以</li>
<li><code>CyclicBarrier</code>是由<code>Lock</code>和<code>Condition</code>实现的，而<code>CountDownLatch</code>是由同步控制器<code>AQS</code>实现的</li>
<li>构造时<code>CyclicBarrier</code>不允许<code>parties</code>为0，而<code>CountDownLatch</code>允许<code>count</code>为0</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第311期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-311-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-311-qi/">
        </link>
        <updated>2021-04-21T00:25:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>没人嘲笑你的梦想，他们只是，嘲笑你的实力。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>绿叶阴阴占得春，草满莺啼处。<br>
——徐俯《卜算子·天生百种愁》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>要保持希望在每天清晨太阳升起。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1618965019908.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>空间可以优化到<code>O(1)</code>的动态规划（前几天字节一面刚好碰上的这条，原题）：</p>
<pre><code class="language-java">public class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int a = 0;
        int b = 1;
        int c = 0;
        for (int i = 1; i &lt;= n; i++) {
            c = 0;
            if(s.charAt(i-1) != '0'){
                c += b;
            }
            if(i &gt; 1 &amp;&amp; s.charAt(i-2) != '0' &amp;&amp; ((s.charAt(i-2)-'0')*10 + (s.charAt(i-1)-'0') &lt;= 26)){
                c += a;
            }
            a = b;
            b = c;
        }
        return c;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1618968261834.png" alt="" loading="lazy"></figure>
<p><s>一开始用的回溯超时了</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Win10中手动添加/修改本地IP]]></title>
        <id>https://2293736867.github.io/post/zai-win10-zhong-shou-dong-tian-jia-xiu-gai-ben-di-ip/</id>
        <link href="https://2293736867.github.io/post/zai-win10-zhong-shou-dong-tian-jia-xiu-gai-ben-di-ip/">
        </link>
        <updated>2021-04-20T12:24:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-前言">1 前言</h1>
<p>好久没动<code>Win10</code>了。。。</p>
<p>今天需要用<code>Win10</code>做一下实验，手动修改<code>IP</code>，于是写下了这篇文章作为过程记录。</p>
<h1 id="2-概述">2 概述</h1>
<p><code>Win10</code>里面修改本地<code>IP</code>不是一件特别困难的事，简单来说可以分为两种方式：</p>
<ul>
<li>图形方式</li>
<li>命令行方式</li>
</ul>
<p>先来看一下比较简单的图形方式。</p>
<h1 id="3-图形操作">3 图形操作</h1>
<p>打开<code>Win</code>，输入<code>Network status</code>，可以看到下面界面：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210420194131656.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>选择其中的网卡（图中是<code>Ethernet</code>），点击其中的<code>Properties</code>：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210420194233437.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>点击其中的<code>Edit</code>并选择<code>Manual</code>就可以修改：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210420194425596.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>关于其中的值如何填写，建议参考<code>ipconfig /all</code>中的值。</p>
<p>图中右边的黑框就是在<code>cmd</code>使用<code>ipconfig /all</code>获取的结果，可以看到：</p>
<ul>
<li>内网<code>IP</code>：<code>10.0.2.15</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
<li>网关：<code>10.0.2.2</code></li>
</ul>
<p>所以根据需要修改内网<code>IP</code>的值即可，子网掩码一般为<code>24</code>（<code>255.255.255.0</code>）、网关、<code>DNS</code>可以直接使用默认网关的值（<code>10.0.2.2</code>）：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2021042019500892.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在<code>cmd</code>里面再次使用<code>ipconfig /all</code>就可以看到新修改的值了：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210420195142582.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-命令行操作">4 命令行操作</h1>
<p>众所周知，在<code>Win10</code>中使用命令行操作的档次比使用图形操作高了不止一个档次，而且，使用图形化操作的话还不能添加新的<code>IP</code>，只能修改<code>IP</code>，那么，这时候就轮到命令行操作登场了。</p>
<p>命令行操作主要使用到<code>netsh</code>命令，官方文档<a href="https://docs.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh-contexts">在此处</a>，先来看一下如何修改<code>IP</code>。</p>
<h2 id="41-修改ip">4.1 修改<code>IP</code></h2>
<p>操作之前，首先需要知道网卡的名字，使用</p>
<pre><code class="language-bash">netsh interface show interface
</code></pre>
<p>就可以看到自己的网卡名字了：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210420200502747.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这里只有一个叫<code>Ethernet</code>的网卡，修改时，使用<code>set</code>命令即可，格式为：</p>
<pre><code class="language-bash">netsh interface ipv4 set address name=&quot;INTERFACE_NAME&quot; static IP_ADDRESS SUBNET_MASK GATEWAY
</code></pre>
<p>比如这里需要修改为<code>10.0.2.18</code>的<code>IP</code>，命令如下（需要管理员权限）：</p>
<pre><code class="language-bash">netsh interface ipv4 set address name=&quot;Ethernet&quot; static 10.0.2.18 255.255.255.0 10.0.2.2
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/2021042020075619.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-新增ip">4.2 新增<code>IP</code></h2>
<p>操作与修改类似，只是修改为<code>add</code>命令，格式如下：</p>
<pre><code class="language-bash">netsh interface ipv4 add address name=&quot;INTERFACE_NAME&quot; IP_ADDRESS SUBNET_MASK GATEWAY
</code></pre>
<p>比如需要添加一个<code>10.0.2.19</code>的<code>IP</code>，命名如下：</p>
<pre><code class="language-bash">net interface ipv4 add address name=&quot;Ethernet&quot; 10.0.2.19 255.255.255.0 10.0.2.2
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/2021042020111724.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-删除ip">4.3 删除<code>IP</code></h2>
<p>删除<code>IP</code>操作也类似：</p>
<pre><code class="language-bash">netsh interface ipv4 delete address name=&quot;INTERFACE_NAME&quot; IP_ADDRESS
</code></pre>
<p>比如把刚才新增加的<code>10.0.2.19</code>删去：</p>
<pre><code class="language-bash">netsh interface ipv4 delete address name=&quot;Ethernet&quot; 10.0.2.19
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210420201345885.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-总结">5 总结</h1>
<p>图形化操作修改比较简单，而命令行修改功能强大，但是配置难度较高，实际情况中可以结合两者使用。</p>
<p>另外，如果出现了无法连接网络的情况，一种简单的解决办法是在<code>Network status</code>中切换为<code>DHCP</code>，自动分配<code>IP</code>以及<code>DNS</code>：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210420194233437.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-参考链接">6 参考链接</h1>
<ul>
<li><a href="https://www.howtogeek.com/103190/change-your-ip-address-from-the-command-prompt/">How to Change Your Computer’s IP Address From the Command Prompt</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh-contexts">Netsh Command Syntax, Contexts, and Formatting</a></li>
</ul>
]]></content>
    </entry>
</feed>