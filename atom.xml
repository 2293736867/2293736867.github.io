<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-05-10T13:14:44.105Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（二）：线程安全与ThreadGroup]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-er-xian-cheng-an-quan-yu-threadgroup/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-er-xian-cheng-an-quan-yu-threadgroup/">
        </link>
        <updated>2021-05-10T12:49:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第四、六章</li>
</ul>
<p>本文是两章的笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要讲述了<code>synchronized</code>以及<code>ThreadGroup</code>的基本用法。</p>
<h1 id="3-synchronized">3 <code>synchronized</code></h1>
<h2 id="31-简介">3.1 简介</h2>
<p><code>synchronized</code>可以防止线程干扰和内存一致性错误，具体表现如下：</p>
<ul>
<li><code>synchronized</code>提供了一种锁机制，能够确保共享变量的互斥访问，从而防止数据不一致的问题</li>
<li><code>synchronized</code>包括<code>monitor enter</code>和<code>monitor exit</code>两个<code>JVM</code>指令，能保证在任何时候任何线程执行到<code>monitor enter</code>成功之前都必须从主存获取数据，而不是从缓存中，在<code>monitor exit</code>运行成功之后，共享变量被更新后的值必须刷入主内存而不是仅仅在缓存中</li>
<li><code>synchronized</code>指令严格遵循<code>Happens-Beofre</code>规则，一个<code>monitor exit</code>指令之前必定要有一个<code>monitor enter</code></li>
</ul>
<h2 id="32-基本用法">3.2 基本用法</h2>
<p><code>synchronized</code>的基本用法可以用于对代码块或方法进行修饰，比如：</p>
<pre><code class="language-java">private final Object MUTEX = new Object();
    
public void sync1(){
    synchronized (MUTEX){
    }
}

public synchronized void sync2(){
}
</code></pre>
<h2 id="33-字节码简单分析">3.3 字节码简单分析</h2>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public class Main {
    private static final Object MUTEX = new Object();

    public static void main(String[] args) throws InterruptedException {
        final Main m = new Main();
        for (int i = 0; i &lt; 5; i++) {
            new Thread(m::access).start();
        }
    }

    public void access(){
        synchronized (MUTEX){
            try{
                TimeUnit.SECONDS.sleep(20);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>编译后查看字节码：</p>
<pre><code class="language-bash">javap -v -c -s -l Main.class
</code></pre>
<p><code>access()</code>字节码截取如下：</p>
<pre><code class="language-cpp">stack=3, locals=4, args_size=1
 0: getstatic     #9                  // Field MUTEX:Ljava/lang/Object;  获取MUTEX
 3: dup
 4: astore_1
 5: monitorenter					  // 执行monitor enter指令
 6: getstatic     #10                 // Field java/util/concurrent/TimeUnit.SECONDS:Ljava/util/concurrent/TimeUnit;
 9: ldc2_w        #11                 // long 20l
12: invokevirtual #13                 // Method java/util/concurrent/TimeUnit.sleep:(J)V
15: goto          23				  // 正常退出，跳转到字节码偏移量23的地方
18: astore_2
19: aload_2
20: invokevirtual #15                 // Method java/lang/InterruptedException.printStackTrace:()V
23: aload_1
24: monitorexit						  // monitor exit指令
25: goto          33
28: astore_3
29: aload_1
30: monitorexit
31: aload_3
32: athrow
33: return
</code></pre>
<p>关于<code>monitorenter</code>与<code>monitorexit</code>说明如下：</p>
<ul>
<li><code>monitorenter</code>：每一个对象与一个<code>monitor</code>相对应，一个线程尝试获取与对象关联的<code>monitor</code>的时候，如果<code>monitor</code>的计数器为0，会获得之后立即对计数器加1，如果一个已经拥有<code>monitor</code>所有权的线程重入，将导致计数器再次累加，而如果其他线程尝试获取时，会一直阻塞直到<code>monitor</code>的计数器变为0，才能再次尝试获取对<code>monitor</code>的所有权</li>
<li><code>monitorexit</code>：释放对<code>monitor</code>的所有权，将<code>monitor</code>的计数器减1，如果计数器为0，意味着该线程不再拥有对<code>monitor</code>的所有权</li>
</ul>
<h2 id="34-注意事项">3.4 注意事项</h2>
<h3 id="341-非空对象">3.4.1 非空对象</h3>
<p>与<code>monitor</code>关联的对象不能为空：</p>
<pre><code class="language-java">private Object MUTEX = null;
private void sync(){
    synchronized (MUTEX){

    }
}
</code></pre>
<p>会直接抛出空指针异常。</p>
<h3 id="342-作用域不当">3.4.2 作用域不当</h3>
<p>由于<code>synchronized</code>关键字存在排它性，作用域越大，往往意味着效率越低，甚至丧失并发优势，比如：</p>
<pre><code class="language-java">private synchronized void sync(){
    method1();
    syncMethod();
    method2();
}
</code></pre>
<p>其中只有第二个方法是并发操作，那么可以修改为</p>
<pre><code class="language-java">private Object MUTEX = new Object();
private void sync(){
    method1();
    synchronized (MUTEX){
        syncMethod();
    }
    method2();
}
</code></pre>
<h3 id="343-使用不同的对象">3.4.3 使用不同的对象</h3>
<p>因为一个对象与一个<code>monitor</code>相关联，如果使用不同的对象，这样就失去了同步的意义，例子如下：</p>
<pre><code class="language-java">public class Main {
    public static class Task implements Runnable{
        private final Object MUTEX = new Object();

        @Override
        public void run(){
            synchronized (MUTEX){
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &lt; 20; i++) {
            new Thread(new Task()).start();
        }
    }
}
</code></pre>
<p>每一个线程争夺的<code>monitor</code>都是互相独立的，这样就失去了同步的意义，起不到互斥的作用。</p>
<h2 id="35-死锁">3.5 死锁</h2>
<p>另外，使用<code>synchronized</code>还需要注意的是有可能造成死锁的问题，先来看一下造成死锁可能的原因。</p>
<h3 id="351-死锁成因">3.5.1 死锁成因</h3>
<ul>
<li>交叉锁导致程序死锁：比如线程A持有R1的锁等待R2的锁，线程B持有R2的锁等待R1的锁</li>
<li>内存不足：比如两个线程T1和T2，T1已获取10MB内存，T2获取了15MB内存，T1和T2都需要获取30MB内存才能工作，但是剩余可用的内存为10MB，这样两个线程都在等待彼此释放内存资源</li>
<li>一问一答式的数据交换：服务器开启某个端口，等待客户端访问，客户端发送请求后，服务器因某些原因错过了客户端请求，导致客户端等待服务器回应，而服务器等待客户端发送请求</li>
<li>死循环引起的死锁：比较常见，使用<code>jstack</code>等工具看不到死锁，但是程序不工作，<code>CPU</code>占有率高，这种死锁也叫系统假死，难以排查和重现</li>
</ul>
<h3 id="352-例子">3.5.2 例子</h3>
<pre><code class="language-java">public class Main {
    private final Object MUTEX_READ = new Object();
    private final Object MUTEX_WRITE = new Object();

    public void read(){
        synchronized (MUTEX_READ){
            synchronized (MUTEX_WRITE){
            }
        }
    }

    public void write(){
        synchronized (MUTEX_WRITE){
            synchronized (MUTEX_READ){
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        new Thread(()-&gt;{
            while (true){
                m.read();
            }
        }).start();
        new Thread(()-&gt;{
            while (true){
                m.write();
            }
        }).start();
    }
}
</code></pre>
<p>两个线程分别占有<code>MUTEX_READ</code>/<code>MUTEX_WRITE</code>，同时等待另一个线程释放<code>MUTEX_WRITE</code>/<code>MUTEX_READ</code>，这就是交叉锁造成的死锁。</p>
<h3 id="353-排查">3.5.3 排查</h3>
<p>使用<code>jps</code>找到进程后，通过<code>jstack</code>查看：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210509221644115.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到明确的提示找到了1个死锁，<code>Thread-0</code>等待被<code>Thread-1</code>占有的<code>monitor</code>，而<code>Thread-1</code>等待被<code>Thread-0</code>占有的<code>monitor</code>。</p>
<h2 id="36-两个特殊的monitor">3.6 两个特殊的<code>monitor</code></h2>
<p>这里介绍两个特殊的<code>monitor</code>：</p>
<ul>
<li><code>this monitor</code></li>
<li><code>class monitor</code></li>
</ul>
<h3 id="361-this-monitor">3.6.1 <code>this monitor</code></h3>
<p>先上一段代码：</p>
<pre><code class="language-java">public class Main {
    public synchronized void method1(){
        System.out.println(Thread.currentThread().getName()+&quot; method1&quot;);
        try{
            TimeUnit.MINUTES.sleep(5);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public synchronized void method2(){
        System.out.println(Thread.currentThread().getName()+&quot; method2&quot;);
        try{
            TimeUnit.MINUTES.sleep(5);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        new Thread(m::method1).start();
        new Thread(m::method2).start();
    }
}
</code></pre>
<p>运行之后可以发现，只有一行输出，也就是说，只是运行了其中一个方法，另一个方法根本没有执行，使用<code>jstack</code>可以发现：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210509222610580.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>一个线程处于休眠中，而另一个线程处于阻塞中。而如果将<code>method2()</code>修改如下：</p>
<pre><code class="language-java">public void method2(){
    synchronized (this) {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>效果是一样的。也就是说，在方法上使用<code>synchronized</code>，等价于<code>synchronized(this)</code>。</p>
<h3 id="362-class-monitor">3.6.2 <code>class monitor</code></h3>
<p>把上面的代码中的方法修改为静态方法：</p>
<pre><code class="language-java">public class Main {
    public static synchronized void method1() {
        System.out.println(Thread.currentThread().getName() + &quot; method1&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static synchronized void method2() {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(Main::method1).start();
        new Thread(Main::method2).start();
    }
}
</code></pre>
<p>运行之后可以发现输出还是只有一行，也就是说只运行了其中一个方法，<code>jstack</code>分析也类似：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210509223432245.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果将<code>method2()</code>修改如下：</p>
<pre><code class="language-java">public static void method2() {
    synchronized (Main.class) {
        System.out.println(Thread.currentThread().getName() + &quot; method2&quot;);
        try {
            TimeUnit.MINUTES.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>可以发现输出还是一致，也就是说，在静态方法上的<code>synchronized</code>，等价于<code>synchronized(XXX.class)</code>。</p>
<h3 id="363-总结">3.6.3 总结</h3>
<ul>
<li><code>this monitor</code>：在成员方法上的<code>synchronized</code>，就是<code>this monitor</code>，等价于在方法中使用<code>synchronized(this)</code></li>
<li><code>class monitor</code>：在静态方法上的<code>synchronized</code>，就是<code>class monitor</code>，等价于在静态方法中使用<code>synchronized(XXX.class)</code></li>
</ul>
<h1 id="4-threadgroup">4 <code>ThreadGroup</code></h1>
<h2 id="41-简介">4.1 简介</h2>
<p>无论什么情况下，一个新创建的线程都会加入某个<code>ThreadGroup</code>中：</p>
<ul>
<li>如果新建线程没有指定<code>ThreadGroup</code>，默认就是<code>main</code>线程所在的<code>ThreadGroup</code></li>
<li>如果指定了<code>ThreadGroup</code>，那么就加入该<code>ThreadGroup</code>中</li>
</ul>
<p><code>ThreadGroup</code>中存在父子关系，一个<code>ThreadGroup</code>可以存在子<code>ThreadGroup</code>。</p>
<h2 id="42-创建">4.2 创建</h2>
<p>创建<code>ThreadGroup</code>可以直接通过构造方法创建，构造方法有两个，一个是直接指定名字（<code>ThreadGroup</code>为<code>main</code>线程的<code>ThreadGroup</code>），一个是带有父<code>ThreadGroup</code>与名字的构造方法：</p>
<pre><code class="language-java">ThreadGroup group1 = new ThreadGroup(&quot;name&quot;);
ThreadGroup group2 = new ThreadGroup(group1,&quot;name2&quot;);
</code></pre>
<p>完整例子：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadGroup group1 = new ThreadGroup(&quot;name&quot;);
    ThreadGroup group2 = new ThreadGroup(group1,&quot;name2&quot;);
    System.out.println(group2.getParent() == group1);
    System.out.println(group1.getParent().getName());
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-bash">true
main
</code></pre>
<h2 id="43-enumerate">4.3 <code>enumerate()</code></h2>
<p><code>enumerate()</code>可用于<code>Thread</code>和<code>ThreadGroup</code>的复制，因为一个<code>ThreadGroup</code>可以加入若干个<code>Thread</code>以及若干个子<code>ThreadGroup</code>，使用该方法可以方便地进行复制。方法描述如下：</p>
<ul>
<li><code>public int enumerate(Thread [] list)</code></li>
<li><code>public int enumerate(Thread [] list, boolean recurse)</code></li>
<li><code>public int enumerate(ThreadGroup [] list)</code></li>
<li><code>public int enumerate(ThreadGroup [] list, boolean recurse)</code></li>
</ul>
<p>上述方法会将<code>ThreadGroup</code>中的活跃线程/<code>ThreadGroup</code>复制到<code>Thread</code>/<code>ThreadGroup</code>数组中，布尔参数表示是否开启递归复制。</p>
<p>例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadGroup myGroup = new ThreadGroup(&quot;MyGroup&quot;);
    Thread thread = new Thread(myGroup,()-&gt;{
        while (true){
            try{
                TimeUnit.SECONDS.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    },&quot;MyThread&quot;);
    thread.start();
    TimeUnit.MILLISECONDS.sleep(1);
    ThreadGroup mainGroup = currentThread().getThreadGroup();
    Thread[] list = new Thread[mainGroup.activeCount()];
    int recurseSize = mainGroup.enumerate(list);
    System.out.println(recurseSize);
    recurseSize = mainGroup.enumerate(list,false);
    System.out.println(recurseSize);
}
</code></pre>
<p>后一个输出比前一个少1，因为不包含<code>myGroup</code>中的线程（递归设置为<code>false</code>）。需要注意的是，<code>enumerate()</code>获取的线程仅仅是一个预估值，并不能百分百地保证当前<code>group</code>的活跃线程，比如调用复制之后，某个线程结束了生命周期或者新的线程加入进来，都会导致数据不准确。另外，返回的<code>int</code>值相较起<code>Thread[]</code>的长度更为真实，因为<code>enumerate</code>仅仅将当前活跃的线程分别放进数组中，而返回值<code>int</code>代表的是真实的数量而不是数组的长度。</p>
<h2 id="44-其他api">4.4 其他<code>API</code></h2>
<ul>
<li><code>activeCount()</code>：获取<code>group</code>中活跃的线程，估计值</li>
<li><code>activeGroupCount()</code>：获取<code>group</code>中活跃的子<code>group</code>，也是一个近似值，会递归获取所有的子<code>group</code></li>
<li><code>getMaxPriority()</code>：用于获取<code>group</code>的优先级，默认情况下，<code>group</code>的优先级为10，且所有线程的优先级不得大于线程所在<code>group</code>的优先级</li>
<li><code>getName()</code>：获取<code>group</code>名字</li>
<li><code>getParent()</code>：获取父<code>group</code>，如果不存在返回<code>null</code></li>
<li><code>list()</code>：一个输出方法，递归输出所有活跃线程信息到控制台</li>
<li><code>parentOf(ThreadGroup g)</code>：判断当前<code>group</code>是不是给定<code>group</code>的父<code>group</code>，如果给定的<code>group</code>是自己本身，也会返回<code>true</code></li>
<li><code>setMaxPriority(int pri)</code>：指定<code>group</code>的最大优先级，设定后也会改变所有子<code>group</code>的最大优先级，另外，修改优先级后会出现线程优先级大于<code>group</code>优先级的情况，比如线程优先级为10，设置<code>group</code>优先级为5后，线程优先级就大于<code>group</code>优先级，但是新加入的线程优先级必须不能大于<code>group</code>优先级</li>
<li><code>interrupt()</code>：导致所有的活跃线程被中断，递归调用线程的<code>interrupt()</code></li>
<li><code>destroy()</code>：如果没有任何活跃线程，调用后在父<code>group</code>中将自己移除</li>
<li><code>setDaemon(boolean daemon)</code>：设置为守护<code>ThreadGroup</code>后，如果该<code>ThreadGroup</code>没有任何活跃线程，自动被销毁</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第330期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-330-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-330-qi/">
        </link>
        <updated>2021-05-09T17:47:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>减肥就是要向妈妈证明，不光胖找不到对象，瘦也找不到！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>寒随一夜去，春逐五更来。<br>
——史青《应诏赋得除夜》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我们的时代还没到来，有的人死后方生。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620582485898.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接上二分，题解有递归和迭代两种实现，两种都进行了优化死活就是跑不到0ms真的就气人：</p>
<pre><code class="language-java">public class Solution {
    public double myPow(double x, int n) {
        if (n == 0 || Math.abs(x - 1.0) &lt; 1e-6) {
            return 1.0;
        }
        if (Math.abs(x + 1.0) &lt; 1e-6) {
            return (n &amp; 1) == 1 ? -1.0 : 1.0;
        }
        if (n == Integer.MIN_VALUE) {
            return 0.0;
        }
        return n &gt; 0 ? f(x,n) : 1/f(x,-n);
    }

    private double f(double x,int n){
        double ans = 1.0;
        double temp = x;
        while (n &gt; 0) {
            if ((n &amp; 1) == 1) {
                ans *= temp;
            }
            temp *= temp;
            n &gt;&gt;= 1;
        }
        return ans;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620582499904.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第329期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-329-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-329-qi/">
        </link>
        <updated>2021-05-09T05:04:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>突然发现，起床第一件事是摸手机，睡前最后一件事是放下手机。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>有孙母未去，出入无完裙。<br>
——杜甫《石壕吏》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>幸福的家庭都是相似的，不幸的家庭各有各的不幸。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620536965623.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一开始直接暴力超时：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {

    private final PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;();
    private final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    private int m;
    private int k;

    public int minDays(int[] bloomDay, int m, int k) {
        this.m = m;
        this.k = k;
        int n = bloomDay.length;
        long target = (long) m * k;
        if (target &gt; n) {
            return -1;
        }
        for (int i = 0; i &lt; n; i++) {
            queue.add(new Node(bloomDay[i], i));
        }
        int bloomNum = 0;
        int day = -1;
        while (!queue.isEmpty()) {
            day = queue.peek().day;
            Node temp;
            while ((temp = queue.peek()) != null) {
                if (temp.day == day) {
                    list.add(temp.index);
                    queue.remove();
                    ++bloomNum;
                }else{
                    break;
                }
            }
            if (bloomNum &gt;= target) {
                if (check()) {
                    break;
                }
            }
        }
        return day;
    }

    private boolean check() {
        int bloomNum = 0;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(this.list);
        list.sort(Comparator.naturalOrder());
        for (int i = 0; i &lt; list.size(); i++) {
            int j;
            int cur = list.get(i);
            for (j = cur+1;j&lt;=cur+k-1 &amp;&amp; list.contains(j);++j){
            }
            if(j &gt; cur+k-1){
                ++bloomNum;
                for (j = cur;j&lt;=cur+k-1;++j){
                    list.remove((Object)j);
                }
                i = -1;
            }
            if(bloomNum == m){
                return true;
            }
        }

        return false;
    }

    private static class Node implements Comparable&lt;Node&gt; {
        int day;
        int index;

        public Node(int day, int index) {
            this.day = day;
            this.index = index;
        }

        @Override
        public int compareTo(Node node) {
            if (node == this) {
                return 0;
            }
            if (this.day &lt; node.day) {
                return -1;
            } else if (this.day &gt; node.day) {
                return 1;
            }
            return 0;
        }
    }
}
</code></pre>
<p>然后看了题解才知道用二分，加上自己的极致优化，成功打败了最快的12ms：</p>
<pre><code class="language-java">public class Solution {

    private int[] bloomDay;

    public int minDays(int[] bloomDay, int m, int k) {
        if (m * k &gt; (this.bloomDay = bloomDay).length) {
            return -1;
        }

        int low = 1;
        int high = 1;
        for (int day : bloomDay) {
            if (day &gt; high) {
                high = day;
            }
        }

        while (low &lt; high) {
            int mid = low + ((high - low) &gt;&gt; 1);
            if (check(mid, m, k)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }

    private boolean check(int day, int m, int k) {
        int flowers = 0;
        int[] bloomDay = this.bloomDay;
        int n = bloomDay.length;

        for (int i = 0; i &lt; n; ++i) {
            if (bloomDay[i] &lt;= day) {
                if (++flowers == k) {
                    if (--m == 0) {
                        return true;
                    }
                    flowers = 0;
                }
            } else {
                if (i + m * k &gt; n) {
                    return false;
                }
                flowers = 0;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620537021276.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620537057255.png" alt="" loading="lazy"></figure>
<h1 id="母亲节">母亲节</h1>
<p>今天是2021年5月9日，也就是五月的第二个周日，换句话说，是母亲节。</p>
<p>这里祝天底下的母亲节日快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决druid在OpenJDK11+Gradle中的依赖问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-druid-zai-openjdk11gradle-zhong-de-yi-lai-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-druid-zai-openjdk11gradle-zhong-de-yi-lai-wen-ti/">
        </link>
        <updated>2021-05-08T12:14:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境<code>OpenJDK 11</code>+<code>Gradle</code>，直接在<code>build.gradle</code>中引入<code>druid</code>的依赖，报错如下：</p>
<pre><code class="language-bash">'dependencies.dependency.systemPath' for com.sun:tools:jar must specify an absolute path but is ${project.basedir}/lib/openjdk-1.8-tools.jar in com.alibaba:druid:1.2.6
'dependencies.dependency.systemPath' for com.sun:jconsole:jar must specify an absolute path but is ${project.basedir}/lib/openjdk-1.8-jconsole.jar in com.alibaba:druid:1.2.6
</code></pre>
<h1 id="2-原因分析">2 原因分析</h1>
<p>具体原因的话在<a href="https://github.com/alibaba/druid/issues/3060">issue</a>中可以知道，其实就是没有兼容<code>JDK11</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210508191003854.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>既然运行没有问题，那么就手动解决编译问题好了。</p>
<h1 id="3-问题解决">3 问题解决</h1>
<p>根据<code>IDEA</code>的错误提示（具体因<code>druid</code>版本而异）：</p>
<pre><code class="language-bash">~/.gradle/caches/modules-2/files-2.1/com.alibaba/druid/1.2.6/c57198d77a31adf5bd36d35f9b12dc936b732587/druid-1.2.6.pom
</code></pre>
<p>修改提示中的<code>pom</code>文件：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210508191212686.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>把上面的两个包注释掉就可以了，在<code>1.2.6</code>版本的<code>druid</code>中，修改<code>pom</code>文件的第703行，添加注释即可：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210508191303886.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再次重新导入依赖可以看到没有问题了：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210508191408437.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决AUR无法正常升级WebStorm2021.1.1的问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-aur-wu-fa-zheng-chang-sheng-ji-webstorm202111-de-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-aur-wu-fa-zheng-chang-sheng-ji-webstorm202111-de-wen-ti/">
        </link>
        <updated>2021-05-08T07:19:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境<code>Manjaro</code>+<code>paru</code>，升级<code>WebStorm</code>的时候，错误提示如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210508150547587.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="2-原因">2 原因</h1>
<p>这个问题在<code>Arch</code>的<code>AUR</code>官网上<a href="https://aur.archlinux.org/packages/webstorm/">有讨论</a>：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210508150825742.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>就是<code>PKGBUILD</code>的文件中的版本号出错了，把版本号修改回来就可以了。</p>
<h1 id="3-解决方案">3 解决方案</h1>
<p>上面说了解决方案就是找到<code>WebStorm</code>的<code>PKGBUILD</code>版本并进行修改，<code>PKGBUILD</code>根据包管理工具的不同位于不同的缓存文件夹下，这里列举两个常见的<code>AUR</code>助手的缓存位置：</p>
<ul>
<li><code>yay</code>：<code>~/.cache/yay</code></li>
<li><code>paru</code>：<code>~/.cache/paru</code></li>
</ul>
<p>笔者使用的是<code>paru</code>，进入<code>~/.cache/paru/webstorm</code>，修改<code>PKGBUILD</code>，把版本从错误提示信息的<code>211.7142.468</code>改为<code>211.7142.46</code>：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2021050815155561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210508151737504.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>修改完后重新安装：</p>
<pre><code class="language-bash">paru -S webstorm
</code></pre>
<p>这样就成功了：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210508151821713.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（一）：Thread详解]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-yi-thread-xiang-jie/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-yi-thread-xiang-jie/">
        </link>
        <updated>2021-05-08T02:45:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第一、二、三章</li>
</ul>
<p>本文是前三章的笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要讲述了线程的生命周期、<code>Thread</code>类的构造方法以及常用<code>API</code>，最后介绍了线程的关闭方法。</p>
<h1 id="3-线程生命周期">3 线程生命周期</h1>
<h2 id="31-五个阶段">3.1 五个阶段</h2>
<p>线程生命周期可以分为五个阶段：</p>
<ul>
<li><code>NEW</code></li>
<li><code>RUNNABLE</code></li>
<li><code>RUNNING</code></li>
<li><code>BLOCKED</code></li>
<li><code>TERMINATED</code></li>
</ul>
<h2 id="32-new">3.2 <code>NEW</code></h2>
<p>用<code>new</code>创建一个<code>Thread</code>对象时，但是并没有使用<code>start()</code>启动线程，此时线程处于<code>NEW</code>状态。准确地说，只是<code>Thread</code>对象的状态，这就是一个普通的<code>Java</code>对象。此时可以通过<code>start()</code>方法进入<code>RUNNABLE</code>状态。</p>
<h2 id="33-runnable">3.3 <code>RUNNABLE</code></h2>
<p>进入<code>RUNNABLE</code>状态必须调用<code>start()</code>方法，这样就在<code>JVM</code>中创建了一个线程。但是，线程一经创建，并不能马上被执行，线程执行与否需要听令于<code>CPU</code>调度，也就是说，此时是处于可执行状态，具备执行的资格，但是并没有真正执行起来，而是在等待被调度。</p>
<p><code>RUNNABLE</code>状态只能意外终止或进入<code>RUNNING</code>状态。</p>
<h2 id="34-running">3.4 <code>RUNNING</code></h2>
<p>一旦<code>CPU</code>通过轮询或其他方式从任务可执行队列中选中了线程，此时线程才能被执行，也就是处于<code>RUNNING</code>状态，在该状态中，可能发生的状态转换如下：</p>
<ul>
<li>进入<code>TERMINATED</code>：比如调用已经不推荐的<code>stop()</code>方法</li>
<li>进入<code>BLOCKED</code>：比如调用了<code>sleep()</code>/<code>wait()</code>方法，或者进行某个阻塞操作（获取锁资源、磁盘<code>IO</code>等）</li>
<li>进入<code>RUNNABLE</code>：<code>CPU</code>时间片到，或者线程主动调用<code>yield()</code></li>
</ul>
<h2 id="35-blocked">3.5 <code>BLOCKED</code></h2>
<p>也就是阻塞状态，进入阻塞状态的原因很多，常见的如下：</p>
<ul>
<li>磁盘<code>IO</code></li>
<li>网络操作</li>
<li>为了获取锁而进入阻塞操作</li>
</ul>
<p>处于<code>BLOCKED</code>状态时，可能发生的状态转换如下：</p>
<ul>
<li>进入<code>TERMINATED</code>：比如调用不推荐的<code>stop()</code>，或者<code>JVM</code>意外死亡</li>
<li>进入<code>RUNNABLE</code>：比如休眠结束、被<code>notify()</code>/<code>nofityAll()</code>唤醒、获取到某个锁、阻塞过程被<code>interrupt()</code>打断等</li>
</ul>
<h2 id="36-terminated">3.6 <code>TERMINATED</code></h2>
<p><code>TERMINATED</code>是线程的最终状态，进入该状态后，意味着线程的生命周期结束，比如在下列情况下会进入该状态：</p>
<ul>
<li>线程运行正常结束</li>
<li>线程运行出错意外结束</li>
<li><code>JVM</code>意外崩溃，导致所有线程都强制结束</li>
</ul>
<h1 id="4-thread构造方法">4 <code>Thread</code>构造方法</h1>
<h2 id="41-构造方法">4.1 构造方法</h2>
<p><code>Thread</code>的构造方法一共有八个，这里根据命名方式分类，使用默认命名的构造方法如下：</p>
<ul>
<li><code>Thread()</code></li>
<li><code>Thread(Runnable target)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target)</code></li>
</ul>
<p>命名线程的构造方法如下：</p>
<ul>
<li><code>Thread(String name)</code></li>
<li><code>Thread(Runnable target,Strintg name)</code></li>
<li><code>Thread(ThreadGroup group,String name)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target,String name)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target,String name,long stackSize)</code></li>
</ul>
<p>但实际上所有的构造方法最终都是调用如下私有构造方法：</p>
<pre><code class="language-java">private Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals);
</code></pre>
<p>在默认命名构造方法中，在源码中可以看到，默认命名其实就是<code>Thread-X</code>的命令（X为数字）：</p>
<pre><code class="language-java">public Thread() {
    this((ThreadGroup)null, (Runnable)null, &quot;Thread-&quot; + nextThreadNum(), 0L);
}

public Thread(Runnable target) {
    this((ThreadGroup)null, target, &quot;Thread-&quot; + nextThreadNum(), 0L);
}

private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
</code></pre>
<p>而在命名构造方法就是自定义的名字。</p>
<p>另外，如果想修改线程的名字，可以调用<code>setName()</code>方法，但是需要注意，处于<code>NEW</code>状态的线程才能修改。</p>
<h2 id="42-线程的父子关系">4.2 线程的父子关系</h2>
<p><code>Thread</code>的所有构造方法都会调用如下方法：</p>
<pre><code class="language-java">private Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals);
</code></pre>
<p>其中的一段源码截取如下：</p>
<pre><code class="language-java">if (name == null) {
    throw new NullPointerException(&quot;name cannot be null&quot;);
} else {
    this.name = name;
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        if (security != null) {
            g = security.getThreadGroup();
        }

        if (g == null) {
            g = parent.getThreadGroup();
        }
    }
}
</code></pre>
<p>可以看到当前这里有一个局部变量叫<code>parent</code>，并且赋值为<code>currentThread()</code>，<code>currentThread()</code>是一个<code>native</code>方法。因为一个线程被创建时的最初状态为<code>NEW</code>，因此<code>currentThread()</code>代表是创建自身线程的那个线程，也就是说，结论如下：</p>
<ul>
<li>一个线程的创建肯定是由另一个线程完成的</li>
<li>被创建线程的父线程是创建它的线程</li>
</ul>
<p>也就是自己创建的线程，父线程为<code>main</code>线程，而<code>main</code>线程由<code>JVM</code>创建。</p>
<p>另外，<code>Thread</code>的构造方法中有几个具有<code>ThreadGroup</code>参数，该参数指定了线程位于哪一个<code>ThreadGroup</code>，如果一个线程创建的时候没有指定<code>ThreadGroup</code>，那么将会和父线程同一个<code>ThreadGroup</code>。<code>main</code>线程所在的<code>ThreadGroup</code>称为<code>main</code>。</p>
<h2 id="43-关于stacksize">4.3 关于<code>stackSize</code></h2>
<p><code>Thread</code>构造方法中有一个<code>stackSize</code>参数，该参数指定了<code>JVM</code>分配线程栈的地址空间的字节数，对平台依赖性较高，在一些平台上：</p>
<ul>
<li>设置较大的值：可以使得线程内调用递归深度增加，降低<code>StackOverflowError</code>出现的概率</li>
<li>设置较低的值：可以使得创建的线程数增多，可以推迟<code>OutOfMemoryError</code>出现的时间</li>
</ul>
<p>但是，在一些平台上该参数不会起任何作用。另外，如果设置为0也不会起到任何作用。</p>
<h1 id="5-thread-api">5 <code>Thread API</code></h1>
<h2 id="51-sleep">5.1 <code>sleep()</code></h2>
<p><code>sleep()</code>有两个重载方法：</p>
<ul>
<li><code>sleep(long mills)</code></li>
<li><code>sleep(long mills,int nanos)</code></li>
</ul>
<p>但是在<code>JDK1.5</code>后，引入了<code>TimeUnit</code>，其中对<code>sleep()</code>方法提供了很好的封装，建议使用<code>TimeUnit.XXXX.sleep()</code>去代替<code>Thread.sleep()</code>：</p>
<pre><code class="language-java">TimeUnit.SECONDS.sleep(1);
TimeUnit.MINUTES.sleep(3);
</code></pre>
<h2 id="52-yield">5.2 <code>yield()</code></h2>
<p><code>yield()</code>属于一种启发式方法，提醒<code>CPU</code>调度器当前线程会自愿放弃资源，如果<code>CPU</code>资源不紧张，会忽略这种提醒。调用<code>yield()</code>方法会使当前线程从<code>RUNNING</code>变为<code>RUNNABLE</code>状态。</p>
<p>关于<code>yield()</code>与<code>sleep()</code>的区别，区别如下：</p>
<ul>
<li><code>sleep()</code>会导致当前线程暂停指定的时间，没有<code>CPU</code>时间片的消耗</li>
<li><code>yield()</code>只是对<code>CPU</code>调度器的一个提示，如果<code>CPU</code>调度器没有忽略这个提示，会导致线程上下文的切换</li>
<li><code>sleep()</code>会使线程短暂阻塞，在给定时间内释放<code>CPU</code>资源</li>
<li>如果<code>yield()</code>生效，<code>yield()</code>会使得从<code>RUNNING</code>状态进入<code>RUNNABLE</code>状态</li>
<li><code>sleep()</code>会几乎百分百地完成给定时间的休眠，但是<code>yield()</code>的提示不一定能担保</li>
<li>一个线程调用<code>sleep()</code>而另一个线程调用<code>interrupt()</code>会捕获到中断信号，而<code>yield</code>则不会</li>
</ul>
<h2 id="53-setpriority">5.3 <code>setPriority()</code></h2>
<h3 id="531-优先级介绍">5.3.1 优先级介绍</h3>
<p>线程与进程类似，也有自己的优先级，理论上来说，优先级越高的线程会有优先被调度的机会，但实际上并不是如此，设置优先级与<code>yield()</code>类似，也是一个提醒性质的操作：</p>
<ul>
<li>对于<code>root</code>用户，会提醒操作系统想要设置的优先级别，否则会被忽略</li>
<li>如果<code>CPU</code>比较忙，设置优先级可能会获得更多的<code>CPU</code>时间片，但是空闲时优先级的高低几乎不会有任何作用</li>
</ul>
<p>所以，设置优先级只是很大程度上让某个线程尽可能获得比较多的执行机会，也就是让线程自己尽可能被操作系统调度，而不是设置了高优先级就一定优先运行，或者说优先级高的线程比优先级低的线程就一定优先运行。</p>
<h3 id="532-优先级源码分析">5.3.2 优先级源码分析</h3>
<p>设置优先级直接调用<code>setPriority()</code>即可，<code>OpenJDK 11</code>源码如下：</p>
<pre><code class="language-java">public final void setPriority(int newPriority) {
    this.checkAccess();
    if (newPriority &lt;= 10 &amp;&amp; newPriority &gt;= 1) {
        ThreadGroup g;
        if ((g = this.getThreadGroup()) != null) {
            if (newPriority &gt; g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }

            this.setPriority0(this.priority = newPriority);
        }

    } else {
        throw new IllegalArgumentException();
    }
}
</code></pre>
<p>可以看到优先级处于<code>[1,10]</code>之间，而且不能设置为大于当前<code>ThreadGroup</code>的优先级，最后通过<code>native</code>方法<code>setPriority0</code>设置优先级。</p>
<p>一般情况下，不会对线程的优先级设置级别，默认情况下，线程的优先级为5，因为<code>main</code>线程的优先级为5，而且<code>main</code>为所有线程的父进程，因此默认情况下线程的优先级也是5。</p>
<h2 id="54-interrupt">5.4 <code>interrupt()</code></h2>
<p><code>interrupt()</code>是一个重要的<code>API</code>，线程中断的<code>API</code>有如下三个：</p>
<ul>
<li><code>void interrupt()</code></li>
<li><code>boolean isInterrupted()</code></li>
<li><code>static boolean interrupted()</code></li>
</ul>
<p>下面对其逐一进行分析。</p>
<h3 id="541-interrupt">5.4.1 <code>interrupt()</code></h3>
<p>一些方法调用会使得当前线程进入阻塞状态，比如：</p>
<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.sleep()</code></li>
<li><code>Thread.join()</code></li>
<li><code>Selector.wakeup()</code></li>
</ul>
<p>而调用<code>interrupt()</code>可以打断阻塞，打断阻塞并不等于线程的生命周期结束，仅仅是打断了当前线程的阻塞状态。一旦在阻塞状态下被打断，就会抛出一个<code>InterruptedException</code>的异常，这个异常就像一个信号一样通知当前线程被打断了，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException{
    Thread thread = new Thread(()-&gt;{
        try{
            TimeUnit.SECONDS.sleep(10);
        }catch (InterruptedException e){
            System.out.println(&quot;Thread is interrupted.&quot;);
        }
    });
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    thread.interrupt();
}
</code></pre>
<p>会输出线程被中断的信息。</p>
<h3 id="542-isinterrupted">5.4.2 <code>isInterrupted()</code></h3>
<p><code>isInterrupted()</code>可以判断当前线程是否被中断，仅仅是对<code>interrupt()</code>标识的一个判断，并不会影响标识发生任何改变（因为调用<code>interrupt()</code>的时候会设置内部的一个叫<code>interrupt flag</code>的标识），例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException{
    Thread thread = new Thread(()-&gt;{
        while (true){}
    });
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot;+thread.isInterrupted());
    thread.interrupt();
    System.out.println(&quot;Thread is interrupted :&quot;+thread.isInterrupted());
}
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-bash">Thread is interrupted :false
Thread is interrupted :true
</code></pre>
<p>另一个例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread() {
        @Override
        public void run() {
            while (true) {
                try {
                    TimeUnit.SECONDS.sleep(3);
                } catch (InterruptedException e) {
                    System.out.println(&quot;In catch block thread is interrupted :&quot; + isInterrupted());
                }
            }
        }
    };
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot; + thread.isInterrupted());
    thread.interrupt();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot; + thread.isInterrupted());
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-bash">Thread is interrupted :false
In catch block thread is interrupted :false
Thread is interrupted :false
</code></pre>
<p>一开始线程未被中断，结果为<code>false</code>，调用中断方法后，在循环体内捕获到了异常（信号），此时会<code>Thread</code>自身会擦除<code>interrupt</code>标识，将标识复位，因此捕获到异常后输出结果也为<code>false</code>。</p>
<h3 id="543-interrupted">5.4.3 <code>interrupted()</code></h3>
<p>这是一个静态方法，调用该方法会擦除掉线程的<code>interrupt</code>标识，需要注意的是如果当前线程被打断了：</p>
<ul>
<li>第一次调用<code>interrupted()</code>会返回<code>true</code>，并且立即擦除掉<code>interrupt</code>标识</li>
<li>第二次包括以后的调用永远都会返回<code>false</code>，除非在此期间线程又一次被打断</li>
</ul>
<p>例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread() {
        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.interrupted());
            }
        }
    };
    thread.setDaemon(true);
    thread.start();
    TimeUnit.MILLISECONDS.sleep(2);
    thread.interrupt();
}
</code></pre>
<p>输出（截取一部分）：</p>
<pre><code class="language-bash">false
false
false
true
false
false
false
</code></pre>
<p>可以看到其中带有一个<code>true</code>，也就是<code>interrupted()</code>判断到了其被中断，此时会立即擦除中断标识，并且只有该次返回<code>true</code>，后面都是<code>false</code>。</p>
<p>关于<code>interrupted()</code>与<code>isInterrupted()</code>的区别，可以从源码（<code>OpenJDK 11</code>）知道：</p>
<pre><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}

public boolean isInterrupted() {
    return this.isInterrupted(false);
}

@HotSpotIntrinsicCandidate
private native boolean isInterrupted(boolean var1);
</code></pre>
<p>实际上两者都是调用同一个<code>native</code>方法，其中的布尔变量表示是否擦除线程的<code>interrupt</code>标识：</p>
<ul>
<li><code>true</code>表示想要擦除，<code>interrupted()</code>就是这样做的</li>
<li><code>false</code>表示不想擦除，<code>isInterrupted()</code>就是这样做的</li>
</ul>
<h2 id="55-join">5.5 <code>join()</code></h2>
<h3 id="551-join简介">5.5.1 <code>join()</code>简介</h3>
<p><code>join()</code>与<code>sleep()</code>一样，都是属于可以中断的方法，如果其他线程执行了对当前线程的<code>interrupt</code>操作，也会捕获到中断信号，并且擦除线程的<code>interrupt</code>标识，<code>join()</code>提供了三个<code>API</code>，分别如下：</p>
<ul>
<li><code>void join()</code></li>
<li><code>void join(long millis,int nanos)</code></li>
<li><code>void join(long mills)</code></li>
</ul>
<h3 id="552-例子">5.5.2 例子</h3>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        List&lt;Thread&gt; threads = IntStream.range(1,3).mapToObj(Main::create).collect(Collectors.toList());
        threads.forEach(Thread::start);
        for (Thread thread:threads){
            thread.join();
        }
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot; # &quot;+i);
            shortSleep();
        }
    }

    private static Thread create(int seq){
        return new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(Thread.currentThread().getName()+&quot; # &quot;+i);
                shortSleep();
            }
        },String.valueOf(seq));
    }

    private static void shortSleep(){
        try{
            TimeUnit.MILLISECONDS.sleep(2);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>输出截取如下：</p>
<pre><code class="language-cpp">2 # 8
1 # 8
2 # 9
1 # 9
main # 0
main # 1
main # 2
main # 3
main # 4
</code></pre>
<p>线程1和线程2交替执行，而<code>main</code>线程会等到线程1和线程2执行完毕后再执行。</p>
<h1 id="6-线程关闭">6 线程关闭</h1>
<p><code>Thread</code>中有一个过时的方法<code>stop</code>，可以用于关闭线程，但是存在的问题是有可能不会释放<code>monitor</code>的锁，因此不建议使用该方法关闭线程。线程的关闭可以分为三类：</p>
<ul>
<li>正常关闭</li>
<li>异常退出</li>
<li>假死</li>
</ul>
<h2 id="61-正常关闭">6.1 正常关闭</h2>
<h3 id="611-正常结束">6.1.1 正常结束</h3>
<p>线程运行结束后，就会正常退出，这是最普通的一种情况。</p>
<h3 id="612-捕获信号关闭线程">6.1.2 捕获信号关闭线程</h3>
<p>通过捕获中断信号去关闭线程，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while(!isInterrupted()){

            }
            System.out.println(&quot;exit...&quot;);
        }
    };
    t.start();
    TimeUnit.SECONDS.sleep(5);
    System.out.println(&quot;System will be shutdown.&quot;);
    t.interrupt();
}
</code></pre>
<p>一直检查<code>interrupt</code>标识是否设置为<code>true</code>，设置为<code>true</code>则跳出循环。另一种方式是使用<code>sleep()</code>：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while(true){
                try{
                    TimeUnit.MILLISECONDS.sleep(1);
                }catch (InterruptedException e){
                    break;
                }
            }
            System.out.println(&quot;exit...&quot;);
        }
    };
    t.start();
    TimeUnit.SECONDS.sleep(5);
    System.out.println(&quot;System will be shutdown.&quot;);
    t.interrupt();
}
</code></pre>
<h3 id="613-volatile">6.1.3 <code>volatile</code></h3>
<p>由于<code>interrupt</code>标识很有可能被擦除，或者不会调用<code>interrupt()</code>方法，因此另一种方法是使用<code>volatile</code>修饰一个布尔变量，并不断循环判断：</p>
<pre><code class="language-java">public class Main {
    static class MyTask extends Thread{
        private volatile boolean closed = false;

        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while (!closed &amp;&amp; !isInterrupted()){

            }
            System.out.println(&quot;exit...&quot;);
        }

        public void close(){
            this.closed = true;
            this.interrupt();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyTask t = new MyTask();
        t.start();
        TimeUnit.SECONDS.sleep(5);
        System.out.println(&quot;System will be shutdown.&quot;);
        t.close();
    }
}
</code></pre>
<h2 id="62-异常退出">6.2 异常退出</h2>
<p>线程执行单元中是不允许抛出<code>checked</code>异常的，如果在线程运行过程中需要捕获<code>checked</code>异常并且判断是否还有运行下去的必要，可以将<code>checked</code>异常封装为<code>unchecked</code>异常，比如<code>RuntimeException</code>，抛出从而结束线程的生命周期。</p>
<h2 id="63-假死">6.3 假死</h2>
<p>所谓假死就是虽然线程存在，但是却没有任何的外在表现，比如：</p>
<ul>
<li>没有日志输出</li>
<li>不进行任何的作业</li>
</ul>
<p>等等，虽然此时线程是存在的，但看起来跟死了一样，事实上是没有死的，出现这种情况，很大可能是因为线程出现了阻塞，或者两个线程争夺资源出现了死锁。</p>
<p>这种情况需要借助一些外部工具去判断，比如<code>VisualVM</code>、<code>jconsole</code>等等，找出存在问题的线程以及当前的状态，并判断是哪个方法造成了阻塞。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第328期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-328-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-328-qi/">
        </link>
        <updated>2021-05-07T17:13:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>人不能低下高贵的头，但捡钱时例外。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>五更鼓角声悲壮，三峡星河影动摇。<br>
——杜甫《阁夜》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>迎着风，拥抱彩虹！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620407692283.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>尽力了，过51个样例：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    private int[] time;
    private int k;
    private int max;

    public int minimumTimeRequired(int[] jobs, int k) {
        Arrays.sort(jobs);
        int len = jobs.length;
        time = new int[this.k = k];
        if (k &gt;= len) {
            max = jobs[0];
            for (int i = 1; i &lt; len; i++) {
                if (max &lt; jobs[i]) {
                    max = jobs[i];
                }
            }
            return max;
        }
        boolean repeated = false;
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; len; i++) {
            if(set.contains(jobs[i])){
                repeated = true;
                break;
            }else{
                set.add(jobs[i]);
            }
        }
        if(k == 2 &amp;&amp; ((len &amp; 1) == 1) &amp;&amp; repeated){
            for (int i = 0; i &lt; len/2; i++) {
                time[0] += jobs[i];
            }
            for (int i = len/2+1; i &lt; len; i++) {
                time[1] += jobs[i];
            }
            if(time[0] &lt; time[1]){
                time[0] += jobs[len/2];
            }else{
                time[1] += jobs[len/2];
            }
            return Math.max(time[0],time[1]);
        }
        time[0] = jobs[len - 1];
        max = time[0];
        for (int i = len - 2; i &gt;= 0; --i) {
            int index = findMin(jobs[i]);
            time[index] += jobs[i];
            if (time[index] &gt; max) {
                max = time[index];
            }
        }
        return max;
    }

    private int findMin(int next){
        int i;
        int min = 0;
        for (i = 0; i &lt; k &amp;&amp; time[i] != 0; i++) {
            if (time[i] + next &lt;= max) {
                return i;
            }
            if(time[i] &lt; time[min]){
                min = i;
            }
        }
        for (int j = i; j &lt; k; j++) {
            if(time[j] &lt; time[min]) {
                min = j;
            }
        }
        return min;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620407710826.png" alt="" loading="lazy"></figure>
<p>看了题解才知道是状态压缩+动态规划，表示不会，这里放上一个回溯剪枝的版本：</p>
<pre><code class="language-java">public class Solution {

    private int minId = Integer.MAX_VALUE;

    public int minimumTimeRequired(int[] jobs, int k) {
        fd(jobs, new int[k], 0, 0);
        return minId;
    }

    private void fd(int[] jobs, int[] times, int m, int minTime) {
        if (m == jobs.length) {
            minId = Math.min(minTime, minId);
            return;
        }
        boolean first = true;
        for (int i=0; i&lt;times.length; i++) {
            if (times[i] == 0L &amp;&amp; !first) {
                return;
            }
            if (times[i] == 0L) {
                first = false;
            }
            times[i] += jobs[m];
            int tmpMax = Math.max(minTime, times[i]);
            if (tmpMax &lt; minId) {
                fd(jobs, times, m + 1, Math.max(minTime, times[i]));
            }
            times[i] -= jobs[m];
        }
    }
}
</code></pre>
<p>居然还有0ms的，惨无人性：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620408017415.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第327期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-327-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-327-qi/">
        </link>
        <updated>2021-05-07T01:35:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>这么多年来没掉入桃色陷阱，靠的就是两个字，没钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>沾衣欲湿杏花雨，吹面不寒杨柳风。<br>
——志南《绝句·古木阴中系短篷》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你的败因只有一个，就是与我为敌。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620351469814.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>遍历异或即可：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int xorOperation(int n, int start) {
        int end = start + 2*(n-1);
        int result = start;
        for (int i = start+2;i&lt;=end;i+=2){
            result ^= i;
        }
        return result;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620351533258.png" alt="" loading="lazy"></figure>
<p>当然也有<code>O(1)</code>时间空间的：</p>
<pre><code class="language-java">class Solution {
    public int xorOperation(int n, int start) {
        int s = start &gt;&gt; 1, e = n &amp; start &amp; 1;
        int ret = sumXor(s - 1) ^ sumXor(s + n - 1);
        return ret &lt;&lt; 1 | e;
    }

    public int sumXor(int x) {
        if (x % 4 == 0) {
            return x;
        }
        if (x % 4 == 1) {
            return 1;
        }
        if (x % 4 == 2) {
            return x + 1;
        }
        return 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第326期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-326-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-326-qi/">
        </link>
        <updated>2021-05-06T04:31:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>只要坚持不懈，嘲笑你的人，迟早被你笑死。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>长风怒卷高浪，飞洒日光寒。<br>
——元好问《水调歌头·赋三门津》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>兜里不硬气，啥都不敢买。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620275719877.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接错位异或即可得出答案：</p>
<pre><code class="language-java">public class Solution {
    public int[] decode(int[] encoded, int first) {
        int n = encoded.length;
        int [] arr = new int[n+1];
        arr[0] = first;
        for (int i = 1; i &lt;= n; i++) {
            arr[i] = arr[i-1] ^ encoded[i-1];
        }
        return arr;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620275746195.png" alt="" loading="lazy"></figure>
<h1 id="补课补课">补课补课</h1>
<p>周六要补课，但是好像那天没课？</p>
<p>好家伙。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第325期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-325-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-325-qi/">
        </link>
        <updated>2021-05-05T07:43:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>退一步海阔天空，没想到脚下落空。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>海棠糝径铺香绣，依旧成春瘦。<br>
——陈亮《虞美人·东风荡飏轻云缕》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果温柔是罪，那就只能用拳头来清洗我们犯下的罪孽。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620203196313.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一维<code>dp</code>，<code>dp</code>数组空间可以优化为<code>O(1)</code>，累计数字的出现个数后转化为“打家劫舍”问题：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        int [] sum = new int[10002];
        int max = 0;
        for (int num:nums){
            ++sum[num];
            max = Math.max(max,num);
        }
        int first = sum[1];
        int second = Math.max(first,sum[2]*2);
        int result = Math.max(first,second);
        for (int i = 3; i &lt;= max; i++) {
            int temp = Math.max(second,first+sum[i]*i);
            if(temp &gt; result){
                result = temp;
            }
            first = second;
            second = temp;
        }
        return result;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620203228100.png" alt="" loading="lazy"></figure>
<h1 id="五一续费">五一续费</h1>
<p>难得的五天假期就这样没有了。。。</p>
<p>好想为五一续费。。。</p>
]]></content>
    </entry>
</feed>