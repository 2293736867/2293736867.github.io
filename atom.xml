<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-03-05T03:55:56.762Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（三）：JVM基本参数]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-san-jvm-ji-ben-can-shu/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-san-jvm-ji-ben-can-shu/">
        </link>
        <updated>2021-03-05T03:49:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-gc%E6%97%A5%E5%BF%97-xloggc">2 <code>GC</code>日志：<code>-Xlog:gc</code></a></li>
<li><a href="#3-%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E6%89%93%E5%8D%B0">3 系统参数打印</a></li>
<li><a href="#4-%E5%A0%86%E5%8F%82%E6%95%B0">4 堆参数</a>
<ul>
<li><a href="#41-%E6%9C%80%E5%A4%A7%E5%A0%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%A0%86%E5%8F%82%E6%95%B0">4.1 最大堆与初始堆参数</a></li>
<li><a href="#42-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8F%82%E6%95%B0">4.2 新生代参数</a></li>
<li><a href="#43-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86">4.3 堆溢出处理</a></li>
</ul>
</li>
<li><a href="#5-%E9%9D%9E%E5%A0%86%E5%8F%82%E6%95%B0">5 非堆参数</a>
<ul>
<li><a href="#51-%E6%96%B9%E6%B3%95%E5%8C%BA">5.1 方法区</a></li>
<li><a href="#52-%E6%A0%88">5.2 栈</a></li>
<li><a href="#53-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">5.3 直接内存</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第三章</li>
</ul>
<p>本文是第三章的一些笔记整理。</p>
<h1 id="2-gc日志-xloggc">2 <code>GC</code>日志：<code>-Xlog:gc</code></h1>
<p>要打印<code>GC</code>日志的话，可以加上<code>-Xlog:gc</code>参数（<code>JDK8</code>及以下请使用<code>-XX:+PrintGC</code>），开启<code>GC</code>打印后，每次<code>GC</code>就会打印如下的日志（<code>OpenJDK11 -Xlog:gc</code>）：</p>
<pre><code class="language-bash">[0.126s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 25M-&gt;0M(502M) 1.902ms
[0.205s][info][gc] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 4.174ms
[0.236s][info][gc] GC(2) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 2.067ms
[0.268s][info][gc] GC(3) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;0M(502M) 2.362ms
</code></pre>
<p>其中开头的时间表示发生<code>GC</code>的时刻，<code>25M-&gt;0M(502M)</code>表示：</p>
<ul>
<li><code>GC</code>前，堆使用量为<code>25M</code></li>
<li><code>GC</code>后，堆使用量为<code>0M</code></li>
<li>堆空间总和约为<code>502M</code></li>
</ul>
<p>末尾的时间表示本次<code>GC</code>的耗时。</p>
<p>另外如果需要更加详细的参数，可以使用<code>-Xlog:gc*</code>（<code>JDK8</code>及以下请使用<code>-XX:+PrintGCDetails</code>），比如下面是一部分的<code>GC</code>日志（<code>-Xlog:gc*</code>）：</p>
<pre><code class="language-bash">[0.137s][info][gc,start     ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[0.138s][info][gc,task      ] GC(0) Using 10 workers of 10 for evacuation
[0.147s][info][gc,phases    ] GC(0)   Pre Evacuate Collection Set: 0.0ms
[0.147s][info][gc,phases    ] GC(0)   Evacuate Collection Set: 8.8ms
[0.147s][info][gc,phases    ] GC(0)   Post Evacuate Collection Set: 0.2ms
[0.147s][info][gc,phases    ] GC(0)   Other: 0.8ms
[0.147s][info][gc,heap      ] GC(0) Eden regions: 25-&gt;0(300)
[0.147s][info][gc,heap      ] GC(0) Survivor regions: 0-&gt;1(4)
[0.147s][info][gc,heap      ] GC(0) Old regions: 0-&gt;0
[0.147s][info][gc,heap      ] GC(0) Humongous regions: 0-&gt;0
[0.147s][info][gc,metaspace ] GC(0) Metaspace: 6633K-&gt;6633K(1056768K)
[0.147s][info][gc           ] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 25M-&gt;0M(502M) 9.878ms
[0.147s][info][gc,cpu       ] GC(0) User=0.05s Sys=0.00s Real=0.01s
</code></pre>
<ul>
<li>行首的时间：事件发生的时刻</li>
<li><code>GC(0)</code>：这是第1次<code>GC</code>，接着会有<code>GC(1)</code>、<code>GC(2)</code></li>
<li><code>Pause Young（Normal）</code>：这次<code>GC</code>回收了新生代</li>
<li><code>Using 10 workers</code>：使用10个工作线程</li>
<li><code>Pre Evacuate Collection Set</code>/<code>Evacuate Collection Set</code>/<code>Post Evacuate</code>/<code>Other</code>：表示<code>G1</code>垃圾回收标记，清除算法不同阶段所花费的时间</li>
<li><code>Eden/Survivor/Old/Humongous/Metaspace</code>：分别表示<code>eden区</code>、<code>存活区</code>、<code>老年区</code>、<code>巨型对象区</code>（就是很大很大的对象所在的区域）、<code>元数据区</code>在<code>GC</code>前后的大小</li>
<li><code>25M-0M(502M)</code>：<code>GC</code>前堆占用<code>25M</code>，<code>GC</code>后为<code>0M</code>，可用堆空间为<code>502M</code></li>
<li><code>User/Sys/Real</code>：分别表示<code>用户态CPU耗时</code>、<code>系统CPU耗时</code>、<code>GC真实经历时间</code></li>
</ul>
<p>如果想查看更全面的堆信息，可以使用<code>Visual VM</code>，将在后续文章中叙述。</p>
<p>另外如果需要将日志持久化，可以使用<code>-Xlog:gc:gc.log</code>。</p>
<h1 id="3-系统参数打印">3 系统参数打印</h1>
<p>参数<code>-XX:+PrintVMOptinos</code>可以打印运行时接收到的显式参数，而<code>-XX:+PrintCommandLineFlags</code>可以打印传递给<code>JVM</code>的隐式与显式参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210304094815957.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>另外一个参数是<code>-XX:+PrintFlagsFinal</code>，会打印所有系统参数的值（数量很多）：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210304094936823.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-堆参数">4 堆参数</h1>
<h2 id="41-最大堆与初始堆参数">4.1 最大堆与初始堆参数</h2>
<p><code>Java</code>进程启动时，虚拟机就会分配一块初始堆空间，可以使用参数<code>-Xms</code>指定这块空间的初始化大小。一般来说虚拟机会尽可能维持在初始堆空间范围内运行，但是如果初始堆空间耗尽，虚拟机会将堆空间进行扩展，扩展上限为最大堆空间，最大堆空间可以使用参数<code>-Xmx</code>指定。</p>
<p>来一段代码测试一下：</p>
<pre><code class="language-java">public class Main {

    public static void main(String[] args){
        printMemory();

        byte [] bytes = new byte[1*1024*1024];
        System.out.println(&quot;Allocate 1024 KB array&quot;);
        printMemory();

        bytes = new byte[4*1024*1024];
        System.out.println(&quot;Allocate 4096 KB array&quot;);
        printMemory();
    }

    public static void printMemory(){
        System.out.println();
        System.out.println(&quot;Max memory = &quot; + Runtime.getRuntime().maxMemory() / 1024+ &quot; KB&quot;);
        System.out.println(&quot;Free memory = &quot;+Runtime.getRuntime().freeMemory()/1024+ &quot; KB&quot;);
        System.out.println(&quot;Total memory = &quot; + Runtime.getRuntime().totalMemory()/ 1024+ &quot; KB&quot;);
        System.out.println();
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms5m
-XX:+PrintCommandLineFlags
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">-XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC 
[0.002s][info   ][gc] Using Serial
[0.002s][info   ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit

[0.110s][info   ][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.112s][info   ][gc,heap      ] GC(0) DefNew: 1664K-&gt;192K(1856K)
[0.112s][info   ][gc,heap      ] GC(0) Tenured: 0K-&gt;598K(4096K)
[0.112s][info   ][gc,metaspace ] GC(0) Metaspace: 6436K-&gt;6436K(1056768K)
[0.112s][info   ][gc           ] GC(0) Pause Young (Allocation Failure) 1M-&gt;0M(5M) 2.069ms
[0.112s][info   ][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.01s
Max memory = 19840 KB
Free memory = 4797 KB
Total memory = 5952 KB

Allocate 1024 KB array

Max memory = 19840 KB
Free memory = 3773 KB
Total memory = 5952 KB

[0.128s][info   ][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.129s][info   ][gc,start     ] GC(2) Pause Full (Allocation Failure)
[0.129s][info   ][gc,phases,start] GC(2) Phase 1: Mark live objects
[0.130s][info   ][gc,phases      ] GC(2) Phase 1: Mark live objects 1.366ms
[0.130s][info   ][gc,phases,start] GC(2) Phase 2: Compute new object addresses
[0.130s][info   ][gc,phases      ] GC(2) Phase 2: Compute new object addresses 0.235ms
[0.130s][info   ][gc,phases,start] GC(2) Phase 3: Adjust pointers
[0.131s][info   ][gc,phases      ] GC(2) Phase 3: Adjust pointers 0.624ms
[0.131s][info   ][gc,phases,start] GC(2) Phase 4: Move objects
[0.131s][info   ][gc,phases      ] GC(2) Phase 4: Move objects 0.042ms
[0.131s][info   ][gc             ] GC(2) Pause Full (Allocation Failure) 1M-&gt;1M(5M) 2.335ms
[0.131s][info   ][gc,heap        ] GC(1) DefNew: 1579K-&gt;0K(1856K)
[0.131s][info   ][gc,heap        ] GC(1) Tenured: 598K-&gt;1899K(4096K)
[0.131s][info   ][gc,metaspace   ] GC(1) Metaspace: 6624K-&gt;6624K(1056768K)
[0.131s][info   ][gc             ] GC(1) Pause Young (Allocation Failure) 2M-&gt;1M(5M) 3.636ms
[0.131s][info   ][gc,cpu         ] GC(1) User=0.00s Sys=0.01s Real=0.00s
Allocate 4096 KB array

Max memory = 19840 KB
Free memory = 4087 KB
Total memory = 10116 KB

[0.133s][info   ][gc,heap,exit   ] Heap
[0.133s][info   ][gc,heap,exit   ]  def new generation   total 1920K, used 44K [0x00000000fec00000, 0x00000000fee10000, 0x00000000ff2a0000)
[0.133s][info   ][gc,heap,exit   ]   eden space 1728K,   2% used [0x00000000fec00000, 0x00000000fec0b198, 0x00000000fedb0000)
[0.133s][info   ][gc,heap,exit   ]   from space 192K,   0% used [0x00000000fedb0000, 0x00000000fedb0000, 0x00000000fede0000)
[0.133s][info   ][gc,heap,exit   ]   to   space 192K,   0% used [0x00000000fede0000, 0x00000000fede0000, 0x00000000fee10000)
[0.133s][info   ][gc,heap,exit   ]  tenured generation   total 8196K, used 5995K [0x00000000ff2a0000, 0x00000000ffaa1000, 0x0000000100000000)
[0.133s][info   ][gc,heap,exit   ]    the space 8196K,  73% used [0x00000000ff2a0000, 0x00000000ff87aed0, 0x00000000ff87b000, 0x00000000ffaa1000)
[0.133s][info   ][gc,heap,exit   ]  Metaspace       used 6640K, capacity 6723K, committed 7040K, reserved 1056768K
[0.133s][info   ][gc,heap,exit   ]   class space    used 590K, capacity 623K, committed 640K, reserved 1048576K
</code></pre>
<p>最大内存由<code>-XX:MaxHeapSize</code>指定，该值为<code>-Xmx</code>的值，也就是<code>20 * 1024 * 1024</code>，而打印的最大可用内存为<code>20316160</code>，比设定的值少，这是因为分配给堆的内存空间与实际可用的内存空间并不是同一个概念，由于<code>GC</code>的需要，虚拟机会对堆空间进行分区管理，不同的区会采用不同的回收算法，一些算法会使用空间换时间的策略，因此会存在损失，最终的结果是实际可用内存会浪费大小等于<code>from</code>/<code>to</code>的空间，从输出可以知道：</p>
<pre><code class="language-bash">[0.139s][info][gc,heap,exit   ]   from space 192K,   0% used [0x00000000fedb0000, 0x00000000fedb0000, 0x00000000fede0000)
</code></pre>
<p><code>from</code>的大小为<code>192k</code>，但是实际情况是最大可用内存<code>19840k</code>+<code>from</code>的<code>192k</code>=<code>20032k</code>，并不是分配的内存<code>20480k</code>，这是因为虚拟机会对<code>from</code>/<code>to</code>进行对齐，将最大可用内存加上对齐后的<code>from</code>/<code>to</code>即得到分配的内存大小。</p>
<p>另外，打印显示，初始运行空闲内存<code>4797k</code>，分配一个<code>1024k</code>数组后，空闲内存为<code>3773k</code>，正好符合，接着分配<code>4096k</code>，因为内存不足，对堆空间进行扩展后再分配，扩展后的堆大小为<code>10116k</code>。</p>
<p>在实际工作中，可以将<code>-Xms</code>与<code>-Xmx</code>设置为相同，这样可以减少运行时的<code>GC</code>次数，提高性能。</p>
<h2 id="42-新生代参数">4.2 新生代参数</h2>
<p><code>-Xmn</code>可以设置新生代的大小，设置一个较大的新生代会减小老年代的大小，这个参数堆<code>GC</code>有很大影响，一般设置为堆空间的<code>1/3-1/4</code>。参数<code>-XX:SurvivorRatio</code>，也就是幸存区比例，可用来设置<code>eden区</code>与<code>from/to区</code>的比例，相当于：</p>
<pre><code class="language-bash">-XX:SurvivorRatio=eden/from=eden/to
</code></pre>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    byte [] b = null;
    for (int i = 0; i &lt; 10; i++) {
        b = new byte[1*1024*1024] ;
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms20m
-Xmn1m
-XX:SurvivorRatio=2
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">[0.002s][info][gc] Using Serial
[0.002s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.042s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.044s][info][gc,heap      ] GC(0) DefNew: 512K-&gt;256K(768K)
[0.044s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;172K(19456K)
[0.044s][info][gc,metaspace ] GC(0) Metaspace: 3871K-&gt;3871K(1056768K)
[0.044s][info][gc           ] GC(0) Pause Young (Allocation Failure) 0M-&gt;0M(19M) 1.617ms
[0.044s][info][gc,cpu       ] GC(0) User=0.01s Sys=0.00s Real=0.00s
[0.064s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.065s][info][gc,heap      ] GC(1) DefNew: 767K-&gt;76K(768K)
[0.065s][info][gc,heap      ] GC(1) Tenured: 172K-&gt;425K(19456K)
[0.065s][info][gc,metaspace ] GC(1) Metaspace: 4518K-&gt;4518K(1056768K)
[0.065s][info][gc           ] GC(1) Pause Young (Allocation Failure) 0M-&gt;0M(19M) 0.870ms
[0.065s][info][gc,cpu       ] GC(1) User=0.00s Sys=0.00s Real=0.00s
[0.093s][info][gc,heap,exit ] Heap
[0.093s][info][gc,heap,exit ]  def new generation   total 768K, used 562K [0x00000000fec00000, 0x00000000fed00000, 0x00000000fed00000)
[0.093s][info][gc,heap,exit ]   eden space 512K,  94% used [0x00000000fec00000, 0x00000000fec79730, 0x00000000fec80000)
[0.093s][info][gc,heap,exit ]   from space 256K,  29% used [0x00000000fec80000, 0x00000000fec93260, 0x00000000fecc0000)
[0.093s][info][gc,heap,exit ]   to   space 256K,   0% used [0x00000000fecc0000, 0x00000000fecc0000, 0x00000000fed00000)
[0.093s][info][gc,heap,exit ]  tenured generation   total 19456K, used 10665K [0x00000000fed00000, 0x0000000100000000, 0x0000000100000000)
[0.093s][info][gc,heap,exit ]    the space 19456K,  54% used [0x00000000fed00000, 0x00000000ff76a630, 0x00000000ff76a800, 0x0000000100000000)
[0.093s][info][gc,heap,exit ]  Metaspace       used 6190K, capacity 6251K, committed 6528K, reserved 1056768K
[0.093s][info][gc,heap,exit ]   class space    used 535K, capacity 570K, committed 640K, reserved 1048576K
</code></pre>
<p><code>eden区</code>与<code>from区</code>的比值为<code>2:1</code>，因此<code>eden区</code>为<code>512K</code>，总可用新生代大小为<code>512K+256K=768K</code>，新生代总大小为<code>512K+256K+256K=1M</code>，由于<code>eden</code>区无法容纳分配<code>1MB</code>数组，因此触发了新生代<code>GC</code>，所有数组分配在了老年代。</p>
<p>而如果使用<code>-Xmn7m</code>（其他参数保持不变），输出如下：</p>
<pre><code class="language-bash">[0.003s][info][gc] Using Serial
[0.003s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.096s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.097s][info][gc,heap      ] GC(0) DefNew: 2684K-&gt;1752K(5376K)
[0.097s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;0K(13312K)
[0.097s][info][gc,metaspace ] GC(0) Metaspace: 5929K-&gt;5929K(1056768K)
[0.097s][info][gc           ] GC(0) Pause Young (Allocation Failure) 2M-&gt;1M(18M) 1.350ms
[0.097s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.00s
[0.098s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(1) DefNew: 4928K-&gt;1024K(5376K)
[0.099s][info][gc,heap      ] GC(1) Tenured: 0K-&gt;727K(13312K)
[0.099s][info][gc,metaspace ] GC(1) Metaspace: 5996K-&gt;5996K(1056768K)
[0.099s][info][gc           ] GC(1) Pause Young (Allocation Failure) 4M-&gt;1M(18M) 1.142ms
[0.099s][info][gc,cpu       ] GC(1) User=0.01s Sys=0.00s Real=0.00s
[0.100s][info][gc,start     ] GC(2) Pause Young (Allocation Failure)
[0.100s][info][gc,heap      ] GC(2) DefNew: 4180K-&gt;1024K(5376K)
[0.100s][info][gc,heap      ] GC(2) Tenured: 727K-&gt;728K(13312K)
[0.100s][info][gc,metaspace ] GC(2) Metaspace: 6008K-&gt;6008K(1056768K)
[0.100s][info][gc           ] GC(2) Pause Young (Allocation Failure) 4M-&gt;1M(18M) 0.190ms
[0.100s][info][gc,cpu       ] GC(2) User=0.00s Sys=0.00s Real=0.00s
[0.100s][info][gc,heap,exit ] Heap
[0.100s][info][gc,heap,exit ]  def new generation   total 5376K, used 4211K [0x00000000fec00000, 0x00000000ff300000, 0x00000000ff300000)
[0.100s][info][gc,heap,exit ]   eden space 3584K,  88% used [0x00000000fec00000, 0x00000000fef1cc00, 0x00000000fef80000)
[0.100s][info][gc,heap,exit ]   from space 1792K,  57% used [0x00000000ff140000, 0x00000000ff2402a0, 0x00000000ff300000)
[0.100s][info][gc,heap,exit ]   to   space 1792K,   0% used [0x00000000fef80000, 0x00000000fef80000, 0x00000000ff140000)
[0.100s][info][gc,heap,exit ]  tenured generation   total 13312K, used 728K [0x00000000ff300000, 0x0000000100000000, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]    the space 13312K,   5% used [0x00000000ff300000, 0x00000000ff3b61f8, 0x00000000ff3b6200, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]  Metaspace       used 6034K, capacity 6091K, committed 6272K, reserved 1056768K
[0.100s][info][gc,heap,exit ]   class space    used 518K, capacity 538K, committed 640K, reserved 1048576K
</code></pre>
<p>此参数下，<code>eden区</code>有足够的空间，所有数组分配在<code>eden</code>区，但是不足以预留<code>10M</code>空间，因此产生了<code>GC</code>，每次申请空间也废弃了上一次申请的空间，在新生代<code>GC</code>中有效回收了这些内存，最后的结果是所有内存分配都在新生代进行，只是在<code>GC</code>过程中部分新生代对象晋升到了老年代。</p>
<p>再次增大新生代，使用<code>-Xmn15m -XX:SurvivorRatio=8</code>（其他参数不变），输出如下：</p>
<pre><code class="language-bash">[0.003s][info][gc] Using Serial
[0.003s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
start
[0.097s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(0) DefNew: 11416K-&gt;1471K(13696K)
[0.099s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;294K(5312K)
[0.099s][info][gc,metaspace ] GC(0) Metaspace: 6103K-&gt;6103K(1056768K)
[0.099s][info][gc           ] GC(0) Pause Young (Allocation Failure) 11M-&gt;1M(18M) 2.322ms
[0.099s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.01s
end
[0.099s][info][gc,heap,exit ] Heap
[0.099s][info][gc,heap,exit ]  def new generation   total 13696K, used 2934K [0x00000000fec00000, 0x00000000ffad0000, 0x00000000ffad0000)
[0.099s][info][gc,heap,exit ]   eden space 12224K,  11% used [0x00000000fec00000, 0x00000000fed6d908, 0x00000000ff7f0000)
[0.099s][info][gc,heap,exit ]   from space 1472K,  99% used [0x00000000ff960000, 0x00000000ffacfff8, 0x00000000ffad0000)
[0.099s][info][gc,heap,exit ]   to   space 1472K,   0% used [0x00000000ff7f0000, 0x00000000ff7f0000, 0x00000000ff960000)
[0.099s][info][gc,heap,exit ]  tenured generation   total 5312K, used 294K [0x00000000ffad0000, 0x0000000100000000, 0x0000000100000000)
[0.099s][info][gc,heap,exit ]    the space 5312K,   5% used [0x00000000ffad0000, 0x00000000ffb19960, 0x00000000ffb19a00, 0x0000000100000000)
[0.099s][info][gc,heap,exit ]  Metaspace       used 6164K, capacity 6251K, committed 6528K, reserved 1056768K
[0.099s][info][gc,heap,exit ]   class space    used 532K, capacity 570K, committed 640K, reserved 1048576K
</code></pre>
<p>可以看到新生代使用<code>15M</code>空间，<code>eden区</code>占了<code>12288K</code>，完全满足了<code>10MB</code>需要，并没有发生<code>GC</code>（日志的<code>GC</code>只是在<code>for</code>循环结束后产生的，一次性回收了<code>10M</code>）。</p>
<p>实际工作中，应根据系统的特点，做合理的设置，基本策略是：</p>
<ul>
<li>尽可能将对象预留在新生代</li>
<li>减少老年代<code>GC</code>次数</li>
</ul>
<p>另外，可以使用<code>-XX:NewRatio=老年代/新生代</code>指定新生代和老年代的比例，比如使用参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms20m
-XX:NewRatio=2
-Xlog:gc*
-XX:+UseSerialGC
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">[0.005s][info][gc] Using Serial
[0.005s][info][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
[0.096s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
[0.097s][info][gc,heap      ] GC(0) DefNew: 4852K-&gt;639K(6144K)
[0.097s][info][gc,heap      ] GC(0) Tenured: 0K-&gt;1112K(13696K)
[0.097s][info][gc,metaspace ] GC(0) Metaspace: 5905K-&gt;5905K(1056768K)
[0.097s][info][gc           ] GC(0) Pause Young (Allocation Failure) 4M-&gt;1M(19M) 1.413ms
[0.097s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.00s
[0.098s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[0.099s][info][gc,heap      ] GC(1) DefNew: 5920K-&gt;0K(6144K)
[0.099s][info][gc,heap      ] GC(1) Tenured: 1112K-&gt;2776K(13696K)
[0.099s][info][gc,metaspace ] GC(1) Metaspace: 5970K-&gt;5970K(1056768K)
[0.099s][info][gc           ] GC(1) Pause Young (Allocation Failure) 6M-&gt;2M(19M) 1.129ms
[0.099s][info][gc,cpu       ] GC(1) User=0.00s Sys=0.01s Real=0.00s
[0.100s][info][gc,heap,exit ] Heap
[0.100s][info][gc,heap,exit ]  def new generation   total 6144K, used 2238K [0x00000000fec00000, 0x00000000ff2a0000, 0x00000000ff2a0000)
[0.100s][info][gc,heap,exit ]   eden space 5504K,  40% used [0x00000000fec00000, 0x00000000fee2f690, 0x00000000ff160000)
[0.100s][info][gc,heap,exit ]   from space 640K,   0% used [0x00000000ff160000, 0x00000000ff160398, 0x00000000ff200000)
[0.100s][info][gc,heap,exit ]   to   space 640K,   0% used [0x00000000ff200000, 0x00000000ff200000, 0x00000000ff2a0000)
[0.100s][info][gc,heap,exit ]  tenured generation   total 13696K, used 2776K [0x00000000ff2a0000, 0x0000000100000000, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]    the space 13696K,  20% used [0x00000000ff2a0000, 0x00000000ff556250, 0x00000000ff556400, 0x0000000100000000)
[0.100s][info][gc,heap,exit ]  Metaspace       used 5998K, capacity 6091K, committed 6272K, reserved 1056768K
[0.100s][info][gc,heap,exit ]   class space    used 517K, capacity 538K, committed 640K, reserved 1048576K
</code></pre>
<p>堆大小为<code>20M</code>，新生代和老年代的比为<code>1:2</code>，因此新生代大小约为<code>7M</code>，老年代为<code>13M</code>，分配<code>1M</code>时，由于<code>from/to</code>空间不足，导致两个<code>1MB</code>的数组进入了老年代。</p>
<h2 id="43-堆溢出处理">4.3 堆溢出处理</h2>
<p>如果在<code>Java</code>程序运行过程中，堆空间不足，会抛出内存溢出错误，也就是常见的<code>OOM</code>。想要分析原因，可以使用参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>，可以在内存溢出时导出整个堆的信息，配合使用的还有<code>-XX:HeapDumpPath</code>，指定导出堆的存放路径，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 25; i++) {
        list.add(new byte[1*1024*1024]);
    }
}
</code></pre>
<p>参数：</p>
<pre><code class="language-bash">-Xmx20m
-Xms5m
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=out.dump
</code></pre>
<p>例子分配了<code>25M</code>的内存，但是堆只有<code>20M</code>，会抛出<code>OOM</code>，并且文件保存到<code>out.dump</code>中，注意该文件是二进制文件，需要使用专业的工具（如<code>MAT</code>等）查看。</p>
<h1 id="5-非堆参数">5 非堆参数</h1>
<h2 id="51-方法区">5.1 方法区</h2>
<p>从<code>JDK8</code>开始，永久区被移除，使用了新的元数据区来存放类的元数据，默认情况下，元数据区受系统可用内存的限制，但是仍然可以使用<code>-XX:MaxMetaspaceSize</code>指定永久区的最大可用值。</p>
<h2 id="52-栈">5.2 栈</h2>
<p>栈是每个线程私有的空间，可以使用<code>-Xss</code>指定线程的栈大小，具体在<a href="https://blog.csdn.net/qq_27525611/article/details/114308179?spm=1001.2014.3001.5501">笔者之前的文章中</a>。</p>
<h2 id="53-直接内存">5.3 直接内存</h2>
<p>直接内存跳过了<code>Java堆</code>，可以使得程序直接访问原生堆空间，在一定程度上加快了内存空间的访问速度。最大可用直接内存可以使用<code>-XX:MaxDirectMemorySize</code>设置，如果不设置，默认为最大堆空间，即<code>-Xmx</code>的值，当直接内存使用量到达最大值时，会触发<code>GC</code>，如果<code>GC</code>后不能有效释放足够的空间，直接内存依然会引起系统的<code>OOM</code>。</p>
<p>下面测试一下直接内存与堆的速度：</p>
<pre><code class="language-java">public class Main {

    public static final int count = 1000000;

    public static void directAccess(){
        long start = System.currentTimeMillis();
        ByteBuffer b = ByteBuffer.allocateDirect(500);
        for(int i=0;i&lt;count;++i){
            for (int j = 0; j &lt; 99; j++) {
                b.putInt(j) ;
            }
            b.flip();
            for (int j = 0; j &lt; 99; j++) {
                b.getInt();
            }
            b.clear();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Direct access: &quot;+(end-start)+&quot; ms&quot;);
    }

    public static void bufferAccess(){
        long start = System.currentTimeMillis();
        ByteBuffer b = ByteBuffer.allocate(500);
        for(int i=0;i&lt;count;++i){
            for (int j = 0; j &lt; 99; j++) {
                b.putInt(j) ;
            }
            b.flip();
            for (int j = 0; j &lt; 99; j++) {
                b.getInt();
            }
            b.clear();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Buffer access: &quot;+(end-start)+&quot; ms&quot;);
    }


    public static void main(String[] args){
        directAccess();
        bufferAccess();

        directAccess();
        bufferAccess();
    }
}
</code></pre>
<p>输出（不带任何参数）：</p>
<pre><code class="language-bash">Direct access: 167 ms
Buffer access: 70 ms
Direct access: 176 ms
Buffer access: 67 ms
</code></pre>
<p>直接内存的访问速度要快于堆内存，但是有一个缺点就是申请的时候速度慢：</p>
<pre><code class="language-java">public static void directAllocate(){
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; count; i++) {
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1000);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Direct allocate: &quot;+(end-start)+&quot; ms&quot;);
}

public static void bufferAllocate(){
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; count; i++) {
        ByteBuffer byteBuffer = ByteBuffer.allocate(1000);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Buffer allocate: &quot;+(end-start)+&quot; ms&quot;);
}


public static void main(String[] args){
    directAllocate();
    bufferAllocate();

    directAllocate();
    bufferAllocate();
}
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Direct allocate: 867 ms
Buffer allocate: 287 ms
Direct allocate: 676 ms
Buffer allocate: 208 ms
</code></pre>
<p>简单来说，直接内存适合申请次数较少、访问较频繁的场合，如果需要频繁申请内存空间，并不适合使用直接内存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第264期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-264-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-264-qi/">
        </link>
        <updated>2021-03-05T03:46:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>穷不要紧，抬头挺胸让大家看看，你不仅穷还丑还矮。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>斜风细雨作春寒，对尊前，忆前欢。<br>
——朱淑真《江城子·赏春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果不被畏惧，神又何以为神。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节面试流程概览]]></title>
        <id>https://2293736867.github.io/post/zi-jie-mian-shi-liu-cheng-gai-lan/</id>
        <link href="https://2293736867.github.io/post/zi-jie-mian-shi-liu-cheng-gai-lan/">
        </link>
        <updated>2021-03-04T00:24:52.000Z</updated>
        <content type="html"><![CDATA[<p><s>很水的一篇，勿喷。。。。</s></p>
<h1 id="1-流程">1 流程</h1>
<ul>
<li>网申</li>
<li>网测</li>
<li>面试</li>
<li>入职</li>
</ul>
<h1 id="2-网申">2 网申</h1>
<p>先头先筛，建议早点投但不用太早。</p>
<p>至于内推，本质上是没有什么区别，也是需要经历面试等阶段，只是企业的一种多渠道招人手段。</p>
<p>网申选岗阶段，可以选两个岗位，彼此独立，不限制投递时间。</p>
<p>可以根据不同的岗位准备不同的简历。</p>
<h1 id="3-网测">3 网测</h1>
<p>技术岗位的网测包括：</p>
<ul>
<li>编程题</li>
<li>单选题</li>
<li>多选题</li>
</ul>
<p>建议的策略是提前了解题型，掌握解题思路，针对性练习。</p>
<h1 id="4-面试">4 面试</h1>
<p>面试分为单面与群面。</p>
<h2 id="41-单面">4.1 单面</h2>
<p>一般3轮：</p>
<ul>
<li>部门经理：考察岗位胜任力（也就是技术）以及是否招人喜欢（面试技巧）</li>
<li>部门总监：岗位胜任力（深层），以及是否招人喜欢（面试技巧）</li>
<li><code>HR</code>：动机、忠诚度</li>
</ul>
<p>建议策略：</p>
<ul>
<li>经历提炼（写好简历）</li>
<li>提前准备</li>
<li>面试必考问题提前准备，不断打磨优化</li>
</ul>
<p>难点：</p>
<ul>
<li>经历讲不明白</li>
<li>讲的经历面试官不感兴趣</li>
</ul>
<p>总结：</p>
<ul>
<li>不准备：99%挂</li>
<li>准备了：未必能过，因为有可能别人比你准备得更好，与分数线同一个道理，你的分数比人低，自然上不去</li>
</ul>
<h2 id="42-群面">4.2 群面</h2>
<p>群面就是把一群面试者组成一个团队去进行面试。</p>
<p>群面不一定要当<code>Leader</code>，<a href="https://www.zhihu.com/question/339135205/answer/781010654">参考</a>。</p>
<p>群面需要找准自己的定位，如果你认为自己适合当<code>Leader</code>，那就争取<code>Leader</code>的角色。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第263期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-263-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-263-qi/">
        </link>
        <updated>2021-03-03T23:14:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>据说到2021年，要消灭贫困人口，我还不想死。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>晓日压重檐，头帐春寒起来忺。<br>
——孙道绚《南乡子·春闺》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>人总是害怕死亡，却殊不知有出生之时必有死亡之日。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（二）：JVM基本结构]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/">
        </link>
        <updated>2021-03-03T09:17:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-jvm%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></a></li>
<li><a href="#3-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">3 <code>JVM</code>基本结构</a></li>
<li><a href="#4-java%E5%A0%86">4 <code>Java堆</code></a></li>
<li><a href="#5-java%E6%A0%88">5 <code>Java栈</code></a>
<ul>
<li><a href="#51-%E7%AE%80%E4%BB%8B">5.1 简介</a></li>
<li><a href="#52-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">5.2 局部变量表</a>
<ul>
<li><a href="#521-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%AF%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.1 参数数量对局部变量表的影响</a></li>
<li><a href="#522-%E6%A7%BD%E4%BD%8D%E5%A4%8D%E7%94%A8">5.2.2 槽位复用</a></li>
<li><a href="#523-%E5%AF%B9gc%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.3 对<code>GC</code>的影响</a></li>
</ul>
</li>
<li><a href="#53-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%BA">5.3 操作数栈与帧数据区</a></li>
<li><a href="#54-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">5.4 栈上分配</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA">6 <code>方法区</code></a></li>
<li><a href="#7-java%E5%A0%86-java%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</a></li>
<li><a href="#8-%E5%B0%8F%E7%BB%93">8 小结</a></li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第二章</li>
</ul>
<p>本文是第二章的一些笔记整理。</p>
<h1 id="2-jvm基本参数-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></h1>
<p><code>java</code>命令的一般形式如下：</p>
<pre><code class="language-bash">java [-options] class [args..]
</code></pre>
<p>其中<code>-options</code>表示<code>JVM</code>启动参数，<code>class</code>为带有<code>main()</code>的<code>Java</code>类，<code>args</code>表示传递给<code>main()</code>的参数，也就是<code>main(String [] args)</code>中的参数。</p>
<p>一般设置参数在<code>-optinos</code>处设置，先看一段简单的代码：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        for(int i=0;i&lt;args.length;++i) {
            System.out.println(&quot;argument &quot;+(i+1)+&quot; : &quot;+args[i]);
        }
        System.out.println(&quot;-Xmx &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot; M&quot;);
    }
}
</code></pre>
<p>设置应用程序参数以及<code>JVM</code>参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2021030313324746.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输出：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210303133306902.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到<code>-Xmx32m</code>传递给<code>JVM</code>，使得最大可用堆空间为<code>32MB</code>，参数<code>a</code>作为应用程序参数，传递给<code>main()</code>，此时<code>args.length</code>的值为1。</p>
<h1 id="3-jvm基本结构">3 <code>JVM</code>基本结构</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210303134417147.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>各部分介绍如下：</p>
<ul>
<li><code>类加载子系统</code>：负责从文件系统或者网络中加载<code>Class</code>信息，加载的类信息存放在一个叫<code>方法区</code>的内存空间中</li>
<li><code>方法区</code>：除了包含加载的类信息之外，还包含运行时常量池信息，包括字符串字面量以及数字常量</li>
<li><code>Java堆</code>：在虚拟机启动时建立，是最主要的内存工作区域，几乎所有的<code>Java</code>对象实例都存在于<code>Java堆</code>中，<strong>堆空间是所有线程共享的</strong></li>
<li><code>直接内存</code>：是在<code>Java堆</code>外的，直接向系统申请的内存区域。<code>NIO</code>库允许<code>Java</code>程序使用<code>直接内存</code>，通常<code>直接内存</code>的访问速度要优于<code>Java堆</code>。另外由于<code>直接内存</code>在堆外，大小不会受限于<code>-Xmx</code>指定的堆大小，但是会受到操作系统总内存大小的限制</li>
<li><code>垃圾回收系统</code>：可以对<code>方法区</code>、<code>Java堆</code>和<code>直接内存</code>进行回收，<code>Java堆</code>是垃圾收集器的工作重点。对于不再使用的垃圾对象，<code>垃圾回收系统</code>会在后台默默工作、默默查找，标识并释放垃圾对象</li>
<li><code>Java栈</code>：每个<code>JVM</code>线程都有一个私有的<code>Java栈</code>，一个线程的<code>Java栈</code>在线程创建时被创建，保存着帧信息、局部变量、方法参数等</li>
<li><code>本地方法栈</code>：与<code>Java栈</code>类似，不同的是<code>Java栈</code>用于<code>Java</code>方法调用，<code>本地方法栈</code>用于本地方法（<code>native method</code>）调用，<code>JVM</code>允许<code>Java</code>直接调用本地方法</li>
<li><code>PC寄存器</code>：每个线程私有的空间，<code>JVM</code>会为每个线程创建<code>PC寄存器</code>，在任意时刻一个<code>Java</code>线程总是执行一个叫做<code>当前方法</code>的方法，如果<code>当前方法</code>不是本地方法，<code>PC</code>寄存器就会指向当前正在被执行的指令，如果<code>当前方法</code>是本地方法，那么<code>PC寄存器</code>的值就是<code>undefined</code></li>
<li><code>执行引擎</code>：负责执行<code>JVM</code>的字节码，现代<code>JVM</code>为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行</li>
</ul>
<p>下面重点说三部分：<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>。</p>
<h1 id="4-java堆">4 <code>Java堆</code></h1>
<p>几乎所有的对象都存在<code>Java堆</code>中，根据垃圾回收机制的不同，<code>Java堆</code>可能拥有不同的结构，最常见的一种是将整个<code>Java堆</code>分为<code>新生代</code>和<code>老年代</code>：</p>
<ul>
<li><code>新生代</code>：存放新生对象或年龄不大的对象，有可能分为<code>eden</code>、<code>s0</code>、<code>s1</code>，其中<code>s0</code>和<code>s1</code>分别被称为<code>from</code>和<code>to</code>区域，它们是两块大小相等、可以互换角色的内存空间</li>
<li><code>老年代</code>：存放老年对象，绝大多数情况下，对象首先在<code>eden</code>分配，在一次新生代回收后，如果对象还存活，会进入<code>s0</code>或<code>s1</code>，之后每经过一次新生代回收，如果对象存活则年龄加1。当对象年龄到达一定条件后，会被认为是老年对象，就会进入老年代</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210303134441993.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-java栈">5 <code>Java栈</code></h1>
<h2 id="51-简介">5.1 简介</h2>
<p><code>Java栈</code>是一块线程私有的内存空间，如果是<code>Java堆</code>与程序数据密切相关，那么<code>Java栈</code>和线程执行密切相关，线程执行的基本行为是函数调用，每次函数调用都是通过<code>Java栈</code>传递的。</p>
<p><code>Java栈</code>与数据结构中的<code>栈</code>类似，有<code>FIFO</code>的特点，在<code>Java</code>栈中保存的主要内容为<strong>栈帧</strong>，每次函数调用都会有一个对应的<code>栈帧</code>入栈，每次调用结束就有一个对应的<code>栈帧</code>出栈。栈顶总是当前的帧（当前执行的函数所对应的帧）。栈帧保存着<code>局部变量表</code>、<code>操作数栈</code>、<code>帧数据</code>等。</p>
<p>这里说一下题外话，相信很多读者对<code>StackOverflowError</code>不陌生，这是因为函数调用过多造成的，因为每次函数调用都会生成对应的栈帧，会占用一定的栈空间，如果栈空间不足，函数调用就无法进行，当请求栈深度大于最大可用栈深度时，就会抛出<code>StackOverflowError</code>。</p>
<p><code>JVM</code>提供了<code>-Xss</code>来指定线程的最大栈空间。</p>
<p>比如，下面这个递归调用的程序：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
            recursion();
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
        }
    }
}
</code></pre>
<p>指定<code>-Xss1m</code>，结果：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210303141441656.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss2m</code>：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210303141344772.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss3m</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210303141413662.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到调用深度随着<code>-Xss</code>的增加而增加。</p>
<h2 id="52-局部变量表">5.2 局部变量表</h2>
<p>局部变量表是栈帧的重要组成部分之一，用于保存函数的参数及局部变量。局部变量表中的变量只在当前函数调用中有效，函数调用结束后，函数栈帧销毁，局部变量表也会随之销毁。</p>
<h3 id="521-参数数量对局部变量表的影响">5.2.1 参数数量对局部变量表的影响</h3>
<p>由于局部变量表在栈帧中，如果函数的参数和局部变量表较多，会使局部变量表膨胀，导致栈帧会占用更多的栈空间，最终减少了函数嵌套调用次数。</p>
<p>比如：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(long a,long b,long c){
        long e=1,f=2,g=3,h=4,i=5,k=6,q=7;

        count++;
        recursion(a,b,c);
    }

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
//            recursion();
            recursion(0L,1L,2L);
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
            count = 0;
        }
    }
}
</code></pre>
<p>无参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210303145401403.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>带参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210303145451827.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到次数明显减少了，原因正是因为局部变量表变大，导致栈帧变大，从而次数减少。</p>
<p>下面使用<code>jclasslib</code>进一步查看，先在<code>IDEA</code>安装如下插件：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210303145242291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装后使用插件查看情况：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20210303145931511.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第一个函数是带参数的，可以看到最大局部变量表的大小为<code>20字</code>（注意不是字节），<code>Long</code>在局部变量表中需要占用2字。而相比之下不带参数的函数最大局部变量表大小为0：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210303150723100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-槽位复用">5.2.2 槽位复用</h3>
<p>局部变量表中的槽位是可以复用的，如果一个局部变量超过了其作用域，则在其作用域之后的局部变量就有可能复用该变量的槽位，这样能够节省资源，比如：</p>
<pre><code class="language-java">public static void localVar1(){
    int a = 0;
    System.out.println(a);
    int b = 0;
}

public static void localVar2(){
    {
        int a = 0;
        System.out.println(a);
    }
    int b = 0;
}
</code></pre>
<p>同样使用<code>jclasslib</code>查看：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210303151315773.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210303151328196.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到少了<code>localVar2</code>的最大局部变量大小为1字，相比<code>localVar1</code>少了1字，继续分析，<code>localVar1</code>第0个槽位为变量a，第1个槽位为变量b：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210303151544872.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而<code>localVar2</code>中的b复用了a的槽位，因此最大变量大小为1字，节约了空间。</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210303151611143.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="523-对gc的影响">5.2.3 对<code>GC</code>的影响</h3>
<p>下面再来看一下局部变量表对垃圾回收的影响，示例：</p>
<pre><code class="language-java">public class Main {
    public static void localGC1(){
        byte [] a = new byte[6*1024*1024];
        System.gc();
    }

    public static void localGC2(){
        byte [] a = new byte[6*1024*1024];
        a = null;
        System.gc();
    }

    public static void localGC3(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        System.gc();
    }

    public static void localGC4(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        int c = 10;
        System.gc();
    }

    public static void localGC5(){
        localGC1();
        System.gc();
    }

    public static void main(String[] args) {
        System.out.println(&quot;-------------localGC1------------&quot;);
        localGC1();
        System.out.println();
        System.out.println(&quot;-------------localGC2------------&quot;);
        localGC2();
        System.out.println();
        System.out.println(&quot;-------------localGC3------------&quot;);
        localGC3();
        System.out.println();
        System.out.println(&quot;-------------localGC4------------&quot;);
        localGC4();
        System.out.println();
        System.out.println(&quot;-------------localGC5------------&quot;);
        localGC5();
        System.out.println();
    }
}
</code></pre>
<p>输出（请加上<code>-Xlog:gc</code>参数）：</p>
<pre><code class="language-bash">[0.004s][info][gc] Using G1
-------------localGC1------------
[0.128s][info][gc] GC(0) Pause Full (System.gc()) 10M-&gt;8M(40M) 12.081ms

-------------localGC2------------
[0.128s][info][gc] GC(1) Pause Young (Concurrent Start) (G1 Humongous Allocation) 9M-&gt;8M(40M) 0.264ms
[0.128s][info][gc] GC(2) Concurrent Cycle
[0.133s][info][gc] GC(3) Pause Full (System.gc()) 16M-&gt;0M(14M) 2.799ms
[0.133s][info][gc] GC(2) Concurrent Cycle 4.701ms

-------------localGC3------------
[0.133s][info][gc] GC(4) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(14M) 0.203ms
[0.133s][info][gc] GC(5) Concurrent Cycle
[0.135s][info][gc] GC(5) Pause Remark 8M-&gt;8M(22M) 0.499ms
[0.138s][info][gc] GC(6) Pause Full (System.gc()) 8M-&gt;8M(22M) 2.510ms
[0.138s][info][gc] GC(5) Concurrent Cycle 4.823ms

-------------localGC4------------
[0.138s][info][gc] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation) 8M-&gt;8M(22M) 0.202ms
[0.138s][info][gc] GC(8) Concurrent Cycle
[0.142s][info][gc] GC(9) Pause Full (System.gc()) 16M-&gt;0M(8M) 2.861ms
[0.142s][info][gc] GC(8) Concurrent Cycle 3.953ms

-------------localGC5------------
[0.143s][info][gc] GC(10) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(8M) 0.324ms
[0.143s][info][gc] GC(11) Concurrent Cycle
[0.145s][info][gc] GC(11) Pause Remark 8M-&gt;8M(16M) 0.316ms
[0.147s][info][gc] GC(12) Pause Full (System.gc()) 8M-&gt;8M(18M) 2.402ms
[0.149s][info][gc] GC(13) Pause Full (System.gc()) 8M-&gt;0M(8M) 2.462ms
[0.149s][info][gc] GC(11) Concurrent Cycle 6.843ms
</code></pre>
<p>首行输出表示使用<code>G1</code>，下面逐个进行分析：</p>
<ul>
<li><code>localGC1</code>：并没有回收内存，因为此时<code>byte</code>数组被变量<code>a</code>引用，因此无法回收</li>
<li><code>localGC2</code>：回收了内存，因为<code>a</code>被设置为了<code>null</code>，<code>byte</code>数组失去强引用</li>
<li><code>localGC3</code>：没有回收内存，虽然此时<code>a</code>变量已经失效，但是仍然存在于局部变量表中，并且指向<code>byte</code>数组，因此无法回收</li>
<li><code>localGC4</code>：回收了内存，因为声明了变量<code>c</code>，复用了<code>a</code>的槽位，导致<code>byte</code>数组失去引用，顺利回收</li>
<li><code>localGC5</code>：回收了内存，虽然<code>localGC1</code>中没有释放内存，但是返回到<code>localGC5</code>后，<code>localGC1</code>的栈帧被销毁，也包括其中的<code>byte</code>数组失去了引用，因此在<code>localGC5</code>中被回收</li>
</ul>
<h2 id="53-操作数栈与帧数据区">5.3 操作数栈与帧数据区</h2>
<p>操作数栈也是栈帧的重要内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，也是一个<code>FIFO</code>的数据结构。</p>
<p>而帧数据区则保存着常量池指针，方便程序访问常量池，此外，帧数据区也保存着异常处理表，以便在出现异常后，找到处理异常的代码。</p>
<h2 id="54-栈上分配">5.4 栈上分配</h2>
<p>栈上分配是<code>JVM</code>提供的一项优化技术，基本思想是，将线程私有的对象打散分配到栈上，好处是函数调用结束后可以自动销毁，而不需要垃圾回收器的介入，从而提高系统性能。</p>
<p>栈上分配的一个技术基础是逃逸分析，逃逸分析目的是判断对象的作用域是否会逃逸出函数体，例子如下：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
    }

    public static void alloc(){
        User user = new User();
        user.id = 5;
        user.name = &quot;test&quot;;
    }

    public static void main(String[] args) {
        long b = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000000; i++) {
            alloc();
        }
        long e = System.currentTimeMillis();
        System.out.println(e-b);
    }
}
</code></pre>
<p>启动参数：</p>
<pre><code class="language-bash">-server # 开启Server模式，此模式下才能开启逃逸分析
-Xmx10m # 最大堆内存
-Xms10m # 初始化堆内存
-XX:+DoEscapeAnalysis # 开启逃逸分析
-Xlog:gc # GC日志
-XX:-UseTLAB # 关闭TLAB
-XX:+EliminateAllocations # 开启标量替换，默认打开，允许将对象打散分配在栈上
</code></pre>
<p>输出如下，没有<code>GC</code>日志：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210303161826251.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果关闭了标量替换，也就是添加<code>-XX:-EliminateAllocations</code>，就可以看到会频繁触发<code>GC</code>，因为这时候对象存放在堆上而不是栈上，堆只有10m空间，会频繁进行<code>GC</code>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210303161747610.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-方法区">6 <code>方法区</code></h1>
<p>与<code>Java堆</code>一样，<code>方法区</code>是所有线程共享的内存区域，用于保存系统的类信息，比如类字段、方法、常量池等，<code>方法区</code>的大小决定了系统可以保存多少个类，如果定义了过多的类，会导致<code>方法区</code>溢出，会直接<code>OOM</code>。</p>
<p>在<code>JDK6/7</code>中<code>方法区</code>可以理解成<code>永久区</code>，<code>JDK8</code>后，<code>永久区</code>被移除，取而代之的是<code>元数据区</code>，可以使用<code>-XX:MaxMetaspaceSize</code>指定，这是一块堆外的直接内存，如果不指定大小，默认情况下<code>JVM</code>会耗尽所有可用的系统内存。</p>
<p>如果<code>元数据区</code>发生溢出，<code>JVM</code>会抛出<code>OOM</code>。</p>
<h1 id="7-java堆-java栈以及方法区的关系">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</h1>
<p>看完了<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>，最后来一段代码来简单分析一下它们的关系：</p>
<pre><code class="language-java">class SimpleHeap{
    private int id;
    public SimpleHeap(int id){
        this.id = id;
    }

    public void show(){
        System.out.println(&quot;id is &quot;+id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
        s1.show();
        s2.show();
    }
}
</code></pre>
<p><code>main</code>中创建了两个局部变量<code>s1</code>、<code>s2</code>，则这两个局部变量存放在<code>Java栈</code>中。同时这两个局部变量是<code>SimpleHeap</code>的实例，这两个实例存放在<code>Java堆</code>中，而其中的<code>show</code>方法，则存放在<code>方法区</code>中，图示如下：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210303135915895.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="8-小结">8 小结</h1>
<p>本文主要讲述了<code>JVM</code>的基本结构以及一些基础参数，基本结构可以分成三部分：</p>
<ul>
<li>第一部分：<code>类加载子系统</code>、<code>Java堆</code>、<code>方法区</code>、<code>直接内存</code></li>
<li>第二部分：<code>Java栈</code>、<code>本地方法栈</code>、<code>PC寄存器</code></li>
<li>第三部分：执行引擎</li>
</ul>
<p>而重点讲了三部分：</p>
<ul>
<li><code>Java堆</code>：常见的结构为<code>新生代</code>+<code>老年代</code>结构，其中新生代可分为<code>edsn</code>、<code>s0</code>、<code>s1</code></li>
<li><code>Java栈</code>：包括局部变量表、操作数栈与帧数据区，还提到了一个<code>JVM</code>优化技术栈上分配，可以通过<code>-XX:+EliminateAllocation</code>开启（默认开启）</li>
<li><code>方法区</code>：所有线程共享区域，用于保存类信息，比如类字段、方法、常量等</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第262期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-262-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-262-qi/">
        </link>
        <updated>2021-03-02T22:54:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别人露腿那叫美，你露腿就想让人怼。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>一年春又尽，倚杖对斜晖。<br>
——左纬《春晚》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>南风知我意，吹梦到西洲。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot+Gradle构建多模块项目]]></title>
        <id>https://2293736867.github.io/post/springbootgradle-gou-jian-duo-mo-kuai-xiang-mu/</id>
        <link href="https://2293736867.github.io/post/springbootgradle-gou-jian-duo-mo-kuai-xiang-mu/">
        </link>
        <updated>2021-03-02T12:54:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-java-gradle">3 <code>Java + Gradle</code></a>
<ul>
<li><a href="#31-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">3.1 创建项目</a></li>
<li><a href="#32-%E4%BF%AE%E6%94%B9buildgradle">3.2 修改<code>build.gradle</code></a></li>
<li><a href="#33-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">3.3 创建模块</a></li>
<li><a href="#34-%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97">3.4 编写模块</a>
<ul>
<li><a href="#341-service%E6%A8%A1%E5%9D%97">3.4.1 <code>service</code>模块</a></li>
<li><a href="#342-app%E6%A8%A1%E5%9D%97">3.4.2 <code>app</code>模块</a></li>
</ul>
</li>
<li><a href="#35-%E8%BF%90%E8%A1%8C">3.5 运行</a></li>
<li><a href="#36-%E6%B5%8B%E8%AF%95">3.6 测试</a></li>
</ul>
</li>
<li><a href="#4-kotlin-gradle-kotlin-dsl">4 <code>Kotlin + Gradle + Kotlin DSL</code></a>
<ul>
<li><a href="#41-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">4.1 创建项目</a></li>
<li><a href="#42-%E4%BF%AE%E6%94%B9buildgradlekts">4.2 修改<code>build.gradle.kts</code></a></li>
<li><a href="#43-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">4.3 创建模块</a></li>
<li><a href="#44-%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97">4.4 编写模块</a>
<ul>
<li><a href="#441-service%E6%A8%A1%E5%9D%97">4.4.1 <code>service</code>模块</a></li>
<li><a href="#442-app%E6%A8%A1%E5%9D%97">4.4.2 <code>app</code>模块</a></li>
</ul>
</li>
<li><a href="#45-%E8%BF%90%E8%A1%8C">4.5 运行</a></li>
<li><a href="#46-%E6%B5%8B%E8%AF%95">4.6 测试</a></li>
</ul>
</li>
<li><a href="#5-%E6%80%BB%E7%BB%93">5 总结</a></li>
<li><a href="#6-%E6%BA%90%E7%A0%81">6 源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p><code>Gradle</code>由于构建速度比<code>Maven</code>快，且比<code>Maven</code>灵活，因此很多后端的应用都使用了<code>Gradle</code>进行构建，但一个问题是，<code>Gradle</code>的多模块项目比较难构建，再加上<code>Gradle</code>的更新非常快，这就给构建一个多模块<code>Gradle</code>项目造成了不少的困难。</p>
<p>基于此出发点，本文提供了两种形式的使用<code>Gradle</code>构建的<code>Spring Boot</code>多模块项目：</p>
<ul>
<li><code>Java + Gradle</code></li>
<li><code>Kotlin + Gradle + Kotlin DSL</code></li>
</ul>
<p>为了减少出现各种错误的概率，步骤做得非常详细（多图预警），文末也附上了源码，下面就一起来看看吧。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li><code>Gradle 6.8.2</code></li>
<li><code>Spring Boot 2.4.3</code></li>
<li><code>Kotlin 1.4.30</code></li>
<li><code>Open JDK 11</code></li>
</ul>
<h1 id="3-java-gradle">3 <code>Java + Gradle</code></h1>
<p>主要步骤：</p>
<ul>
<li>使用<code>Spring Initializer</code>创建项目</li>
<li>修改<code>build.gradle</code></li>
<li>创建模块</li>
<li>编写模块</li>
<li>运行</li>
<li>测试</li>
</ul>
<h2 id="31-创建项目">3.1 创建项目</h2>
<p>直接使用<code>IDEA</code>提供的<code>Spring Initializer</code>即可，构建工具选择<code>Gradle</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210302182258479.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>依赖：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210302203252834.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>构建完成后删除<code>src</code>目录</strong>，因为根目录属于管理模块目录不提供运行的应用：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210302182628108.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-修改buildgradle">3.2 修改<code>build.gradle</code></h2>
<p>这是最复杂的一步，并且<code>Gradle</code>版本更新的话步骤可能会不一样，<strong>首先在底部添加一个空的<code>subprojects</code></strong>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2021030218292823.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着<strong>把<code>dependencies</code>以及<code>test</code>移动进去</strong>：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210302183050141.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后一步是，<strong>在<code>subprojects</code>开头，添加插件<code>apply</code>，根据默认初始化创建的<code>plugins</code>，逐一添加</strong>。</p>
<p>比如这里默认使用了三个插件：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210302183301588.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><code>apply</code>到<code>subprojects</code>中：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210302183725544.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-创建模块">3.3 创建模块</h2>
<p><code>File -&gt; New -&gt; Module</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210302183544698.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输入模块名即可，这里的例子是创建两个模块：</p>
<ul>
<li><strong><code>service</code></strong></li>
<li><strong><code>app</code></strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2021030218391243.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210302183958660.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>创建好后如图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/2021030218410737.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>完成创建之后，<strong>把两个模块中的<code>build.gradle</code>除了<code>repositories</code>之外的全部删去</strong>，仅保留<code>repositories</code>：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210302184254983.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210302184353774.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="34-编写模块">3.4 编写模块</h2>
<h3 id="341-service模块">3.4.1 <code>service</code>模块</h3>
<p>首先<strong>创建包</strong>，根据根目录中的<code>group</code>创建：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210302184845857.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210302184922482.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着编写一个叫<code>TestService</code>的带<code>@Service</code>注解的类，里面包含一个<code>test</code>方法：</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210302185028647.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同时修改<code>service</code>模块的<code>build.gradle</code>，<strong>添加<code>bootJar</code>以及<code>jar</code>选项</strong>：</p>
<pre><code class="language-bash">bootJar{
    enabled = false
}

jar{
    enabled = true
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210302184713211.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="342-app模块">3.4.2 <code>app</code>模块</h3>
<p>同样先根据根目录的<code>group</code><strong>创建包</strong>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210302185147370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着在<code>app</code>模块的<code>build.gradle</code><strong>添加<code>service</code>模块的依赖</strong>：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210302185447644.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建启动类以及一个<code>Controller</code>：</p>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20210302185526487.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-java">package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class,args);
    }
}
</code></pre>
<pre><code class="language-java">package com.example.controller;

import com.example.service.TestService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class TestController {
    private final TestService service;
    @GetMapping(&quot;/test&quot;)
    public String test(){
        return service.test();
    }
}
</code></pre>
<h2 id="35-运行">3.5 运行</h2>
<p>接下来就可以运行了，可以直接点击<code>Application</code>旁边的绿色小三角：</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/2021030218570925.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>或者从运行配置中选择<code>Application</code>运行（<code>IDEA</code>自动创建的，原来的那个<code>DemoApplication</code>带一个×是因为启动文件已经删除了，可以顺便把该配置删除）：</p>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20210302185745193.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>没问题的话就可以成功运行了：</p>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/20210302185917750.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同时浏览器访问<code>localhost:8080/test</code>会出现<code>test</code>字样：</p>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/20210302190006675.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="36-测试">3.6 测试</h2>
<p>在创建测试类之前，也需要<strong>先创建包，且需要确保包名与启动类的包名一致</strong>：</p>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/20210302202906337.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建测试类：</p>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/20210302203102853.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-java">package com.example;

import com.example.service.TestService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class JavaTest {
    @Autowired
    private TestService service;
    @Test
    public void test(){
        System.out.println(service.test());
    }
}
</code></pre>
<p>接着进行测试：</p>
<figure data-type="image" tabindex="27"><img src="https://img-blog.csdnimg.cn/20210302203048671.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样使用<code>Java</code>+<code>Gradle</code>构建一个多模块的<code>Spring Boot</code>项目就成功了。</p>
<h1 id="4-kotlin-gradle-kotlin-dsl">4 <code>Kotlin + Gradle + Kotlin DSL</code></h1>
<p><code>Kotlin DSL</code>在原生<code>Gradle</code>（<code>Groovy DSL</code>）的基础上进行改进，但同时语法也变得更加陌生，难度因此也加大了不少，不过这并没有难倒笔者。构建多模块的基本步骤与上面类似：</p>
<ul>
<li>使用<code>Spring Initializer</code>创建项目</li>
<li>修改<code>build.gradle.kts</code></li>
<li>创建模块</li>
<li>编写模块</li>
<li>运行</li>
<li>测试</li>
</ul>
<h2 id="41-创建项目">4.1 创建项目</h2>
<p>选择<code>Kotlin</code>+<code>Gradle</code>：</p>
<figure data-type="image" tabindex="28"><img src="https://img-blog.csdnimg.cn/20210302191228379.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>依赖：</p>
<figure data-type="image" tabindex="29"><img src="https://img-blog.csdnimg.cn/20210302191254471.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样<strong>删除<code>src</code></strong>：</p>
<figure data-type="image" tabindex="30"><img src="https://img-blog.csdnimg.cn/20210302194145804.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-修改buildgradlekts">4.2 修改<code>build.gradle.kts</code></h2>
<p>同样在尾部<strong>添加一个空的<code>subprojects</code></strong>：</p>
<figure data-type="image" tabindex="31"><img src="https://img-blog.csdnimg.cn/20210302191442159.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>把<code>dependencies</code>以及<code>tasks</code>移动进去</strong>：</p>
<figure data-type="image" tabindex="32"><img src="https://img-blog.csdnimg.cn/20210302191518343.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://img-blog.csdnimg.cn/20210302191614874.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后<strong>在<code>subprojects</code>开始处<code>apply</code>插件</strong>，<strong>根据默认的插件进行<code>apply</code></strong>：</p>
<figure data-type="image" tabindex="34"><img src="https://img-blog.csdnimg.cn/20210302194246705.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-bash">apply{
    plugin(&quot;io.spring.dependency-management&quot;)
    plugin(&quot;org.springframework.boot&quot;)
    plugin(&quot;org.jetbrains.kotlin.plugin.spring&quot;)
    plugin(&quot;org.jetbrains.kotlin.jvm&quot;)
}
</code></pre>
<p><strong><code>plugins</code>中的<code>kotlin</code>是<code>org.jetbrains.kotlin</code>的简写</strong>，在<code>subprjects</code>中注意加上即可。</p>
<h2 id="43-创建模块">4.3 创建模块</h2>
<p><code>File -&gt; New -&gt; Module</code>，把一些必要选项勾选上：</p>
<figure data-type="image" tabindex="35"><img src="https://img-blog.csdnimg.cn/20210302194457119.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这里同样创建两个模块：</p>
<ul>
<li><code>app</code></li>
<li><code>service</code></li>
</ul>
<figure data-type="image" tabindex="36"><img src="https://img-blog.csdnimg.cn/2021030219454215.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://img-blog.csdnimg.cn/20210302194600752.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样把两个模块中的**<code>build.gradle.kts</code>删除其他部分留下<code>repositories</code>**：</p>
<figure data-type="image" tabindex="38"><img src="https://img-blog.csdnimg.cn/2021030219473681.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-编写模块">4.4 编写模块</h2>
<h3 id="441-service模块">4.4.1 <code>service</code>模块</h3>
<p>首先根据根目录的<code>build.gradle.kts</code><strong>创建包</strong>：</p>
<figure data-type="image" tabindex="39"><img src="https://img-blog.csdnimg.cn/2021030219485442.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://img-blog.csdnimg.cn/20210302194928711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>编写<code>TestService</code>：</p>
<figure data-type="image" tabindex="41"><img src="https://img-blog.csdnimg.cn/20210302195018197.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后修改<code>build.gradle.kts</code>，<strong>加上<code>tasks.bootJar</code>与<code>tasks.jar</code></strong>：</p>
<pre><code class="language-bash">tasks.bootJar{
    enabled = false
}

tasks.jar{
    enabled = true
}
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://img-blog.csdnimg.cn/20210302195205578.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="442-app模块">4.4.2 <code>app</code>模块</h3>
<p>先<strong>创建包</strong>：</p>
<figure data-type="image" tabindex="43"><img src="https://img-blog.csdnimg.cn/20210302195304362.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>添加对<code>service</code>模块的依赖</strong>：</p>
<figure data-type="image" tabindex="44"><img src="https://img-blog.csdnimg.cn/20210302195354683.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建一个启动类以及一个<code>Controller</code>：</p>
<figure data-type="image" tabindex="45"><img src="https://img-blog.csdnimg.cn/20210302195607272.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">package com.example

import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication

@SpringBootApplication
class Application

fun main(args:Array&lt;String&gt;) {
    SpringApplication.run(Application::class.java,*args)
}
</code></pre>
<pre><code class="language-kotlin">package com.example.controller

import com.example.service.TestService
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class TestController {
    @Autowired
    lateinit var service: TestService
    @GetMapping(&quot;/test&quot;)
    fun test() = service.test()
}
</code></pre>
<h2 id="45-运行">4.5 运行</h2>
<p>点击<code>main</code>旁边的绿色小三角即可：</p>
<figure data-type="image" tabindex="46"><img src="https://img-blog.csdnimg.cn/20210302195715732.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>运行成功：</p>
<figure data-type="image" tabindex="47"><img src="https://img-blog.csdnimg.cn/2021030219575668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样可以访问<code>localhost:8080/test</code>：</p>
<figure data-type="image" tabindex="48"><img src="https://img-blog.csdnimg.cn/20210302195852323.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="46-测试">4.6 测试</h2>
<p>注意在编写测试之前需要保证测试类与启动类在同一个包下，也就是需要<strong>先创建包</strong>：</p>
<figure data-type="image" tabindex="49"><img src="https://img-blog.csdnimg.cn/20210302201002664.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建测试类：</p>
<figure data-type="image" tabindex="50"><img src="https://img-blog.csdnimg.cn/20210302201052939.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-kotlin">package com.example

import com.example.service.TestService
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest

@SpringBootTest
class KotlinTest {
    @Autowired
    lateinit var service: TestService
    @Test
    fun test(){
        println(service.test())
    }
}
</code></pre>
<p>直接点击小三角测试即可：</p>
<figure data-type="image" tabindex="51"><img src="https://img-blog.csdnimg.cn/20210302201159661.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>测试通过，这样<code>Kotlin+Gradle+Kotlin DSL</code>的多模块<code>Spring Boot</code>项目就算创建完成了。</p>
<h1 id="5-总结">5 总结</h1>
<p>笔者在实践的过程中也遇到了无数的错误，比如找不到类，或者<code>build.gradle</code>/<code>build.gradle.kts</code>文件错误，幸好有万能的搜索引擎，帮笔者解决了错误，最后才成功写下这篇文章。</p>
<p>总的来说，<code>Gradle</code>创建多模块项目要比<code>Maven</code>要难，而且<code>Gradle</code>的更新速度很快，语法变化较大，相比之下<code>Maven</code>非常稳定，最新的<code>Maven 3.6.3</code>还是19年11月发布的，然而<code>Gradle</code>都准备<code>7.0</code>了：</p>
<figure data-type="image" tabindex="52"><img src="https://img-blog.csdnimg.cn/20210302201723618.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="53"><img src="https://img-blog.csdnimg.cn/20210302201753711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>笔者建议，如果是真的需要使用<code>Gradle</code>，需要考虑一下团队的状况，毕竟上手难度要大于<code>Maven</code>，如果在<code>Gradle</code>创建多模块的过程中遇到一些极其难以解决的问题，转为<code>Maven</code>不失为一个好办法。</p>
<h1 id="6-源码">6 源码</h1>
<p>附上两个例子的源码：</p>
<ul>
<li><a href="https://github.com/2293736867/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">CODE CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（一）：JVM初探]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-yi-jvm-chu-tan/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-yi-jvm-chu-tan/">
        </link>
        <updated>2021-03-02T05:20:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第一章</li>
</ul>
<p>本文是第一章的一些笔记整理。</p>
<h1 id="2-java里程碑">2 <code>Java</code>里程碑</h1>
<h2 id="21-java起源">2.1 <code>Java</code>起源</h2>
<p>1990年<code>Sun</code>公司决定开发一门新的程序语言——<code>Oak</code>，已经具备安全性、网络通信、面向对象、垃圾回收、多线程等特性，由于<code>Oak</code>已被注册，于是改名为<code>Java</code>。</p>
<h2 id="22-jdk-10">2.2 <code>JDK 1.0</code></h2>
<p>1995年<code>Sun</code>发布了<code>Java</code>以及<code>HotJava</code>产品，1996年正式发布<code>JDK 1.0</code>，包括两部分：</p>
<ul>
<li>运行环境：<code>JRE</code>，包括核心<code>API</code>，用户界面<code>API</code>，发布技术、<code>JVM</code>等</li>
<li>开发环境：<code>JDK</code>，包括编译器<code>javac</code>等</li>
</ul>
<p>1997年发布<code>JDK1.1</code>。</p>
<h2 id="23-jdk-12-17">2.3 <code>JDK 1.2-1.7</code></h2>
<p>1998年发布<code>JDK 1.2</code>，<code>JDK1.2</code>兼容智能卡和小型消费类设备，还兼容大型服务器系统。同时<code>Sun</code>发布<code>JSP/Servlet</code>+<code>EJB</code>规范，将<code>Java</code>分成了<code>J2EE</code>、<code>J2SE</code>、<code>J2ME</code>。</p>
<p>2000年发布<code>JDK 1.3</code>，默认虚拟机改为<code>Hotspot</code>。</p>
<p>2002年发布<code>JDK1.4</code>，<code>Classic</code>虚拟机退出舞台。</p>
<p>2004年发布<code>JDK 1.5</code>，支持泛型、注解、自动装箱拆箱、枚举、可变长参数等。</p>
<p>2006年发布<code>JDK 1.6</code>，<code>Java</code>开源并建立了<code>OpenJDK</code>。</p>
<p>2011年发布<code>JDK 1.7</code>，启用了<code>G1</code>垃圾回收器，支持64位系统的压缩指针以及<code>NIO 2.0</code>。</p>
<h2 id="24-jdk-18">2.4 <code>JDK 1.8+</code></h2>
<p>2014年发布<code>JDK 1.8</code>，<code>JDK 1.8</code>是一个<code>LTS</code>版，到目前还支持，引入了全新的<code>Lambda</code>。</p>
<p>2017年发布<code>JDK 9</code>。</p>
<p>2018年发布<code>JDK 10</code>。</p>
<p>2018年发布<code>JDK 11</code>，又一个<code>LTS</code>版，引入了字符串增强、<code>Epsilon</code>垃圾收集器、<code>ZGC</code>等。</p>
<h1 id="3-jvm种类简介">3 <code>JVM</code>种类简介</h1>
<p><code>Java</code>发展初期，使用的是<code>Classic</code>虚拟机，之后在<code>Solaris</code>短暂地使用过<code>Exact VM</code>虚拟机，到现在被大规模部署和使用的是<code>Hotspot</code>虚拟机。</p>
<p>另外，在<code>IBM</code>内部使用着一款叫<code>J9</code>的虚拟机，<code>Apache</code>也曾经推出过<code>Apache Harmony</code>，基于<code>JDK 5</code>以及<code>JDK 6</code>，于2011年停止开发。</p>
<h1 id="4-jvm简单编译调试实战">4 <code>JVM</code>简单编译调试实战</h1>
<p>下面以<code>OpenJDK15</code>为例，对<code>OpenJDK 15 JVM</code>进行源码编译。</p>
<p>（注：由于笔者系统为<code>Manjaro</code>，这是一个滚更的系统，很多工具链都会更新到最新的状态，比如<code>GCC 10.2</code>，书籍中的例子是利用<code>JDK8</code>去编译<code>JDK10</code>，实际测试发现会报错，<code>configure</code>成功了但是<code>make</code>失败，然后就切换到最新的<code>JDK</code>，就编译成功了。对于不是滚更的系统，可以使用<code>JDK10</code>去编译<code>JDK11</code>等，而非采用目前最新的<code>JDK15</code>）</p>
<h2 id="41-获取源码bootjdk">4.1 获取源码+<code>BootJDK</code></h2>
<p>戳<a href="https://jdk.java.net/java-se-ri/15">这里</a>下载：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210301194640139.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以使用如下命令检测下载文件的完整性：</p>
<pre><code class="language-bash">echo &quot;bb67cadee687d7b486583d03c9850342afea4593be4f436044d785fba9508fb7 openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
echo &quot;d07bf62b4b20fa6bcd4c8fcd635e5df20b7c090af291675b2bd99f8cea8760a0 openjdk-15+36_src.zip&quot; | sha256sum --check
</code></pre>
<p>另外需要准备一个<code>BootJDK</code>，根据<code>BootJDK</code>的规则：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210301185154595.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>建议使用<code>当前版本号</code>/<code>版本号-1</code>/<code>版本号-2</code>的<code>JDK</code>，这里选用的是<code>OpenJDK 15</code>。</p>
<h2 id="42-安装依赖库">4.2 安装依赖库</h2>
<p>笔者系统<code>Manajro</code>，需要安装一些基础依赖：</p>
<pre><code class="language-bash">paru -S base-devel
# 或
pacman -S base-devel
# 或
yay -S base-devel
</code></pre>
<p>如果依赖库安装不完整在配置阶段以及编译阶段会给出相应提示，再进行对应依赖安装即可。</p>
<h2 id="43-编译">4.3 编译</h2>
<p>解压源码进入目录：</p>
<pre><code class="language-bash">unzip openjdk-15+36_src.zip
tar -zxvf openjdk-15+36_linux-x64_bin.tar.gz
cd openjdk
</code></pre>
<p>配置：</p>
<pre><code class="language-bash">bash configure --with-debug-level=slowdebug --with-jvm-variants=server --with-target-bits=64 --with-memory-size=8000 --disable-warnings-as-errors --with-native-debug-symbols=internal --with-boot-jdk=../jdk-15
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>--with-debug-level=slowdebug</code>：编译<code>DEBUG</code>版本的<code>JDK</code>，选项可以是<code>slowdebug</code>/<code>fastdebug</code>/<code>release</code>/<code>optimized</code></li>
<li><code>--with-jvm-variants=server</code>：构建<code>server</code>变体的<code>Hotspot</code>，选项可以是<code>server</code>/<code>client</code>/<code>minimal</code>/<code>core</code>/<code>zero</code>/<code>custom</code></li>
<li><code>--with-target-bits=64</code>：编译64位的<code>JDK</code>，编译32位可以使用<code>--with-target-bits=32</code></li>
<li><code>--with-memory-size=8000</code>：编译的计算机至少需要8G内存，这个可以根据个人需要调整</li>
<li><code>--disable-warnings-as-errors</code>：忽略警告的信息，注意该参数很重要，不加的话会显示配置成功但<code>make</code>失败</li>
<li><code>--with-native-debug-symbols=internal</code>：生成<code>symbol</code>文件，便于后续调试，选项可以是<code>internal</code>/<code>none</code>/<code>external</code>/<code>zipped</code></li>
<li><code>--with-boot-jdk</code>：<code>BootJDK</code>的目录</li>
</ul>
<p>结果：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210301221634945.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>配置后进行编译：</p>
<pre><code class="language-bash">make images
</code></pre>
<p>这个阶段需要一点时间，而且会把<code>CPU</code>拉满，好了之后会提示<code>Finished building</code>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210301221606736.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>笔者环境下编译出来的<code>JDK</code>占了3G：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210301224350705.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>进入对应目录可以查看版本：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210301224537520.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-调试">4.4 调试</h2>
<p>调试需要<code>gdb</code>，先安装好<code>gdb</code>：</p>
<pre><code class="language-bash">paru -S gdb
</code></pre>
<p>进入<code>bin</code>目录（<code>build/linux-x86_64-server-slowdebug/jdk/bin</code>），输入：</p>
<pre><code class="language-bash">gdb -args ./java -version
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210302103935814.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在<code>main</code>函数打断点：</p>
<pre><code class="language-bash">(gdb) b main
</code></pre>
<p>再执行<code>run</code>，可以看到会停在<code>java.base/share/native/launcher/main.c</code>第98行：</p>
<pre><code class="language-bash">(gdb) run
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210302104117877.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再次输入<code>n</code>可进行单步调试：</p>
<pre><code class="language-bash">(gdb) n
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210302104249857.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样就算完成了基础的调试操作，为进一步学习<code>JVM</code>准备好基本的环境。</p>
<h2 id="45-jvm下载">4.5 <code>JVM</code>下载</h2>
<p>如果编译失败的话，笔者这里提供了自己编译出来的<code>JVM</code>：</p>
<ul>
<li><a href="https://github.com/2293736867/OpenJDK15FromSourceCode">Github</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SHA256sum系列命令检测文件完整性]]></title>
        <id>https://2293736867.github.io/post/sha256sum-xi-lie-ming-ling-jian-ce-wen-jian-wan-zheng-xing/</id>
        <link href="https://2293736867.github.io/post/sha256sum-xi-lie-ming-ling-jian-ce-wen-jian-wan-zheng-xing/">
        </link>
        <updated>2021-03-02T03:15:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-sha256sum">1 <code>sha256sum</code></h1>
<p><code>sha256sum</code>是一个检测文件完整性的命令，一般下载的文件都会附带一个哈希值，使用<code>sha256sum</code>计算下载文件的哈希值再与目标哈希值比较即可确定文件是否完整，类似的命令还有：</p>
<ul>
<li><code>md5sum</code></li>
<li><code>sha1sum</code></li>
<li><code>sha224sum</code></li>
<li><code>sha384sum</code></li>
<li><code>sha512sum</code></li>
</ul>
<h1 id="2-安装">2 安装</h1>
<p>该系列命令在一个叫<code>coreutils</code>的包内，一般<code>Linux</code>都会安装，没有的话可以从软件包仓库安装，以笔者系统<code>Manjaro</code>为例：</p>
<pre><code class="language-bash">paru -S coreutils
</code></pre>
<p>另外目前最新的<code>SHA</code>算法为<code>SHA3</code>，需要使用<code>SHA3</code>的话可以安装<code>sha3sum</code>：</p>
<pre><code class="language-bash">paru -S sha3sum
</code></pre>
<h1 id="3-使用">3 使用</h1>
<p>使用很简单，命令后面直接加上对应的文件，即可计算哈希值，以<a href="https://jdk.java.net/java-se-ri/15">OpenJDK</a>为例：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210301221955176.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>文件旁边有一个<code>sha256</code>的值，先把文件下载，使用<code>sha256sum</code>计算：</p>
<pre><code class="language-bash">sha256sum openjdk-15+36_linux-x64_bin.tar.gz
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210301222200204.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>然后下一步就是比较给出的<code>sha256</code>，没理由手动一个一个比较吧？</p>
<p>可以直接使用下面的命令去比较：</p>
<pre><code class="language-bash">echo &quot;bb67cadee687d7b486583d03c9850342afea4593be4f436044d785fba9508fb7 openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210301222615349.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>格式为：</p>
<pre><code class="language-bash">echo &quot;sha256哈希值 文件名&quot; | sha256sum --check
</code></pre>
<p>如果不匹配，会显示<code>checksum did NOT match</code>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210301222726136.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如果哈希值存在于文件中，可以使用下面的命令：</p>
<pre><code class="language-bash">echo &quot;$(cat 哈希值文件名) 待比较的文件&quot; | sha256sum --check
</code></pre>
<p>比如：</p>
<pre><code class="language-bash">echo &quot;$(cat sha256) openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第261期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-261-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-261-qi/">
        </link>
        <updated>2021-03-01T22:51:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>物以类聚人以穷分，有钱人终成眷属。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>海日生残夜，江春入旧年。<br>
——王湾《次北固山下》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我又不是因为你们的评价才去当的英雄，是因为我想当才去当的。</p>
</blockquote>
]]></content>
    </entry>
</feed>