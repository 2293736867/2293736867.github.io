<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-06-01T06:35:23.461Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日一句  351-400期合集]]></title>
        <id>https://2293736867.github.io/post/mei-ri-yi-ju-351-400-qi-he-ji/</id>
        <link href="https://2293736867.github.io/post/mei-ri-yi-ju-351-400-qi-he-ji/">
        </link>
        <updated>2021-06-01T06:06:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第351期">第351期</h1>
<blockquote>
<p>梦与现实是不同的，所以才能够为了把梦变为现实而努力。</p>
</blockquote>
<h1 id="第352期">第352期</h1>
<blockquote>
<p>多少岁月与轻狂交织的梦，被遗忘在大海的尽头，随时光匆匆而去。</p>
</blockquote>
<h1 id="第353期">第353期</h1>
<blockquote></blockquote>
<h1 id="第354期">第354期</h1>
<blockquote></blockquote>
<h1 id="第355期">第355期</h1>
<blockquote></blockquote>
<h1 id="第356期">第356期</h1>
<blockquote></blockquote>
<h1 id="第357期">第357期</h1>
<blockquote></blockquote>
<h1 id="第358期">第358期</h1>
<blockquote></blockquote>
<h1 id="第359期">第359期</h1>
<blockquote></blockquote>
<h1 id="第360期">第360期</h1>
<blockquote></blockquote>
<h1 id="第361期">第361期</h1>
<blockquote></blockquote>
<h1 id="第362期">第362期</h1>
<blockquote></blockquote>
<h1 id="第363期">第363期</h1>
<blockquote></blockquote>
<h1 id="第364期">第364期</h1>
<blockquote></blockquote>
<h1 id="第365期">第365期</h1>
<blockquote></blockquote>
<h1 id="第366期">第366期</h1>
<blockquote></blockquote>
<h1 id="第367期">第367期</h1>
<blockquote></blockquote>
<h1 id="第368期">第368期</h1>
<blockquote></blockquote>
<h1 id="第369期">第369期</h1>
<blockquote></blockquote>
<h1 id="第370期">第370期</h1>
<blockquote></blockquote>
<h1 id="第371期">第371期</h1>
<blockquote></blockquote>
<h1 id="第372期">第372期</h1>
<blockquote></blockquote>
<h1 id="第373期">第373期</h1>
<blockquote></blockquote>
<h1 id="第374期">第374期</h1>
<blockquote></blockquote>
<h1 id="第375期">第375期</h1>
<blockquote></blockquote>
<h1 id="第376期">第376期</h1>
<blockquote></blockquote>
<h1 id="第377期">第377期</h1>
<blockquote></blockquote>
<h1 id="第378期">第378期</h1>
<blockquote></blockquote>
<h1 id="第379期">第379期</h1>
<blockquote></blockquote>
<h1 id="第380期">第380期</h1>
<blockquote></blockquote>
<h1 id="第381期">第381期</h1>
<blockquote></blockquote>
<h1 id="第382期">第382期</h1>
<blockquote></blockquote>
<h1 id="第383期">第383期</h1>
<blockquote></blockquote>
<h1 id="第384期">第384期</h1>
<blockquote></blockquote>
<h1 id="第385期">第385期</h1>
<blockquote></blockquote>
<h1 id="第386期">第386期</h1>
<blockquote></blockquote>
<h1 id="第387期">第387期</h1>
<blockquote></blockquote>
<h1 id="第388期">第388期</h1>
<blockquote></blockquote>
<h1 id="第389期">第389期</h1>
<blockquote></blockquote>
<h1 id="第390期">第390期</h1>
<blockquote></blockquote>
<h1 id="第391期">第391期</h1>
<blockquote></blockquote>
<h1 id="第392期">第392期</h1>
<blockquote></blockquote>
<h1 id="第393期">第393期</h1>
<blockquote></blockquote>
<h1 id="第394期">第394期</h1>
<blockquote></blockquote>
<h1 id="第395期">第395期</h1>
<blockquote></blockquote>
<h1 id="第396期">第396期</h1>
<blockquote></blockquote>
<h1 id="第397期">第397期</h1>
<blockquote></blockquote>
<h1 id="第398期">第398期</h1>
<blockquote></blockquote>
<h1 id="第399期">第399期</h1>
<blockquote></blockquote>
<h1 id="第400期">第400期</h1>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第352期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-352-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-352-qi/">
        </link>
        <updated>2021-06-01T05:53:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>虽然你长的丑，但是你想的美啊。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>凭栏渐觉春光暝，怅望碧天帆去尽。<br>
——吴翌凤《玉楼春·空园数日无芳信》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>多少岁月与轻狂交织的梦，被遗忘在大海的尽头，随时光匆匆而去。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<p>六一儿童节当然是吃糖果啦：</p>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622527201233.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>前缀和，判断最大与最小：</p>
<ul>
<li>最大：(天数+1)*最大每天吃的糖果数量</li>
<li>最小：天数*1（因为每天至少一颗糖果）</li>
</ul>
<pre><code class="language-java">public class Solution {
    public boolean[] canEat(int[] candiesCount, int[][] queries) {
        int n = queries.length;
        boolean [] res = new boolean[n];
        int m = candiesCount.length;
        long [] sum = new long[m];
        sum[0] = candiesCount[0];
        for (int i = 1; i &lt; m; i++) {
            sum[i] = sum[i-1] + candiesCount[i];
        }

        for (int i = 0; i &lt; n; i++) {
            if(queries[i][0] == 0) {
                res[i] = queries[i][1] &lt; sum[0];
            }else{
                res[i] = (((queries[i][1] + 1)*(long)queries[i][2]) &gt; sum[queries[i][0]-1] &amp;&amp; sum[queries[i][0]] &gt; queries[i][1]);
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622527220078.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第351期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-351-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-351-qi/">
        </link>
        <updated>2021-05-31T00:35:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>问世间钱为何物，只叫人生死相许。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>日照香炉生紫烟，遥看瀑布挂前川。<br>
——李白《望庐山瀑布》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>梦与现实是不同的，所以才能够为了把梦变为现实而努力。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622421449590.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>与昨天的每日一题差不多，先判断2的幂，再通过<code>0xaaaaaaaa</code>或<code>0x55555555</code>判断即可：</p>
<pre><code class="language-java">public class Solution {
    public boolean isPowerOfFour(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n &amp; 0x55555555) != 0;
    }
}
</code></pre>
<p><code>0x55555555</code>的二进制是</p>
<pre><code class="language-bash">0101  0101  0101  0101  0101  0101  0101  0101
</code></pre>
<p>如果是2的幂的同时（只有一个1），与<code>0x55555555</code>相与，肯定不为0，这样就可以判断是4的幂了，同样道理也可以使用<code>0xaaaaaaaa</code>判断：</p>
<pre><code class="language-java">public class Solution {
    public boolean isPowerOfFour(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n &amp; 0xaaaaaaaa) == 0;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622421599795.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第350期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-350-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-350-qi/">
        </link>
        <updated>2021-05-30T06:28:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>如果你跌倒了，那就，找个舒服的姿势趴着吧。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>无意苦争春，一任群芳妒。<br>
——陆游《卜算子·咏梅》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我把这几个字写了又删，删了又写。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622356263336.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>原数减1后与原数相与，这个操作可以将最右边的一个1变为0，如果只有1个1，也就是如果是2的幂，那么最右边的一个1变为0后整个数就是0。</p>
<pre><code class="language-java">class Solution {
    public boolean isPowerOfTwo(int n) {
        return n&lt;1 ? false : (n &amp; (n - 1)) == 0;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622356156620.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第349期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-349-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-349-qi/">
        </link>
        <updated>2021-05-29T00:55:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>正在输入...，给了多少人希望，又给了多少人失望。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>美女渭桥东，春还事蚕作。<br>
——李白《陌上桑》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>定义虽然精确，现实极度模糊。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622249816294.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>这题是以<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560、和为K的子数组</a>作为基础的：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622249881301.png" alt="" loading="lazy"></figure>
<p>560题可以使用哈希表将复杂度从<code>O(n^2)</code>降到<code>O(n)</code>，每一次计算前缀和的时候，计算<code>prefixSum - k</code>是否在哈希表中出现过，如果出现过，从哈希表中取值对应的值并累加到结果中，最后将<code>prefixSum</code>添加到哈希表中，将<code>prefixSum</code>的出现次数加1（默认为0）：</p>
<pre><code class="language-java">class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(n);
        map.put(0,1);
        int sum = 0;
        int count = 0;
        for (int i = 0; i &lt; n; i++) {
            sum += nums[i];
            if(map.containsKey(sum - k)) {
                count += map.get(sum-k);
            }
            map.put(sum,map.getOrDefault(sum,0)+1);
        }
        return count;
    }
}
</code></pre>
<p>这题同样需要使用到这个方法（来自官方题解）：</p>
<pre><code class="language-java">class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int ans = 0;
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i &lt; m; ++i) { // 枚举上边界
            int[] sum = new int[n];
            for (int j = i; j &lt; m; ++j) { // 枚举下边界
                for (int c = 0; c &lt; n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                ans += subarraySum(sum, target);
            }
        }
        return ans;
    }

    public int subarraySum(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        map.put(0, 1);
        int count = 0, pre = 0;
        for (int x : nums) {
            pre += x;
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第348期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-348-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-348-qi/">
        </link>
        <updated>2021-05-27T16:32:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>命只有一条，但要命的事，可不止一件。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>毫端蕴秀临霜写，口齿噙香对月吟。<br>
——曹雪芹《咏菊》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>沉默——真正猎手的选择。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622133327190.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>按位计算（<s>差点被昨天的异或求1误导了。。。</s>）：</p>
<pre><code class="language-java">public class Solution {
    public int totalHammingDistance(int[] nums) {
        int n = nums.length;
        int sum = 0;

        for (int i = 0; i &lt; 32; i++) {
            int c = 0;
            for (int j = 0; j &lt; n; j++) {
                c += (nums[j] &gt;&gt; i) &amp; 1;
            }
            sum += c * (n-c);
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622133330537.png" alt="" loading="lazy"></figure>
<h1 id="启程">启程</h1>
<p>Good luck.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第347期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-347-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-347-qi/">
        </link>
        <updated>2021-05-26T18:21:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我最大的缺点，就是缺点钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>春归归不得，两桨松花隔。<br>
——纳兰性德《菩萨蛮·问君何事轻离别》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你知道的都是真相，只可惜那些并不是真相的全部。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622053358345.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>先看一下最原始的逐位比对的解法：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int n = 31;
        int num = 0;
        while(n &gt; 0){
            if((x&amp;1) != (y&amp;1)){
                ++num;
            }
            x &gt;&gt;= 1;
            y &gt;&gt;= 1;
            --n;
        }
        return num;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622053396720.png" alt="" loading="lazy"></figure>
<p>当然，可以优化，可以先用两个数相异或，然后再右移计算1的位数：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int num = 0;
        int s = x^y;
        while(s != 0){
            if((s&amp;1) == 1){
                ++num;
            }
            s &gt;&gt;= 1;
        }
        return num;
    }
}
</code></pre>
<p>当然这还不是最快的，因为异或后的数值还对“没有用”的<code>0</code>进行了右移。</p>
<p>这时候就需要用到一条神奇的公式：</p>
<pre><code class="language-bash">s &amp; (s-1)
</code></pre>
<p>这条公式会直接把<code>s</code>最右边的<code>1</code>变为<code>0</code>，这样就再一次减少了“无用”的<code>0</code>的右移次数：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int num = 0;
        int s = x^y;
        while(s != 0){
            ++num;
            s = s&amp;(s-1);
        }
        return num;
    }
}
</code></pre>
<p>最后放上一个调库的解法：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x^y);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第346期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-346-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-346-qi/">
        </link>
        <updated>2021-05-25T18:39:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>困难也许会迟到，但绝不对缺席。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>两岸桃花烘日出，四维高柳到天垂。<br>
——姜彧《浣溪沙·山滴岚光水拍堤》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>没人生来杰出。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621993294270.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>栈模拟：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public String reverseParentheses(String s) {
        final Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        final StringBuilder builder = new StringBuilder();
        int len = s.length();
        for (int i = 0; i &lt; len; i++) {
            char c = s.charAt(i);
            if(c == '('){
                stack.push(builder.toString());
                builder.setLength(0);
            }else if(c == ')'){
                builder.reverse();
                builder.insert(0,stack.pop());
            }else{
                builder.append(c);
            }
        }
        return builder.toString();
    }
}
</code></pre>
<p>因为长度限制在2000，时间只需1ms：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621993235564.png" alt="" loading="lazy"></figure>
<p>来个双指针：</p>
<pre><code class="language-java">public class Solution {
    public String reverseParentheses(String s) {
        final StringBuilder builder = new StringBuilder(s);
        while (true){
            int post = builder.indexOf(&quot;)&quot;);
            if(post == -1){
                break;
            }
            int pre = builder.lastIndexOf(&quot;(&quot;,post);
            StringBuilder temp = new StringBuilder(builder.substring(pre+1,post));
            temp.reverse();
            builder.replace(pre,post+1,temp.toString());
        }
        return builder.toString();
    }
}
</code></pre>
<p>手动模拟从内向外反转，时间：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621993923712.png" alt="" loading="lazy"></figure>
<p>最后来一个反向遍历，不带反转，本质就是需要减少每次<code>reverse()</code>消耗的时间，返回的只是一个按题目顺序要求的遍历顺序的结果，而不是真正反转字符串，示意图如下（来自<a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/zhan-dong-tu-yan-shi-by-xiaohu9527-hua8/">题解</a>）：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621994961055.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">import java.util.Stack;

public class Solution {
    public String reverseParentheses(String s) {
        final StringBuilder builder = new StringBuilder();
        int n = s.length();
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int [] next = new int[n];
        for (int i = 0; i &lt; n; i++) {
            char c = s.charAt(i);
            if(c == '('){
                stack.push(i);
            }else if(c == ')'){
                int j = stack.pop();
                next[i] = j;
                next[j] = i;
            }
        }

        int direction = 1;
        for (int i = 0; i &lt; n; i+=direction) {
            char c = s.charAt(i);
            if(c == '(' || c == ')'){
                i = next[i];
                direction = -direction;
            }else{
                builder.append(c);
            }
        }
        return builder.toString();
    }
}
</code></pre>
<p>使用一个辅助栈存储括号位置，当出现<code>)</code>时对<code>next</code>数组赋值，表示下一次遍历开始的位置，遍历完成后再次<code>O(n)</code>遍历：</p>
<ul>
<li>如果出现了括号，移动指针到<code>next[i]</code>的位置，并改变遍历方向</li>
<li>如果不是括号，添加到结果末尾</li>
</ul>
<p>最后返回<code>builder.toString()</code>。</p>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1621995094642.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第345期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-345-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-345-qi/">
        </link>
        <updated>2021-05-24T21:20:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>骑电动车请戴好头盔，否则，开奔驰的同学会认出你。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>指点牡丹初绽朵，日高犹自凭朱栏，含嚬不语恨春残。<br>
——韦庄《浣溪沙·清晓妆成寒食天》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我希望兜兜转转之后那个人还是你。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621891391130.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>不会，只会暴力，放个官方题解<code>dp</code>：</p>
<pre><code class="language-java">class Solution {
    // x 的范围为 [0, 2^10)
    static final int MAXX = 1 &lt;&lt; 10;
    // 极大值，为了防止整数溢出选择 INT_MAX / 2
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minChanges(int[] nums, int k) {
        int n = nums.length;
        int[] f = new int[MAXX];
        Arrays.fill(f, INFTY);
        // 边界条件 f(-1,0)=0
        f[0] = 0;
        
        for (int i = 0; i &lt; k; ++i) {
            // 第 i 个组的哈希映射
            Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;Integer, Integer&gt;();
            int size = 0;
            for (int j = i; j &lt; n; j += k) {
                cnt.put(nums[j], cnt.getOrDefault(nums[j], 0) + 1);
                ++size;
            }

            // 求出 t2
            int t2min = Arrays.stream(f).min().getAsInt();

            int[] g = new int[MAXX];
            Arrays.fill(g, t2min);
            for (int mask = 0; mask &lt; MAXX; ++mask) {
                // t1 则需要枚举 x 才能求出
                for (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) {
                    int x = entry.getKey(), countx = entry.getValue();
                    g[mask] = Math.min(g[mask], f[mask ^ x] - countx);
                }
            }
            
            // 别忘了加上 size
            for (int j = 0; j &lt; MAXX; ++j) {
                g[j] += size;
            }
            f = g;
        }

        return f[0];
    }
}
</code></pre>
<p>然后速度并不怎么样：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621891491344.png" alt="" loading="lazy"></figure>
<p>贪心优化：</p>
<pre><code class="language-java">class Solution {
    int[][] cnt;
    int[] sz;
    int[] nums;
    int k;
    public int cost(int pos,int num){
        return sz[pos]-cnt[pos][num];
    }
    Integer[][] memo;
    public int dfs(int pos,int num){//[0,pos]组之前异或值为num的cost
        if(pos==0)return cost(pos,num);
        if(memo[pos][num]!=null)return memo[pos][num];

        int res = Integer.MAX_VALUE/2;
        for(int i=pos;i&lt;nums.length;i+=k){//枚举[0,1023]可以覆盖了所有情况，但是会超时
            //枚举这个组里的值x，那么前面需要值num^x，更新代价
            int x = nums[i];
            res = Math.min(res,cost(pos,x)+dfs(pos-1,num^x));
        }
        memo[pos][num] = res;
        return memo[pos][num];
    }
    public int[] get_min_cost(int k){//计算第k组的最小cost
        //res[0]==cost res[1]==众数个数
        int min_cost = Integer.MAX_VALUE/2;
        int mass_cnt = Integer.MAX_VALUE/2;
        for(int i=0;i&lt;1024;i++){A
            if(cost(k,i)&lt;min_cost){
                min_cost = cost(k,i);
                mass_cnt = cnt[k][i]; 
            }
        }
        return new int[]{min_cost,mass_cnt};
    }
    public int minChanges(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        int n = nums.length;
        cnt = new int[k][1024];
        sz =  new int[k];
        memo = new Integer[k][1024];
        for(int i=0;i&lt;k;i++){
            for(int j=i;j&lt;n;j+=k){
                cnt[i][nums[j]]++;
                sz[i]++;
            }
        }
        //dp从已有的数进行转移，先dp
        int res = dfs(k-1,0);

        //如果dp转移的时候枚举[0,1024]，虽然可以覆盖所有情况
        //但是复杂度变成k*n*1024了
        //只使用已有的数进行转移，可以将1024降为m，k*m=n，总复杂度就变成n^2了。
        //但是会漏一种情况，有的组选择了新的数，此时这个组的cost为 (组内元素个数)。
        //那么这种组有几个呢？
        //可能是0个。可能是...

        //贪心打补丁
        int sum_cost = 0;
        int cost_i = -1;
        int id = -1;
        int mass_cnt = Integer.MAX_VALUE/2;//众数
        for(int i=0;i&lt;k;i++){
            int[] t = get_min_cost(i);//得到第i组的最小cost
            sum_cost += t[0];
            if(t[1]&lt;mass_cnt){
                mass_cnt = t[1];
                id = i;
            }
        }
        //找到那个众数个数最小的组 
        //本来的cost_i = sz[i]-mass_cnt 变成 sz[i] 
        res = Math.min(sum_cost+mass_cnt,res);
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621891537477.png" alt="" loading="lazy"></figure>
<p>看看第一名的大佬，是真的强：</p>
<pre><code class="language-java">public class Solution {
    static class VC implements Comparable&lt;VC&gt; {
        final int value;
        final int index;
        int count;

        VC(int index, int v) {
            this.index = index;
            this.value = v;
        }

        @Override
        public int compareTo(VC o) {
            return o.count - this.count;
        }

        @Override
        public String toString() {
            return value + &quot;:&quot; + count;
        }
    }

    static class Node implements Comparable&lt;Node&gt; {
        final int index;
        VC[] vs;
        int size;
        int count;
        int min_change;
        int min_change_all;
        int[] cs;

        Node(VC[] vcs, int[] nums, int index, int k) {
            this.index = index;
            vs = new VC[(nums.length - index - 1) / k + 1];
            size = 0;
            for (int i = index; i &lt; nums.length; i += k) {
                int v = nums[i];
                VC vc = vcs[v];
                if (vc == null || vc.index != index) {
                    vc = vcs[v] = new VC(index, v);
                }
                if (vc.count++ == 0)
                    vs[size++] = vc;
                count++;
            }
            Arrays.sort(vs, 0, size);
            this.min_change = count - vs[0].count;
        }

        void buildcs() {
            int maxv = 0;
            for (int i = 0; i &lt; size; i++) {
                maxv = Math.max(maxv, vs[i].value);
            }
            this.cs = new int[maxv + 1];
            for (int i = 0; i &lt; size; i++) {
                this.cs[vs[i].value] = vs[i].count;
            }
        }

        int cs(int value) {
            return value &lt; cs.length ? cs[value] : 0;
        }

        @Override
        public int compareTo(Node o) {
            int r = o.min_change - this.min_change;
            if (r == 0)
                r = this.count - o.count;
            return r;
        }

    }

/**
     * 这里使用BFS比DP的计算量少很多。首先按照每行最少替换成本降序排列，然后从最小成本开始替换，每次替换也首先考虑当前行的最小成本，按照DFS思路构建替换路径，计算每个路径的替换成本。
     * 每个路径的替换成本都与最小成本数进行比较，同时将其中的最小再作为比较标准，最小成本默认是数列的长度。
     * 这里的剪枝做的很巧妙，min_change_all表示余下未替换步骤采用最优替换的最小替换和，再次基础上加上当前已经执行的替换数，如果比min_change大，就放弃后面的计算。min_change_all的设计很巧妙。
     * 和DP相比，它按照每行的最优选择依次DFS搜索可能的替换路径，再搜索到最后一层时，判断该数值作为替换的成本（因此存在或不存在都考虑到了），不用像DP那样计算所有可能的替换值。
     */
    static int dfs(Node[] nodes, int index, int v, int changes, int min_change) {
        Node node = nodes[index];
        if (index == 0) {
            changes += node.count - node.cs(v);
            if (changes &lt; min_change) {
                min_change = changes;
            }
            return min_change;
        }
        //优秀的剪枝判断
        if (changes + node.min_change_all &gt;= min_change) {
            return min_change;
        }
        for (int i = 0; i &lt; node.size; i++) {
            VC vc = node.vs[i];
            min_change = dfs(nodes, index - 1, v ^ vc.value, changes + node.count - vc.count, min_change);
        }
        return min_change;
    }

    public int minChanges(int[] nums, int k) {
        final int N = nums.length;
        int res = 0;
        if (k == 1) {
            for (int v : nums)
                if (v != 0) res++;
            return res;
        }
        if (k &gt;= N) {
            for (int v : nums)
                res ^= v;
            res = res == 0 ? 0 : 1;
            return res;
        }
        Node[] nodes = new Node[k];
        int maxv = 0;
        for (int v : nums)
            maxv = Math.max(maxv, v);
        VC[] vcs = new VC[maxv + 1];
        for (int i = 0; i &lt; k; i++) {
            nodes[i] = new Node(vcs, nums, i, k);
        }
        Arrays.sort(nodes);

        int s = 0;
        for (Node node : nodes) {
            s += node.min_change;
            node.min_change_all = s;
        }
        nodes[0].buildcs();
        res = dfs(nodes, k - 1, 0, 0, N);
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621891584866.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第344期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-344-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-344-qi/">
        </link>
        <updated>2021-05-24T10:33:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>不管是白帽子还是黑帽子，会变绿的都不是好帽子。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>垂死病中惊坐起，暗风吹雨入寒窗。<br>
——元稹《闻乐天授江州司马》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>有时候，和你吵架，我宁愿当一个输家，也不愿意赢我爱的你！！！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621766022694.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>区间<code>DP</code>，模板是三重循环：</p>
<ul>
<li>一重循环：区间长度</li>
<li>二重循环：区间起点</li>
<li>三重循环：区间分割点</li>
</ul>
<p>转移方程：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621766144129.png" alt="" loading="lazy"></figure>
<p><s>说的头头是道。。。</s></p>
<p>代码（抄题解的，真的不会第一次遇到这种题）：</p>
<pre><code class="language-java">public class Solution {
    public int strangePrinter(String s){
        int n = s.length();
        int[][] f = new int[n][n];

        for (int i = n-1; i &gt;= 0; --i) {
            f[i][i] = 1;
            for (int j = i+1; j &lt; n; j++) {
                if(s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i][j-1];
                }else{
                    int minn = Integer.MAX_VALUE;
                    for (int k = i; k &lt; j; k++) {
                        minn = Math.min(minn,f[i][k] + f[k+1][j]);
                    }
                    f[i][j] = minn;
                }
            }
        }
        return f[0][n-1];
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621766026705.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>