<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-11-24T06:37:10.157Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第164期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-164-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-164-qi/">
        </link>
        <updated>2020-11-25T06:34:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>研究证明常年抽烟喝酒的人，患老年痴呆的概率较低，因为早死的概率较高。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>不似秋光，只与离人照断肠。<br>
——苏轼《减字木兰花·春月》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>梦与现实是不同的，所以才能够为了把梦变成现实而努力。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第163期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-163-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-163-qi/">
        </link>
        <updated>2020-11-24T03:06:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别说</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>初八月，半镜上青霄。<br>
——纳兰性德《望江南·咏弦月》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>春空千鹤若幻梦，夕波千鸟若长鸣。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第162期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-162-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-162-qi/">
        </link>
        <updated>2020-11-23T05:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>如果我有什么，让你不喜欢的地方，麻烦你自己克服一下。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>惟有河边雁，秋来南向飞。<br>
——庾信《重别周尚书》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>路是脚踏出来的，历史是人写出来的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第161期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-161-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-161-qi/">
        </link>
        <updated>2020-11-22T05:21:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>做人如果没点追求，那么，该多轻松啊。。。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>泉眼无声惜细流，树阴照水爱晴柔。<br>
——杨万里《小吃》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不管风吹浪打，胜似闲庭信步。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows Terminal 安装与配置]]></title>
        <id>https://2293736867.github.io/post/windows-terminal-an-zhuang-yu-pei-zhi/</id>
        <link href="https://2293736867.github.io/post/windows-terminal-an-zhuang-yu-pei-zhi/">
        </link>
        <updated>2020-11-21T22:24:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-安装">1 安装</h1>
<p>安装可以从应用商店安装（直接搜索即可）或者<code>Github</code>安装（可以<a href="https://github.com/microsoft/terminal/releases">戳这里</a>）：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201122072848904.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>下载<code>msixbundle</code>格式的文件即可直接打开安装。</p>
<h1 id="2-配置前准备">2 配置前准备</h1>
<h2 id="21-下载字体">2.1 下载字体</h2>
<p>推荐使用<code>FiraCode</code>，下载链接<a href="https://github.com/tonsky/FiraCode/releases">戳这里</a>。</p>
<p>解压后选择其中一个<code>ttf</code>安装即可：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201122073318304.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="22-安装powershell-core">2.2 安装<code>PowerShell Core</code></h2>
<p>这里的<code>PowerShell Core</code>与自带的<code>PowerShell</code>不是同一个东西，前者是能跨平台的，下载链接<a href="https://github.com/PowerShell/PowerShell/releases">戳这里</a>。</p>
<p><code>Windows</code>下可以直接选择<code>msi</code>格式下载：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201122073833531.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装好后可以对比一下新的<code>PowerShell Core</code>默认是黑底的，而且标题也不一样：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201122084405269.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-配置">3 配置</h1>
<h2 id="31-模块">3.1 模块</h2>
<pre><code class="language-bash"># PSReadline
Install-Module -Name PSReadLine -AllowPrerelease -Force

# posh-git
Install-Module posh-git -Scope CurrentUser

# oh-my-posh
Install-Module oh-my-posh -Scope CurrentUser
</code></pre>
<p>安装过程中可能会卡住，稍等即可。</p>
<p>另外有可能会提示不信任的仓库，选择<code>y</code>即可：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201122084754503.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-修改pwsh为默认终端">3.2 修改<code>PWSH</code>为默认终端</h2>
<p>打开<code>Window Terminal</code>的配置文件，查看<code>list</code>中有无<code>PowerShell Core</code>，如果没有，请手动添加到<code>list</code>中：</p>
<pre><code class="language-json">{
    &quot;guid&quot;: &quot;{60c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,
    &quot;name&quot;: &quot;PowerShell Core&quot;,
    //&quot;icon&quot;:&quot;C:\\My\\PowerShell\\7\\ps_black_64-svg.ico&quot;,
    &quot;commandline&quot;: &quot;pwsh.exe --nologo&quot;,
    &quot;hidden&quot;: false
},
</code></pre>
<p>其中<code>guid</code>可以从<code>cmd</code>复制过来并修改其中一个字符即可，<code>commandLine</code>直接填<code>pwsh.exe</code>，后面的<code>--nologo</code>参数可以去掉烦人的提示。至于图标，默认是没有图标的，需要手动添加，可以从<code>PowerShell</code>的<code>Github</code>下载，并转换为<code>ico</code>格式，最后填上路径就可以正常显示了：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20201122095928888.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201122095958565.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-美化">3.3 美化</h2>
<p>由于安装了<code>oh-my-posh</code>，可以使用<code>Set-Theme</code>切换主题，比如：</p>
<pre><code class="language-bash">Set-Theme Agnoster
</code></pre>
<p>输入<code>Set-Theme</code>即可按<code>Tab</code>补全主题。</p>
<p>另外这样修改的主题只是临时生效，想要永久生效需要写入配置文件中，输入：</p>
<pre><code class="language-bash">$profile
</code></pre>
<p>会显示配置文件的位置，每个人不一样，没有的话就新建，在其中输入：</p>
<pre><code class="language-bash">Import-Module posh-git
Import-Module oh-my-posh
Import-Module PSReadLine
Set-Theme Agnoster
</code></pre>
<p>即可使主题永久生效。</p>
<p>另外，如果主题的颜色不满意，可以配合<code>Show-Colors</code>与<code>Show-ThemeColors</code>修改主题颜色。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Window下Python+CUDA+PyTorch安装]]></title>
        <id>https://2293736867.github.io/post/window-xia-pythoncudapytorch-an-zhuang/</id>
        <link href="https://2293736867.github.io/post/window-xia-pythoncudapytorch-an-zhuang/">
        </link>
        <updated>2020-11-21T22:23:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p><code>Windows</code>下<code>Python+CUDA+PyTorch</code>安装，步骤都很详细，特此记录下来，帮助读者少走弯路。</p>
<h1 id="2-python">2 <code>Python</code></h1>
<p><code>Python</code>的安装还是比较简单的，从<a href="https://www.python.org/downloads/windows/">官网</a>下载<code>exe</code>安装包即可：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201122090347592.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>因为目前最新的<code>torch</code>版本只支持到<code>Python 3.8</code>，因此为了不会出现版本兼容问题建议安装<code>Python 3.8</code>。</p>
<p>下载中间的那个<code>executable installer</code>并安装，打开会建议选择自定义：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201122125346381.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>选择需要的组件：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201122125405751.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>选择位置：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201122125434926.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201122125518138.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装完后可以从命令行查看是否安装成功（一般默认会把路径添加到环境变量中）：</p>
<pre><code class="language-bash">python --version
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20201122125550824.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>由于该安装包会自动把<code>pip</code>也一起安装，因此在使用时会提示<code>pip</code>需要升级，请使用如下命令升级<code>pip</code>：</p>
<pre><code class="language-bash">python -m pip install --upgrade pip
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201122125631452.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在安装前建议添加国内源，在用户目录下新建一个<code>pip</code>文件夹，并在其中新建一个叫<code>pip.ini</code>的文件，输入如下内容：</p>
<pre><code class="language-bash">[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host = https://pypi.tuna.tsinghua.edu.cn
</code></pre>
<h1 id="3-cuda">3 <code>CUDA</code></h1>
<p><code>CUDA</code>的安装也不难，一般<code>Windows</code>会在装系统的时候自动安装好对应的<code>N卡</code>驱动，从<a href="https://developer.nvidia.com/cuda-downloads">官网</a>下载对应的<code>CUDA Toolkit</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20201122085450915.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>下载好后打开（实际上是一个压缩包，这里是解压路径）：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20201122075536401.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20201122080106156.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>解压完成后会自动打开安装界面：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20201122085245286.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>没特殊需求可以直接使用默认安装选项，否则请选择自定义组件进行安装：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20201122085653698.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>由于笔者没有安装<code>VS</code>，这里会提示找不到<code>VS</code>，忽略即可：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20201122085731986.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接下来就是等待安装：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20201122085917820.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20201122090931273.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装完成：</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/2020112209100961.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>打开<code>cmd</code>输入<code>nvcc --version</code>，显示版本号即为安装成功：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20201122091150326.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-pytorch">4 <code>PyTorch</code></h1>
<h2 id="41-下载">4.1 下载</h2>
<p><code>PyTorch</code>建议使用离线方式手动安装，<a href="https://download.pytorch.org/whl/torch_stable.html">戳这里</a>下载对应<code>CUDA</code>版本与对应<code>Python</code>版本的<code>torch</code>以及<code>torchvision</code>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20201122102935438.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最前面的<code>cu110</code>表示<code>cuda 11.0</code>，接着是<code>torch/torchvision</code>，再接着是版本，后面的<code>cp</code>表示<code>Python</code>版本，比如<code>cp36</code>表示<code>Python 3.6</code>，接着是系统和架构。</p>
<h2 id="42-安装">4.2 安装</h2>
<p>下载完成后使用<code>pip</code>安装即可：</p>
<pre><code class="language-bash">pip install torch-1.7.0+cu110-cp38-cp38-win_amd64.whl
pip install torchvision-0.8.1+cu110-cp38-cp38-win_amd64.whl
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20201122130514235.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>注意如果是<code>Windows 2004</code>版本可能会出现如下问题：</p>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20201122135440480.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这是<code>numpy 19.0.4</code>版本的问题，详情可以<a href="https://developercommunity.visualstudio.com/content/problem/1207405/fmod-after-an-update-to-windows-2004-is-causing-a.html">戳这里</a>。</p>
<p>解决方法是安装<code>19.0.3</code>版本：</p>
<pre><code class="language-bash">pip uninstall numpy
pip install numpy==19.0.3
</code></pre>
<p>接着进行测试，打开<code>python</code>：</p>
<pre><code class="language-bash">python
import torch
print(torch.__version__)
</code></pre>
<p>输出<code>torch</code>版本即表示成功：</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/20201122135552214.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第160期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-160-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-160-qi/">
        </link>
        <updated>2020-11-21T05:12:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>所谓复习就是，把不会的东西再确认一遍，你确实不会。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>西宫南内多秋草，落叶满阶红不扫。<br>
——白居易《长恨歌》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>从善如登，从恶如崩。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java实现操作系统中四种动态内存分配算法：BF+NF+WF+FF]]></title>
        <id>https://2293736867.github.io/post/java-shi-xian-cao-zuo-xi-tong-zhong-si-chong-dong-tai-nei-cun-fen-pei-suan-fa-bfnfwfff/</id>
        <link href="https://2293736867.github.io/post/java-shi-xian-cao-zuo-xi-tong-zhong-si-chong-dong-tai-nei-cun-fen-pei-suan-fa-bfnfwfff/">
        </link>
        <updated>2020-11-21T04:56:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>本文是利用<code>Java</code>实现操作系统中的四种动态内存分配方式 ，分别是：</p>
<ul>
<li><code>BF</code></li>
<li><code>NF</code></li>
<li><code>WF</code></li>
<li><code>FF</code></li>
</ul>
<p>分两部分，第一部分是介绍四种分配方式的概念以及例子，第二部分是代码实现以及讲解。</p>
<h1 id="2-四种分配方式">2 四种分配方式</h1>
<h2 id="21-概念">2.1 概念</h2>
<p>操作系统中有一个动态分区分配的概念，内存在初始化的时候不会划分区域，而是在进程装入的时候，根据所要装入的进程动态地对内存空间进行划分，以提高内存空间的利用率，降低碎片的大小，主要的方法有一下四种：</p>
<ul>
<li>首次适应算法（<code>First Fit</code>）：从空闲分区链首开始查找，直到找到一个满足其大小要求的空闲分区为止</li>
<li>循环首次适应算法（<code>Next Fit</code>）：从上次找到的空闲分区的下一个开始查找</li>
<li>最佳适应算法（<code>Best Fit</code>）：把空闲分区按大小递增的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
<li>最坏适应算法（<code>Worst Fit</code>）：与最佳适应算法相反，把空闲分区按大小递减的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
</ul>
<h2 id="22-例子">2.2 例子</h2>
<p>假设现在有<code>100MB</code>的内存空间，某一时刻先后分配了<code>20MB</code>、<code>4MB</code>、<code>10MB</code>内存，示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201121154826958.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>现在需要再分配<code>5MB</code>内存。</p>
<p>若采用<code>FF</code>，因为<code>FF</code>是直接按顺序分配内存，从低地址开始搜索空闲分区，因此便会从第一块空闲分区分配<code>5MB</code>（地址<code>0-5</code>），示意图：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020112115543974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>NF</code>，<code>NF</code>与<code>FF</code>类似，只不过<code>NF</code>是从上一次找到的空闲分区的下一块开始查找，因为上一次分配的是<code>10MB</code>，因此会从最后一块空闲分区（地址<code>80-100</code>）分配内存：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201121155703771.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>BF</code>，<code>BF</code>是遍历所有空闲分区并找到一个能满足要求的最小分区，也就会找到一个比<code>5MB</code>大的空闲分区，且该空闲分区是所有空闲分区中最小的，也就是地址为<code>64-70</code>的空闲分区：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201121155908288.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>WF</code>，<code>WF</code>与<code>BF</code>相反，总是从最大的空闲分区开始分配，因此会从地址为<code>30-60</code>的空闲分区进行分配：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201121160047113.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-代码实现">3 代码实现</h1>
<h2 id="31-总览">3.1 总览</h2>
<p>代码分成了四个类：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2020112116032076.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>Main</code>：测试</li>
<li><code>Print</code>：输出打印</li>
<li><code>Table</code>：表示每一个分区</li>
<li><code>TableList</code>：对分区进行控制，包括初始化，分配，回收等</li>
</ul>
<h2 id="32-main">3.2 <code>Main</code></h2>
<p><code>Main</code>是测试类，代码如下：</p>
<pre><code class="language-java">public class Main {

    private final static TableList list = new TableList(64);

    public static void main(String[] args) {
        list.useWF();
//        list.useBF();
//        list.useNF();
//        list.useFF();

        list.allocate(10);
        list.allocate(20);
        list.free(10);
        list.show();
        list.allocate(8);
        list.show();
        list.allocate(13);
        list.allocate(1);
        list.show();
        list.free(1);
        list.allocate(9);
        list.free(13);
        list.show();
        list.allocate(18);
        list.show();
        list.allocate(3);
        list.allocate(4);
        list.free(20);
        list.free(8);
        list.show();
        list.allocate(8);
        list.free(9);
        list.show();
        list.clear();
        list.show();
    }
}
</code></pre>
<p>通过<code>TableList</code>对内存进行分配以及释放，初始化分配<code>64MB</code>大小内存，切换分配算法时使用前四行的其中一行即可。</p>
<h2 id="33-table">3.3 <code>Table</code></h2>
<p><code>Table</code>类表示每一个分区，无论是空闲的还是已分配的，成员变量有四个，分别是：</p>
<ul>
<li>起始地址</li>
<li>大小</li>
<li>是否空闲（只有两种状态，空闲或分配）</li>
<li>是否是上一次分配（<code>NF</code>专用）</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">@AllArgsConstructor
public class Table {
    @Getter
    @Setter
    private int address;
    @Setter
    @Getter
    private int size;
    private boolean free;
    @Getter
    @Setter
    private boolean lastAllocated;

    public static Table freeTable(int address,int size)
    {
        return new Table(address,size,true,false);
    }

    public static Table allocatedTable(int address,int size)
    {
        return new Table(address,size,false,false);
    }

    public boolean isFree()
    {
        return free;
    }

    public boolean isAllocated()
    {
        return !isFree();
    }

    public void setFree()
    {
        free = true;
    }
}
</code></pre>
<p>只有一些<code>Getter</code>和<code>Setter</code>，为了方便提供了一个创建空闲分区或已分配分区的静态方法，指定起始地址和大小即可。</p>
<h2 id="34-tablelist">3.4 <code>TableList</code></h2>
<p><code>TableList</code>是整个算法的核心类，成员变量如下：</p>
<pre><code class="language-java">private final List&lt;Table&gt; list = new ArrayList&lt;&gt;();
private final int totalSize;
private boolean ff = false;
private boolean nf = false;
private boolean bf = false;
private boolean wf = false;
private boolean first = true;
private final static Print print = new Print();
</code></pre>
<p><code>list</code>就是所有的空闲分区与已分配分区组成的数组，<code>totalSize</code>是总大小，接着是四个控制算法的布尔变量，<code>first</code>表示是否是第一次分配内存，因为第一次的话四种算法都是固定的从地址为<code>0</code>处开始分配。</p>
<p>接下来就是内存分配算法以及释放算法。</p>
<h3 id="341-ff">3.4.1 <code>FF</code></h3>
<pre><code class="language-java">if (ff)
{
    for (int i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.add(i,allocated);
            return;
        }
    }
}
</code></pre>
<p><code>FF</code>的实现还是比较简单的，直接遍历列表，如果是空闲分区并满足大小要求，直接进行分配，修改空闲分区的起始地址和大小并插入一个新的已分配分区到列表中即可。</p>
<h3 id="342-nf">3.4.2 <code>NF</code></h3>
<pre><code class="language-java">else if (nf)
{
    int lastNFIndex = findLastAllocated();
    int i = lastNFIndex;
    do
    {
        if(i == list.size())
            i = 0;
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.get(lastNFIndex).setLastAllocated(false);
            table.setLastAllocated(true);
            list.add(i,allocated);
            return;
        }
        ++i;
    }
    while (i != lastNFIndex);
}
</code></pre>
<p><code>NF</code>的话需要提前记录上一次分配的位置，通过<code>Table</code>中的<code>lastAllocated</code>确定上一次分配的位置，找到后从该位置开始遍历列表，注意需要进行绕回处理，因为到末尾位置后有可能还没有能满足的空闲分区，此时需要将下标绕回到<code>0</code>并再次遍历直到到达上一次分配的位置。</p>
<h3 id="343-bfwf">3.4.3 <code>BF</code>+<code>WF</code></h3>
<p>由于<code>BF</code>与<code>WF</code>都需要遍历所有的空闲分区，只是前者是选择最小满足要求的，后者是选择最大满足要求的，因此两者的实现差别在于一个判断大小的符号，代码如下：</p>
<pre><code class="language-java">else
{
    int i;
    int target = -1;
    for (i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree())
        {
            if(table.getSize() &gt;= size)
            {
                if(target == -1)
                    target = i;
                else
                {
                    if(bf)
                    {
                        if(list.get(target).getSize() &gt; table.getSize())
                            target = i;
                    }
                    else
                    {
                        if(list.get(target).getSize() &lt; table.getSize())
                            target = i;
                    }
                }
            }
        }
    }
    if(target != -1)
    {
        Table table = list.get(target);
        int address = table.getAddress();
        table.setAddress(address+size);
        table.setSize(table.getSize()-size);
        list.add(target,Table.allocatedTable(address,size));
        return;
    }
}
</code></pre>
<p>首先遍历找到符合条件的空闲分区的下标，接着通过判断<code>target</code>，也就是目标空闲分区的下标，如果为<code>-1</code>表示没有找到符合条件的空闲分区，如果不为<code>-1</code>直接分配空间。</p>
<h3 id="344-释放算法">3.4.4 释放算法</h3>
<p>释放算法的设计是比较复杂的，代码如下：</p>
<pre><code class="language-java">public void free(int size)
{
    int index = 0;
    while(index &lt; list.size())
    {
        if(list.get(index).isAllocated() &amp;&amp; list.get(index).getSize() == size)
            break;
        ++index;
    }
    if(index &gt;= list.size())
    {
        print.freeFailed(size);
        return;
    }
    int address = list.get(index).getAddress();
    if(index == 0)
    {
        list.get(0).setFree();
        if(index+1 &lt; list.size())
        {
            Table nextTable = list.get(index+1);
            if(nextTable.isFree())
            {
                list.get(0).setSize(nextTable.getSize()+size);
                list.remove(index+1);
            }
        }
    }
    else if(index == list.size()-1)
    {
        list.get(index).setFree();
        Table lastTable = list.get(index-1);
        if(lastTable.isFree())
        {
            lastTable.setSize(lastTable.getSize()+size);
            list.remove(index);
        }
    }
    else
    {
        Table before = list.get(index-1);
        Table after = list.get(index+1);

        if(before.isFree() &amp;&amp; after.isFree())
        {
            before.setSize(before.getSize()+size+after.getSize());
            list.remove(index+1);
            list.remove(index);
        }
        else if(before.isFree() &amp;&amp; after.isAllocated())
        {
            before.setSize(before.getSize()+size);
            list.remove(index);
        }
        else if(before.isAllocated() &amp;&amp; after.isFree())
        {
            after.setSize(after.getSize()+size);
            after.setAddress(address);
            list.remove(index);
        }
        else
        {
            list.get(index).setFree();
        }
    }
}
</code></pre>
<p>主要考虑了六种情况（黄色代表需要释放的空间，橙色是已分配的内存空间）：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201121170701544.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>第一种情况就是需要释放首部的分区，此时需要修改后面空闲分区的起始地址和大小，并删除目标分区</li>
<li>第二种情况是释放尾部的分区，此时需要修改前面空闲分区的大小即可，无需修改起始地址，并删除目标分区</li>
<li>第三种情况是后面是已分配的分区，前面的空闲分区，需要修改前面空闲分区的大小，并删除目标分区</li>
<li>第四种情况是前面是已分配的分区，后面是空闲分区，需要修改后面的空闲分区的起始地址以及大小，并删除目标分区</li>
<li>第五种情况是前后都是已分配的分区，此时只需要修改目标分区的标志为空闲即可，无需额外操作</li>
<li>第六种情况是前后都是空闲分区，这种情况下需要进行连接操作，具体来说就是先修改前面空闲分区的大小，接着删除目标分区以及后面的空闲分区</li>
</ul>
<p>下面回到代码，首先是判断第一种情况：</p>
<pre><code class="language-java">if(index == 0)
{
    list.get(0).setFree();
    if(index+1 &lt; list.size())
    {
        Table nextTable = list.get(index+1);
        if(nextTable.isFree())
        {
            list.get(0).setSize(nextTable.getSize()+size);
            list.remove(index+1);
        }
    }
}
</code></pre>
<p>也就是需要释放首部的分区，通过<code>setFree()</code>设置标志位表示空闲状态，接着判断是否需要修改后面空闲分区的大小，因为有可能后面是一个已分配的分区而不是空闲分区。</p>
<pre><code class="language-java">else if(index == list.size()-1)
{
    list.get(index).setFree();
    Table lastTable = list.get(index-1);
    if(lastTable.isFree())
    {
        lastTable.setSize(lastTable.getSize()+size);
        list.remove(index);
    }
}
</code></pre>
<p>这里是判断第二种情况，也就是释放尾部的分区，同样需要判断前一个分区是已分配的分区还是空闲的分区，是空闲分区的话修改大小并移除目标分区。</p>
<pre><code class="language-java">else
{
    Table before = list.get(index-1);
    Table after = list.get(index+1);

    if(before.isFree() &amp;&amp; after.isFree())
    {
        before.setSize(before.getSize()+size+after.getSize());
        list.remove(index+1);
        list.remove(index);
    }
    else if(before.isFree() &amp;&amp; after.isAllocated())
    {
        before.setSize(before.getSize()+size);
        list.remove(index);
    }
    else if(before.isAllocated() &amp;&amp; after.isFree())
    {
        after.setSize(after.getSize()+size);
        after.setAddress(address);
        list.remove(index);
    }
    else
    {
        list.get(index).setFree();
    }
}
</code></pre>
<p>接下来是最后四种情况的判断，首先获取前一个以及后一个分区，接着按上面算法的思路进行判断即可。</p>
<h1 id="4-测试">4 测试</h1>
<p>以<code>WF</code>为例，默认大小<code>64MB</code>，测试顺序如下：</p>
<ul>
<li>分配<code>10MB</code></li>
<li>分配<code>20MB</code></li>
<li>释放<code>10MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>13MB</code></li>
<li>分配<code>1MB</code></li>
<li>打印结果</li>
<li>释放<code>1MB</code></li>
<li>分配<code>9MB</code></li>
<li>释放<code>13MB</code></li>
<li>打印结果</li>
<li>分配<code>18MB</code></li>
<li>打印结果</li>
<li>分配<code>3MB</code></li>
<li>分配<code>4MB</code></li>
<li>释放<code>20MB</code></li>
<li>释放<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>释放<code>9MB</code></li>
<li>打印结果</li>
<li>清空</li>
<li>打印结果</li>
</ul>
<p>输出：</p>
<pre><code class="language-java">Free           :      0-10MB
Allocated      :      10-30MB
Free           :      30-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Allocated      :      38-51MB
Allocated      :      51-52MB
Free           :      52-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Do nothing.
Allocated failed, out of memory
Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Free           :      4-38MB
Allocated      :      38-41MB
Free           :      41-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Allocated      :      4-12MB
Free           :      12-38MB
Allocated      :      38-41MB
Free           :      41-64MB

----------------------------------------------------------------

Free           :      0-64MB

----------------------------------------------------------------
</code></pre>
<p>读者可以自行画图验证。</p>
<h1 id="5-源码">5 源码</h1>
<ul>
<li><a href="https://github.com/2293736867/FourDynamicAllocatedAlgorithm">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/FourDynamicAllocatedAlgorithm">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/FourDynamicAllocatedAlgorithm">CODE.CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Linux无法读写U盘中的NTFS问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-linux-wu-fa-du-xie-u-pan-zhong-de-ntfs-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-linux-wu-fa-du-xie-u-pan-zhong-de-ntfs-wen-ti/">
        </link>
        <updated>2020-11-20T05:36:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>由于笔者因为某些需要把<code>Windows</code>装在了<code>U盘</code>上面（在这里建议一下如果有需要请使用固态<code>U盘</code>），在<code>Linux</code>下挂载时，能读取但并不能写。</p>
<h1 id="2-尝试的解决方案">2 尝试的解决方案</h1>
<h2 id="21-remount">2.1 <code>remount</code></h2>
<p>一开始是因为没有读写权限，所以就重新挂载，命令如下：</p>
<pre><code class="language-bash">mount -o rw,remount /dev/sda2
</code></pre>
<p>（<code>/dev/sda2</code>是因为笔者的<code>U盘</code>大小<code>64G</code>，把<code>Windows</code>直接装在了里面，默认分了两个分区，一个是启动分区<code>/dev/sda1</code>，一个是系统分区<code>/dev/sda2</code>）</p>
<p>但是还是不能写入。</p>
<h2 id="22-ntfs-3g">2.2 <code>ntfs-3g</code></h2>
<p>首先安装了<code>ntfs-3g</code>，然后再次尝试挂载：</p>
<pre><code class="language-bash">sudo mount -t ntfs-3g /dev/sda2 /run/media/point
sudo ntfs-3g /dev/sda2 /run/media/point
</code></pre>
<p>还是不能写入。</p>
<h2 id="23-ntfsfix">2.3 <code>ntfsfix</code></h2>
<p><code>ntfsfix</code>能修复常见的错误以及<code>NTFS</code>分区不一致的问题，尝试了一下：</p>
<pre><code class="language-bash">sudo ntfsfix /dev/sda2
</code></pre>
<p>还是不能写入。</p>
<h1 id="3-最终解决方案">3 最终解决方案</h1>
<p>再次查了一下资料（<a href="https://itsfoss.com/solve-ntfs-mount-problem-ubuntu-windows-8-dual-boot/">戳这里</a>）发现这个可能是因为<code>Windows</code>的快速启动导致的：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201120111553555.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>把快速启动关了就行。</p>
<p>但是这<code>U盘</code>里面的快速启动貌似关闭不了。。。</p>
<p>最后在<code>StackExchange</code>（<a href="https://unix.stackexchange.com/questions/107978/cant-access-windows-drive-windows-is-hibernated-refused-to-mount">戳这里</a>）上找到了答案：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020112011181392.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>核心是<code>remove_hiberfile</code>这个挂载选项，同时也查了一下<code>man</code>：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201120112112981.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在启动<code>Linux</code>时，<code>Windows</code>是有可能处于<code>hibernate</code>状态的，该状态下是不能写的并且强制只读挂载，加入<code>remove_hiberfile</code>参数后，去除了<code>hibernation file</code>，这样在笔者的环境上测试就能正常写入了，但是要注意使用该参数可能会导致保存的<code>Windows session</code><br>
数据全部丢失：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201120112642753.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>所以最终挂载命令如下：</p>
<pre><code class="language-bash">sudo ntfs-3g -o remove_hiberfile /dev/sda2 /run/media/point
</code></pre>
<p>测试了一下<code>Windows</code>并没有任何损坏，因此如果出现上述的问题可以尝试加上<code>remove_hiberfile</code>参数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第159期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-159-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-159-qi/">
        </link>
        <updated>2020-11-20T04:53:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你还不算惨，惨的人，都没手机用。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>山光物态弄春晖，莫为轻阴便拟归。<br>
——张旭《山中留客》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>所以我松开拳头用手握紧笔，作为自己作为人类页作为你。</p>
</blockquote>
]]></content>
    </entry>
</feed>