<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-07-06T03:59:17.421Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第386期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-386-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-386-qi/">
        </link>
        <updated>2021-07-06T02:54:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>唯一比孤独更可怕的，是被人知道你孤独。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>酒困路长惟欲睡，日高人渴漫思茶。<br>
——苏轼《浣溪沙·蔌蔌衣巾落枣花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>回避现实的人，未来将更不理想。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625540146259.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接上两个<code>TreeMap</code>：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) {
        Map&lt;Integer, Map&lt;String, Integer&gt;&gt; map = new TreeMap&lt;&gt;();
        Set&lt;String&gt; foods = new TreeSet&lt;&gt;();
        int n = orders.size();
        for (int i = 0; i &lt; n; i++) {
            Integer table = Integer.parseInt(orders.get(i).get(1));
            String food = orders.get(i).get(2);
            foods.add(food);
            if (map.containsKey(table)) {
                map.get(table).put(food, map.get(table).getOrDefault(food, 0) + 1);
            }else{
                Map&lt;String,Integer&gt; temp = new TreeMap&lt;&gt;();
                temp.put(food,1);
                map.put(table,temp);
            }
        }
//        System.out.println(map);
//        System.out.println(foods);
        int foodsSize = foods.size();
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(map.size()+1);
        List&lt;String&gt; temp = new ArrayList&lt;&gt;(foodsSize+1);
        temp.add(&quot;Table&quot;);
        temp.addAll(foods);
        list.add(temp);
        for (Map.Entry&lt;Integer,Map&lt;String,Integer&gt;&gt; entry:map.entrySet()){
            temp = new ArrayList&lt;&gt;(foodsSize+1);
            temp.add(String.valueOf(entry.getKey()));
            Map&lt;String,Integer&gt; foodsMap = entry.getValue();
            for (String s:foods){
                temp.add(String.valueOf(foodsMap.getOrDefault(s,0)));
            }
            list.add(temp);
        }
        return list;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625540154308.png" alt="" loading="lazy"></figure>
<p><s>好像有点慢。</s></p>
<p>优化一点点：</p>
<ul>
<li>采用<code>HashMap</code>和<code>HashSet</code>，添加完毕再排序</li>
<li>指定初始化<code>HashMap</code>的大小，降低动态扩容的开销</li>
<li>缓存<code>table</code>的数字转字符串后的字符串</li>
</ul>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) {
        Map&lt;Integer, Map&lt;String, Integer&gt;&gt; map = new HashMap&lt;&gt;(512);
        Set&lt;String&gt; foods = new HashSet&lt;&gt;();
        String[] numberToString = new String[512];
        int n = orders.size();
        for (int i = 0; i &lt; n; i++) {
            String tableStr = orders.get(i).get(1);
            Integer table = Integer.parseInt(tableStr);
            numberToString[table] = tableStr;
            String food = orders.get(i).get(2);
            foods.add(food);
            if (map.containsKey(table)) {
                map.get(table).put(food, map.get(table).getOrDefault(food, 0) + 1);
            }else{
                Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;();
                temp.put(food,1);
                map.put(table,temp);
            }
        }
        int foodsSize = foods.size();
        foods = new TreeSet&lt;&gt;(foods);
        map = new TreeMap&lt;&gt;(map);
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(map.size()+1);
        List&lt;String&gt; temp = new ArrayList&lt;&gt;(foodsSize+1);
        temp.add(&quot;Table&quot;);
        temp.addAll(foods);
        list.add(temp);
        for (Map.Entry&lt;Integer,Map&lt;String,Integer&gt;&gt; entry:map.entrySet()){
            temp = new ArrayList&lt;&gt;(foodsSize+1);
            temp.add(numberToString[entry.getKey()]);
            Map&lt;String,Integer&gt; foodsMap = entry.getValue();
            for (String s:foods){
                temp.add(String.valueOf(foodsMap.getOrDefault(s,0)));
            }
            list.add(temp);
        }
        return list;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625543943000.png" alt="" loading="lazy"></figure>
<p>好像有那么一点效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第385期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-385-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-385-qi/">
        </link>
        <updated>2021-07-05T06:34:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你努力找他说话的样子，像极了商场里的导购。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>日啖荔枝三百颗，不辞长作岭南人。<br>
——苏轼《食荔枝》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>卑屈游戏谁是先该离场的呢？</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625466878403.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>好家伙，真真正正的困难题，需要用到哈希表、栈以及字符串处理的一些方法。</p>
<p>一开始朴素的想法是，将其分块处理，比如：</p>
<pre><code class="language-bash">Mg(OH)2
</code></pre>
<p>可以分成三块：</p>
<ul>
<li><code>Mg</code></li>
<li><code>OH</code></li>
<li><code>2</code></li>
</ul>
<p>于是就写出了下面的代码：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class Solution {
    private char[] formula;
    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String,Integer&gt; map = new TreeMap&lt;&gt;(countFormula(0,formula.length()-1));
        StringBuilder builder = new StringBuilder();
        for(Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
            builder.append(entry.getKey());
            int value = entry.getValue();
            if(value != 1){
                builder.append(value);
            }
        }
        return builder.toString();
    }

    private Map&lt;String,Integer&gt; countFormula(int begin,int end){
        char [] formula = this.formula;
        int beginBracket = begin;
        while(beginBracket &lt;= end &amp;&amp; formula[beginBracket] != '('){
            ++beginBracket;
        }
        if(beginBracket &gt; end){
            return countAtom(begin,end);
        }
        int endBracket = end;
        while(endBracket &gt;= begin &amp;&amp; formula[endBracket] != ')'){
            --endBracket;
        }
        int num = Integer.parseInt(new String(formula,endBracket+1,end - endBracket));
        Map&lt;String,Integer&gt; map = countFormula(beginBracket+1,endBracket-1);
        for (Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
            entry.setValue(entry.getValue() * num);
        }
        Map&lt;String,Integer&gt; prefix = countAtom(begin,beginBracket-1);
        for (Map.Entry&lt;String,Integer&gt; entry:prefix.entrySet()){
            map.put(entry.getKey(),map.getOrDefault(entry.getKey(),0)+entry.getValue());
        }
        return map;
    }

    private Map&lt;String,Integer&gt; countAtom(int begin,int end){
        char[] formula = this.formula;
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = begin; i &lt;= end; i++) {
            if(Character.isUpperCase(formula[i])){
                int j = i;
                ++i;
                while(i &lt;= end &amp;&amp; Character.isLowerCase(formula[i])){
                    ++i;
                }
                String str = new String(formula,j,i-j);
                StringBuilder num = new StringBuilder();
                while(i &lt;= end &amp;&amp; Character.isDigit(formula[i])){
                    num.append(formula[i]);
                    ++i;
                }
                map.put(str,map.getOrDefault(str,0)+
                    (num.length() == 0 ? 1 : Integer.parseInt(num.toString())
                ));
                --i;
            }
        }
        return map;
    }
}
</code></pre>
<p>但是过不了下面的样例：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625467206949.png" alt="" loading="lazy"></figure>
<p>于是又改了一下：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

public class Solution {
    private char[] formula;

    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(count(this.formula));
        StringBuilder builder = new StringBuilder();
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            builder.append(entry.getKey());
            int value = entry.getValue();
            if (value != 1) {
                builder.append(value);
            }
        }
        return builder.toString();
    }

    private Map&lt;String,Integer&gt; count(char[] formula) {
        int n = formula.length;
        Stack&lt;Map&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            int j = i;
            while (i &lt; n &amp;&amp; Character.isDigit(formula[i])){
                ++i;
            }
            if(j != i){
                int num = Integer.parseInt(new String(formula,j,i-j));
                Map&lt;String, Integer&gt; top = stack.pop();
                for (Map.Entry&lt;String, Integer&gt; entry : top.entrySet()) {
                    entry.setValue(entry.getValue() * num);
                }
                if(!stack.isEmpty()) {
                    Map&lt;String, Integer&gt; prefix = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : prefix.entrySet()) {
                        top.put(entry.getKey(), top.getOrDefault(entry.getKey(), 0) + entry.getValue());
                    }
                }
                stack.push(top);
            }
            j = i;
            while (i &lt; n &amp;&amp; formula[i] != '(' &amp;&amp; formula[i] != ')') {
                ++i;
            }
            Map&lt;String, Integer&gt; map = countAtom(j, i - 1);
//            System.out.println(&quot;map is &quot; + map);
            if(map.size() &gt; 0) {
                stack.push(map);
                if (i &lt; n &amp;&amp; formula[i] == ')') {
                    StringBuilder number = new StringBuilder();
                    ++i;
                    while (i &lt; n &amp;&amp; Character.isDigit(formula[i])) {
                        number.append(formula[i]);
                        ++i;
                    }
                    int num = (number.length() == 0 ? 1 : Integer.parseInt(number.toString()));
//                    System.out.println(&quot;num is &quot; + num);
                    Map&lt;String, Integer&gt; top = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : top.entrySet()) {
                        entry.setValue(entry.getValue() * num);
                    }
                    if(!stack.isEmpty()) {
                        Map&lt;String, Integer&gt; prefix = stack.pop();
                        for (Map.Entry&lt;String, Integer&gt; entry : prefix.entrySet()) {
                            map.put(entry.getKey(), map.getOrDefault(entry.getKey(), 0) + entry.getValue());
                        }
                    }
                    stack.push(top);
//                    System.out.println(&quot;[i] is &quot; + formula[i]);
                }
            }
        }
//        System.out.println(stack);
        return stack.pop();
    }

    private Map&lt;String, Integer&gt; countAtom(int begin, int end) {
        char[] formula = this.formula;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = begin; i &lt;= end; i++) {
            if (Character.isUpperCase(formula[i])) {
                int j = i;
                ++i;
                while (i &lt;= end &amp;&amp; Character.isLowerCase(formula[i])) {
                    ++i;
                }
                String str = new String(formula, j, i - j);
                StringBuilder num = new StringBuilder();
                while (i &lt;= end &amp;&amp; Character.isDigit(formula[i])) {
                    num.append(formula[i]);
                    ++i;
                }
                map.put(str, map.getOrDefault(str, 0) +
                        (num.length() == 0 ? 1 : Integer.parseInt(num.toString())
                        ));
                --i;
            }
        }
        return map;
    }
}
</code></pre>
<p>但是：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625467234437.png" alt="" loading="lazy"></figure>
<p>后面重新换了一个思路，对单个原子进行处理，比如<code>Mg(OH)2</code>中的<code>OH</code>，不能直接看作一个<code>OH</code>，而是一个栈，从栈顶到栈底分别为：</p>
<ul>
<li><code>1</code></li>
<li><code>H</code></li>
<li><code>1</code></li>
<li><code>O</code></li>
</ul>
<p>这样每次遇到数字的时候就进行合并，遇到左括号直接压栈，遇到右括号就进行弹栈操作：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

public class Solution {
    private char[] formula;
    private static final String TYPE = &quot;type&quot;;
    private static final Integer ATOM = 0;
    private static final Integer BRACKET = 1;

    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(count(this.formula));
        StringBuilder builder = new StringBuilder();
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            if(!entry.getKey().equals(TYPE)) {
                builder.append(entry.getKey());
                int value = entry.getValue();
                if (value != 1) {
                    builder.append(value);
                }
            }
        }
        return builder.toString();
    }

    private Map&lt;String, Integer&gt; count(char[] formula) {
        int n = formula.length;
        Stack&lt;Map&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n; ) {
            if (Character.isUpperCase(formula[i])) {
                StringBuilder atom = new StringBuilder();
                atom.append(formula[i++]);
                while (i &lt; n &amp;&amp; Character.isLowerCase(formula[i])) {
                    atom.append(formula[i++]);
                }
                Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
                map.put(atom.toString(), 1);
                map.put(TYPE, ATOM);
                stack.push(map);
            } else if (Character.isDigit(formula[i])) {
                StringBuilder number = new StringBuilder();
                number.append(formula[i++]);
                while (i &lt; n &amp;&amp; Character.isDigit(formula[i])) {
                    number.append(formula[i++]);
                }
                int num = Integer.parseInt(number.toString());
                Map&lt;String, Integer&gt; map = stack.pop();
                for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                    if (!entry.getKey().equals(TYPE)) {
                        entry.setValue(entry.getValue() * num);
                    }
                }
                stack.push(map);
            } else if (formula[i] == '(') {
                Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
                map.put(TYPE, BRACKET);
                stack.push(map);
                ++i;
            } else {
                Map&lt;String, Integer&gt; map = stack.peek();
                Map&lt;String, Integer&gt; base = stack.pop();
                while (!map.get(TYPE).equals(BRACKET)) {
                    map = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                        if (!entry.getKey().equals(TYPE)) {
                            base.put(entry.getKey(), base.getOrDefault(entry.getKey(), 0) + entry.getValue());
                        }
                    }
                }
                stack.push(base);
                ++i;
            }
        }
        Map&lt;String,Integer&gt; base = stack.pop();
        while(!stack.isEmpty()){
            Map&lt;String,Integer&gt; map = stack.pop();
            for (Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
                if (!entry.getKey().equals(TYPE)) {
                    base.put(entry.getKey(), base.getOrDefault(entry.getKey(), 0) + entry.getValue());
                }
            }
        }
        return base;
    }
}
</code></pre>
<p>最后经过两个小时的修改和煎熬终于<code>AC</code>了：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625467441798.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625467445201.png" alt="" loading="lazy"></figure>
<p>最后优化了几ms：</p>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1625467745085.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第384期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-384-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-384-qi/">
        </link>
        <updated>2021-07-04T01:33:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>人生最大的耻辱是什么，考试作弊了还不及格。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>纸屏石枕竹方床，手倦抛书午梦长。<br>
——蔡确《夏日登车盖亭》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>悲痛藏于心，欢喜言于表，说的不就是我们吗！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625362601439.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接哈希表：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        boolean[] hash = new boolean[1_0000 + 1];
        int repeated = 0;
        for (int num : nums) {
            if (hash[num]) {
                repeated = num;
            }
            hash[num] = true;
        }
        for (int i = 1; i &lt;= n; ++i) {
            if (!hash[i]) {
                return new int[]{repeated, i};
            }
        }
        return new int[]{};
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625362622318.png" alt="" loading="lazy"></figure>
<p>当然最朴素的想法就是直接计数：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int[] count = new int[n + 1];
        int[] res = new int[2];
        for (int num : nums) {
            ++count[num];
        }
        for (int i = 1; i &lt;= n; ++i) {
            if(count[i] == 2){
                res[0] = i;
            }
            if(count[i] == 0){
                res[1] = i;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625362781875.png" alt="" loading="lazy"></figure>
<p>好家伙这速度可以啊。</p>
<p>还有一种做法是使用<code>O(1)</code>空间的位运算：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int x = 0;
        int y = 0;
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        for (int i = 1; i &lt;= n; i++) {
            xor ^= i;
        }
        xor &amp;= (-xor);
        for (int num : nums) {
            if ((num &amp; xor) == 0) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        for (int i = 1; i &lt;= n; i++) {
            if((i &amp; xor) == 0) {
                x ^= i;
            }else{
                y ^= i;
            }
        }
        for (int num:nums){
            if(num == x){
                return new int[]{x,y};
            }
        }
        return new int[]{y, x};
    }
}
</code></pre>
<p>思想就是：</p>
<ul>
<li>利用<code>xor</code>与原数组中每个数相异或</li>
<li>再利用<code>xor</code>与<code>1..n</code>相异或</li>
<li>这样<code>xor</code>就是三个重复的数与一个缺失的数字异或的结果</li>
<li>计算<code>lowbit</code>，<code>lowbit = xor ^ (-xor)</code>，使用<code>lowbit</code>得到最低位1表示的结果</li>
<li>再遍历原数组以及<code>1..n</code>组成的数组，将其中每个数与<code>lowbit</code>相与，如果为<code>0</code>，使用一个临时变量<code>x</code>与其相异或，否则使用临时变量<code>y</code>与其相异或</li>
<li>得到的<code>x</code>、<code>y</code>分别是重复的数字和丢失的数字，但具体哪个是哪个还不能确定</li>
<li>最后再次遍历原数组，如果<code>x</code>或<code>y</code>在原数组中出现过，那么它就是重复的数字，另一个就是丢失的数字</li>
<li>否则它是丢失的数字，另一个是重复的数字</li>
</ul>
<p>说了这么多，但是时间还是不怎么样，虽然空间做到了<code>O(1)</code>，但是扫太多遍了：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625363920298.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第383期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-383-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-383-qi/">
        </link>
        <updated>2021-07-03T02:41:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>遇到困难的三个步骤，面对它，处理它，放弃它。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>东边日出西边雨，道是无晴却有晴。<br>
——刘禹锡《竹枝词二首·其一》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>I'm nothing without you.</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625280248893.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>虽然写着是中等题，但是感觉是简单题，统计计数后排序然后将结果添加到结果中即可，注意包含大小写字母和数字（题目又没写。。。）：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public String frequencySort(String s) {
        if (s == null || s.isBlank()) {
            return s;
        }
        int n = s.length();
        char[] res = new char[n];
        Node[] nodes = new Node[62];
        for (int i = 0; i &lt; 26; i++) {
            nodes[i] = new Node((char) ('a' + i));
        }
        for (int i = 26; i &lt; 52; i++) {
            nodes[i] = new Node((char) ('A' + (i - 26)));
        }
        for (int i = 52; i &lt; 62; i++) {
            nodes[i] = new Node((char) ('0' + (i - 52)));
        }
        for (char c : s.toCharArray()) {
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
                ++nodes[c - 'a'].count;
            } else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
                ++nodes[c - 'A' + 26].count;
            } else {
                ++nodes[c - '0' + 52].count;
            }
        }

        Arrays.sort(nodes);
        int index = 0;
        for (Node node:nodes){
            int count = node.count;
            char c = node.c;
            for (int i = 0; i &lt; count; i++) {
                res[index++] = c; 
            }
        }
        return new String(res);
    }

    private static class Node implements Comparable&lt;Node&gt; {
        char c;
        int count = 0;

        public Node(char c) {
            this.c = c;
        }

        @Override
        public int compareTo(Node node) {
            return Integer.compare(node.count, count);
        }

        @Override
        public String toString() {
            return &quot;[c=&quot; + c + &quot;,count=&quot; + count + &quot;]&quot;;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625280239823.png" alt="" loading="lazy"></figure>
<p>寻思着好像没有什么优化方法，昨天的计排好像也用不上，看了题解用的居然是桶排，好家伙。</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625280765329.png" alt="" loading="lazy"></figure>
<p>但是最快的第一名还是用的快排：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625281014724.png" alt="" loading="lazy"></figure>
<p>最后还是参考题解，配合栈用上了计排：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public String frequencySort(String s) {
        int n = s.length();
        char[] res = new char[n];
        int[] count = new int[62];
        for (char c : s.toCharArray()) {
            ++count[charToIndex(c)];
        }
        int max = 0;
        for (int c : count) {
            if (c &gt; max) {
                max = c;
            }
        }
        Stack[] stacks = new Stack[max + 1];
        for (int i = 0; i &lt; 62; ++i) {
            if (count[i] != 0) {
                int ct = count[i];
                if (stacks[ct] == null) {
                    stacks[ct] = new Stack&lt;&gt;();
                    stacks[ct].push(indexToChar(i));
                } else {
                    stacks[ct].push(indexToChar(i));
                }
            }
        }

        int index = 0;
        for (int i = max; i &gt;= 1; --i) {
            Stack stack = stacks[i];
            if (stack != null) {
                while (!stack.isEmpty()) {
                    char c = (Character) stack.pop();
                    for (int j = 0; j &lt; i; j++) {
                        res[index++] = c;
                    }
                }
            }
        }
        return new String(res);
    }

    private int charToIndex(char c) {
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
            return c - 'a';
        }
        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
            return c - 'A' + 26;
        }
        return c - '0' + 52;
    }

    private char indexToChar(int index) {
        if (index &gt;= 0 &amp;&amp; index &lt;= 25) {
            return (char) ('a' + index);
        }
        if (index &gt;= 26 &amp;&amp; index &lt;= 51) {
            return (char) ('A' + (index - 26));
        }
        return (char) ('0' + (index - 52));
    }

}
</code></pre>
<p>（<s>为什么<code>Java</code>不支持泛型数组</s>）</p>
<p>但还是一样的时间：</p>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625285002545.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第382期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-382-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-382-qi/">
        </link>
        <updated>2021-07-02T04:10:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>好好过日子吧，每天都会有新打击。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>接天莲叶无穷碧，映日荷花别样红。<br>
——杨万里《晓出净慈寺送林子方》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>没有一个世界会比活在这个世界痛苦。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625199129271.jpg" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一开始直接上贪心：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625199695745.png" alt="" loading="lazy"></figure>
<p>中规中矩的水平吧，上<code>Github</code>拿个快排优化一下：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        quicksort(costs, 0, costs.length - 1);
        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }

    private static void quicksort(int[] ar, int lo, int hi) {
        if (lo &lt; hi) {
            int splitPoint = partition(ar, lo, hi);
            quicksort(ar, lo, splitPoint);
            quicksort(ar, splitPoint + 1, hi);
        }
    }

    private static int partition(int[] ar, int lo, int hi) {
        int pivot = ar[lo];
        int i = lo - 1, j = hi + 1;
        while (true) {
            do {
                i++;
            } while (ar[i] &lt; pivot);
            do {
                j--;
            } while (ar[j] &gt; pivot);
            if (i &lt; j) swap(ar, i, j);
            else return j;
        }
    }

    private static void swap(int[] ar, int i, int j) {
        int tmp = ar[i];
        ar[i] = ar[j];
        ar[j] = tmp;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625199743893.png" alt="" loading="lazy"></figure>
<p><s>???</s></p>
<p><s>离谱</s></p>
<p><s>这优化</s></p>
<p>然后想了一下怎么把时间优化到<code>O(n)</code>，看了一下题解居然是用计数排序（<s>怎么就没想到，裂开</s>）。</p>
<p>然后肯定就是手写一个简陋的计数排序：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] ct = new int[10_0000+1];
        for (int c:costs){
            ++ct[c];
        }
        int index = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if(ct[i] != 0) {
                for (int j = 0; j &lt; ct[i]; j++) {
                    costs[index++] = i;
                }
            }
        }
        //System.out.println(Arrays.toString(costs));

        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625200111336.png" alt="" loading="lazy"></figure>
<p>u1s1还真有点效果。</p>
<p>但是还是不够快，想了一下因为是求最后的数量，计数后不需要把数放回原来的数组，直接从<code>coins</code>里面减就行了，如果变成负数了直接返回：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int index = 0;
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            for (int j = 0; j &lt; ct[i]; j++) {
                costs[index++] = i;
                if (coins &gt;= i) {
                    coins -= i;
                    ++res;
                } else {
                    return res;
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625200311409.png" alt="" loading="lazy"></figure>
<p>u1s1这才叫优化。</p>
<p>再优化一下下，如果是所有同样定价的雪糕可以同时买下，直接用倍数去乘，而不是循环去减：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int index = 0;
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if (ct[i] != 0) {
                if (coins &gt;= ct[i] * i) {
                    coins -= ct[i] * i;
                    res += ct[i];
                } else {
                    for (int j = 0; j &lt; ct[i]; j++) {
                        costs[index++] = i;
                        if (coins &gt;= i) {
                            coins -= i;
                            ++res;
                        } else {
                            return res;
                        }
                    }
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1625200504043.png" alt="" loading="lazy"></figure>
<p>但是好像没什么效果。</p>
<p>不行，坚定信念要优化的笔者，决定再优化一下下，把循环去掉，用倍数加去代替逐个雪糕相减：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if (ct[i] != 0) {
                if (coins &gt;= ct[i] * i) {
                    coins -= ct[i] * i;
                    res += ct[i];
                } else {
                    res += (coins / i);
                    return res;
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://2293736867.github.io/post-images/1625200817021.png" alt="" loading="lazy"></figure>
<p>尽梨了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第381期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-381-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-381-qi/">
        </link>
        <updated>2021-06-30T16:33:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>对于穷人，生活不累的话，那就不叫生活！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>烛摧花，鹤惊露，忽三更。<br>
——朱敦儒《水调歌头》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我只是不想再失去他——哪怕是仅存在一瞬的幻影！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625070969908.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map.containsKey(fromPlayer)){
                map.get(fromPlayer).add(toPlayer);
            }else{
                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                list.add(toPlayer);
                map.put(fromPlayer,list);
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                List&lt;Integer&gt; list = map.get(current);
                if(list != null){
                    queue.addAll(list);
                }
            }
        }
        while(!queue.isEmpty()){
            if(queue.remove() == n-1){
                ++res;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625071812210.png" alt="" loading="lazy"></figure>
<p>这效率。。。</p>
<p>稍微优化一下，使用数组代替<code>HashMap</code>，但是也没有提高多少效率：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int [][] map = new int[n][];
        int [] mapLen = new int[n];
        int [] mapIndex = new int[n];

        for (int i = 0; i &lt; relation.length; i++) {
            ++mapLen[relation[i][0]];
        }

        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map[fromPlayer] == null){
                map[fromPlayer] = new int[mapLen[fromPlayer]];
                map[fromPlayer][0] = toPlayer;
                mapIndex[fromPlayer] = 1;
            }else{
                map[fromPlayer][mapIndex[fromPlayer]++] = toPlayer;
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                int [] value = map[current];
                if(value != null){
                    for (int l = 0; l &lt; value.length; l++) {
                        queue.add(value[l]);
                    }
                }
            }
        }
        while(!queue.isEmpty()){
            if(queue.remove() == n-1){
                ++res;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625072240855.png" alt="" loading="lazy"></figure>
<p>再优化一下下：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int [][] map = new int[n][];
        int [] mapLen = new int[n];
        int [] mapIndex = new int[n];

        for (int i = 0; i &lt; relation.length; i++) {
            ++mapLen[relation[i][0]];
        }

        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map[fromPlayer] == null){
                map[fromPlayer] = new int[mapLen[fromPlayer]];
                map[fromPlayer][0] = toPlayer;
                mapIndex[fromPlayer] = 1;
            }else{
                map[fromPlayer][mapIndex[fromPlayer]++] = toPlayer;
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                int [] value = map[current];
                if(value != null){
                    for (int l = 0; l &lt; value.length; l++) {
                        int v = value[l];
                        if(i == k-1 &amp;&amp; v == n-1){
                            ++res;
                        }
                        queue.add(v);
                    }
                }
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625072398603.png" alt="" loading="lazy"></figure>
<p>极限了极限了。。。（<s>太菜了太菜了</s>）</p>
<p>看了题解发现原来有三种方法：</p>
<ul>
<li>深搜</li>
<li>广搜</li>
<li>动归</li>
</ul>
<p>动归解法如下：</p>
<pre><code class="language-java">class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int[][] dp = new int[k + 1][n];
        dp[0][0] = 1;
        for (int i = 0; i &lt; k; i++) {
            for (int[] edge : relation) {
                int src = edge[0], dst = edge[1];
                dp[i + 1][dst] += dp[i][src];
            }
        }
        return dp[k][n - 1];
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625072669552.png" alt="" loading="lazy"></figure>
<p><s>BFS优化个der</s></p>
<h1 id="100周年">100周年</h1>
<p>建党100周年！</p>
<p>刚过12点就朋友圈刷屏了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第380期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-380-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-380-qi/">
        </link>
        <updated>2021-06-29T16:29:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>宁可美的千篇一律，也不要丑的各有千秋。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>月明船笛参差起，风定池莲自在香。<br>
——秦观《纳凉》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>清晨、黄昏、天空和飞鸟，代码、诗歌、活着和爱你。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625070598099.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>还是广搜题，序列化和反序列化都用的广搜：</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) {
            return &quot;&quot;;
        }

        StringBuilder builder = new StringBuilder();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();

        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode temp = queue.poll();

            if (temp == null) {
                builder.append(&quot;null,&quot;);
            } else {
                builder.append(temp.val).append(&quot;,&quot;);
                queue.add(temp.left);
                queue.add(temp.right);
            }
        }
        return &quot;[&quot; + builder.substring(0, builder.length() - 1) + &quot;]&quot;;
    }

    public TreeNode deserialize(String data) {
        int len = data.length();
        if (len == 0) {
            return null;
        }
        String[] strs = data.substring(1, len - 1).split(&quot;,&quot;);
        int n = strs.length;
        if (strs[0].charAt(0) == 'n') {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(strs[0]));
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        for (int i = 1; i &lt; n; ) {
            TreeNode temp = queue.poll();
            if (temp != null) {
                TreeNode left = (strs[i].charAt(0) == 'n' ? null : new TreeNode(Integer.parseInt(strs[i])));
                TreeNode right = (strs[i + 1].charAt(0) == 'n' ? null : new TreeNode(Integer.parseInt(strs[i + 1])));
                temp.left = left;
                temp.right = right;
                queue.add(left);
                queue.add(right);
                i += 2;
            } else {
                while (queue.peek() == null) {
                    queue.poll();
                }
            }
        }
        return root;
    }
}
</code></pre>
<p>最离谱的第一名居然0ms：</p>
<pre><code class="language-java">public class Codec {
    private TreeNode root;
    public String serialize(TreeNode root) {
        this.root = root;
        return &quot;&quot;;
    }

    public TreeNode deserialize(String data) {
        return this.root;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625070696173.png" alt="" loading="lazy"></figure>
<p>好家伙。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第379期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-379-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-379-qi/">
        </link>
        <updated>2021-06-28T16:22:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>问渠那得清如许，唯有毒汤活水来！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>藕花珠缀，犹似汗凝妆。<br>
——阎选《临江仙·雨停荷荠逗浓香》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>宣纸泛黄，时间流逝，即使眨眼即过，也要抓住那瞬间的辉煌。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625070154587.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>简单题，顺便也把类似的171题答案附上（注意1！！）：</p>
<pre><code class="language-java">public class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder builder = new StringBuilder();
        while (columnNumber != 0) {
            --columnNumber;
            builder.append((char) (columnNumber % 26 + 'A'));
            columnNumber /= 26;
        }
        return builder.reverse().toString();
    }

    public int titleToNumber(String columnTitle) {
        int sum = 0;
        int base = 1;
        for (int i = columnTitle.length() - 1; i &gt;= 0; --i) {
            sum += (columnTitle.charAt(i) - 'A' + 1) * base;
            base *= 26;
        }
        return sum;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第378期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-378-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-378-qi/">
        </link>
        <updated>2021-06-28T13:24:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>都说姐漂亮，其实都是妆出来的。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>此花此叶常相映，翠减红哀愁杀人。<br>
——李商隐《赠荷花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>用我一生，换你十年天真无邪。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1624886536347.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>复制的，想了一下好像做不出来。。。（<s>太菜了</s>）</p>
<pre><code class="language-java">class Solution {
    int s, t;
    int[][] rs;
    public int numBusesToDestination(int[][] _rs, int _s, int _t) {
        rs = _rs; s = _s; t = _t;
        if (s == t) return 0;
        int ans = bfs();
        return ans;
    }
    int bfs() {
        // 记录某个车站可以进入的路线
        Map&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        // 队列存的是经过的路线
        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();
        // 哈希表记录的进入该路线所使用的距离
        Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();
        int n = rs.length;
        for (int i = 0; i &lt; n; i++) {
            for (int station : rs[i]) {
                // 将从起点可以进入的路线加入队列
                if (station == s) {
                    d.addLast(i);
                    m.put(i, 1);
                }
                Set&lt;Integer&gt; set = map.getOrDefault(station, new HashSet&lt;&gt;());
                set.add(i);
                map.put(station, set);
            }
        }
        while (!d.isEmpty()) {
            // 取出当前所在的路线，与进入该路线所花费的距离
            int poll = d.pollFirst();
            int step = m.get(poll);

            // 遍历该路线所包含的车站
            for (int station : rs[poll]) {
                // 如果包含终点，返回进入该路线花费的距离即可
                if (station == t) return step;

                // 将由该线路的车站发起的路线，加入队列
                Set&lt;Integer&gt; lines = map.get(station);
                if (lines == null) continue;
                for (int nr : lines) {
                    if (!m.containsKey(nr)) {
                        m.put(nr, step + 1);
                        d.add(nr);
                    }
                }
            }
        }
        return -1;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1624886541130.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第377期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-377-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-377-qi/">
        </link>
        <updated>2021-06-27T13:21:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>运动一周瘦不下来不要紧，因为运动十周也瘦不下来的。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>荷风送香气，竹露滴清响。<br>
——孟浩然《夏日南亭怀辛大》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>其实你不是真的很有趣，你只是太孤独。这个你，就是我。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1624886887334.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>还还还是广搜：</p>
<pre><code class="language-java">class Solution {
    public int snakesAndLadders(int[][] board) {
        int n = board.length;
        boolean[] vis = new boolean[n * n + 1];
        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();
        queue.offer(new int[]{1, 0});
        while (!queue.isEmpty()) {
            int[] p = queue.poll();
            for (int i = 1; i &lt;= 6; ++i) {
                int nxt = p[0] + i;
                if (nxt &gt; n * n) { // 超出边界
                    break;
                }
                int[] rc = id2rc(nxt, n); // 得到下一步的行列
                if (board[rc[0]][rc[1]] &gt; 0) { // 存在蛇或梯子
                    nxt = board[rc[0]][rc[1]];
                }
                if (nxt == n * n) { // 到达终点
                    return p[1] + 1;
                }
                if (!vis[nxt]) {
                    vis[nxt] = true;
                    queue.offer(new int[]{nxt, p[1] + 1}); // 扩展新状态
                }
            }
        }
        return -1;
    }

    public int[] id2rc(int id, int n) {
        int r = (id - 1) / n, c = (id - 1) % n;
        if (r % 2 == 1) {
            c = n - 1 - c;
        }
        return new int[]{n - 1 - r, c};
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1624886872960.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>