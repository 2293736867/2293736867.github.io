<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-05-26T18:28:33.868Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第347期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-347-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-347-qi/">
        </link>
        <updated>2021-05-26T18:21:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我最大的缺点，就是缺点钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>春归归不得，两桨松花隔。<br>
——纳兰性德《菩萨蛮·问君何事轻离别》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你知道的都是真相，只可惜那些并不是真相的全部。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1622053358345.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>先看一下最原始的逐位比对的解法：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int n = 31;
        int num = 0;
        while(n &gt; 0){
            if((x&amp;1) != (y&amp;1)){
                ++num;
            }
            x &gt;&gt;= 1;
            y &gt;&gt;= 1;
            --n;
        }
        return num;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1622053396720.png" alt="" loading="lazy"></figure>
<p>当然，可以优化，可以先用两个数相异或，然后再右移计算1的位数：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int num = 0;
        int s = x^y;
        while(s != 0){
            if((s&amp;1) == 1){
                ++num;
            }
            s &gt;&gt;= 1;
        }
        return num;
    }
}
</code></pre>
<p>当然这还不是最快的，因为异或后的数值还对“没有用”的<code>0</code>进行了右移。</p>
<p>这时候就需要用到一条神奇的公式：</p>
<pre><code class="language-bash">s &amp; (s-1)
</code></pre>
<p>这条公式会直接把<code>s</code>最右边的<code>1</code>变为<code>0</code>，这样就再一次减少了“无用”的<code>0</code>的右移次数：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        int num = 0;
        int s = x^y;
        while(s != 0){
            ++num;
            s = s&amp;(s-1);
        }
        return num;
    }
}
</code></pre>
<p>最后放上一个调库的解法：</p>
<pre><code class="language-java">public class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x^y);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第346期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-346-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-346-qi/">
        </link>
        <updated>2021-05-25T18:39:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>困难也许会迟到，但绝不对缺席。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>两岸桃花烘日出，四维高柳到天垂。<br>
——姜彧《浣溪沙·山滴岚光水拍堤》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>没人生来杰出。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621993294270.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>栈模拟：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public String reverseParentheses(String s) {
        final Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        final StringBuilder builder = new StringBuilder();
        int len = s.length();
        for (int i = 0; i &lt; len; i++) {
            char c = s.charAt(i);
            if(c == '('){
                stack.push(builder.toString());
                builder.setLength(0);
            }else if(c == ')'){
                builder.reverse();
                builder.insert(0,stack.pop());
            }else{
                builder.append(c);
            }
        }
        return builder.toString();
    }
}
</code></pre>
<p>因为长度限制在2000，时间只需1ms：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621993235564.png" alt="" loading="lazy"></figure>
<p>来个双指针：</p>
<pre><code class="language-java">public class Solution {
    public String reverseParentheses(String s) {
        final StringBuilder builder = new StringBuilder(s);
        while (true){
            int post = builder.indexOf(&quot;)&quot;);
            if(post == -1){
                break;
            }
            int pre = builder.lastIndexOf(&quot;(&quot;,post);
            StringBuilder temp = new StringBuilder(builder.substring(pre+1,post));
            temp.reverse();
            builder.replace(pre,post+1,temp.toString());
        }
        return builder.toString();
    }
}
</code></pre>
<p>手动模拟从内向外反转，时间：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621993923712.png" alt="" loading="lazy"></figure>
<p>最后来一个反向遍历，不带反转，本质就是需要减少每次<code>reverse()</code>消耗的时间，返回的只是一个按题目顺序要求的遍历顺序的结果，而不是真正反转字符串，示意图如下（来自<a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/zhan-dong-tu-yan-shi-by-xiaohu9527-hua8/">题解</a>）：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621994961055.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">import java.util.Stack;

public class Solution {
    public String reverseParentheses(String s) {
        final StringBuilder builder = new StringBuilder();
        int n = s.length();
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int [] next = new int[n];
        for (int i = 0; i &lt; n; i++) {
            char c = s.charAt(i);
            if(c == '('){
                stack.push(i);
            }else if(c == ')'){
                int j = stack.pop();
                next[i] = j;
                next[j] = i;
            }
        }

        int direction = 1;
        for (int i = 0; i &lt; n; i+=direction) {
            char c = s.charAt(i);
            if(c == '(' || c == ')'){
                i = next[i];
                direction = -direction;
            }else{
                builder.append(c);
            }
        }
        return builder.toString();
    }
}
</code></pre>
<p>使用一个辅助栈存储括号位置，当出现<code>)</code>时对<code>next</code>数组赋值，表示下一次遍历开始的位置，遍历完成后再次<code>O(n)</code>遍历：</p>
<ul>
<li>如果出现了括号，移动指针到<code>next[i]</code>的位置，并改变遍历方向</li>
<li>如果不是括号，添加到结果末尾</li>
</ul>
<p>最后返回<code>builder.toString()</code>。</p>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1621995094642.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第345期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-345-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-345-qi/">
        </link>
        <updated>2021-05-24T21:20:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>骑电动车请戴好头盔，否则，开奔驰的同学会认出你。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>指点牡丹初绽朵，日高犹自凭朱栏，含嚬不语恨春残。<br>
——韦庄《浣溪沙·清晓妆成寒食天》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我希望兜兜转转之后那个人还是你。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621891391130.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>不会，只会暴力，放个官方题解<code>dp</code>：</p>
<pre><code class="language-java">class Solution {
    // x 的范围为 [0, 2^10)
    static final int MAXX = 1 &lt;&lt; 10;
    // 极大值，为了防止整数溢出选择 INT_MAX / 2
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minChanges(int[] nums, int k) {
        int n = nums.length;
        int[] f = new int[MAXX];
        Arrays.fill(f, INFTY);
        // 边界条件 f(-1,0)=0
        f[0] = 0;
        
        for (int i = 0; i &lt; k; ++i) {
            // 第 i 个组的哈希映射
            Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;Integer, Integer&gt;();
            int size = 0;
            for (int j = i; j &lt; n; j += k) {
                cnt.put(nums[j], cnt.getOrDefault(nums[j], 0) + 1);
                ++size;
            }

            // 求出 t2
            int t2min = Arrays.stream(f).min().getAsInt();

            int[] g = new int[MAXX];
            Arrays.fill(g, t2min);
            for (int mask = 0; mask &lt; MAXX; ++mask) {
                // t1 则需要枚举 x 才能求出
                for (Map.Entry&lt;Integer, Integer&gt; entry : cnt.entrySet()) {
                    int x = entry.getKey(), countx = entry.getValue();
                    g[mask] = Math.min(g[mask], f[mask ^ x] - countx);
                }
            }
            
            // 别忘了加上 size
            for (int j = 0; j &lt; MAXX; ++j) {
                g[j] += size;
            }
            f = g;
        }

        return f[0];
    }
}
</code></pre>
<p>然后速度并不怎么样：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621891491344.png" alt="" loading="lazy"></figure>
<p>贪心优化：</p>
<pre><code class="language-java">class Solution {
    int[][] cnt;
    int[] sz;
    int[] nums;
    int k;
    public int cost(int pos,int num){
        return sz[pos]-cnt[pos][num];
    }
    Integer[][] memo;
    public int dfs(int pos,int num){//[0,pos]组之前异或值为num的cost
        if(pos==0)return cost(pos,num);
        if(memo[pos][num]!=null)return memo[pos][num];

        int res = Integer.MAX_VALUE/2;
        for(int i=pos;i&lt;nums.length;i+=k){//枚举[0,1023]可以覆盖了所有情况，但是会超时
            //枚举这个组里的值x，那么前面需要值num^x，更新代价
            int x = nums[i];
            res = Math.min(res,cost(pos,x)+dfs(pos-1,num^x));
        }
        memo[pos][num] = res;
        return memo[pos][num];
    }
    public int[] get_min_cost(int k){//计算第k组的最小cost
        //res[0]==cost res[1]==众数个数
        int min_cost = Integer.MAX_VALUE/2;
        int mass_cnt = Integer.MAX_VALUE/2;
        for(int i=0;i&lt;1024;i++){A
            if(cost(k,i)&lt;min_cost){
                min_cost = cost(k,i);
                mass_cnt = cnt[k][i]; 
            }
        }
        return new int[]{min_cost,mass_cnt};
    }
    public int minChanges(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        int n = nums.length;
        cnt = new int[k][1024];
        sz =  new int[k];
        memo = new Integer[k][1024];
        for(int i=0;i&lt;k;i++){
            for(int j=i;j&lt;n;j+=k){
                cnt[i][nums[j]]++;
                sz[i]++;
            }
        }
        //dp从已有的数进行转移，先dp
        int res = dfs(k-1,0);

        //如果dp转移的时候枚举[0,1024]，虽然可以覆盖所有情况
        //但是复杂度变成k*n*1024了
        //只使用已有的数进行转移，可以将1024降为m，k*m=n，总复杂度就变成n^2了。
        //但是会漏一种情况，有的组选择了新的数，此时这个组的cost为 (组内元素个数)。
        //那么这种组有几个呢？
        //可能是0个。可能是...

        //贪心打补丁
        int sum_cost = 0;
        int cost_i = -1;
        int id = -1;
        int mass_cnt = Integer.MAX_VALUE/2;//众数
        for(int i=0;i&lt;k;i++){
            int[] t = get_min_cost(i);//得到第i组的最小cost
            sum_cost += t[0];
            if(t[1]&lt;mass_cnt){
                mass_cnt = t[1];
                id = i;
            }
        }
        //找到那个众数个数最小的组 
        //本来的cost_i = sz[i]-mass_cnt 变成 sz[i] 
        res = Math.min(sum_cost+mass_cnt,res);
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621891537477.png" alt="" loading="lazy"></figure>
<p>看看第一名的大佬，是真的强：</p>
<pre><code class="language-java">public class Solution {
    static class VC implements Comparable&lt;VC&gt; {
        final int value;
        final int index;
        int count;

        VC(int index, int v) {
            this.index = index;
            this.value = v;
        }

        @Override
        public int compareTo(VC o) {
            return o.count - this.count;
        }

        @Override
        public String toString() {
            return value + &quot;:&quot; + count;
        }
    }

    static class Node implements Comparable&lt;Node&gt; {
        final int index;
        VC[] vs;
        int size;
        int count;
        int min_change;
        int min_change_all;
        int[] cs;

        Node(VC[] vcs, int[] nums, int index, int k) {
            this.index = index;
            vs = new VC[(nums.length - index - 1) / k + 1];
            size = 0;
            for (int i = index; i &lt; nums.length; i += k) {
                int v = nums[i];
                VC vc = vcs[v];
                if (vc == null || vc.index != index) {
                    vc = vcs[v] = new VC(index, v);
                }
                if (vc.count++ == 0)
                    vs[size++] = vc;
                count++;
            }
            Arrays.sort(vs, 0, size);
            this.min_change = count - vs[0].count;
        }

        void buildcs() {
            int maxv = 0;
            for (int i = 0; i &lt; size; i++) {
                maxv = Math.max(maxv, vs[i].value);
            }
            this.cs = new int[maxv + 1];
            for (int i = 0; i &lt; size; i++) {
                this.cs[vs[i].value] = vs[i].count;
            }
        }

        int cs(int value) {
            return value &lt; cs.length ? cs[value] : 0;
        }

        @Override
        public int compareTo(Node o) {
            int r = o.min_change - this.min_change;
            if (r == 0)
                r = this.count - o.count;
            return r;
        }

    }

/**
     * 这里使用BFS比DP的计算量少很多。首先按照每行最少替换成本降序排列，然后从最小成本开始替换，每次替换也首先考虑当前行的最小成本，按照DFS思路构建替换路径，计算每个路径的替换成本。
     * 每个路径的替换成本都与最小成本数进行比较，同时将其中的最小再作为比较标准，最小成本默认是数列的长度。
     * 这里的剪枝做的很巧妙，min_change_all表示余下未替换步骤采用最优替换的最小替换和，再次基础上加上当前已经执行的替换数，如果比min_change大，就放弃后面的计算。min_change_all的设计很巧妙。
     * 和DP相比，它按照每行的最优选择依次DFS搜索可能的替换路径，再搜索到最后一层时，判断该数值作为替换的成本（因此存在或不存在都考虑到了），不用像DP那样计算所有可能的替换值。
     */
    static int dfs(Node[] nodes, int index, int v, int changes, int min_change) {
        Node node = nodes[index];
        if (index == 0) {
            changes += node.count - node.cs(v);
            if (changes &lt; min_change) {
                min_change = changes;
            }
            return min_change;
        }
        //优秀的剪枝判断
        if (changes + node.min_change_all &gt;= min_change) {
            return min_change;
        }
        for (int i = 0; i &lt; node.size; i++) {
            VC vc = node.vs[i];
            min_change = dfs(nodes, index - 1, v ^ vc.value, changes + node.count - vc.count, min_change);
        }
        return min_change;
    }

    public int minChanges(int[] nums, int k) {
        final int N = nums.length;
        int res = 0;
        if (k == 1) {
            for (int v : nums)
                if (v != 0) res++;
            return res;
        }
        if (k &gt;= N) {
            for (int v : nums)
                res ^= v;
            res = res == 0 ? 0 : 1;
            return res;
        }
        Node[] nodes = new Node[k];
        int maxv = 0;
        for (int v : nums)
            maxv = Math.max(maxv, v);
        VC[] vcs = new VC[maxv + 1];
        for (int i = 0; i &lt; k; i++) {
            nodes[i] = new Node(vcs, nums, i, k);
        }
        Arrays.sort(nodes);

        int s = 0;
        for (Node node : nodes) {
            s += node.min_change;
            node.min_change_all = s;
        }
        nodes[0].buildcs();
        res = dfs(nodes, k - 1, 0, 0, N);
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621891584866.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第344期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-344-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-344-qi/">
        </link>
        <updated>2021-05-24T10:33:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>不管是白帽子还是黑帽子，会变绿的都不是好帽子。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>垂死病中惊坐起，暗风吹雨入寒窗。<br>
——元稹《闻乐天授江州司马》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>有时候，和你吵架，我宁愿当一个输家，也不愿意赢我爱的你！！！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621766022694.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>区间<code>DP</code>，模板是三重循环：</p>
<ul>
<li>一重循环：区间长度</li>
<li>二重循环：区间起点</li>
<li>三重循环：区间分割点</li>
</ul>
<p>转移方程：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621766144129.png" alt="" loading="lazy"></figure>
<p><s>说的头头是道。。。</s></p>
<p>代码（抄题解的，真的不会第一次遇到这种题）：</p>
<pre><code class="language-java">public class Solution {
    public int strangePrinter(String s){
        int n = s.length();
        int[][] f = new int[n][n];

        for (int i = n-1; i &gt;= 0; --i) {
            f[i][i] = 1;
            for (int j = i+1; j &lt; n; j++) {
                if(s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i][j-1];
                }else{
                    int minn = Integer.MAX_VALUE;
                    for (int k = i; k &lt; j; k++) {
                        minn = Math.min(minn,f[i][k] + f[k+1][j]);
                    }
                    f[i][j] = minn;
                }
            }
        }
        return f[0][n-1];
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621766026705.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第343期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-343-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-343-qi/">
        </link>
        <updated>2021-05-22T18:15:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我躺在床上看天花板，想着我工作的天花板，只是别人的地板。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>殷勤昨夜三更雨，又得浮生一日凉。<br>
——苏轼《鹧鸪天·林断山明竹隐墙》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>就像那句狠话：有一天，我一定会后悔的。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621707462173.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>前缀树、、、、渣渣不会：</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Solution {
    public int[] maximizeXor(int[] nums, int[][] queries) {
        int n = queries.length;
        int [] res = new int[n];
        Arrays.sort(nums);

        Integer[] queries_idx = new Integer[n];
        for (int i = 0; i &lt; n; i++) {
            queries_idx[i] = i;
        }
        Arrays.sort(queries_idx,(a,b)-&gt;queries[a][1] - queries[b][1]);
        Trie trie = new Trie();
        int numIndex = 0;
        for (int i = 0; i &lt; n; i++) {
            while(numIndex &lt; nums.length &amp;&amp; nums[numIndex] &lt;= queries[queries_idx[i]][1]) {
                trie.insert(nums[numIndex],nums[nums.length-1]);
                ++numIndex;
            }
            res[queries_idx[i]] = trie.get(queries[queries_idx[i]][0],nums[nums.length-1]);
        }
        return res;
    }

    private static class TrieNode{
        int val;
        TrieNode [] next = new TrieNode[2];

        public TrieNode(){}

        public TrieNode(int val){
            this.val = val;
        }
    }

    private static class Trie{
        TrieNode root = new TrieNode(1);

        public void insert(int num,int maxNum){
            TrieNode node = root;
            char[] chars = binaryToDecimal(num,Integer.toBinaryString(maxNum).length()).toCharArray();
            int len = chars.length;

            for (int i = 0; i &lt; len; i++) {
                char c = chars[i];
                if(c == '0'){
                    if(node.next[0] == null){
                        node.next[0] = new TrieNode();
                    }
                    node = node.next[0];
                }else{
                    if(node.next[1] == null){
                        node.next[1] = new TrieNode();
                    }
                    node = node.next[1];
                }
            }
            node.val = num;
        }

        public int get(int num,int maxNum){
            TrieNode node = root;
            if(node.next[0] == null &amp;&amp; node.next[1] == null){
                return -1;
            }
            char[] chars = binaryToDecimal(num,Integer.toBinaryString(maxNum).length()).toCharArray();
            int len = chars.length;
            for (int i = 0; i &lt; len; i++) {
                char c = chars[i];
                if(c == '0'){
                    if(node.next[1] != null){
                        node = node.next[1];
                    }else{
                        node = node.next[0];
                    }
                }else {
                    if(node.next[0] != null){
                        node = node.next[0];
                    }else{
                        node = node.next[1];
                    }
                }
            }
            return node.val ^ num;
        }

        private String binaryToDecimal(int decNum,int digit){
            StringBuilder builder = new StringBuilder();
            for (int i = digit-1; i &gt;= 0; --i) {
                builder.append((decNum&gt;&gt;i)&amp;1);
            }
            return builder.toString();
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621707490560.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第342期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-342-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-342-qi/">
        </link>
        <updated>2021-05-22T14:58:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>希望是或，失望是烟，人生就是一边生火一边冒烟。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>那知自是，桃花结子，不因春瘦。<br>
——晁补之《水龙吟·次歆吟圣予惜春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>但是我，我没有眼泪。宇宙，宇宙也没有眼泪呀！眼泪有什么用？</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621695761950.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>数学题，偶数肯定赢，奇数的话需要全部元素的异或结果为0才能赢：</p>
<pre><code class="language-java">public class Solution {
    public boolean xorGame(int[] nums) {
        int x = 0;
        for (int v : nums) x ^= v;
        return x == 0 || nums.length % 2 == 0;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621695774938.png" alt="" loading="lazy"></figure>
<h1 id="袁老千古">袁老千古</h1>
<p>好好吃饭。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第341期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-341-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-341-qi/">
        </link>
        <updated>2021-05-21T04:33:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别人露腿那叫美，你露腿就想让人怼。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>黄师塔前江水东，春光懒困倚微风。<br>
——杜甫《江畔独步寻花·其五》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>只要微笑就可以了。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621571697210.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>实际上是最长公共子序列：</p>
<pre><code class="language-java">public class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621571700653.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第340期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-340-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-340-qi/">
        </link>
        <updated>2021-05-20T02:04:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>为什么中国人结婚，都非要选个好日子呢？因为结完婚就没好日子过了！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>阳春布德泽，万物生光辉。<br>
——佚名《长歌行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>掉头一去是风吹黑发，回首再来已雪满白头。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621489567021.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>统计词频+优先队列（前k个）：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;String&gt; topKFrequent(String[] words, int k) {
        Map&lt;String, Node&gt; map = new HashMap&lt;&gt;();
        for (String s : words) {
            if(map.containsKey(s)){
                ++map.get(s).ct;
            }else{
                map.put(s,new Node(s));
            }
        }

        PriorityQueue&lt;Node&gt; heap = new PriorityQueue&lt;&gt;((s1,s2)-&gt; s1.ct == s2.ct ? s1.s.compareTo(s2.s) : (s2.ct - s1.ct));

        for (Node node:map.values()){
            heap.offer(node)    ;
        }

        List&lt;String&gt; list = new ArrayList&lt;&gt;(k);
        for (int i = 0; i &lt; k; i++) {
            list.add(heap.poll().s);
        }
        return list;
    }

    private static class Node{
        String s;
        int ct;

        public Node(String s){
            ct = 1;
            this.s = s;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621489575585.png" alt="" loading="lazy"></figure>
<h1 id="听说今天是520">听说今天是520</h1>
<p>真搞不懂为什么这么多人送礼物？</p>
<p>今天又不是什么特殊的日子。</p>
<p>至于吗？</p>
<p>520居然真的还会有人送礼物？</p>
<p>不会吧不会吧？</p>
<p>都2021年了，</p>
<p>不会真的有人在520送礼物吧？</p>
<p>不会吧不会吧？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第339期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-339-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-339-qi/">
        </link>
        <updated>2021-05-19T01:56:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>打工钱少就出来创业吧，保证能让你，赔个精光。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>两岸桃花烘日出，思维高柳到天垂。<br>
——姜彧《浣溪沙·山滴岚光水拍堤》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你的名字那么普通也就我听到会心头一怔。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621476068651.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>前缀和+快速选择：</p>
<pre><code class="language-java">public class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        int [][] xor = new int[m+1][n+1];

        int []result = new int[m*n];
        int resultIndex = 0;

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                result[resultIndex++] = xor[i+1][j+1] = (matrix[i][j] ^ xor[i+1][j] ^ xor[i][j+1] ^ xor[i][j]);
            }
        }

        return quickSelect(result,0,m*n-1,m*n-k+1);
    }

    private int quickSelect(int []nums,int start,int end,int k){
        if (start == end) {
            return nums[start];
        }
        int left = start;
        int right = end;
        int pivot = nums[start + (end - start) / 2];
        while (left &lt;= right) {
            if (nums[left] &lt; pivot) {
                left++;
            } else if (nums[right] &gt; pivot) {
                right--;
            } else {
                int temp = nums[left];
                nums[left++] = nums[right];
                nums[right--] = temp;
            }
        }
        if (start + k - 1 &lt;= right) {
            return quickSelect(nums, start, right, k);
        }
        if (start + k - 1 &gt;= left) {
            return quickSelect(nums, left, end, start + k - left);
        }
        return nums[right + 1];
    }

}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621489558295.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第338期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-338-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-338-qi/">
        </link>
        <updated>2021-05-17T16:32:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>岁月让我知道，除了快递，我谁也不必等。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>来时浦口花迎入，采罢江头月送归。<br>
——王昌龄《采莲曲二首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我发现，勇气根本靠不住，只有完全的疯狂才有意义。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621269247204.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>暴力<code>O(n3)</code>：</p>
<pre><code class="language-java">
public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int [] x = new int[n];
        x[0] = arr[0];
        for (int i = 1; i &lt; n; i++) {
            x[i] = arr[i] ^ x[i-1];
        }
        for (int i = 0; i &lt; n; i++) {
            for (int j = i+1; j &lt; n; j++) {
                for (int k = j; k &lt; n; k++) {
                    int a = (i-1 &gt;= 0 ? x[j-1] ^ x[i-1] : x[j-1]);
                    int b = x[k] ^ x[j-1];
                    if(a == b){
                        ++sum;
                    }
                }
            }
        }
        return sum;
    }
}
</code></pre>
<p>自己也不太看得下去：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621269284763.png" alt="" loading="lazy"></figure>
<p><s>真·时间换空间。</s></p>
<p>题解还有一个<code>O(n^2)</code>的，核心公式如下：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621269590200.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621269595883.png" alt="" loading="lazy"></figure>
<p>符合范围的<code>i</code>、<code>k</code>，<code>j</code>可以任意取值，也就是两者的差值：</p>
<pre><code class="language-java">public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int[] x = new int[n + 1];
        for (int i = 0; i &lt; n; i++) {
            x[i+1] = arr[i] ^ x[i];
        }
        for (int i = 0; i &lt; n; i++) {
            for (int k = i + 1; k &lt; n; k++) {
                if (x[i] == x[k + 1]) {
                    sum += k - i;
                }
            }
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1621269646584.png" alt="" loading="lazy"></figure>
<p>居然还有<code>O(n)</code>的：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int[] x = new int[n + 1];
        for (int i = 0; i &lt; n; i++) {
            x[i + 1] = arr[i] ^ x[i];
        }

        Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();
        Map&lt;Integer, Integer&gt; total = new HashMap&lt;&gt;();

        for (int k = 0; k &lt; n; k++) {

            if (cnt.containsKey(x[k + 1])) {
                sum += cnt.get(x[k + 1]) * k - total.get(x[k + 1]);
            }

            cnt.put(x[k], cnt.getOrDefault(x[k], 0) + 1);
            total.put(x[k], total.getOrDefault(x[k], 0) + k);
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1621270596468.png" alt="" loading="lazy"></figure>
<p><code>O(n)</code>还要比<code>O(n^2)</code>要慢？？？？</p>
<p>好家伙。</p>
]]></content>
    </entry>
</feed>