<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-07-14T15:35:48.398Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第28期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-28-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-28-qi/">
        </link>
        <updated>2020-07-16T03:47:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote></blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote></blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote></blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote></blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第27期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-27-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-27-qi/">
        </link>
        <updated>2020-07-15T03:47:16.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1594740928858.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>瘦的人能把衣服穿出故事，胖的人只能穿成事故。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>海马没有胃，只有肠子可以从食物中吸收营养。因此食物会迅速通过其消化系统，导致它们必须几乎不断进食。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>纷纷红紫已成尘，布谷声中夏令新。<br>
——陆游《初夏绝句》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>爱欲于人，犹如执炬，逆风而行，必有烧手之患。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.qugeek.com/app/player.php?auto-action=true&amp;action=search&amp;s-source=tencent&amp;wd=%E4%BD%A0%E7%9A%84%E9%85%92%E9%A6%86%E5%AF%B9%E6%88%91%E6%89%93%E4%BA%86%E7%83%8A+%E7%B2%A4%E8%AF%AD">独留世上-小甜（你的酒馆对我打了烊粤语）</a></p>
</blockquote>
<blockquote>
<p>是那天<br>
多恩爱的一双<br>
但这刻<br>
竟通话都牵强<br>
明白爱情死了<br>
不必开口讲原谅</p>
</blockquote>
<blockquote>
<p>情像酒馆打烊门关上<br>
留下此生不必还的账<br>
能自欺不松开谁手掌<br>
紧抱残像 来独留世上<br>
情是苦酒一杯像砒霜<br>
尝尽刻骨穿心和冷枪<br>
然后撕开伤口来欣赏<br>
无关我那样</p>
</blockquote>
<blockquote>
<p>说过那些天老地长<br>
日后换作凄凉<br>
如同无恙<br>
我半醉半醒<br>
挤笑扮欢畅<br>
梦里断肠</p>
</blockquote>
<blockquote>
<p>未够伤<br>
小小擦损轻伤<br>
愉快些<br>
请关掉供的氧<br>
明白爱情死了<br>
不必开口说原谅</p>
</blockquote>
<blockquote>
<p>情像酒馆打烊门关上<br>
留下此生不必还的账<br>
能自欺不松开谁手掌<br>
紧抱残像<br>
来独留世上</p>
</blockquote>
<blockquote>
<p>情是苦酒一杯像砒霜<br>
尝尽刻骨穿心和冷枪<br>
然后撕开伤口来欣赏<br>
无关我那样</p>
</blockquote>
<blockquote>
<p>请你请你补上那一枪<br>
你我方算美好绝唱<br>
想你想你不过渐变凉<br>
气数早已结出寒霜</p>
</blockquote>
<blockquote>
<p>情像酒馆打烊门关上<br>
留下此生不必还的账<br>
谁亦不必捉紧谁手掌<br>
应要拍掌<br>
能独留世上<br>
情是苦酒一杯像砒霜<br>
吸取寂寞做绝望营养<br>
当作喜剧落幕便散场<br>
无关我那样<br>
然后安息于心房中央<br>
无关我那样</p>
</blockquote>
<h1 id="印度神油">印度神油</h1>
<h2 id="起源">起源</h2>
<p>印度神油真的来自印度吗？<br>
就像阿拉伯数字不是阿拉伯人发明一样，印度神油其实并不来自印度，产自中国香港。<br>
1958年，何敏森，何敏祯两兄弟在香港九龙办了一个叫“华仁行”的化工厂：<br>
<img src="https://2293736867.github.io/post-images/1594711562829.webp" alt="" loading="lazy"><br>
主要产品包括杀虫剂，脚气喷雾，药膏等，当时有一个著名的黑旋风广告：</p>
<blockquote>
<p>月黑风高夜，黑旋风忍者为民除害，唔使用剑嘎，用黑旋风就得嘞<br>
——黑旋风够晒威，黑旋风的确好使<br>
<img src="https://2293736867.github.io/post-images/1594711679246.webp" alt="" loading="lazy"></p>
</blockquote>
<p>至于印度神油，则是何敏森的灵感之作。第一代印度神油如下：<br>
<img src="https://2293736867.github.io/post-images/1594711751781.png" alt="" loading="lazy"></p>
<blockquote>
<p>多年后的华仁行老员工透露：所有的成为都是自己配出来的，主要是一些有麻醉作用的药物，跟真正的印度半毛钱关系也没有。</p>
</blockquote>
<p>至于为什么安上印度的名号，大概是因为印度宗教与性文化。</p>
<p>印度几乎所有的宗教，文化和艺术都起源于《吠陀经》，在吠陀教传统中，性是永无终结的。人们对将对性的信奉和拒绝当作决定灵魂存亡的措施，无论是印度教教徒还是佛教教徒都信仰“投胎转世”的人生轮回说，认为人死后灵魂可变成人或动物继续存在。而性就是人类这种人生轮回的一个重要部分，尤其在印度教是继承了印度土著居民达罗毗茶人的生殖文化和雅利安人的自然崇拜传统而产生的一种宗教，他们都认为生殖与性欲就是人生最关键的连接点。</p>
<p>尽管印度教和佛教都有禁欲主义传统，但是在大量的典籍中却发现这些宗教与性文化有千丝万缕的联系，而这些典籍中的记载也令人寻味，也就知道这些宗教禁欲却不禁性。他们只是认为人应该放弃对性自由，婚姻和家庭三种乐欲的追求，这样才能去往极乐世界，而性本身确实天堂必经之路。由此可以看出禁欲与禁性是完全不同的两个概念，而佛教在传入中国时却对于性是完全禁止，这是因为佛教为了在中国生存和更好的传播并发展延续而不得不与中国文化传统习俗相融合，逐渐改变修缮佛教中的教义，向中国根深蒂固的儒家文化让步，以求妥协和彼此融合。中国的佛教更多的是带有中国儒家文化色彩，而这也是为什么佛教能在中国发扬光大而在印度本土逐渐衰落的原因之一。而与印度接壤的西藏却更接近于原来的印度佛教，并有了藏传佛教中的密宗一支。</p>
<p>印度人虽然撰写了第一本集“爱”与“性”为一体的《爱经》，但他们却总是将“爱”与“性”完全分开，认为真正的爱应该是无师自通的人类本能，无需任何指导，相反“性”却需要强调技巧。因而，印度关于性问题的书籍中常常用最主要的篇幅来介绍“无爱的性技巧”，即使《爱经》一书也明显反映出这一倾向。</p>
<p>大多的宗教尽管互不相干，却也在长期的历史沿革中不断吸收和相互的影响着。如佛教中的密宗，其中就有一个欢喜佛。在笈多王朝（320年-600年）以后，佛教在印度本土日益衰微，几乎没有立足之地，印度教日趋强盛，几乎控制了印度大部分地区，尤其在南印度，基本都是印度教的势力范围。尽管在古印度帕拉王朝（750-1150年）的庇护统治下，佛教又保存了一段较长的时期，但是为了发展和延续，不得不吸收了大量的印度教的内容，衍变为密宗。</p>
<p>密教也称坦罗多教，坦罗多的词根tan的原义就是生殖，繁衍。在密宗中，彼岸的超验智慧“般若”代表女性的创造活力，另一种修炼的方式“方便”代表男性的创造活力，分别以女阴的变形莲花和男根的变形金刚杵为象征，通过想象的阴阳交媾和真实的男女欢交的瑜伽方式，亲证“般若”与“方便”融为一体的极乐涅磐境界。这就是欢喜佛的宗教寓意。佛教密宗里男女双修就是印度教性力派影响下的产物。</p>
<p>在欢喜佛图象中凶神恶煞的明王和明王妃合抱交媾，明妃搂其头，一足围绕其腰，就是“大乐”形式。与明王合为一体的妩媚多姿的明妃，是明王修行时必不可少的伙伴。在佛经上叫做“先以欲勾之，后令入佛智”，她以爱欲供奉那些残暴的神魔，使之受到感化，然后再把他们引到佛的境界中来。这就是供奉欢喜佛所谓的“调心工具”和培植佛性的“机缘”。对着欢喜佛的“观形鉴视”，时日久了则习以为常，欲念之心顿消，利用“空乐双运”产生了悟空性，达到“以欲制欲”的目的。</p>
<p>密宗认为他们对女性的崇拜是一种无私的行为，是一种真正意义上的爱：无爱，也就是《爱经》所诠释的性爱的最高境界。因此，密宗仪式中的性事并不表现为激情，而是一种非个性化的行为，一种无状态的心灵状态和浑然一体的自我，沉浸于其中的是彻底的自我和自我的解脱。正是在这种解脱的意义上，禁欲与纵性，苦行与性力奇特地化为一体，成为同归的殊途。这也就是为什么在许多的寺庙中你都可以看见精美绝伦的性爱雕像的原由，在今天，漫步在印度诸多神庙中，你感受到的不是性的羞涩隐晦而是一种自然的原生态的美，那种源于生命本质的，是最持久的，也是永恒的。</p>
<p>好了扯远了，回归正题，为了让印度神油为更多人”造福“，华仁行找来一辆厢式卡车，上面印着：</p>
<blockquote>
<p>印度神油，妙不可言，佛国之宝，的确够劲</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1594714257356.webp" alt="" loading="lazy"></figure>
<p>在加上电影的宣传：<br>
<img src="https://2293736867.github.io/post-images/1594738150613.webp" alt="" loading="lazy"><br>
<img src="https://2293736867.github.io/post-images/1594738154518.webp" alt="" loading="lazy"></p>
<p>印度神油变得非常火爆，一位印度的中文导游表示：</p>
<blockquote>
<p>每一个中国游客都会问哪里能买到正宗的印度神油，自己不厌其烦地被追问了几十年。</p>
</blockquote>
<p>另外据阿里巴巴，京东等电商平台数据统计显示，2019年3月-2020年2月，男士精油近一年线上交易总额达1.04亿，销售同比上涨86.17%。<br>
<img src="https://2293736867.github.io/post-images/1594738322802.webp" alt="" loading="lazy"></p>
<h2 id="究竟有没有用">究竟有没有用？</h2>
<p>用“鼻祖”华仁行出品的印度神油来说，主要原材料为蟾蜍，即从中华大蟾蜍或黑眶蟾蜍皮肤身上的有毒分泌物制取而成。现代医学认为，产出对于跌打损伤有消肿止痛之效，适量喷涂皮肤可有麻痹之感，使得敏感度下降，从而起到延时作用。<br>
但是对于真正存在生殖障碍的患者来说，无异于饮鸠止渴。此外频繁使用外用药极易导致受伤或者发炎，操作手法也需谨慎，否则麻到对方等于互相伤害。</p>
<p>浙江大学医学院揭露，西医用于治疗男性障碍一般多为口服用药，这种外用药无法直接作用于内部海绵体，并不能起到实际作用，反而会延误病情的治疗良机。说到底印度神油只是一款有着局麻作用的普通男性外用保健品，充其量只能起到辅助作用，健康本体才是关键所在。<br>
再看看后来的“正统”印度本土精油，可以分为六大种类：</p>
<ul>
<li>皇帝油</li>
<li>延时喷剂</li>
<li>男士红油</li>
<li>阿育吠陀玉女油</li>
<li>阿育吠陀霸油</li>
<li>男优膏</li>
</ul>
<p>但其实即使商品种类混杂，能证明真实有效的并不多，换句话说，说无效也不奇怪。</p>
<h2 id="鱼龙混杂的神油市场">鱼龙混杂的神油市场</h2>
<p>印度神油并非商标，谁都可以使用以及生产，久而久之市场混乱程度可想而知。<br>
在电商平台上随意搜索即能找到各种各样的印度神油，虽然价格参差不齐，但是都会突出“本产品由印度XXX集团出品”，“本品选用印度秘方XXX”等宣传词，月销量过万者比比皆是。但实际上国家药监局从未批准过从印度进口任何延时喷剂，这类山寨精油大多是私人作坊炮制出的三无产品，即便国内最正宗的印度神油，最多也不过是香港华仁行生产的罢了。<br>
每年国家处理的神油造假类案件达数万起，一方面利益熏心的商家们为增加销量，不惜铤而走险，不仅私自添加明令禁止的化学成分，很多配比更是经不起考量，轻则过敏反应，重则对肝，肾等产生不可逆转的副作用。另一方面，因为涉及隐私，多数人宁可吞下哑巴亏，也不愿公开报案，使得造假制假事件屡禁不止，愈演愈烈。</p>
<h2 id="说明">说明</h2>
<p>摘自<a href="https://mp.weixin.qq.com/s/10z5mjGHASnqbj3l2Vzb_g">这里</a>与<a href="https://sites.google.com/site/voiceofgreengrass/-474">这里</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第26期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-26-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-26-qi/">
        </link>
        <updated>2020-07-14T03:25:54.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1594697528030.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>穷不可怕，可怕的是，最穷的人是我。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>凭借2013年的电影《达拉斯买家俱乐部》，化妆师罗宾·马修斯赢得了第86届奥斯卡最佳化妆与发型设计奖，在整部影片28天的制作周期中，化妆预算仅为250美元。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>最爱湖东行不足，绿杨阴里白沙堤。<br>
——白居易《钱塘湖春行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>吾心吾行澄如明镜，所作所为皆为正义。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1335350269">生而为人-尚士达</a></p>
</blockquote>
<blockquote>
<p>曾经说过不会抽的烟<br>
都已经吸进肺里好几年<br>
曾经的梦想天真无邪<br>
后来满脑子都是为了钱<br>
每年生日闭眼许的愿<br>
能有几个可以灵验<br>
人总会变 抱歉</p>
</blockquote>
<blockquote>
<p>都说生命可以不分贵贱<br>
可有人生来就被叫做少爷<br>
有人只能看着地面<br>
抬头都是些肮脏的嘴脸<br>
励志要走社会的前列<br>
可总是败在势力的面前<br>
肺腑之言 抱歉</p>
</blockquote>
<blockquote>
<p>我想忘了从前的一切<br>
做一个凡事不问的俗人<br>
从今天起远离人群<br>
做一只狡猾的狐狸<br>
那天我双手合十<br>
看着镜子里狼狈的自己<br>
我用了一半的青春<br>
来思考做人的道理</p>
</blockquote>
<blockquote>
<p>对不起年少的自己<br>
行千万里 再别忘了初心</p>
</blockquote>
<blockquote>
<p>都说生命可以不分贵贱<br>
可有人生来就被叫做少爷<br>
有人只能看着地面<br>
抬头都是些肮脏的嘴脸<br>
励志要走在社会的前列<br>
可总是败在势力的面前<br>
肺腑之言 抱歉</p>
</blockquote>
<blockquote>
<p>我想忘了从前的一切<br>
做一个凡事不问的俗人<br>
从今天起远离人群<br>
做一只狡猾的狐狸<br>
那天我双手合十<br>
看着镜子里狼狈的自己<br>
我用了一半的青春<br>
来思考做人的道理<br>
对不起年少的自己<br>
行千万里 再别忘了初心</p>
</blockquote>
<blockquote>
<p>我想忘了从前的一切<br>
做一个凡事不问的俗人<br>
从今天起远离人群<br>
做一只狡猾的狐狸<br>
那天我双手合十<br>
看着镜子里狼狈的自己<br>
我用了一半的青春<br>
来思考做人的道理<br>
对不起年少的自己<br>
行千万里 再别忘了初心</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第25期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-qi/">
        </link>
        <updated>2020-07-13T02:41:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1594608403583.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>把女孩子弄哭是很没种的事，把男孩子弄哭是一件叼爆的事啊。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>骆驼仅需13分钟就可喝下13加仑（约114升的水）。这些水储存在骆驼的血液中，而不是存在能量丰富而且富含脂肪的驼峰中。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>又莫是东风逐君来，便吹散眉间一点春皱。<br>
——苏轼《洞仙歌·咏柳》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不合理的事物，未必都是显而易见的。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=546715801">童话幻灭-蒋蒋</a></p>
</blockquote>
<blockquote>
<p>你开始悲伤哽咽<br>
像诗里写的决别<br>
陪你看过那场雪<br>
一转眼却要分别<br>
这故事就要完结<br>
落笔时满天枫叶<br>
陪你走过那条街<br>
霎那间童话幻灭</p>
</blockquote>
<blockquote>
<p>我没搞懂也没种<br>
我陷在黑黑无底洞<br>
爬不出来<br>
不知好歹<br>
板着脸孔话很冲<br>
说我不是你的英雄<br>
算哪盘菜<br>
只好认栽</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1594609876841.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>我努力释怀回忆的挚爱<br>
却刻进脑海不让人去猜<br>
目送着离开注定回不来<br>
就算是伤害也瞒天过海</p>
</blockquote>
<blockquote>
<p>你开始悲伤哽咽<br>
像诗里写的决别<br>
陪你看过那场雪<br>
一转眼却要分别<br>
这故事就要完结<br>
落笔时满天枫叶<br>
陪你走过那条街<br>
霎那间童话幻灭</p>
</blockquote>
<blockquote>
<p>我没搞懂也没种<br>
我陷在黑黑无底洞<br>
爬不出来<br>
不知好歹<br>
板着脸孔话很冲<br>
说我不是你的英雄<br>
算哪盘菜<br>
只好认栽</p>
</blockquote>
<blockquote>
<p>我努力释怀回忆的挚爱<br>
却刻进脑海不让人去猜<br>
目送着离开注定回不来<br>
就算是伤害也瞒天过海</p>
</blockquote>
<blockquote>
<p>你开始悲伤哽咽<br>
像诗里写的决别<br>
陪你看过那场雪<br>
一转眼就要分别<br>
落笔时满天枫叶<br>
陪你走过那条街<br>
霎那间童话幻灭</p>
</blockquote>
<blockquote>
<p>你开始悲伤哽咽<br>
像诗里写的决别<br>
陪你看过那场雪<br>
一转眼就要分别<br>
这故事就要完结<br>
落笔时满天枫叶<br>
陪你走过那条街<br>
霎那间通话幻灭</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（四）：简单工厂模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-si-jian-dan-gong-han-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-si-jian-dan-gong-han-mo-shi/">
        </link>
        <updated>2020-07-13T02:40:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%9A%E4%B9%89">1 定义</a></li>
<li><a href="#2-%E7%BB%93%E6%9E%84">2 结构</a></li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E7%AE%80%E5%8C%96">4 简化</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-定义">1 定义</h1>
<p><strong>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</strong></p>
<p>因为在简单工厂模式用于创建实例的方法是静态的方法，因此简单工厂模式又被称为静态工厂方法模式，它属于类创建型模式。</p>
<p>尽管简单工厂模式不属于GoF23种设计模式之一，但是实际中用途广泛，并且可以作为学习“工厂方法模式”以及“抽象工厂模式”的基础。</p>
<h1 id="2-结构">2 结构</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/202007122243106.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>由图可知包含以下三个角色：</p>
<ul>
<li>Factory（工厂角色）：即工厂类，负责实现创建所有产品实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象，在工厂类中提供了一个静态工厂方法用于获取产品</li>
<li>Product（抽象产品角色）：是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法。Product会提高系统的灵活性，使得在工厂类只需要定义一个通用的工厂产品方法，因为所有创建的具体产品都是其子类对象</li>
<li>ConcreteProduct（具体产品角色）：所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法</li>
</ul>
<h1 id="3-实例">3 实例</h1>
<p>某公司需要开发一个图表库，该图表库可以提供各种不同外观的图表，例如柱状图，折线图等等。</p>
<p>首先可以先设计一个抽象图表类（这里是一个接口）：</p>
<pre><code class="language-java">interface Chart
{
	void display();
}
</code></pre>
<p>接着各种具体产品类（柱状图，折线图，饼状图等）实现该接口即可：</p>
<pre><code class="language-java">class HistogramChart implements Chart
{
    public HistogramChart()
    {
        System.out.println(&quot;创建柱状图&quot;);
    }

    public void display()
    {
        System.out.println(&quot;显示柱状图&quot;);
    }
}

class PieChart implements Chart
{
    public PieChart()
    {
        System.out.println(&quot;创建饼状图&quot;);
    }

    public void display()
    {
        System.out.println(&quot;显示饼状图&quot;);
    }
}

class LineChart implements Chart
{
    public LineChart()
    {
        System.out.println(&quot;创建折线图&quot;);
    }

    public void display()
    {
        System.out.println(&quot;显示折线图&quot;);
    }
}
</code></pre>
<p>最后是工厂类，为了方便加上了枚举参数：</p>
<pre><code class="language-java">class Factory
{
    public static Chart getChart(Charts charts)
    {
        switch(charts)
        {
            case PIE_CHART:
                return new PieChart();
            case LINE_CHART:
                return new LineChart();
            case HISTOGRAM_CHART:
                return new HistogramChart();
            default:
                return null;
        }
    }
}

enum Charts
{
    PIE_CHART,LINE_CHART,HISTOGRAM_CHART;
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Chart chart = Factory.getChart(Charts.LINE_CHART);
    chart.display();
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200713093445437.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-简化">4 简化</h1>
<p>为了简化简单工厂模式，可以将抽象产品类与工厂类合并，将静态方法移至抽象产品类中：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200713094122200.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样可以通过抽象产品类的静态方法获取子类对象，优化代码如下：</p>
<pre><code class="language-java">interface Chart
{
    void display();
    static Chart getChart(Charts charts)
    {
        switch(charts)
        {
            case PIE_CHART:
                return new PieChart();
            case LINE_CHART:
                return new LineChart();
            case HISTOGRAM_CHART:
                return new HistogramChart();
            default:
                return null;
        }
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<p>简单工厂模式的主要优点如下：</p>
<ul>
<li>分离职责：简单工厂模式实现了对象创建以及使用的分离，工厂类包含必要的判断逻辑，可以决定在什么时候创建什么哪一个产品的实例，客户端可以免除直接创建产品对象的职责，仅仅是“消费”产品</li>
<li>简化记忆：客户端无须知道具体产品类的名字，只需要知道对应的参数即可，一般使用常量字符串或者枚举</li>
<li>提高灵活性：可以引入配置文件（xml等）在不修改客户端代码情况下增加新的具体产品类，提高灵活性</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<p>简单工厂模式的主要缺点如下：</p>
<ul>
<li>工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统都要受影响</li>
<li>由于引入了工厂类会增加系统中类的个数，会增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型过多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</li>
<li>简单工厂模式使用了静态工厂方法，造成工厂角色无法基于继承的等级结构</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>工厂类负责创建的对象比较少，由于创建对象较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li>客户端只需要知道传入工厂类的参数，对如何创建对象不关心</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2020071309592074.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习笔记（二）]]></title>
        <id>https://2293736867.github.io/post/vue-xue-xi-bi-ji-er/</id>
        <link href="https://2293736867.github.io/post/vue-xue-xi-bi-ji-er/">
        </link>
        <updated>2020-07-12T05:47:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-条件判断">1 条件判断</h1>
<h2 id="11-普通if">1.1 普通if</h2>
<p>条件判断使用<code>v-if</code>指令：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;p v-if=&quot;seen&quot;&gt;看到了&lt;/p&gt;;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:{
		seen:true
	}
})
&lt;/script&gt;
</code></pre>
<p><code>v-if</code>指令根据表达式的值（在这里是<code>seen</code>）决定是否插入<code>&lt;p&gt;</code></p>
<h2 id="12-if-else">1.2 if-else</h2>
<p>可以使用<code>v-else</code>添加一个<code>else</code>块：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;div v-if=&quot;Math.random()&gt;0.5&quot;&gt;1&lt;/div&gt;
	&lt;div v-else&gt;2&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app'
})
&lt;/sctipt&gt;
</code></pre>
<p>也可以增加<code>v-else-if</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;div v-if=&quot;value === 'A'&quot;&gt;A&lt;/div&gt;
	&lt;div v-else-if=&quot;value === 'B'&quot;&gt;B&lt;/div&gt;
	&lt;div v-else-if=&quot;value === 'C'&quot;&gt;C&lt;/div&gt;
	&lt;div v-else&gt;D&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:{
		value:'A'
	}
})
&lt;/script&gt;
</code></pre>
<p><code>v-else</code>以及<code>v-else-if</code>必须跟在<code>v-if</code>或者<code>v-else-if</code>之后。</p>
<h2 id="13-v-show">1.3 v-show</h2>
<p>也可以根据<code>v-show</code>展示元素：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;h1 v-show=&quot;ok&quot;&gt;Test&lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:
	{
		ok:true
	}
})
&lt;/script&gt;
</code></pre>
<h1 id="2-循环">2 循环</h1>
<p>循环使用<code>v-for</code>，格式为：<code>A in B</code>，其中<code>A</code>是<code>B</code>中的每一个值，若<code>B</code>为数组，则<code>A</code>表示其中的没一个元素，若<code>B</code>为对象，则<code>A</code>可以表示<code>B</code>中的没一个值，通常配合<code>&lt;li&gt;</code>使用：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;ol&gt;
		&lt;li v-for=&quot;i in arr&quot;&gt;{{i.value}}&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:
	{
		arr:
		[
			{value:'value1'},
			{value:'value2'},
			{value:'value3'}
		]
	}
})
&lt;/script&gt;
</code></pre>
<p>另外也可以通过一个对象的属性来迭代数据：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;ul&gt;
		&lt;li v-for=&quot;value in obj&quot;&gt;{{value}}&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:
	{
		obj:
		{
			value1:'value1',
			value2:'value2',
			value3:'value3'
		}
	}
})
&lt;/script&gt;
</code></pre>
<p>也可以提供第二个参数作为键名：</p>
<pre><code class="language-html">&lt;li v-for=&quot;(value,key) in obj&quot;&gt;
{{key}} -&gt; {{value}}
&lt;/li&gt;
</code></pre>
<p>第三个参数作为索引：</p>
<pre><code class="language-html">&lt;li v-for=&quot;(value,key,index) in obj&quot;&gt;
{{index}} : {{key}} -&gt; {{value}}
&lt;/li&gt;
</code></pre>
<p>另外也可以迭代整数：</p>
<pre><code class="language-html">&lt;li v-for=&quot;n in 10&quot;&gt;{{n}}&lt;/li&gt;
</code></pre>
<p>范围是从0到10，包含0与10。</p>
<h1 id="3-计算属性">3 计算属性</h1>
<h2 id="31-computed">3.1 computed</h2>
<p>计算属性类似与方法调用，比如之前的反转字符串的例子：</p>
<pre><code class="language-js">{{message.split('').reverse().join('')}}
</code></pre>
<p>这样看起来很长，可以使用计算属性进行简化：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;p&gt;{{reverse}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;script&gt;
new Vue({
	el:'#app',
	data:
	{
		message:'Test'
	},
	computed:
	{
		reverse:function()
		{
			return this.message.split.reverse().join('')
		}
	}
})
&lt;/script&gt;
</code></pre>
<p>这里声明了一个计算属性<code>reverse</code>，提供的函数作为属性<code>reverse</code>的<code>getter</code>，<code>reverse</code>依赖于<code>message</code>，当<code>message</code>更新时，<code>reverse</code>也会更新。</p>
<h2 id="32-computed与methods">3.2 computed与methods</h2>
<p>可以使用<code>methods</code>来代替<code>computed</code>：</p>
<pre><code class="language-js">methods:
{
	reverse:function()
	{
		return this.message.split.reverse().join('')
	}
}
</code></pre>
<p>对应只需要增加一对<code>()</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
	&lt;p&gt;{{reverse()}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p><code>computed</code>基于它的依赖缓存，只有相关依赖修改时才会重新取值，而使用<code>methods</code>，在重新渲染时函数总会重新调用执行。</p>
<h2 id="33-setter">3.3 setter</h2>
<p><code>computed</code>默认只有 <code>getter</code>，不过也可以自行提供<code>setter</code>：</p>
<pre><code class="language-js">var vm = new Vue({
	el:'#app',
	data:
	{
		name:'test',
		url:'https://www.test.com'
	},
	computed:
	{
		site:
		{
			get:function()
			{
				return this.name + ' ' + this.url; 
			},
			set:function(value)
			{
				var values = value.split(' ')
				this.name = values[0]
				this.url = values[1]
			}
		}
	}
})

vm.site = 'test2 https://www.test2.com'
document.write('name:'+vm.name)
document.write('&lt;br&gt;')
document.write('url:'+vm.url)
</code></pre>
<p>输入如下：<br>
<img src="https://img-blog.csdnimg.cn/20200712134247478.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第24期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-24-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-24-qi/">
        </link>
        <updated>2020-07-12T03:23:19.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1594524691715.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你不能因为你胖，就忽略了你的丑。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>男性制造的精子比女性制造的卵子多1000000000000000000000000倍（25个0）。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>休说鲈鱼堪脍，尽西风，季鹰归未？<br>
——辛弃疾《水龙吟·登建康赏心亭》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>异地恋是，尝过欣喜若狂，也知道失魂落魄。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1418131597">风恋歌-恋恋故人难 / 芝麻Mochi</a> (吹梦到西洲的日文版)</p>
</blockquote>
<blockquote>
<p>いつかの街角で 君とすれ違った時<br>
気付かぬふりをした 理由さえもわからずに<br>
木枯らし吹く道を俯きながら呟く<br>
ぽつりと漏れた言葉は 届くことなく消えてった<br>
街路樹 落ち葉が溢れる<br>
でも私の季節は変わらないままで<br>
教えてよ この風の行方<br>
あなたの想いは誰に向け吹くの<br>
頬を伝い流れる涙が乾かないのは<br>
そんな全て包む 愛を待っているから<br>
道行く足並みが忙しなくなるこの頃<br>
あなたは今頃何処で 誰の手を取り歩いてるの<br>
景色は色を変えるけど<br>
今も私の想いは変わらないままで<br>
教えてよ この恋の行方<br>
あなたを探して どこまでも往くの<br>
胸の奥に灯った炎が揺らがないのは<br>
今日も吹き止まない 風を待っているから<br>
あと何回この季節を 乗り越えられたのなら<br>
あなたに伝えられるだろう<br>
愛しさと切なさのその全てを<br>
教えてよ この恋の行方<br>
あなたにまた会えたのなら<br>
いつか夢に見た形じゃなくても どうか近くにいさせて<br>
教えてよ この風の行方<br>
あなたの想いは誰に向け吹くの<br>
頬を伝い流れる涙が乾かないのは<br>
そんな全て包む 愛を待っているから</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（三）：单例模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-san-dan-li-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-san-dan-li-mo-shi/">
        </link>
        <updated>2020-07-12T03:21:55.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%9A%E4%B9%89">1 定义</a></li>
<li><a href="#2-%E8%A6%81%E7%82%B9">2 要点</a></li>
<li><a href="#3-%E9%80%9A%E7%94%A8%E6%AD%A5%E9%AA%A4">3 通用步骤</a></li>
<li><a href="#4-%E5%AE%9E%E4%BE%8B">4 实例</a></li>
<li><a href="#5-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B">5 饿汉式单例</a></li>
<li><a href="#6-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B">6 懒汉式单例</a></li>
<li><a href="#7-%E9%A5%BF%E6%B1%89%E5%BC%8F%E4%B8%8E%E6%87%92%E6%B1%89%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">7 饿汉式与懒汉式的比较</a></li>
<li><a href="#8-iodh">8 IoDH</a></li>
<li><a href="#9-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%8E%A8%E8%8D%90">9 枚举实现单例（推荐）</a></li>
<li><a href="#10-%E6%80%BB%E7%BB%93">10 总结</a>
<ul>
<li><a href="#101-%E4%BC%98%E7%82%B9">10.1 优点</a></li>
<li><a href="#102-%E7%BC%BA%E7%82%B9">10.2 缺点</a></li>
<li><a href="#103-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">10.3 使用场景</a></li>
<li><a href="#104-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%80%BB%E7%BB%93">10.4 思维导图总结</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-定义">1 定义</h1>
<p>有时候为了节约系统资源，需要确保系统中某个类只有唯一一个实例，当这个实例创建成功之后，无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一的实例，这是单例模式的动机所在。</p>
<p><strong>单例模式（Singleton Pattern）：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</strong></p>
<h1 id="2-要点">2 要点</h1>
<ul>
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ul>
<h1 id="3-通用步骤">3 通用步骤</h1>
<p>一般来说把一个普通类重构为一个单例类需要以下三步：</p>
<ul>
<li>构造函数私有化：也就是禁止外部直接使用new等创建对象</li>
<li>定义一个静态类成员保存实例</li>
<li>增加一个类似<code>getInstance()</code>的公有静态方法来获取实例</li>
</ul>
<p>因此一般来说单例模式的结构图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200712012413110.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-实例">4 实例</h1>
<p>下面以一个简化的负载均衡器设计进行单例模式的说明。<br>
某个软件需要使用一个全局唯一的负载均衡器，设计如下：</p>
<pre><code class="language-java">public class LoadBalancer
{
    private static LoadBalancer instance = null;

    private LoadBalancer(){}

    public static LoadBalancer getInstance()
    {
        return instance == null ? instance = new LoadBalancer() : instance;
    }

    public static void main(String[] args) {
        LoadBalancer balancer1 = LoadBalancer.getInstance();
        LoadBalancer balancer2 = LoadBalancer.getInstance();
        System.out.println(balancer1 == balancer2);
    }
}
</code></pre>
<p>这是最简单的单例类的设计，获取实例时仅仅判断是否为<code>null</code>，没有考虑到线程问题。也就是说，多个线程同时获取实例时，还是会产生多个实例，一般来说，常见的解决方式如下：</p>
<ul>
<li>饿汉式单例</li>
<li>懒汉式单例</li>
<li>IoDH</li>
</ul>
<h1 id="5-饿汉式单例">5 饿汉式单例</h1>
<p>饿汉式单例就是在普通的单例类基础上，在定义静态变量时就直接实例化，因此在类加载的时候就已经创建了单例对象，而且在获取实例时不需要进行判空操作直接返回实例即可：</p>
<pre><code class="language-java">public class LoadBalancer
{
    private static LoadBalancer instance = new LoadBalancer();

    private LoadBalancer(){}

    public static LoadBalancer getInstance()
    {
        return instance;
    }
}
</code></pre>
<p>当类被加载时，静态变量<code>instance</code>被初始化，类的私有构造方法将被调用，单例类的唯一实例将被创建。</p>
<h1 id="6-懒汉式单例">6 懒汉式单例</h1>
<p>懒汉式单例在类加载时不进行初始化，在需要的时候再初始化，加载实例，同时为了避免多个线程同时调用<code>getInstance()</code>，可以加上<code>synchronized</code>：</p>
<pre><code class="language-java">public class LoadBalancer
{
    private static LoadBalancer instance = null;

    private LoadBalancer(){}

    synchronized public static LoadBalancer getInstance()
    {
        return instance == null ? instance = new LoadBalancer() : instance;
    }
}
</code></pre>
<p>这种技术又叫延迟加载技术，尽管解决了多个线程同时访问的问题，但是每次调用时都需要进行线程锁定判断，这样会降低效率。事实上，单例的核心在于<code>instance = new LoadBalancer()</code>，因此只需要锁定这行代码，优化如下：</p>
<pre><code class="language-java">public static LoadBalancer getInstance()
{
	if(instance == null)
	{
		synchronized (LoadBalancer.class)
		{
			instance = new LoadBalancer();
		}
	}
	return instance;
}
</code></pre>
<p>但是实际情况中还是有可能出现多个实例，因为如果A和B两个线程同时调用<code>getInstance()</code>，都通过了<code>if(instance == null)</code>的判断，假设线程A先获得锁，创建实例后，A释放锁，接着B获取锁，再次创建了一个实例，这样还是导致产生多个单例对象，因此，通常采用一种叫“<strong>双重检查锁定</strong>”的方式来确保不会产生多个实例：</p>
<pre><code class="language-java">private volatile static LoadBalancer instance = null;
public static LoadBalancer getInstance()
{
	if(instance == null)
	{
		synchronized (LoadBalancer.class)
		{
			if(instance == null)
			{
				instance = new LoadBalancer();
			}
		}
	}
	return instance;
}
</code></pre>
<p>需要注意的是要使用<code>volatile</code>修饰变量，<code>volatile</code>可以保证可见性以及有序性。</p>
<h1 id="7-饿汉式与懒汉式的比较">7 饿汉式与懒汉式的比较</h1>
<ul>
<li>饿汉式单例在类加载时就已经初始化，优点在于无需考虑多线程访问问题，可以确保实例的唯一性</li>
<li>从调用速度方面来说会优于懒汉式单例，因为在类加载时就已经被创建</li>
<li>从资源利用效率来说饿汉式单例会劣于懒汉式，因为无论是否需要使用都会加载单例对象，而且由于加载时需要创建实例会导致类加载时间变长</li>
<li>懒汉式单例实现了延迟加载，无须一直占用系统资源</li>
<li>懒汉式单例需要处理多线程并发访问问题，需要双重检查锁定，且通常来说初始化过程需要较长时间，会增大多个线程同时首次调用的几率，这会导致系统性能受一定影响</li>
</ul>
<h1 id="8-iodh">8 IoDH</h1>
<p>为了克服饿汉式单例不能延迟加载以及懒汉式单例的线程安全控制繁琐问题，可以使用一种叫<code>Initialization on Demand Holder（IoDH）</code>的技术。实现IoDH时，需在单例类增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过<code>getInstance()</code>方法返回给外部使用，代码如下：</p>
<pre><code class="language-java">public class LoadBalancer
{
	private LoadBalancer(){}
	private static class HolderClass
	{
		private static final LoadBalancer instance = new LoadBalancer();
	}
	
	public static LoadBalancer getInstance()
	{
		return HolderClass.instance;
	}
}
</code></pre>
<p>由于单例对象没有作为<code>LoadBalancer</code>的成员变量直接实例化，因此类加载时不会实例化<code>instance</code>。首次调用<code>getInstance()</code>时，会初始化<code>instance</code>，由JVM保证线程安全性，确保只能被初始化一次。另外相比起懒汉式单例，<code>getInstance()</code>没有线程锁定，因此性能不会有任何影响。<br>
通过IoDH既可以实现延迟加载，又可以保证线程安全，不影响系统性能，但是缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH。另外，还可能引发<code>NoClassDefFoundError</code>（当初始化失败时），例子可以<a href="https://blog.csdn.net/f59130/article/details/80912055">戳这里</a>。</p>
<h1 id="9-枚举实现单例推荐">9 枚举实现单例（推荐）</h1>
<p>其中，无论是饿汉式，还是懒汉式，还是IoDH，都有或多或少的问题，并且还可以通过反射以及序列化/反序列化方式去“强制”生成多个单例，有没有更优雅的解决方案呢？<br>
有！答案就是枚举。<br>
代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        LoadBalancer balancer1 = SingletonEnum.INSTANCE.getInstance();
        LoadBalancer balancer2 = SingletonEnum.INSTANCE.getInstance();
        System.out.println(balancer1 == balancer2);
    }
}

class LoadBalancer
{
}

enum SingletonEnum
{
    INSTANCE;
    private LoadBalancer instance = null;
    private SingletonEnum()
    {
        instance = new LoadBalancer();
    }

    public LoadBalancer getInstance()
    {
        return instance;
    }
}
</code></pre>
<h1 id="10-总结">10 总结</h1>
<h2 id="101-优点">10.1 优点</h2>
<p>单例模式主要优点如下：</p>
<ul>
<li>单例模式提供了对唯一实例的受控访问，可以严格控制客户怎样以及何时访问它</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式可以提高系统性能</li>
<li>可以扩展成多例类</li>
</ul>
<h2 id="102-缺点">10.2 缺点</h2>
<p>单例模式主要缺点如下：</p>
<ul>
<li>没有抽象层，扩展困难</li>
<li>单例类职责过重，一定程度上违反了单一权责原则，因为既提供了业务方法，也提供了创建对象方法，将对象创建以及对象本身的功能耦合在一起</li>
<li>很多语言提供了GC机制，实例化的对象长时间不使用将被回收，下次使用需要重新实例化，这回导致共享的单例对象状态丢失</li>
</ul>
<h2 id="103-使用场景">10.3 使用场景</h2>
<ul>
<li>系统需要一个实例对象</li>
<li>客户调用类的单个实例只允许使用一个公共访问点</li>
</ul>
<h2 id="104-思维导图总结">10.4 思维导图总结</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020071203301916.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第23期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-23-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-23-qi/">
        </link>
        <updated>2020-07-11T03:56:54.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1594439943160.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我从不去想何时能成功，既然选择了远方，那就还远着呢。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>自1922年以来，已有30项（最高100万美元）现金悬赏令向所有人征集能够证明超自然现象的证据，可至今为止，仍未收集到任何相关证据。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>江月去人只数尺子，风灯照夜欲三更。<br>
——杜甫《漫成一绝》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>所有的梦境都是另一个现实，永远不要忘记。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1449406576">温泉-许嵩/刘美麟</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1594439982530.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>你用温柔手臂弯住迟钝的我<br>
蓝色披风鼓裹着半立方悸动<br>
骑行在泉水小镇下坡有点陡<br>
正好紧贴我背后</p>
</blockquote>
<blockquote>
<p>和你在一起就会莫名的放松<br>
所有阴翳的回忆都一扫而空<br>
在深巷小馆品尝当年的果酒<br>
像你清新而醇厚</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
绽放在夏日雨后<br>
你融化了多少的忧愁或许只有我能懂<br>
你轻轻的问我<br>
我有没有点重<br>
可抱住你就不想松手</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
环绕着香甜的风<br>
你戳中了我的审美点准确得好像针灸<br>
我微微的颤抖<br>
那紧张的喉咙<br>
认真讲述了没做的梦<br>
很生动</p>
</blockquote>
<blockquote>
<p>你用温柔手臂弯住迟钝的我<br>
蓝色披风鼓裹着半立方悸动<br>
骑行在泉水小镇下坡有点陡<br>
正好紧贴我身后</p>
</blockquote>
<blockquote>
<p>和你在一起就会莫名的放松<br>
所有阴翳的会议都一扫而空<br>
在深巷小馆品尝当地的果酒<br>
像你清新而醇厚</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
绽放在夏日雨后<br>
你融化了多少的忧愁或许只有我能懂<br>
你轻轻的问我<br>
我有没有点重<br>
可抱住你就不想松手</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
环绕着香甜的风<br>
你戳中了我的审美点准确得好像针灸<br>
我微微的颤抖<br>
那紧张的喉咙<br>
认真讲述了没做的梦<br>
很生动</p>
</blockquote>
<blockquote>
<p>说实话我可不确定我能够陪你多久<br>
没关系能博红颜一笑是我的温柔<br>
等我们绕过几轮冬夏和春秋<br>
还能不能和你遨游</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
绽放在夏日雨后<br>
你融化了多少的忧愁或许只有我能懂<br>
你轻轻的问我<br>
我有没有点重<br>
可抱住你就不想松手</p>
</blockquote>
<blockquote>
<p>喜欢看你的笑容<br>
环绕着香甜的风<br>
有泡在丛林里的温泉神器疗愈的作用<br>
我微微的颤抖<br>
那紧张的喉咙<br>
认真讲述了没做的梦<br>
很生动</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二）：UML与面向对象设计原则]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-uml-yu-mian-xiang-dui-xiang-she-ji-yuan-ze/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-uml-yu-mian-xiang-dui-xiang-she-ji-yuan-ze/">
        </link>
        <updated>2020-07-11T03:53:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-uml">1 UML</a>
<ul>
<li><a href="#11-uml">1.1 UML</a></li>
<li><a href="#12-uml%E7%89%B9%E6%80%A7">1.2 UML特性</a></li>
<li><a href="#13-uml%E7%BB%93%E6%9E%84">1.3 UML结构</a>
<ul>
<li><a href="#131-%E8%A7%86%E5%9B%BE">1.3.1 视图</a></li>
<li><a href="#132-%E5%9B%BE">1.3.2 图</a></li>
<li><a href="#133-%E6%A8%A1%E5%9E%8B%E5%85%83%E7%B4%A0">1.3.3 模型元素</a></li>
<li><a href="#134-%E9%80%9A%E7%94%A8%E6%9C%BA%E5%88%B6">1.3.4 通用机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-uml%E7%B1%BB%E5%9B%BE">2 UML类图</a>
<ul>
<li><a href="#21-%E7%B1%BB%E5%9B%BE">2.1 类图</a>
<ul>
<li><a href="#211-%E7%B1%BB%E5%90%8D">2.1.1 类名</a></li>
<li><a href="#212-%E5%B1%9E%E6%80%A7">2.1.2 属性</a></li>
<li><a href="#213-%E6%93%8D%E4%BD%9C">2.1.3 操作</a></li>
</ul>
</li>
<li><a href="#22-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">2.2 类之间的关系</a></li>
</ul>
</li>
<li><a href="#3-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB">3 关联关系</a>
<ul>
<li><a href="#31-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94">3.1 双向关联</a></li>
<li><a href="#32-%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94">3.2 单向关联</a></li>
<li><a href="#33-%E8%87%AA%E5%85%B3%E8%81%94">3.3 自关联</a></li>
<li><a href="#34-%E5%A4%9A%E9%87%8D%E6%80%A7%E5%85%B3%E8%81%94">3.4 多重性关联</a></li>
<li><a href="#35-%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB">3.5 聚合关系</a></li>
<li><a href="#36-%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB">3.6 组合关系</a></li>
</ul>
</li>
<li><a href="#4-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">4 依赖关系</a></li>
<li><a href="#5-%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB">5 泛化关系</a></li>
<li><a href="#6-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB">6 接口与实现关系</a></li>
<li><a href="#7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">7 面向对象设计原则</a>
<ul>
<li><a href="#71-%E6%A6%82%E8%BF%B0">7.1 概述</a></li>
<li><a href="#72-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp">7.2 单一职责原则SRP</a></li>
<li><a href="#73-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99ocp">7.3 开闭原则OCP</a></li>
<li><a href="#74-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99lsp">7.4 里氏代换原则LSP</a></li>
<li><a href="#75-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99dip">7.5 依赖倒转原则DIP</a></li>
<li><a href="#76-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99isp">7.6 接口隔离原则ISP</a></li>
<li><a href="#77-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99crp">7.7 合成复用原则CRP</a>
<ul>
<li><a href="#771-%E7%BB%A7%E6%89%BF">7.7.1 继承</a></li>
<li><a href="#772-%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88">7.7.2 组合/聚合</a></li>
</ul>
</li>
<li><a href="#78-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99lod">7.8 迪米特法则LoD</a></li>
</ul>
</li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-uml">1 UML</h1>
<h2 id="11-uml">1.1 UML</h2>
<p>UML（Unified Modeling Language）是统一建模语言，1997年11月UML1.1版本提交给OMG并正式通过，成为建模语言的个那个也标准。2003年6月UML2.0获得正式通过。</p>
<h2 id="12-uml特性">1.2 UML特性</h2>
<ul>
<li>U（Unified）：统一，UML融合了多种优秀的面向对象建模方法以及多种得到认可的软件工程方法，消除了因方法林立且相互独立而带来的种种不便，集众家之长，股名“统一”。通过统一的表示方法可以让不同知识背景的领域专家，系统分析设计人员以及开发人员可以方便地交流</li>
<li>M（Modeling）：UML是一种通用的可视化建模语言，不同与编程语言，UML通过一些标准的图形符号和文字来对系统进行建模，用于对软件进行描述，可视化处理，构造系统制品的文档。UML适用于各种软件开发方法，软件生命周期的各个阶段，各种应用领域以及各种开发工具</li>
<li>L（Language）：UML是一种语言，也就意味着它有属于自己的标准表达规则，不是一种类似Java，C++的编程语言，而是一种分析设计语言，一种建模语言</li>
</ul>
<h2 id="13-uml结构">1.3 UML结构</h2>
<p>UML结构通常包括以下4个部分：视图，图，模型元素以及通用机制。</p>
<h3 id="131-视图">1.3.1 视图</h3>
<p>UML视图用于从不同的角度来表示待建模的系统。视图是由许多图形组成的一个抽象集合，在建立一个系统模型时，只有通过定义多个视图，每个视图显示该系统的一个特定方面，才能构造出该系统的完整蓝图。<br>
UML视图包括：</p>
<ul>
<li>用户视图：以用户的观点表示系统的目标，是所有视图的核心，用于描述系统的需求</li>
<li>结构视图：系统的静态行为，描述系统的静态元素，比如包，类，对象以及它们之间的关系</li>
<li>行为视图：系统的动态行为，描述系统的组成元素在系统运行时的交互关系</li>
<li>实现视图：系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系</li>
<li>环境视图：系统中物理元素的分布，描述系统中硬件设备以及他们之间的关系</li>
</ul>
<h3 id="132-图">1.3.2 图</h3>
<p>UML图是描述UML视图内容的图形，UML2.0提供了13种图，分别是用例图，类图，对象图，包图，组合结构图，状态图，活动图，顺序图，通信图，定时图，交互概览图，组件图和部署图。其中：</p>
<ul>
<li>用例图对应用户视图</li>
<li>类图，对象图，包图和组合结构图对应结构视图</li>
<li>状态图，活动图，顺序图，通信图，定时图和交互概览图对应行为视图</li>
<li>组件图对应实现视图</li>
<li>部署图对应环境视图</li>
</ul>
<h3 id="133-模型元素">1.3.3 模型元素</h3>
<p>模型元素是指UML图中所使用的一些概念，对应于普通的面向对象概念，如类，对象，消息以及这些概念之间的关系，如关联关系，泛化关系等。</p>
<h3 id="134-通用机制">1.3.4 通用机制</h3>
<p>UML提供的通用机制为模型元素提供额外的注释，信息和语义，这些通用机制也提供了扩展机制，允许用户对UML进行扩展，如定义新的建模元素，扩展原有的语义，添加新的特殊信息来扩展模型元素的规则说明等，以便适用于特定的方法或过程，组织和用户。</p>
<h1 id="2-uml类图">2 UML类图</h1>
<h2 id="21-类图">2.1 类图</h2>
<p>类封装了数据和行为，是具有相同属性，操作，关系的对象集合的总称。类图是用出现在系统中不同类来描述系统的静态结构，主要描述不同的类以及它们之间的关系。<br>
在UML中，类图包含类名，属性以及操作。如下面的Employee类：<br>
<img src="https://img-blog.csdnimg.cn/20200710201647414.png" alt="在这里插入图片描述" loading="lazy"><br>
类一般由三部分组成：</p>
<ul>
<li>类名</li>
<li>属性</li>
<li>操作</li>
</ul>
<h3 id="211-类名">2.1.1 类名</h3>
<p>类名就是类的名字，一个字符串。</p>
<h3 id="212-属性">2.1.2 属性</h3>
<p>类的成员变量，一般的格式为</p>
<pre><code class="language-bash">可见性 名称 : 类型 [ = 默认值]
</code></pre>
<p>可见性表示该属性对于类外的元素是否可见，包括：</p>
<ul>
<li>公有：<code>+</code></li>
<li>私有：<code>-</code></li>
<li>受保护：<code>#</code></li>
<li>包：<code>~</code></li>
</ul>
<h3 id="213-操作">2.1.3 操作</h3>
<p>UML规定操作的定义方式为：</p>
<pre><code class="language-bash">可见性 名称(参数列表)[ : 返回类型]
</code></pre>
<ul>
<li>可见性与属性可见性的定义一致</li>
<li>参数列表表示方法的参数，语法与属性定义类似，用<code>,</code>分隔</li>
</ul>
<h2 id="22-类之间的关系">2.2 类之间的关系</h2>
<p>UML提供了四种不同的方式表示类与类之间的关系：</p>
<ul>
<li>关联关系</li>
<li>依赖关系</li>
<li>泛化关系</li>
<li>接口与实现关系</li>
</ul>
<p>下面逐个看一下。</p>
<h1 id="3-关联关系">3 关联关系</h1>
<p>关联关系是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML中用实线连接有关联关系的类。可以在关联线上标注角色名，关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的，但可以使类之间的关系更加明确。<br>
例如在一个登录界面类<code>LoginForm</code>包含一个<code>JButton</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/20200710230718471.png" alt="在这里插入图片描述" loading="lazy"><br>
UML中关联通常包括以下六种形式：</p>
<ul>
<li>双向关联</li>
<li>单向关联</li>
<li>自关联</li>
<li>多重性关联</li>
<li>聚合关系</li>
<li>组合关系</li>
</ul>
<h2 id="31-双向关联">3.1 双向关联</h2>
<p>默认情况下关联是双向的，例如顾客购买商品并拥有商品，反之卖出的商品总是某个顾客与之相关联：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200710231216478.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-单向关联">3.2 单向关联</h2>
<p>关联也可以是单向的，在UML中关联用带箭头的实线表示，比如顾客拥有地址：<br>
<img src="https://img-blog.csdnimg.cn/20200710231436264.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="33-自关联">3.3 自关联</h2>
<p>系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系为自关联，常见于链表：<br>
<img src="https://img-blog.csdnimg.cn/20200710231728997.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="34-多重性关联">3.4 多重性关联</h2>
<p>多重性关联又称为多重性关联联系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或者一个数字范围来表示。常见的表示方式如下：<br>
<img src="https://img-blog.csdnimg.cn/20200710233413832.png" alt="在这里插入图片描述" loading="lazy"><br>
例如一个界面可以具有0个或多个按钮，但是一个按钮只能从属于一个界面：<br>
<img src="https://img-blog.csdnimg.cn/20200710233621254.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="35-聚合关系">3.5 聚合关系</h2>
<p>聚合关系表示整体与部分的关系，使用空心菱形表示。聚合关系中部分是整体的一部分，但是部分可以脱离整体独立存在，比如引擎是汽车的一部分，但是引擎可以独立于汽车存在：<br>
<img src="https://img-blog.csdnimg.cn/20200710234027538.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="36-组合关系">3.6 组合关系</h2>
<p>组合关系也表示整体与部分之间的关系，但是部分不能脱离整体存在。组合关系使用实心菱形表示。比如人的头和嘴巴是组合关系：<br>
<img src="https://img-blog.csdnimg.cn/20200710234310219.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-依赖关系">4 依赖关系</h1>
<p>依赖关系是一种使用关系，在需要表示“一个事物使用另一个事物”时使用依赖关系。UML中依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如驾驶员开车，开车需要车，也就是驾驶员依赖于车：<br>
<img src="https://img-blog.csdnimg.cn/20200710234731593.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-泛化关系">5 泛化关系</h1>
<p>泛化关系也就是继承关系，用于描述父类与之类之间的关系，父类又叫基类或者超类，子类又称作派生类。UML中泛化关系用带空心三角形的直线表示，箭头指向基类：<br>
<img src="https://img-blog.csdnimg.cn/20200710235324792.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-接口与实现关系">6 接口与实现关系</h1>
<p>很多语言比如Java，C#都有接口的概念，接口通常没有属性，所有是操作都是抽象的，只有操作的声明没有操作的实现。UML中使用<code>&lt;&lt;Interface&gt;&gt;</code>表示接口：<br>
<img src="https://img-blog.csdnimg.cn/20200710235919561.png" alt="在这里插入图片描述" loading="lazy"><br>
类与接口之间的实现关系使用空心三角形+虚线表示：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200710235847382.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="7-面向对象设计原则">7 面向对象设计原则</h1>
<h2 id="71-概述">7.1 概述</h2>
<p>面向对象设计的目标之一是支持可维护性复用，一方面需要实现设计方案或者源代码的重用，一方面要确保系统能够易于扩展和修改，具有较好的灵活性。面向对象设计原则由此诞生，它们蕴含于很多设计模式中，是从许多方案总结出来的指导性原则。常见的7种面向对象设计原则如下：</p>
<ul>
<li>单一权责原则</li>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法则</li>
</ul>
<h2 id="72-单一职责原则srp">7.2 单一职责原则SRP</h2>
<p><strong>单一权责原则（Single Responsibility Principal）：一个类只负责一个功能领域中的相应职责。<br>
或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
<p>单一权责原则的核心思想是：一个类不能太“累”。一个类（大到模块，小到方法）承担的职责越多，被复用的可能性越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此需要将职责分离，封装在不同的类中，即将不同的变化原因封装在不同的类中。单一权责原则是实现高内聚，低耦合的指导方针。</p>
<h2 id="73-开闭原则ocp">7.3 开闭原则OCP</h2>
<p><strong>开闭原则（Open-Closed Principle）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量不修改原有代码的情况下进行扩展。</strong></p>
<p>其中软件实体可以是一个软件模块，一个由多个类组成的局部结构或者一个独立的类。<br>
一个软件设计符合开闭原则，则可以非常方便地对其进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。</p>
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以通过接口，抽象类等定义抽象层，通过具体类进行扩展，修改系统的行为时无需修改抽象层，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<h2 id="74-里氏代换原则lsp">7.4 里氏代换原则LSP</h2>
<p><strong>里氏代换原则（Liskov Substitution Principle）：所有引用基类/父类的地方必须能透明地使用其子类的对象。</strong></p>
<p>简单地说就是父类出现的地方可以用子类代替，程序不会产生任何的错误和异常。使用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现父类中声明的方法，运行时，子类实例代替父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p>
<h2 id="75-依赖倒转原则dip">7.5 依赖倒转原则DIP</h2>
<p><strong>依赖倒转原则（Dependency Inversion Principal）：抽象不应该依赖具体细节，细节应当依赖于抽象，换言之要针对接口编程，而不是针对实现编程。</strong></p>
<p>依赖倒转原则要求程序在源代码中传递参数时或者在关联关系中，尽量引用高层次的抽象层类，即使有接口和抽象类进行变量类型声明，参数类型声明，方法返回类型声明以及数据类型的转换等，而不是用具体类来做。一个具体类应该只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用在子类中新增的方法。</p>
<p>在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式包括：</p>
<ul>
<li>构造注入：通过构造函数来传入具体类的对象</li>
<li>设值注入（setter注入）：通过setter来传入具体类对象</li>
<li>接口注入：通过实现在接口中声明的方法来传入具体类对象</li>
</ul>
<p>上面的方法在定义时使用抽象类型，在运行时传入具体类型的对象，由子类对象来覆盖父类对象 。</p>
<h2 id="76-接口隔离原则isp">7.6 接口隔离原则ISP</h2>
<p><strong>接口隔离原则（Interface Segregation Principal）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖于那些它不需要的接口。</strong></p>
<p>也就是说，当一个接口太大时需要划分为更小的接口，使用该接口的客户端仅需知道与之相关的方法。每一个接口应该承担一种相对独立的角色，这里的接口有两层意思：</p>
<ul>
<li>一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象</li>
<li>另一种是指某个语言具体接口的定义，有严格的定义和结构，比如Java中的interface</li>
</ul>
<p>ISP对两种不同含义的表达方式有所不同：</p>
<ul>
<li>当接口理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分，可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫“角色隔离原则”</li>
<li>把接口理解成狭义的特定语言的接口，ISP表达的意思是接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不提供大的总接口。接口应尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或者业务逻辑类）所需的方法即可，这种机制也叫“定制服务”</li>
</ul>
<p>使用接口隔离原则时，注意控制接口的粒度：</p>
<ul>
<li>接口太小导致接口泛滥，不利于维护</li>
<li>接口太大将违背ISP，灵活性差，使用不方便</li>
</ul>
<p>一般而言接口中仅包含为某一类用户定制的方法即可。</p>
<h2 id="77-合成复用原则crp">7.7 合成复用原则CRP</h2>
<p><strong>合成复用原则（Composite Reuse Principal）：尽量使用对象组合而不是继承来达成复用目的。</strong></p>
<p>合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principal），就是在一个新对象中通过关联关系（组合/聚合）对对象进行重用而不是使用继承。</p>
<p>面向对象设计中，可以通过两种方法在不同环境中复用已有的设计和实现：</p>
<ul>
<li>继承</li>
<li>组合/聚合</li>
</ul>
<h3 id="771-继承">7.7.1 继承</h3>
<p>继承需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度。继承主要带来的问题是会破环系统的封装性，因为继承会将基类实现细节暴露给子类，由于基类内部细节对子类可见，因此叫“<strong>白箱复用</strong>”。一般而言两个类之间的关系是“Is-A”关系就可以使用继承。</p>
<h3 id="772-组合聚合">7.7.2 组合/聚合</h3>
<p>尽管可以通过继承来对代码进行复用，一般来说优先考虑组合/聚合。组合/聚合可以使系统更加灵活，降低类与类之间的耦合度。由于新对象可以直接调用已有对象的功能，这样做可以使成员对象的内部实现细节对新对象不可见，所以这种复用叫“<strong>黑箱复用</strong>”。一般而言两个类之间的关系是“Has-A”关系就可以使用组合/聚合。</p>
<h2 id="78-迪米特法则lod">7.8 迪米特法则LoD</h2>
<p><strong>迪米特法则（Law of Demeter）：一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p>
<p>迪米特法则又叫最少知识原则（Least Knowledge Principal，LKP），迪米特法则会对软件实体之间通信的宽度与深度进行限制，可以降低系统的耦合度，使类与类之间保持松耦合。<br>
迪米特法则还有几种定义形式：不要和“陌生人”说话，只与直接朋友通信。对于一个对象“朋友”可以是以下几类：</p>
<ul>
<li>对象本身（this）</li>
<li>以参数形式传入的对象</li>
<li>成员对象</li>
<li>如果成员对象是一个集合，那么集合中的元素也是“朋友”</li>
<li>当前对象所创建的对象</li>
</ul>
<p>满足上述条件之一即是“朋友”，否则就是“陌生人”，不能和“陌生人”发生直接交互。<br>
迪米特法则要求设计系统时尽量减少对象之间的交互，通过引入一个合理的中间类来降低现有对象之间的耦合度。应用迪米特法则时需要注意几点：</p>
<ul>
<li>优先将类设计为不变类</li>
<li>类划分上尽量创建松耦合的类</li>
<li>类结构设计上尽量降低成员变量和成员函数的访问权限</li>
<li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711005605808.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711094651100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>