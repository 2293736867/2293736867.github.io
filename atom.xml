<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-03-03T09:25:35.853Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（二）：JVM基本结构]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-er-jvm-ji-ben-jie-gou/">
        </link>
        <updated>2021-03-03T09:17:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9D%A5%E6%BA%90">1 来源</a></li>
<li><a href="#2-jvm%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></a></li>
<li><a href="#3-jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">3 <code>JVM</code>基本结构</a></li>
<li><a href="#4-java%E5%A0%86">4 <code>Java堆</code></a></li>
<li><a href="#5-java%E6%A0%88">5 <code>Java栈</code></a>
<ul>
<li><a href="#51-%E7%AE%80%E4%BB%8B">5.1 简介</a></li>
<li><a href="#52-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">5.2 局部变量表</a>
<ul>
<li><a href="#521-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%AF%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.1 参数数量对局部变量表的影响</a></li>
<li><a href="#522-%E6%A7%BD%E4%BD%8D%E5%A4%8D%E7%94%A8">5.2.2 槽位复用</a></li>
<li><a href="#523-%E5%AF%B9gc%E7%9A%84%E5%BD%B1%E5%93%8D">5.2.3 对<code>GC</code>的影响</a></li>
</ul>
</li>
<li><a href="#53-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%BA">5.3 操作数栈与帧数据区</a></li>
<li><a href="#54-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">5.4 栈上分配</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA">6 <code>方法区</code></a></li>
<li><a href="#7-java%E5%A0%86-java%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</a></li>
<li><a href="#8-%E5%B0%8F%E7%BB%93">8 小结</a></li>
</ul>
</p>
<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第二章</li>
</ul>
<p>本文是第二章的一些笔记整理。</p>
<h1 id="2-jvm基本参数-xmx">2 <code>JVM</code>基本参数<code>-Xmx</code></h1>
<p><code>java</code>命令的一般形式如下：</p>
<pre><code class="language-bash">java [-options] class [args..]
</code></pre>
<p>其中<code>-options</code>表示<code>JVM</code>启动参数，<code>class</code>为带有<code>main()</code>的<code>Java</code>类，<code>args</code>表示传递给<code>main()</code>的参数，也就是<code>main(String [] args)</code>中的参数。</p>
<p>一般设置参数在<code>-optinos</code>处设置，先看一段简单的代码：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        for(int i=0;i&lt;args.length;++i) {
            System.out.println(&quot;argument &quot;+(i+1)+&quot; : &quot;+args[i]);
        }
        System.out.println(&quot;-Xmx &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot; M&quot;);
    }
}
</code></pre>
<p>设置应用程序参数以及<code>JVM</code>参数：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2021030313324746.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输出：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210303133306902.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210303133306902.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到<code>-Xmx32m</code>传递给<code>JVM</code>，使得最大可用堆空间为<code>32MB</code>，参数<code>a</code>作为应用程序参数，传递给<code>main()</code>，此时<code>args.length</code>的值为1。</p>
<h1 id="3-jvm基本结构">3 <code>JVM</code>基本结构</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210303134417147.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>各部分介绍如下：</p>
<ul>
<li><code>类加载子系统</code>：负责从文件系统或者网络中加载<code>Class</code>信息，加载的类信息存放在一个叫<code>方法区</code>的内存空间中</li>
<li><code>方法区</code>：除了包含加载的类信息之外，还包含运行时常量池信息，包括字符串字面量以及数字常量</li>
<li><code>Java堆</code>：在虚拟机启动时建立，是最主要的内存工作区域，几乎所有的<code>Java</code>对象实例都存在于<code>Java堆</code>中，<strong>堆空间是所有线程共享的</strong></li>
<li><code>直接内存</code>：是在<code>Java堆</code>外的，直接向系统申请的内存区域。<code>NIO</code>库允许<code>Java</code>程序使用<code>直接内存</code>，通常<code>直接内存</code>的访问速度要优于<code>Java堆</code>。另外由于<code>直接内存</code>在堆外，大小不会受限于<code>-Xmx</code>指定的堆大小，但是会受到操作系统总内存大小的限制</li>
<li><code>垃圾回收系统</code>：可以对<code>方法区</code>、<code>Java堆</code>和<code>直接内存</code>进行回收，<code>Java堆</code>是垃圾收集器的工作重点。对于不再使用的垃圾对象，<code>垃圾回收系统</code>会在后台默默工作、默默查找，标识并释放垃圾对象</li>
<li><code>Java栈</code>：每个<code>JVM</code>线程都有一个私有的<code>Java栈</code>，一个线程的<code>Java栈</code>在线程创建时被创建，保存着帧信息、局部变量、方法参数等</li>
<li><code>本地方法栈</code>：与<code>Java栈</code>类似，不同的是<code>Java栈</code>用于<code>Java</code>方法调用，<code>本地方法栈</code>用于本地方法（<code>native method</code>）调用，<code>JVM</code>允许<code>Java</code>直接调用本地方法</li>
<li><code>PC寄存器</code>：每个线程私有的空间，<code>JVM</code>会为每个线程创建<code>PC寄存器</code>，在任意时刻一个<code>Java</code>线程总是执行一个叫做<code>当前方法</code>的方法，如果<code>当前方法</code>不是本地方法，<code>PC</code>寄存器就会指向当前正在被执行的指令，如果<code>当前方法</code>是本地方法，那么<code>PC寄存器</code>的值就是<code>undefined</code></li>
<li><code>执行引擎</code>：负责执行<code>JVM</code>的字节码，现代<code>JVM</code>为了提高执行效率，会使用即时编译技术将方法编译成机器码后执行</li>
</ul>
<p>下面重点说三部分：<code>Java堆</code>、<code>Java栈</code>以及``</p>
<h1 id="4-java堆">4 <code>Java堆</code></h1>
<p>几乎所有的对象都存在<code>Java堆</code>中，根据垃圾回收机制的不同，<code>Java堆</code>可能拥有不同的结构，最常见的一种是将整个<code>Java堆</code>分为<code>新生代</code>和<code>老年代</code>：</p>
<ul>
<li><code>新生代</code>：存放新生对象或年龄不大的对象，有可能分为<code>eden</code>、<code>s0</code>、<code>s1</code>，其中<code>s0</code>和<code>s1</code>分别被称为<code>from</code>和<code>to</code>区域，它们是两块大小相等、可以互换角色的内存空间</li>
<li><code>老年代</code>：存放老年对象，绝大多数情况下，对象首先在<code>eden</code>分配，在一次新生代回收后，如果对象还存活，会进入<code>s0</code>或<code>s1</code>，之后每经过一次新生代回收，如果对象存活则年龄加1。当对象年龄到达一定条件后，会被认为是老年对象，就会进入老年代</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210303134441993.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-java栈">5 <code>Java栈</code></h1>
<h2 id="51-简介">5.1 简介</h2>
<p><code>Java栈</code>是一块线程私有的内存空间，如果是<code>Java堆</code>与程序数据密切相关，那么<code>Java栈</code>和线程执行密切相关，线程执行的基本行为是函数调用，每次函数调用都是通过<code>Java栈</code>传递的。</p>
<p><code>Java栈</code>与数据结构中的<code>栈</code>类似，有<code>FIFO</code>的特点，在<code>Java</code>栈中保存的主要内容为<strong>栈帧</strong>，每次函数调用都会有一个对应的<code>栈帧</code>入栈，每次调用结束就有一个对应的<code>栈帧</code>出栈。栈顶总是当前的帧（当前执行的函数所对应的帧）。栈帧保存着<code>局部变量表</code>、<code>操作数栈</code>、<code>帧数据</code>等。</p>
<p>这里说一下题外话，相信很多读者对<code>StackOverflowError</code>不陌生，这是因为函数调用过多造成的，因为每次函数调用都会生成对应的栈帧，会占用一定的栈空间，如果栈空间不足，函数调用就无法进行，当请求栈深度大于最大可用栈深度时，就会抛出<code>StackOverflowError</code>。</p>
<p><code>JVM</code>提供了<code>-Xss</code>来指定线程的最大栈空间。</p>
<p>比如，下面这个递归调用的程序：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
            recursion();
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
        }
    }
}
</code></pre>
<p>指定<code>-Xss1m</code>，结果：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210303141441656.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss2m</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210303141344772.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>指定<code>-Xss3m</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210303141413662.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到调用深度随着<code>-Xss</code>的增加而增加。</p>
<h2 id="52-局部变量表">5.2 局部变量表</h2>
<p>局部变量表是栈帧的重要组成部分之一，用于保存函数的参数及局部变量。局部变量表中的变量只在当前函数调用中有效，函数调用结束后，函数栈帧销毁，局部变量表也会随之销毁。</p>
<h3 id="521-参数数量对局部变量表的影响">5.2.1 参数数量对局部变量表的影响</h3>
<p>由于局部变量表在栈帧中，如果函数的参数和局部变量表较多，会使局部变量表膨胀，导致栈帧会占用更多的栈空间，最终减少了函数嵌套调用次数。</p>
<p>比如：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static void recursion(long a,long b,long c){
        long e=1,f=2,g=3,h=4,i=5,k=6,q=7;

        count++;
        recursion(a,b,c);
    }

    public static void recursion(){
        ++count;
        recursion();
    }

    public static void main(String[] args) {
        try{
//            recursion();
            recursion(0L,1L,2L);
        }catch (StackOverflowError e){
            System.out.println(&quot;Deep of calling = &quot;+count);
            count = 0;
        }
    }
}
</code></pre>
<p>无参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210303145401403.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>带参数的调用次数（<code>-Xss1m</code>）：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210303145451827.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到次数明显减少了，原因正是因为局部变量表变大，导致栈帧变大，从而次数减少。</p>
<p>下面使用<code>jclasslib</code>进一步查看，先在<code>IDEA</code>安装如下插件：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20210303145242291.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>安装后使用插件查看情况：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210303145931511.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第一个函数是带参数的，可以看到最大局部变量表的大小为<code>20字</code>（注意不是字节），<code>Long</code>在局部变量表中需要占用2字。而相比之下不带参数的函数最大局部变量表大小为0：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210303150723100.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-槽位复用">5.2.2 槽位复用</h3>
<p>局部变量表中的槽位是可以复用的，如果一个局部变量超过了其作用域，则在其作用域之后的局部变量就有可能复用该变量的槽位，这样能够节省资源，比如：</p>
<pre><code class="language-java">public static void localVar1(){
    int a = 0;
    System.out.println(a);
    int b = 0;
}

public static void localVar2(){
    {
        int a = 0;
        System.out.println(a);
    }
    int b = 0;
}
</code></pre>
<p>同样使用<code>jclasslib</code>查看：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210303151315773.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210303151328196.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到少了<code>localVar2</code>的最大局部变量大小为1字，相比<code>localVar1</code>少了1字，继续分析，<code>localVar1</code>第0个槽位为变量a，第1个槽位为变量b：</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210303151544872.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而<code>localVar2</code>中的b复用了a的槽位，因此最大变量大小为1字，节约了空间。</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210303151611143.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="523-对gc的影响">5.2.3 对<code>GC</code>的影响</h3>
<p>下面再来看一下局部变量表对垃圾回收的影响，示例：</p>
<pre><code class="language-java">public class Main {
    public static void localGC1(){
        byte [] a = new byte[6*1024*1024];
        System.gc();
    }

    public static void localGC2(){
        byte [] a = new byte[6*1024*1024];
        a = null;
        System.gc();
    }

    public static void localGC3(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        System.gc();
    }

    public static void localGC4(){
        {
            byte [] a = new byte[6*1024*1024];
        }
        int c = 10;
        System.gc();
    }

    public static void localGC5(){
        localGC1();
        System.gc();
    }

    public static void main(String[] args) {
        System.out.println(&quot;-------------localGC1------------&quot;);
        localGC1();
        System.out.println();
        System.out.println(&quot;-------------localGC2------------&quot;);
        localGC2();
        System.out.println();
        System.out.println(&quot;-------------localGC3------------&quot;);
        localGC3();
        System.out.println();
        System.out.println(&quot;-------------localGC4------------&quot;);
        localGC4();
        System.out.println();
        System.out.println(&quot;-------------localGC5------------&quot;);
        localGC5();
        System.out.println();
    }
}
</code></pre>
<p>输出（请加上<code>-Xlog:gc</code>参数）：</p>
<pre><code class="language-bash">[0.004s][info][gc] Using G1
-------------localGC1------------
[0.128s][info][gc] GC(0) Pause Full (System.gc()) 10M-&gt;8M(40M) 12.081ms

-------------localGC2------------
[0.128s][info][gc] GC(1) Pause Young (Concurrent Start) (G1 Humongous Allocation) 9M-&gt;8M(40M) 0.264ms
[0.128s][info][gc] GC(2) Concurrent Cycle
[0.133s][info][gc] GC(3) Pause Full (System.gc()) 16M-&gt;0M(14M) 2.799ms
[0.133s][info][gc] GC(2) Concurrent Cycle 4.701ms

-------------localGC3------------
[0.133s][info][gc] GC(4) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(14M) 0.203ms
[0.133s][info][gc] GC(5) Concurrent Cycle
[0.135s][info][gc] GC(5) Pause Remark 8M-&gt;8M(22M) 0.499ms
[0.138s][info][gc] GC(6) Pause Full (System.gc()) 8M-&gt;8M(22M) 2.510ms
[0.138s][info][gc] GC(5) Concurrent Cycle 4.823ms

-------------localGC4------------
[0.138s][info][gc] GC(7) Pause Young (Concurrent Start) (G1 Humongous Allocation) 8M-&gt;8M(22M) 0.202ms
[0.138s][info][gc] GC(8) Concurrent Cycle
[0.142s][info][gc] GC(9) Pause Full (System.gc()) 16M-&gt;0M(8M) 2.861ms
[0.142s][info][gc] GC(8) Concurrent Cycle 3.953ms

-------------localGC5------------
[0.143s][info][gc] GC(10) Pause Young (Concurrent Start) (G1 Humongous Allocation) 0M-&gt;0M(8M) 0.324ms
[0.143s][info][gc] GC(11) Concurrent Cycle
[0.145s][info][gc] GC(11) Pause Remark 8M-&gt;8M(16M) 0.316ms
[0.147s][info][gc] GC(12) Pause Full (System.gc()) 8M-&gt;8M(18M) 2.402ms
[0.149s][info][gc] GC(13) Pause Full (System.gc()) 8M-&gt;0M(8M) 2.462ms
[0.149s][info][gc] GC(11) Concurrent Cycle 6.843ms
</code></pre>
<p>首行输出表示使用<code>G1</code>，下面逐个进行分析：</p>
<ul>
<li><code>localGC1</code>：并没有回收内存，因为此时<code>byte</code>数组被变量<code>a</code>引用，因此无法回收</li>
<li><code>localGC2</code>：回收了内存，因为<code>a</code>被设置为了<code>null</code>，<code>byte</code>数组失去强引用</li>
<li><code>localGC3</code>：没有回收内存，虽然此时<code>a</code>变量已经失效，但是仍然存在于局部变量表中，并且指向<code>byte</code>数组，因此无法回收</li>
<li><code>localGC4</code>：回收了内存，因为声明了变量<code>c</code>，复用了<code>a</code>的槽位，导致<code>byte</code>数组失去引用，顺利回收</li>
<li><code>localGC5</code>：回收了内存，虽然<code>localGC1</code>中没有释放内存，但是返回到<code>localGC5</code>后，<code>localGC1</code>的栈帧被销毁，也包括其中的<code>byte</code>数组失去了引用，因此在<code>localGC5</code>中被回收</li>
</ul>
<h2 id="53-操作数栈与帧数据区">5.3 操作数栈与帧数据区</h2>
<p>操作数栈也是栈帧的重要内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，也是一个<code>FIFO</code>的数据结构。</p>
<p>而帧数据区则保存着常量池指针，方便程序访问常量池，此外，帧数据区也保存着异常处理表，以便在出现异常后，找到处理异常的代码。</p>
<h2 id="54-栈上分配">5.4 栈上分配</h2>
<p>栈上分配是<code>JVM</code>提供的一项优化技术，基本思想是，将线程私有的对象打散分配到栈上，好处是函数调用结束后可以自动销毁，而不需要垃圾回收器的介入，从而提高系统性能。</p>
<p>栈上分配的一个技术基础是逃逸分析，逃逸分析目的是判断对象的作用域是否会逃逸出函数体，例子如下：</p>
<pre><code class="language-java">public class Main {
    private static int count = 0;

    public static class User{
        public int id = 0;
        public String name = &quot;&quot;;
    }

    public static void alloc(){
        User user = new User();
        user.id = 5;
        user.name = &quot;test&quot;;
    }

    public static void main(String[] args) {
        long b = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000000; i++) {
            alloc();
        }
        long e = System.currentTimeMillis();
        System.out.println(e-b);
    }
}
</code></pre>
<p>启动参数：</p>
<pre><code class="language-bash">-server # 开启Server模式，此模式下才能开启逃逸分析
-Xmx10m # 最大堆内存
-Xms10m # 初始化堆内存
-XX:+DoEscapeAnalysis # 开启逃逸分析
-Xlog:gc # GC日志
-XX:-UseTLAB # 关闭TLAB
-XX:+EliminateAllocations # 开启标量替换，默认打开，允许将对象打散分配在栈上
</code></pre>
<p>输出如下，没有<code>GC</code>日志：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210303161826251.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而如果关闭了标量替换，也就是添加<code>-XX:-EliminateAllocations</code>，就可以看到会频繁触发<code>GC</code>，因为这时候对象存放在堆上而不是栈上，堆只有10m空间，会频繁进行<code>GC</code>：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210303161747610.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-方法区">6 <code>方法区</code></h1>
<p>与<code>Java堆</code>一样，<code>方法区</code>是所有线程共享的内存区域，用于保存系统的类信息，比如类字段、方法、常量池等，<code>方法区</code>的大小决定了系统可以保存多少个类，如果定义了过多的类，会导致<code>方法区</code>溢出，会直接<code>OOM</code>。</p>
<p>在<code>JDK6/7</code>中<code>方法区</code>可以理解成<code>永久区</code>，<code>JDK8</code>后，<code>永久区</code>被移除，取而代之的是<code>元数据区</code>，可以使用<code>-XX:MaxMetaspaceSize</code>指定，这是一块堆外的直接内存，如果不指定大小，默认情况下<code>JVM</code>会耗尽所有可用的系统内存。</p>
<p>如果<code>元数据区</code>发生溢出，<code>JVM</code>会抛出<code>OOM</code>。</p>
<h1 id="7-java堆-java栈以及方法区的关系">7 <code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>的关系</h1>
<p>看完了<code>Java堆</code>、<code>Java栈</code>以及<code>方法区</code>，最后来一段代码来简单分析一下它们的关系：</p>
<pre><code class="language-java">class SimpleHeap{
    private int id;
    public SimpleHeap(int id){
        this.id = id;
    }

    public void show(){
        System.out.println(&quot;id is &quot;+id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
        s1.show();
        s2.show();
    }
}
</code></pre>
<p><code>main</code>中创建了两个局部变量<code>s1</code>、<code>s2</code>，则这两个局部变量存放在<code>Java栈</code>中。同时这两个局部变量是<code>SimpleHeap</code>的实例，这两个实例存放在<code>Java堆</code>中，而其中的<code>show</code>方法，则存放与<code>方法区</code>中，图示如下：</p>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20210303135915895.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="8-小结">8 小结</h1>
<p>本文主要讲述了<code>JVM</code>的基本结构以及一些基础参数，基本结构可以分成三部分：</p>
<ul>
<li>第一部分：<code>类加载子系统</code>、<code>Java堆</code>、<code>方法区</code>、<code>直接内存</code></li>
<li>第二部分：<code>Java栈</code>、<code>本地方法栈</code>、<code>PC寄存器</code></li>
<li>第三部分：执行引擎</li>
</ul>
<p>而重点讲了三部分：</p>
<ul>
<li><code>Java堆</code>：常见的结构为<code>新生代</code>+<code>老年代</code>结构，其中新生代可分为<code>edsn</code>、<code>s0</code>、<code>s1</code></li>
<li><code>Java栈</code>：包括局部变量表、操作数栈与帧数据区，还提到了一个<code>JVM</code>优化技术栈上分配，可以通过<code>-XX:+EliminateAllocation</code>开启（默认开启）</li>
<li><code>方法区</code>：所有线程共享区域，用于保存类信息，比如类字段、方法、常量等</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot+Gradle构建多模块项目]]></title>
        <id>https://2293736867.github.io/post/springbootgradle-gou-jian-duo-mo-kuai-xiang-mu/</id>
        <link href="https://2293736867.github.io/post/springbootgradle-gou-jian-duo-mo-kuai-xiang-mu/">
        </link>
        <updated>2021-03-02T12:54:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-java-gradle">3 <code>Java + Gradle</code></a>
<ul>
<li><a href="#31-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">3.1 创建项目</a></li>
<li><a href="#32-%E4%BF%AE%E6%94%B9buildgradle">3.2 修改<code>build.gradle</code></a></li>
<li><a href="#33-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">3.3 创建模块</a></li>
<li><a href="#34-%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97">3.4 编写模块</a>
<ul>
<li><a href="#341-service%E6%A8%A1%E5%9D%97">3.4.1 <code>service</code>模块</a></li>
<li><a href="#342-app%E6%A8%A1%E5%9D%97">3.4.2 <code>app</code>模块</a></li>
</ul>
</li>
<li><a href="#35-%E8%BF%90%E8%A1%8C">3.5 运行</a></li>
<li><a href="#36-%E6%B5%8B%E8%AF%95">3.6 测试</a></li>
</ul>
</li>
<li><a href="#4-kotlin-gradle-kotlin-dsl">4 <code>Kotlin + Gradle + Kotlin DSL</code></a>
<ul>
<li><a href="#41-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">4.1 创建项目</a></li>
<li><a href="#42-%E4%BF%AE%E6%94%B9buildgradlekts">4.2 修改<code>build.gradle.kts</code></a></li>
<li><a href="#43-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">4.3 创建模块</a></li>
<li><a href="#44-%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97">4.4 编写模块</a>
<ul>
<li><a href="#441-service%E6%A8%A1%E5%9D%97">4.4.1 <code>service</code>模块</a></li>
<li><a href="#442-app%E6%A8%A1%E5%9D%97">4.4.2 <code>app</code>模块</a></li>
</ul>
</li>
<li><a href="#45-%E8%BF%90%E8%A1%8C">4.5 运行</a></li>
<li><a href="#46-%E6%B5%8B%E8%AF%95">4.6 测试</a></li>
</ul>
</li>
<li><a href="#5-%E6%80%BB%E7%BB%93">5 总结</a></li>
<li><a href="#6-%E6%BA%90%E7%A0%81">6 源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p><code>Gradle</code>由于构建速度比<code>Maven</code>快，且比<code>Maven</code>灵活，因此很多后端的应用都使用了<code>Gradle</code>进行构建，但一个问题是，<code>Gradle</code>的多模块项目比较难构建，再加上<code>Gradle</code>的更新非常快，这就给构建一个多模块<code>Gradle</code>项目造成了不少的困难。</p>
<p>基于此出发点，本文提供了两种形式的使用<code>Gradle</code>构建的<code>Spring Boot</code>多模块项目：</p>
<ul>
<li><code>Java + Gradle</code></li>
<li><code>Kotlin + Gradle + Kotlin DSL</code></li>
</ul>
<p>为了减少出现各种错误的概率，步骤做得非常详细（多图预警），文末也附上了源码，下面就一起来看看吧。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li><code>Gradle 6.8.2</code></li>
<li><code>Spring Boot 2.4.3</code></li>
<li><code>Kotlin 1.4.30</code></li>
<li><code>Open JDK 11</code></li>
</ul>
<h1 id="3-java-gradle">3 <code>Java + Gradle</code></h1>
<p>主要步骤：</p>
<ul>
<li>使用<code>Spring Initializer</code>创建项目</li>
<li>修改<code>build.gradle</code></li>
<li>创建模块</li>
<li>编写模块</li>
<li>运行</li>
<li>测试</li>
</ul>
<h2 id="31-创建项目">3.1 创建项目</h2>
<p>直接使用<code>IDEA</code>提供的<code>Spring Initializer</code>即可，构建工具选择<code>Gradle</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210302182258479.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>依赖：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210302203252834.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>构建完成后删除<code>src</code>目录</strong>，因为根目录属于管理模块目录不提供运行的应用：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210302182628108.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-修改buildgradle">3.2 修改<code>build.gradle</code></h2>
<p>这是最复杂的一步，并且<code>Gradle</code>版本更新的话步骤可能会不一样，<strong>首先在底部添加一个空的<code>subprojects</code></strong>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2021030218292823.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着<strong>把<code>dependencies</code>以及<code>test</code>移动进去</strong>：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210302183050141.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后一步是，<strong>在<code>subprojects</code>开头，添加插件<code>apply</code>，根据默认初始化创建的<code>plugins</code>，逐一添加</strong>。</p>
<p>比如这里默认使用了三个插件：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210302183301588.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><code>apply</code>到<code>subprojects</code>中：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210302183725544.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-创建模块">3.3 创建模块</h2>
<p><code>File -&gt; New -&gt; Module</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210302183544698.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>输入模块名即可，这里的例子是创建两个模块：</p>
<ul>
<li><strong><code>service</code></strong></li>
<li><strong><code>app</code></strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2021030218391243.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20210302183958660.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>创建好后如图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/2021030218410737.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>完成创建之后，<strong>把两个模块中的<code>build.gradle</code>除了<code>repositories</code>之外的全部删去</strong>，仅保留<code>repositories</code>：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20210302184254983.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20210302184353774.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="34-编写模块">3.4 编写模块</h2>
<h3 id="341-service模块">3.4.1 <code>service</code>模块</h3>
<p>首先<strong>创建包</strong>，根据根目录中的<code>group</code>创建：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20210302184845857.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20210302184922482.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着编写一个叫<code>TestService</code>的带<code>@Service</code>注解的类，里面包含一个<code>test</code>方法：</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20210302185028647.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同时修改<code>service</code>模块的<code>build.gradle</code>，<strong>添加<code>bootJar</code>以及<code>jar</code>选项</strong>：</p>
<pre><code class="language-bash">bootJar{
    enabled = false
}

jar{
    enabled = true
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20210302184713211.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="342-app模块">3.4.2 <code>app</code>模块</h3>
<p>同样先根据根目录的<code>group</code><strong>创建包</strong>：</p>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20210302185147370.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>接着在<code>app</code>模块的<code>build.gradle</code><strong>添加<code>service</code>模块的依赖</strong>：</p>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20210302185447644.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建启动类以及一个<code>Controller</code>：</p>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/20210302185526487.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-java">package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class,args);
    }
}
</code></pre>
<pre><code class="language-java">package com.example.controller;

import com.example.service.TestService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class TestController {
    private final TestService service;
    @GetMapping(&quot;/test&quot;)
    public String test(){
        return service.test();
    }
}
</code></pre>
<h2 id="35-运行">3.5 运行</h2>
<p>接下来就可以运行了，可以直接点击<code>Application</code>旁边的绿色小三角：</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/2021030218570925.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>或者从运行配置中选择<code>Application</code>运行（<code>IDEA</code>自动创建的，原来的那个<code>DemoApplication</code>带一个×是因为启动文件已经删除了，可以顺便把该配置删除）：</p>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20210302185745193.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>没问题的话就可以成功运行了：</p>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/20210302185917750.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同时浏览器访问<code>localhost:8080/test</code>会出现<code>test</code>字样：</p>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/20210302190006675.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="36-测试">3.6 测试</h2>
<p>在创建测试类之前，也需要<strong>先创建包，且需要确保包名与启动类的包名一致</strong>：</p>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/20210302202906337.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建测试类：</p>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/20210302203102853.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-java">package com.example;

import com.example.service.TestService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class JavaTest {
    @Autowired
    private TestService service;
    @Test
    public void test(){
        System.out.println(service.test());
    }
}
</code></pre>
<p>接着进行测试：</p>
<figure data-type="image" tabindex="27"><img src="https://img-blog.csdnimg.cn/20210302203048671.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样使用<code>Java</code>+<code>Gradle</code>构建一个多模块的<code>Spring Boot</code>项目就成功了。</p>
<h1 id="4-kotlin-gradle-kotlin-dsl">4 <code>Kotlin + Gradle + Kotlin DSL</code></h1>
<p><code>Kotlin DSL</code>在原生<code>Gradle</code>（<code>Groovy DSL</code>）的基础上进行改进，但同时语法也变得更加陌生，难度因此也加大了不少，不过这并没有难倒笔者。构建多模块的基本步骤与上面类似：</p>
<ul>
<li>使用<code>Spring Initializer</code>创建项目</li>
<li>修改<code>build.gradle.kts</code></li>
<li>创建模块</li>
<li>编写模块</li>
<li>运行</li>
<li>测试</li>
</ul>
<h2 id="41-创建项目">4.1 创建项目</h2>
<p>选择<code>Kotlin</code>+<code>Gradle</code>：</p>
<figure data-type="image" tabindex="28"><img src="https://img-blog.csdnimg.cn/20210302191228379.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>依赖：</p>
<figure data-type="image" tabindex="29"><img src="https://img-blog.csdnimg.cn/20210302191254471.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样<strong>删除<code>src</code></strong>：</p>
<figure data-type="image" tabindex="30"><img src="https://img-blog.csdnimg.cn/20210302194145804.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="42-修改buildgradlekts">4.2 修改<code>build.gradle.kts</code></h2>
<p>同样在尾部<strong>添加一个空的<code>subprojects</code></strong>：</p>
<figure data-type="image" tabindex="31"><img src="https://img-blog.csdnimg.cn/20210302191442159.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>把<code>dependencies</code>以及<code>tasks</code>移动进去</strong>：</p>
<figure data-type="image" tabindex="32"><img src="https://img-blog.csdnimg.cn/20210302191518343.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://img-blog.csdnimg.cn/20210302191614874.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后<strong>在<code>subprojects</code>开始处<code>apply</code>插件</strong>，<strong>根据默认的插件进行<code>apply</code></strong>：</p>
<figure data-type="image" tabindex="34"><img src="https://img-blog.csdnimg.cn/20210302194246705.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-bash">apply{
    plugin(&quot;io.spring.dependency-management&quot;)
    plugin(&quot;org.springframework.boot&quot;)
    plugin(&quot;org.jetbrains.kotlin.plugin.spring&quot;)
    plugin(&quot;org.jetbrains.kotlin.jvm&quot;)
}
</code></pre>
<p><strong><code>plugins</code>中的<code>kotlin</code>是<code>org.jetbrains.kotlin</code>的简写</strong>，在<code>subprjects</code>中注意加上即可。</p>
<h2 id="43-创建模块">4.3 创建模块</h2>
<p><code>File -&gt; New -&gt; Module</code>，把一些必要选项勾选上：</p>
<figure data-type="image" tabindex="35"><img src="https://img-blog.csdnimg.cn/20210302194457119.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这里同样创建两个模块：</p>
<ul>
<li><code>app</code></li>
<li><code>service</code></li>
</ul>
<figure data-type="image" tabindex="36"><img src="https://img-blog.csdnimg.cn/2021030219454215.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://img-blog.csdnimg.cn/20210302194600752.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样把两个模块中的**<code>build.gradle.kts</code>删除其他部分留下<code>repositories</code>**：</p>
<figure data-type="image" tabindex="38"><img src="https://img-blog.csdnimg.cn/2021030219473681.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-编写模块">4.4 编写模块</h2>
<h3 id="441-service模块">4.4.1 <code>service</code>模块</h3>
<p>首先根据根目录的<code>build.gradle.kts</code><strong>创建包</strong>：</p>
<figure data-type="image" tabindex="39"><img src="https://img-blog.csdnimg.cn/2021030219485442.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://img-blog.csdnimg.cn/20210302194928711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>编写<code>TestService</code>：</p>
<figure data-type="image" tabindex="41"><img src="https://img-blog.csdnimg.cn/20210302195018197.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最后修改<code>build.gradle.kts</code>，<strong>加上<code>tasks.bootJar</code>与<code>tasks.jar</code></strong>：</p>
<pre><code class="language-bash">tasks.bootJar{
    enabled = false
}

tasks.jar{
    enabled = true
}
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://img-blog.csdnimg.cn/20210302195205578.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="442-app模块">4.4.2 <code>app</code>模块</h3>
<p>先<strong>创建包</strong>：</p>
<figure data-type="image" tabindex="43"><img src="https://img-blog.csdnimg.cn/20210302195304362.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>添加对<code>service</code>模块的依赖</strong>：</p>
<figure data-type="image" tabindex="44"><img src="https://img-blog.csdnimg.cn/20210302195354683.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建一个启动类以及一个<code>Controller</code>：</p>
<figure data-type="image" tabindex="45"><img src="https://img-blog.csdnimg.cn/20210302195607272.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-kotlin">package com.example

import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication

@SpringBootApplication
class Application

fun main(args:Array&lt;String&gt;) {
    SpringApplication.run(Application::class.java,*args)
}
</code></pre>
<pre><code class="language-kotlin">package com.example.controller

import com.example.service.TestService
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class TestController {
    @Autowired
    lateinit var service: TestService
    @GetMapping(&quot;/test&quot;)
    fun test() = service.test()
}
</code></pre>
<h2 id="45-运行">4.5 运行</h2>
<p>点击<code>main</code>旁边的绿色小三角即可：</p>
<figure data-type="image" tabindex="46"><img src="https://img-blog.csdnimg.cn/20210302195715732.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>运行成功：</p>
<figure data-type="image" tabindex="47"><img src="https://img-blog.csdnimg.cn/2021030219575668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>同样可以访问<code>localhost:8080/test</code>：</p>
<figure data-type="image" tabindex="48"><img src="https://img-blog.csdnimg.cn/20210302195852323.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="46-测试">4.6 测试</h2>
<p>注意在编写测试之前需要保证测试类与启动类在同一个包下，也就是需要<strong>先创建包</strong>：</p>
<figure data-type="image" tabindex="49"><img src="https://img-blog.csdnimg.cn/20210302201002664.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再创建测试类：</p>
<figure data-type="image" tabindex="50"><img src="https://img-blog.csdnimg.cn/20210302201052939.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-kotlin">package com.example

import com.example.service.TestService
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest

@SpringBootTest
class KotlinTest {
    @Autowired
    lateinit var service: TestService
    @Test
    fun test(){
        println(service.test())
    }
}
</code></pre>
<p>直接点击小三角测试即可：</p>
<figure data-type="image" tabindex="51"><img src="https://img-blog.csdnimg.cn/20210302201159661.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>测试通过，这样<code>Kotlin+Gradle+Kotlin DSL</code>的多模块<code>Spring Boot</code>项目就算创建完成了。</p>
<h1 id="5-总结">5 总结</h1>
<p>笔者在实践的过程中也遇到了无数的错误，比如找不到类，或者<code>build.gradle</code>/<code>build.gradle.kts</code>文件错误，幸好有万能的搜索引擎，帮笔者解决了错误，最后才成功写下这篇文章。</p>
<p>总的来说，<code>Gradle</code>创建多模块项目要比<code>Maven</code>要难，而且<code>Gradle</code>的更新速度很快，语法变化较大，相比之下<code>Maven</code>非常稳定，最新的<code>Maven 3.6.3</code>还是19年11月发布的，然而<code>Gradle</code>都准备<code>7.0</code>了：</p>
<figure data-type="image" tabindex="52"><img src="https://img-blog.csdnimg.cn/20210302201723618.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="53"><img src="https://img-blog.csdnimg.cn/20210302201753711.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>笔者建议，如果是真的需要使用<code>Gradle</code>，需要考虑一下团队的状况，毕竟上手难度要大于<code>Maven</code>，如果在<code>Gradle</code>创建多模块的过程中遇到一些极其难以解决的问题，转为<code>Maven</code>不失为一个好办法。</p>
<h1 id="6-源码">6 源码</h1>
<p>附上两个例子的源码：</p>
<ul>
<li><a href="https://github.com/2293736867/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/JavaAndKotlinMultiModulesGradleSpringBootProjectDemo">CODE CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（一）：JVM初探]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-yi-jvm-chu-tan/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-yi-jvm-chu-tan/">
        </link>
        <updated>2021-03-02T05:20:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第一章</li>
</ul>
<p>本文是第一章的一些笔记整理。</p>
<h1 id="2-java里程碑">2 <code>Java</code>里程碑</h1>
<h2 id="21-java起源">2.1 <code>Java</code>起源</h2>
<p>1990年<code>Sun</code>公司决定开发一门新的程序语言——<code>Oak</code>，已经具备安全性、网络通信、面向对象、垃圾回收、多线程等特性，由于<code>Oak</code>已被注册，于是改名为<code>Java</code>。</p>
<h2 id="22-jdk-10">2.2 <code>JDK 1.0</code></h2>
<p>1995年<code>Sun</code>发布了<code>Java</code>以及<code>HotJava</code>产品，1996年正式发布<code>JDK 1.0</code>，包括两部分：</p>
<ul>
<li>运行环境：<code>JRE</code>，包括核心<code>API</code>，用户界面<code>API</code>，发布技术、<code>JVM</code>等</li>
<li>开发环境：<code>JDK</code>，包括编译器<code>javac</code>等</li>
</ul>
<p>1997年发布<code>JDK1.1</code>。</p>
<h2 id="23-jdk-12-17">2.3 <code>JDK 1.2-1.7</code></h2>
<p>1998年发布<code>JDK 1.2</code>，<code>JDK1.2</code>兼容智能卡和小型消费类设备，还兼容大型服务器系统。同时<code>Sun</code>发布<code>JSP/Servlet</code>+<code>EJB</code>规范，将<code>Java</code>分成了<code>J2EE</code>、<code>J2SE</code>、<code>J2ME</code>。</p>
<p>2000年发布<code>JDK 1.3</code>，默认虚拟机改为<code>Hotspot</code>。</p>
<p>2002年发布<code>JDK1.4</code>，<code>Classic</code>虚拟机退出舞台。</p>
<p>2004年发布<code>JDK 1.5</code>，支持泛型、注解、自动装箱拆箱、枚举、可变长参数等。</p>
<p>2006年发布<code>JDK 1.6</code>，<code>Java</code>开源并建立了<code>OpenJDK</code>。</p>
<p>2011年发布<code>JDK 1.7</code>，启用了<code>G1</code>垃圾回收器，支持64位系统的压缩指针以及<code>NIO 2.0</code>。</p>
<h2 id="24-jdk-18">2.4 <code>JDK 1.8+</code></h2>
<p>2014年发布<code>JDK 1.8</code>，<code>JDK 1.8</code>是一个<code>LTS</code>版，到目前还支持，引入了全新的<code>Lambda</code>。</p>
<p>2017年发布<code>JDK 9</code>。</p>
<p>2018年发布<code>JDK 10</code>。</p>
<p>2018年发布<code>JDK 11</code>，又一个<code>LTS</code>版，引入了字符串增强、<code>Epsilon</code>垃圾收集器、<code>ZGC</code>等。</p>
<h1 id="3-jvm种类简介">3 <code>JVM</code>种类简介</h1>
<p><code>Java</code>发展初期，使用的是<code>Classic</code>虚拟机，之后在<code>Solaris</code>短暂地使用过<code>Exact VM</code>虚拟机，到现在被大规模部署和使用的是<code>Hotspot</code>虚拟机。</p>
<p>另外，在<code>IBM</code>内部使用着一款叫<code>J9</code>的虚拟机，<code>Apache</code>也曾经推出过<code>Apache Harmony</code>，基于<code>JDK 5</code>以及<code>JDK 6</code>，于2011年停止开发。</p>
<h1 id="4-jvm简单编译调试实战">4 <code>JVM</code>简单编译调试实战</h1>
<p>下面以<code>OpenJDK15</code>为例，对<code>OpenJDK 15 JVM</code>进行源码编译。</p>
<p>（注：由于笔者系统为<code>Manjaro</code>，这是一个滚更的系统，很多工具链都会更新到最新的状态，比如<code>GCC 10.2</code>，书籍中的例子是利用<code>JDK8</code>去编译<code>JDK10</code>，实际测试发现会报错，<code>configure</code>成功了但是<code>make</code>失败，然后就切换到最新的<code>JDK</code>，就编译成功了。对于不是滚更的系统，可以使用<code>JDK10</code>去编译<code>JDK11</code>等，而非采用目前最新的<code>JDK15</code>）</p>
<h2 id="41-获取源码bootjdk">4.1 获取源码+<code>BootJDK</code></h2>
<p>戳<a href="https://jdk.java.net/java-se-ri/15">这里</a>下载：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210301194640139.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以使用如下命令检测下载文件的完整性：</p>
<pre><code class="language-bash">echo &quot;bb67cadee687d7b486583d03c9850342afea4593be4f436044d785fba9508fb7 openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
echo &quot;d07bf62b4b20fa6bcd4c8fcd635e5df20b7c090af291675b2bd99f8cea8760a0 openjdk-15+36_src.zip&quot; | sha256sum --check
</code></pre>
<p>另外需要准备一个<code>BootJDK</code>，根据<code>BootJDK</code>的规则：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210301185154595.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>建议使用<code>当前版本号</code>/<code>版本号-1</code>/<code>版本号-2</code>的<code>JDK</code>，这里选用的是<code>OpenJDK 15</code>。</p>
<h2 id="42-安装依赖库">4.2 安装依赖库</h2>
<p>笔者系统<code>Manajro</code>，需要安装一些基础依赖：</p>
<pre><code class="language-bash">paru -S base-devel
# 或
pacman -S base-devel
# 或
yay -S base-devel
</code></pre>
<p>如果依赖库安装不完整在配置阶段以及编译阶段会给出相应提示，再进行对应依赖安装即可。</p>
<h2 id="43-编译">4.3 编译</h2>
<p>解压源码进入目录：</p>
<pre><code class="language-bash">unzip openjdk-15+36_src.zip
tar -zxvf openjdk-15+36_linux-x64_bin.tar.gz
cd openjdk
</code></pre>
<p>配置：</p>
<pre><code class="language-bash">bash configure --with-debug-level=slowdebug --with-jvm-variants=server --with-target-bits=64 --with-memory-size=8000 --disable-warnings-as-errors --with-native-debug-symbols=internal --with-boot-jdk=../jdk-15
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>--with-debug-level=slowdebug</code>：编译<code>DEBUG</code>版本的<code>JDK</code>，选项可以是<code>slowdebug</code>/<code>fastdebug</code>/<code>release</code>/<code>optimized</code></li>
<li><code>--with-jvm-variants=server</code>：构建<code>server</code>变体的<code>Hotspot</code>，选项可以是<code>server</code>/<code>client</code>/<code>minimal</code>/<code>core</code>/<code>zero</code>/<code>custom</code></li>
<li><code>--with-target-bits=64</code>：编译64位的<code>JDK</code>，编译32位可以使用<code>--with-target-bits=32</code></li>
<li><code>--with-memory-size=8000</code>：编译的计算机至少需要8G内存，这个可以根据个人需要调整</li>
<li><code>--disable-warnings-as-errors</code>：忽略警告的信息，注意该参数很重要，不加的话会显示配置成功但<code>make</code>失败</li>
<li><code>--with-native-debug-symbols=internal</code>：生成<code>symbol</code>文件，便于后续调试，选项可以是<code>internal</code>/<code>none</code>/<code>external</code>/<code>zipped</code></li>
<li><code>--with-boot-jdk</code>：<code>BootJDK</code>的目录</li>
</ul>
<p>结果：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210301221634945.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>配置后进行编译：</p>
<pre><code class="language-bash">make images
</code></pre>
<p>这个阶段需要一点时间，而且会把<code>CPU</code>拉满，好了之后会提示<code>Finished building</code>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210301221606736.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>笔者环境下编译出来的<code>JDK</code>占了3G：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210301224350705.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>进入对应目录可以查看版本：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210301224537520.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="44-调试">4.4 调试</h2>
<p>调试需要<code>gdb</code>，先安装好<code>gdb</code>：</p>
<pre><code class="language-bash">paru -S gdb
</code></pre>
<p>进入<code>bin</code>目录（<code>build/linux-x86_64-server-slowdebug/jdk/bin</code>），输入：</p>
<pre><code class="language-bash">gdb -args ./java -version
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210302103935814.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在<code>main</code>函数打断点：</p>
<pre><code class="language-bash">(gdb) b main
</code></pre>
<p>再执行<code>run</code>，可以看到会停在<code>java.base/share/native/launcher/main.c</code>第98行：</p>
<pre><code class="language-bash">(gdb) run
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210302104117877.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>再次输入<code>n</code>可进行单步调试：</p>
<pre><code class="language-bash">(gdb) n
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20210302104249857.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样就算完成了基础的调试操作，为进一步学习<code>JVM</code>准备好基本的环境。</p>
<h2 id="45-jvm下载">4.5 <code>JVM</code>下载</h2>
<p>如果编译失败的话，笔者这里提供了自己编译出来的<code>JVM</code>：</p>
<ul>
<li><a href="https://github.com/2293736867/OpenJDK15FromSourceCode">Github</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SHA256sum系列命令检测文件完整性]]></title>
        <id>https://2293736867.github.io/post/sha256sum-xi-lie-ming-ling-jian-ce-wen-jian-wan-zheng-xing/</id>
        <link href="https://2293736867.github.io/post/sha256sum-xi-lie-ming-ling-jian-ce-wen-jian-wan-zheng-xing/">
        </link>
        <updated>2021-03-02T03:15:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-sha256sum">1 <code>sha256sum</code></h1>
<p><code>sha256sum</code>是一个检测文件完整性的命令，一般下载的文件都会附带一个哈希值，使用<code>sha256sum</code>计算下载文件的哈希值再与目标哈希值比较即可确定文件是否完整，类似的命令还有：</p>
<ul>
<li><code>md5sum</code></li>
<li><code>sha1sum</code></li>
<li><code>sha224sum</code></li>
<li><code>sha384sum</code></li>
<li><code>sha512sum</code></li>
</ul>
<h1 id="2-安装">2 安装</h1>
<p>该系列命令在一个叫<code>coreutils</code>的包内，一般<code>Linux</code>都会安装，没有的话可以从软件包仓库安装，以笔者系统<code>Manjaro</code>为例：</p>
<pre><code class="language-bash">paru -S coreutils
</code></pre>
<p>另外目前最新的<code>SHA</code>算法为<code>SHA3</code>，需要使用<code>SHA3</code>的话可以安装<code>sha3sum</code>：</p>
<pre><code class="language-bash">paru -S sha3sum
</code></pre>
<h1 id="3-使用">3 使用</h1>
<p>使用很简单，命令后面直接加上对应的文件，即可计算哈希值，以<a href="https://jdk.java.net/java-se-ri/15">OpenJDK</a>为例：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210301221955176.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>文件旁边有一个<code>sha256</code>的值，先把文件下载，使用<code>sha256sum</code>计算：</p>
<pre><code class="language-bash">sha256sum openjdk-15+36_linux-x64_bin.tar.gz
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210301222200204.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>然后下一步就是比较给出的<code>sha256</code>，没理由手动一个一个比较吧？</p>
<p>可以直接使用下面的命令去比较：</p>
<pre><code class="language-bash">echo &quot;bb67cadee687d7b486583d03c9850342afea4593be4f436044d785fba9508fb7 openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210301222615349.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>格式为：</p>
<pre><code class="language-bash">echo &quot;sha256哈希值 文件名&quot; | sha256sum --check
</code></pre>
<p>如果不匹配，会显示<code>checksum did NOT match</code>：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210301222726136.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如果哈希值存在于文件中，可以使用下面的命令：</p>
<pre><code class="language-bash">echo &quot;$(cat 哈希值文件名) 待比较的文件&quot; | sha256sum --check
</code></pre>
<p>比如：</p>
<pre><code class="language-bash">echo &quot;$(cat sha256) openjdk-15+36_linux-x64_bin.tar.gz&quot; | sha256sum --check
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第260期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-260-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-260-qi/">
        </link>
        <updated>2021-03-01T03:42:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>没有什么事情能把人一次击倒，只要足够坚强，它会持续的把你击倒！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>料想春光先到处，吹绽梅英。<br>
——苏轼《浪淘沙·探春》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>再凶的男孩子，绑鞋带还不是要系蝴蝶结。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第259期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-259-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-259-qi/">
        </link>
        <updated>2021-02-28T10:07:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>马云成功跟长相没关系，姜尚成功跟年龄没关系，而成功跟你没关系。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>日暮苍山远，天寒白屋贫。<br>
——刘长卿《逢雪宿芙蓉山主人》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>正因为不会发生，人们才称它为“奇迹”。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第258期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-258-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-258-qi/">
        </link>
        <updated>2021-02-27T01:46:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>有些事，不说是个结，说了是个疤。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>把酒祝东风，且共从容。<br>
——欧阳修《浪淘沙·把酒祝东风》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不管什么时候，能够改变世界的人都是一心追逐梦想的人。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第257期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-257-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-257-qi/">
        </link>
        <updated>2021-02-26T10:51:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>这个年级会在你耳边唱歌的，喜欢你的肉体还会送你包的，只剩下蚊子了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>似此星辰非昨夜，为谁风露立中宵。<br>
——黄景仁《绮怀》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>一本书上每多一个公式，就会减少一半读者。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第256期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-256-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-256-qi/">
        </link>
        <updated>2021-02-25T10:48:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>知识给你力量，无知会给你更强大无畏，且无法预测的力量。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>梨花院落溶溶月，柳絮池塘淡淡风。<br>
——晏殊《无题·油壁香车不在逢》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>因为我喜欢你，喜欢得想吃掉你啊！</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot demo系列（十）：Redis缓存]]></title>
        <id>https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-redis-huan-cun/</id>
        <link href="https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-redis-huan-cun/">
        </link>
        <updated>2021-02-24T05:35:47.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-redis%E5%AE%89%E8%A3%85">3 <code>Redis</code>安装</a></li>
<li><a href="#4-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">4 新建项目</a></li>
<li><a href="#5-%E9%85%8D%E7%BD%AE%E7%B1%BB">5 配置类</a></li>
<li><a href="#6-%E5%AE%9E%E4%BD%93%E7%B1%BB">6 实体类</a></li>
<li><a href="#7-%E6%8C%81%E4%B9%85%E5%B1%82">7 持久层</a></li>
<li><a href="#8-%E4%B8%9A%E5%8A%A1%E5%B1%82">8 业务层</a></li>
<li><a href="#9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">9 配置文件</a></li>
<li><a href="#10-%E5%90%AF%E5%8A%A8redis">10 启动<code>Redis</code></a>
<ul>
<li><a href="#101-%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1%E5%99%A8">10.1 启动<code>Redis</code>服务器</a></li>
<li><a href="#102-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8">10.2 连接服务器</a></li>
</ul>
</li>
<li><a href="#11-%E6%B5%8B%E8%AF%95">11 测试</a></li>
<li><a href="#12-%E9%99%84%E5%BD%95kotlin%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82">12 附录：<code>Kotlin</code>中的一些细节</a>
<ul>
<li><a href="#121-string%E6%95%B0%E7%BB%84">12.1 <code>String</code>数组</a></li>
<li><a href="#122-class">12.2 <code>@class</code></a>
<ul>
<li><a href="#1221-%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0class">12.2.1 手动添加<code>@class</code></a></li>
<li><a href="#1222-%E5%B0%86%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%AE%BE%E7%BD%AE%E4%B8%BAopen">12.2.2 将实体类设置为<code>open</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-%E5%8F%82%E8%80%83%E6%BA%90%E7%A0%81">13 参考源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>本文演示了如何在<code>Spring Boot</code>中将<code>Redis</code>作为缓存使用，具体的内容包括：</p>
<ul>
<li>环境搭建</li>
<li>项目搭建</li>
<li>测试</li>
</ul>
<h1 id="2-环境">2 环境</h1>
<ul>
<li><code>Redis</code></li>
<li><code>MySQL</code></li>
<li><code>MyBatis Plus</code></li>
</ul>
<h1 id="3-redis安装">3 <code>Redis</code>安装</h1>
<p><code>Redis</code>安装非常简单，以笔者的<code>Manjaro</code>为例，直接<code>paru</code>安装：</p>
<pre><code class="language-bash">paru -S redis
</code></pre>
<p><code>Ubuntu</code>、<code>CentOS</code>之类的都提供了软件包安装：</p>
<pre><code class="language-bash">sudo apt install redis
sudo yum install redis
</code></pre>
<p>如果想从源码编译安装：</p>
<pre><code class="language-bash">wget http://download.redis.io/redis-stable.tar.gz
tar xvzf redis-stable.tar.gz
cd redis-stable
make
</code></pre>
<p><code>Windows</code>以及其他系统的安装可以参考<a href="https://www.redis.net.cn/tutorial/3503.html">此处</a>。</p>
<h1 id="4-新建项目">4 新建项目</h1>
<p>新建项目，加入如下依赖：</p>
<p><code>Maven</code>：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>：</p>
<pre><code class="language-bash">implementation(&quot;com.baomidou:mybatis-plus-boot-starter:3.4.2&quot;)
implementation(&quot;mysql:mysql-connector-java:8.0.23&quot;)
</code></pre>
<p>项目结构：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210223194201507.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-配置类">5 配置类</h1>
<p><code>MyBatis Plus</code>+<code>Redis</code>配置类：</p>
<pre><code class="language-java">@Configuration
@MapperScan(&quot;com.example.demo.dao&quot;)
public class MyBatisPlusConfig {
}
</code></pre>
<pre><code class="language-java">@Configuration
@AutoConfigureAfter(RedisAutoConfiguration.class)
@EnableCaching
public class RedisConfig {
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setConnectionFactory(factory);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration configuration = RedisCacheConfiguration.defaultCacheConfig()
        .serializeKeysWith(
            RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())
        ).serializeValuesWith(
            RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())
        );
        return RedisCacheManager.builder(factory).cacheDefaults(configuration).build();
    }
}
</code></pre>
<p>重点说一下<code>Redis</code>配置类，这个类主要生成两个<code>Bean</code>：</p>
<ul>
<li><code>RedisTemplate</code>：简化<code>Redis</code>操作的数据访问类</li>
<li><code>CacheManager</code>：<code>Spring</code>的中央缓存管理器</li>
</ul>
<p>其中<code>RedisTemplate</code>是一个模板类，第一个参数的类型是该<code>template</code>使用的键的类型，通常是<code>String</code>，第二个参数的类型是该<code>template</code>使用的值的类型，通常为<code>Object</code>或<code>Seriazable</code>。</p>
<p><code>setKeySerializer</code>和<code>setValueSerializer</code>分别设置键值的序列化器。键一般为<code>String</code>类型，可以使用自带的<code>StringRedisSerializer</code>。对于值，可以使用自带的<code>GenericJackson2RedisSerializer</code>。</p>
<p><code>CacheManager</code>的配置类似，就不重新说了。</p>
<h1 id="6-实体类">6 实体类</h1>
<pre><code class="language-java">@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String name;
}
</code></pre>
<h1 id="7-持久层">7 持久层</h1>
<pre><code class="language-java">public interface UserMapper extends BaseMapper&lt;User&gt; {
}
</code></pre>
<h1 id="8-业务层">8 业务层</h1>
<pre><code class="language-java">@org.springframework.stereotype.Service
@Transactional
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class Service {
    private final UserMapper mapper;

    @CachePut(value = &quot;user&quot;,key = &quot;#user.id&quot;)
    public User save(User user){
        User oldUser = mapper.selectById(user.getId());
        if(oldUser == null){
            mapper.insert(user);
            return user;
        }
        if(mapper.updateById(user) == 1)
            return user;
        return oldUser;
    }

    @CacheEvict(value = &quot;user&quot;,key = &quot;#id&quot;)
    public boolean delete(Integer id){
        return mapper.deleteById(id) == 1;
    }

    @Cacheable(value = &quot;user&quot;,key = &quot;#id&quot;)
    public User select(Integer id){
        return mapper.selectById(id);
    }

    @Cacheable(value=&quot;allUser&quot;,key = &quot;#root.target+#root.methodName&quot;)
    //root.target是目标类，这里是com.example.demo.Service，root.methodName是方法名，这里是selectAll
    public List&lt;User&gt; selectAll(){
        return mapper.selectList(null);
    }
}
</code></pre>
<p>注解说明如下：</p>
<ul>
<li><code>@CachePut</code>：执行方法体再将返回值缓存，一般用于更新数据</li>
<li><code>@CacheEvict</code>：删除缓存，一般用于删除数据</li>
<li><code>@Cacheable</code>：查询缓存，如果有缓存就直接返回，没有缓存的话执行方法体并将返回值存入缓存，一般用于查询数据</li>
</ul>
<p>三个注解都涉及到了<code>key</code>以及<code>value</code>属性，实际上，真正的存入<code>Redis</code>的<code>key</code>是两者的组合，比如：</p>
<pre><code class="language-java">@Cacheable(value=&quot;user&quot;,key=&quot;#id&quot;)
</code></pre>
<p>则存入的<code>Redis</code>中的<code>key</code>为：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210223210929435.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而存入对应的值为方法返回值序列化后的结果，比如如果返回值为<code>User</code>，则会被序列化为：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/202102240035293.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="9-配置文件">9 配置文件</h1>
<pre><code class="language-yml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
logging:
  level:
    com.example.demo: debug
</code></pre>
<p><code>spring.redis.database</code>指定数据库的索引，默认为0，<code>host</code>与<code>port</code>分别指定主机（默认本地）以及端口（默认<code>6379</code>）。</p>
<p>也就是说，简单配置的话可以完全省略<code>Redis</code>相关配置，仅指定数据库连接<code>url</code>、用户名以及密码：</p>
<pre><code class="language-yml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456
logging:
  level:
    com.example.demo: debug
</code></pre>
<h1 id="10-启动redis">10 启动<code>Redis</code></h1>
<h2 id="101-启动redis服务器">10.1 启动<code>Redis</code>服务器</h2>
<p><code>Redis</code>服务器启动需要一个配置文件，默认位置为<code>/etc/redis.conf</code>（源码编译安装的话在源文件夹内），建议先复制一份：</p>
<pre><code class="language-bash">cp /etc/redis.conf ~/Desktop/
</code></pre>
<p>默认的配置文件为单机<code>Redis</code>配置，端口<code>6379</code>，<code>redis-server</code>可以直接运行：</p>
<pre><code class="language-bash">sudo redis-server redis.conf
</code></pre>
<h2 id="102-连接服务器">10.2 连接服务器</h2>
<p>连接可以通过自带的<code>redis-cli</code>命令：</p>
<pre><code class="language-bash">redis-cli -h localhost -p 6379
</code></pre>
<p>默认情况下可以直接使用</p>
<pre><code class="language-bash">redis-cli
</code></pre>
<p>连接。</p>
<p>基本操作：</p>
<ul>
<li><code>keys *</code>：查询所有键</li>
<li><code>get key</code>：查询<code>key</code>所对应的值</li>
<li><code>flushall</code>：清空所有键</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210224002836614.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="11-测试">11 测试</h1>
<pre><code class="language-java">@SpringBootTest
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
class DemoApplicationTests {

    private final Service service;

    @Test
    void select() {
        service.select(1);
        service.select(1);
    }

    @Test
    void selectAll(){
        service.selectAll();
        service.selectAll();
    }

    @Test
    void delete(){
        service.delete(1);
    }

    @Test
    void save(){
        User user = new User(1,&quot;name1&quot;);
        service.save(user);
        service.select(user.getId());
        user.setName(&quot;name2&quot;);
        service.save(user);
        service.select(user.getId());
    }
}
</code></pre>
<p>执行其中的<code>select</code>，会发现<code>MyBatis Plus</code>只有一次<code>select</code>的输出，证明缓存生效了：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210223211341949.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而把缓存注解去掉后，会有两次<code>select</code>输出：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210223211541773.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其它测试方法就不截图了，原理类似。</p>
<h1 id="12-附录kotlin中的一些细节">12 附录：<code>Kotlin</code>中的一些细节</h1>
<h2 id="121-string数组">12.1 <code>String</code>数组</h2>
<p>其实<code>@Cacheable</code>/<code>@CacheEvict</code>/<code>@CachePut</code>中的<code>value</code>都是<code>String []</code>，在<code>Java</code>中可以直接写上<code>value</code>，在<code>Kotlin</code>中需要<code>[value]</code>。</p>
<h2 id="122-class">12.2 <code>@class</code></h2>
<p>序列化到<code>Redis</code>时，实体类会被加上一个<code>@class</code>字段：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/202102240035293.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这个标识供<code>Jackson</code>反序列化时使用，笔者一开始的实体类实现是：</p>
<pre><code class="language-kotlin">data class User(var id:Int?=null, var name:String=&quot;&quot;)
</code></pre>
<p>但是序列化后不携带<code>@class</code>字段：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20210224011003732.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在反序列化时直接报错：</p>
<pre><code class="language-bash">Could not read JSON: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (byte[])&quot;{&quot;id&quot;:1,&quot;name&quot;:&quot;name2&quot;}&quot;; line: 1, column: 23]; nested exception is com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (byte[])&quot;{&quot;id&quot;:1,&quot;name&quot;:&quot;name2&quot;}&quot;; line: 1, column: 23]
</code></pre>
<p>解决方法有两个：</p>
<ul>
<li>手动添加<code>@class</code>字段</li>
<li>将实体类设为<code>open</code></li>
</ul>
<h3 id="1221-手动添加class">12.2.1 手动添加<code>@class</code></h3>
<p>准确来说并不是手动添加，而是让注解添加，需要添加一个类注解<code>@JsonTypeInfo</code>：</p>
<pre><code class="language-kotlin">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)
data class User(var id:Int?=null, var name:String=&quot;&quot;)
</code></pre>
<p>该注解的<code>use</code>用于指定类型标识码，该值只能为<code>JsonTypeInfo.Id.CLASS</code>。</p>
<h3 id="1222-将实体类设置为open">12.2.2 将实体类设置为<code>open</code></h3>
<p>在<code>Java</code>中，实体类没有任何额外配置，<code>Redis</code>序列化/反序列化一样没有问题，是因为值序列化器<code>GenericJackson2JsonRedisSerializer</code>，该类会自动添加一个<code>@class</code>字段，因此不会出现上面的问题。</p>
<p>但是在<code>Kotlin</code>中，类默认不是<code>open</code>的，也就是无法添加<code>@class</code>字段，因此便会反序列化失败，解决方案是将实体类设置为<code>open</code>：</p>
<pre><code class="language-kotlin">open class User(var id:Int?=null, var name:String=&quot;&quot;)
</code></pre>
<p>但是缺点是不能使用<code>data class</code>了。</p>
<h1 id="13-参考源码">13 参考源码</h1>
<p><code>Java</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoJava/tree/main/RedisCache">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoJava/tree/main/RedisCache">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoJava/-/tree/main/RedisCache">CODECHINA</a></li>
</ul>
<p><code>Kotlin</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoKotlin/tree/main/RedisCache">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoKotlin/tree/main/RedisCache">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoKotlin/-/tree/main/RedisCache">CODECHINA</a></li>
</ul>
]]></content>
    </entry>
</feed>