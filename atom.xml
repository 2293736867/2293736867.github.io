<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-06-07T03:51:44.159Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[残酷游戏]]></title>
        <id>https://2293736867.github.io/post/can-ku-you-xi/</id>
        <link href="https://2293736867.github.io/post/can-ku-you-xi/">
        </link>
        <updated>2020-06-07T03:20:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>其实自命受苦都只因我能离不离<br>
看着对你爱得仿似爱情欲避不避<br>
若能耗尽力气  去捕捉你<br>
亦能剩下自己可挽救自己<br>
我也知越是幻想不准想你更记得起<br>
我在故意去将苦涩替代寂寞滋味<br>
用残酷游戏  制造卑微<br>
自由自在莫非惨过永远受气</p>
</blockquote>
<p>摊牌，<br>
哦豁，<br>
GG。<br>
历史总是惊人的相似，<br>
现实总是太多的无奈。<br>
注孤生。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFX+SpringBoot+验证码功能的小型薪酬管理系统]]></title>
        <id>https://2293736867.github.io/post/javafxspringbootyan-zheng-ma-gong-neng-de-xiao-xing-xin-chou-guan-li-xi-tong/</id>
        <link href="https://2293736867.github.io/post/javafxspringbootyan-zheng-ma-gong-neng-de-xiao-xing-xin-chou-guan-li-xi-tong/">
        </link>
        <updated>2020-06-06T06:56:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E7%AE%80%E4%BB%8B">1.1 简介</a></li>
<li><a href="#12-%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B">1.2 响应流程</a></li>
<li><a href="#13-%E6%BC%94%E7%A4%BA">1.3 演示</a></li>
</ul>
</li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86">3 前端代码部分</a>
<ul>
<li><a href="#31-%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0">3.1 前端概述</a></li>
<li><a href="#32-%E6%A6%82%E8%A7%88">3.2 概览</a>
<ul>
<li><a href="#321-%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E6%A0%91">3.2.1. 代码目录树</a></li>
<li><a href="#322-%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E6%A0%91">3.2.2 资源目录树</a></li>
<li><a href="#323-%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96">3.2.3 项目依赖</a></li>
</ul>
</li>
<li><a href="#33-%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%9D%97">3.3 常量模块</a></li>
<li><a href="#34-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9D%97">3.4 控制器模块</a>
<ul>
<li><a href="#341-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%95%8C%E9%9D%A2">3.4.1 登录注册界面</a></li>
<li><a href="#342-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">3.4.2 用户界面</a></li>
</ul>
</li>
<li><a href="#35-%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%A8%A1%E5%9D%97">3.5 实体类模块</a></li>
<li><a href="#36-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">3.6  日志模块</a></li>
<li><a href="#37-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97">3.7 网络模块</a>
<ul>
<li><a href="#371-request%E5%8C%85">3.7.1 request包</a></li>
<li><a href="#372-requestbuilder%E5%8C%85">3.7.2 requestBuilder包</a></li>
<li><a href="#373-okhttp">3.7.3 OKHTTP</a></li>
<li><a href="#374-https">3.7.4 HTTPS</a>
<ul>
<li><a href="#3741-okhttp%E9%85%8D%E7%BD%AE">3.7.4.1 OkHttp配置</a></li>
<li><a href="#3742-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E8%AF%81%E4%B9%A6">3.7.4.2 服务器设置证书</a></li>
</ul>
</li>
<li><a href="#375-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86">3.7.5 图片处理</a></li>
</ul>
</li>
<li><a href="#38-%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%9D%97">3.8 动画模块</a></li>
<li><a href="#39-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%A8%A1%E5%9D%97">3.9 工具类模块</a>
<ul>
<li><a href="#391-conversion">3.9.1 Conversion</a></li>
<li><a href="#392-utils">3.9.2 Utils</a></li>
</ul>
</li>
<li><a href="#310-%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9D%97">3.10 视图模块</a></li>
</ul>
</li>
<li><a href="#4-%E5%89%8D%E7%AB%AFui%E9%83%A8%E5%88%86">4 前端UI部分</a>
<ul>
<li><a href="#41-fxml">4.1 fxml</a></li>
<li><a href="#42-css">4.2 css</a></li>
<li><a href="#43-stage%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">4.3 Stage构建过程</a></li>
</ul>
</li>
<li><a href="#5-%E5%90%8E%E7%AB%AF%E9%83%A8%E5%88%86">5 后端部分</a>
<ul>
<li><a href="#51-%E5%90%8E%E7%AB%AF%E6%A6%82%E8%BF%B0">5.1 后端概述</a></li>
<li><a href="#52-%E6%A6%82%E8%A7%88">5.2 概览</a>
<ul>
<li><a href="#521-%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E6%A0%91">5.2.1 代码目录树</a></li>
<li><a href="#522-%E4%BE%9D%E8%B5%96">5.2.2 依赖</a></li>
</ul>
</li>
<li><a href="#53-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B1%82">5.3 控制器层</a></li>
<li><a href="#54-%E4%B8%9A%E5%8A%A1%E5%B1%82%E4%B8%8E%E6%8C%81%E4%B9%85%E5%B1%82">5.4 业务层与持久层</a></li>
<li><a href="#55-%E6%97%A5%E5%BF%97">5.5 日志</a></li>
<li><a href="#56-%E5%B7%A5%E5%85%B7%E7%B1%BB">5.6 工具类</a></li>
<li><a href="#57-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5.7 配置文件</a>
<ul>
<li><a href="#571-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB">5.7.1 配置文件分类</a></li>
<li><a href="#572-%E5%8A%A0%E5%AF%86">5.7.2 加密</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%93%E5%8C%85">6 部署与打包</a>
<ul>
<li><a href="#61-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85">6.1 前端打包</a>
<ul>
<li><a href="#611-idea%E4%B8%80%E6%AC%A1%E6%89%93%E5%8C%85">6.1.1 IDEA一次打包</a></li>
<li><a href="#612-exe4j%E4%BA%8C%E6%AC%A1%E6%89%93%E5%8C%85">6.1.2 exe4j二次打包</a>
<ul>
<li><a href="#6121-exe4j">6.1.2.1 exe4j</a></li>
<li><a href="#6122-%E7%94%9F%E6%88%90jre">6.1.2.2 生成jre</a></li>
<li><a href="#6123-exe4j%E6%89%93%E5%8C%85">6.1.2.3 exe4j打包</a></li>
</ul>
</li>
<li><a href="#613-enigma-virtual-box%E4%B8%89%E6%AC%A1%E6%89%93%E5%8C%85">6.1.3 Enigma Virtual Box三次打包</a></li>
</ul>
</li>
<li><a href="#62-%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2">6.2 后端部署</a></li>
</ul>
</li>
<li><a href="#7-%E8%BF%90%E8%A1%8C">7 运行</a></li>
<li><a href="#8-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">8 注意事项</a>
<ul>
<li><a href="#81-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">8.1 路径问题</a></li>
<li><a href="#82-https">8.2 HTTPS</a></li>
<li><a href="#83-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86">8.3 配置文件加密</a></li>
<li><a href="#84-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6">8.4 键盘事件</a></li>
<li><a href="#85-%E6%95%B0%E6%8D%AE%E5%BA%93">8.5 数据库</a></li>
<li><a href="#86-%E9%AA%8C%E8%AF%81%E7%A0%81">8.6 验证码</a></li>
</ul>
</li>
<li><a href="#9-%E6%BA%90%E7%A0%81">9 源码</a></li>
<li><a href="#10-%E5%8F%82%E8%80%83">10 参考</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-简介">1.1 简介</h2>
<p>一个简单的小型薪酬管理系统，前端JavaFX+后端Spring Boot，功能倒没多少，主要精力放在了UI和前端的一些逻辑上面，后端其实做得很简单。<br>
主要功能：</p>
<ul>
<li>用户注册/登录</li>
<li>验证码找回密码</li>
<li>用户修改信息，修改头像</li>
<li>柱状图形式显示薪酬</li>
<li>管理员管理用户，录入工资</li>
</ul>
<h2 id="12-响应流程">1.2 响应流程</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200606152440586.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="13-演示">1.3 演示</h2>
<p>登录界面：<br>
<img src="https://img-blog.csdnimg.cn/202006041443179.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200604144337577.png" alt="在这里插入图片描述" loading="lazy"><br>
用户界面：<br>
<img src="https://img-blog.csdnimg.cn/20200604154028861.gif" alt="在这里插入图片描述" loading="lazy"><br>
管理员界面：<br>
<img src="https://img-blog.csdnimg.cn/20200604154042814.gif" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>IDEA 2020.1</li>
<li>本地JDK+服务器JDK：OpenJDK 11</li>
<li>OepnJFX 11</li>
<li>Spring Boot 2.3.0（Spring Boot的更新速度真是太快了）</li>
<li>Tomcat 9.0.33</li>
<li>MySQL 8.0.17</li>
</ul>
<h1 id="3-前端代码部分">3 前端代码部分</h1>
<h2 id="31-前端概述">3.1 前端概述</h2>
<p>前端主要分为5个部分实现：控制器模块，视图模块，网络模块，动画模块还有工具类模块。</p>
<ul>
<li>控制器模块：负责交互事件</li>
<li>视图模块：负责更新UI</li>
<li>网络模块：向后台发送数据请求</li>
<li>动画模块：移动、缩放、渐隐动画</li>
<li>工具类模块：加密，检查网路连通，居中界面等</li>
</ul>
<h2 id="32-概览">3.2 概览</h2>
<h3 id="321-代码目录树">3.2.1. 代码目录树</h3>
<p><img src="https://img-blog.csdnimg.cn/20200604154555276.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200604154632618.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="322-资源目录树">3.2.2 资源目录树</h3>
<p>分为css，fxml，默认图片，pem与项目配置文件。<br>
<img src="https://img-blog.csdnimg.cn/20200604154841664.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>css：界面所用到的样式</li>
<li>fxml：一个特殊的xml文件，用于定义界面与绑定Controller中的函数，也就是绑定事件</li>
<li>image：程序用到的默认图片</li>
<li>key：证书文件，用于OkHttp中的HTTPS</li>
<li>properties：项目一些常量属性<br>
<img src="https://img-blog.csdnimg.cn/20200604154809871.png" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<h3 id="323-项目依赖">3.2.3 项目依赖</h3>
<p>主要依赖如下：</p>
<ul>
<li><a href="https://mvnrepository.com/search?q=gson">Gson</a></li>
<li><a href="https://mvnrepository.com/search?q=log4j2">Log4j2</a></li>
<li><a href="https://mvnrepository.com/search?q=lombok">Lombok</a></li>
<li><a href="https://mvnrepository.com/search?q=okhttp">OkHttp3</a></li>
<li><a href="https://mvnrepository.com/search?q=apache%20commons">Apache Commons</a></li>
<li><a href="https://gluonhq.com/products/javafx/">OpenJFX11</a></li>
</ul>
<h2 id="33-常量模块">3.3 常量模块</h2>
<p><img src="https://img-blog.csdnimg.cn/20200604155521365.png" alt="在这里插入图片描述" loading="lazy"><br>
程序所需要的常量：</p>
<ul>
<li>CSSPath：CSS路径，用于<code>scene.getStylesheets.add(path)</code></li>
<li>FXMLPath：FXML路径，用于<code>FXMLLoader.load(getClass.getResource(path).openStream())</code></li>
<li>AllURL：发送网络请求的路径</li>
<li>BuilderKeys：OkHttp中的<code>FormBody.Builder</code>中使用的常量键名</li>
<li>PaneName：Pane名字，用于在同一个Scene切换不同的Pane</li>
<li>ReturnCode：后端返回码</li>
<li>ViewSize：界面尺寸</li>
</ul>
<p>重点说一下路径问题，笔者的css与fxml文件都放在resources下：<br>
<img src="https://img-blog.csdnimg.cn/20200604160107770.png" alt="在这里插入图片描述" loading="lazy"><br>
其中fxml路径在项目中的用法如下：</p>
<pre><code class="language-java">URL url = getClass().getResource(FXMLPath.xxxx);
FXMLLoader loader = new FXMLLoader();
loader.setLocation(url);
loader.load(url.openStream());
</code></pre>
<p>获取路径从根路径获取，比如上图中的MessageBox.fxml：</p>
<pre><code class="language-java">private static final String FXML_PREFIX = &quot;/fxml/&quot;;
private static final String FXML_SUFFIX = &quot;.fxml&quot;;
public static final String MESSAGE_BOX = FXML_PREFIX + &quot;MessageBox&quot; + FXML_SUFFIX;
</code></pre>
<p>若fxml文件直接放在resources根目录下，可以使用：</p>
<pre><code class="language-java">getClass().getResource(&quot;/xxx.fxml&quot;);
</code></pre>
<p>直接获取。<br>
css同理：</p>
<pre><code class="language-java">private static final String CSS_PREFIX = &quot;/css/&quot;;
private static final String CSS_SUFFIX = &quot;.css&quot;;
public static final String MESSAGE_BOX = CSS_PREFIX + &quot;MessageBox&quot; + CSS_SUFFIX;
</code></pre>
<p>网络请求的URL建议把路径写到配置文件中，比如这里的从配置文件读取：</p>
<pre><code class="language-java">Properties properties = Utils.getProperties();
if (properties != null)
{
    String baseUrl = properties.getProperty(&quot;baseurl&quot;) + properties.getProperty(&quot;port&quot;) + &quot;/&quot; + properties.getProperty(&quot;projectName&quot;);
    SIGN_IN_UP_URL = baseUrl + &quot;signInUp&quot;;
    //...
}
</code></pre>
<h2 id="34-控制器模块">3.4 控制器模块</h2>
<p>控制器模块用于处理用户的交互事件，本项目中分为三大类：</p>
<ul>
<li>登录注册界面控制器</li>
<li>用户界面控制器</li>
<li>管理员界面控制器</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200604160932518.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200604161111938.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="341-登录注册界面">3.4.1 登录注册界面</h3>
<p>这是程序一开始进入的界面，会在这里绑定一些基本的关闭，最小化，标题栏拖拽事件：</p>
<pre><code class="language-java">public void onMousePressed(MouseEvent e)
{
    stageX = stage.getX();
    stageY = stage.getY();
    screexX = e.getScreenX();
    screenY = e.getScreenY();
}
public void onMouseDragged(MouseEvent e)
{
    stage.setX(e.getScreenX() - screexX + stageX);
    stage.setY(e.getScreenY() - screenY + stageY);
}
public void close()
{
    GUI.close();
}
public void minimize()
{
    GUI.minimize();
}
</code></pre>
<p>登录界面的控制器也很简单，就一个登录/注册功能加一个跳转到找回密码界面，代码就不贴了。<br>
至于找回密码界面，需要做的比较多，首先需要判断用户输入的电话是否在后端数据库存在，另外还有检查两次输入的密码是否一致，还有判断短信是否发送成功与用户输入的验证码与后端返回的验证码是否一致（短信验证码部分其实不需要后端处理，因为是调用腾讯云的API，原本是放在前端的，凡是考虑到可能会泄漏一些重要的类似appid之类的信息就放到后端处理了）。</p>
<h3 id="342-用户界面">3.4.2 用户界面</h3>
<p>接着是用户登录后进入的界面，加了渐隐与移动动画：</p>
<pre><code class="language-java">public void userEnter()
{
    new Transition()
    .add(new Move(userImage).x(-70))
    .add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))
    .add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
    .add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180))
    .play();
}

public void userExited()
{
    new Transition()
    .add(new Move(userImage).x(0))
    .add(new Fade(userLabel).fromTo(1,0)).add(new Move(userLabel).x(0))
    .add(new Scale(userPolygon).ratio(1)).add(new Move(userPolygon).x(0))
    .add(new Scale(queryPolygon).ratio(1)).add(new Move(queryPolygon).x(0))
    .play();
}
</code></pre>
<p>效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200604162515550.gif" alt="在这里插入图片描述" loading="lazy"><br>
实际处理是把<code>&lt;Image&gt;</code>以及<code>&lt;Label&gt;</code>放进一个<code>&lt;AnchorPane&gt;</code>中，然后为这个<code>&lt;AnchorPane&gt;</code>添加鼠标移入与移出事件。从代码中可以知道图片加上了位移动画，文字同时加上了淡入与位移动画，多边形同时加上了缩放与位移动画。以左下的<code>&lt;AnchorPane&gt;</code>事件为例，当鼠标移入时，首先把图片左移：</p>
<pre><code class="language-java">.add(new Move(userImage).x(-70))
</code></pre>
<p>x表示横向位移。<br>
接着是淡入与位移文字：</p>
<pre><code class="language-java">.add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))    
</code></pre>
<p>fromTo表示从透明度的变化，从0到1，相当于淡入效果。<br>
最后放大多边形1.8倍同时右移多边形：</p>
<pre><code class="language-java">.add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
</code></pre>
<p>ratio表示放大的倍率，这里是放大到原来的1.8倍。<br>
右上的同样需要进行放大与移动：</p>
<pre><code class="language-java">.add(new Scale(queryPolygon).ratio(1.8)).add(new Move(queryPolygon).x(180))
</code></pre>
<p>其中用到的Transition，Scale，Fade是自定义的动画处理类，详情请查看&quot;3.8 动画模块&quot;。</p>
<h2 id="35-实体类模块">3.5 实体类模块</h2>
<p>简单的一个Worker：</p>
<pre><code class="language-java">@Getter
@Setter
@NoArgsConstructor
public class Worker {
    private String cellphone;
    private String password;
    private String name = &quot;无姓名&quot;;
    private String department = &quot;无部门&quot;;
    private String position = &quot;无职位&quot;;
    private String timeAndSalary;

    public Worker(String cellphone,String password)
    {
        this.cellphone = cellphone;
        this.password = password;
    }
}
</code></pre>
<p>注解使用了Lombok，Lombok介绍请<a href="https://www.cnblogs.com/relucent/p/8992147.html">戳这里</a>，完整用法<a href="https://projectlombok.org/features/all">戳这里</a>。<br>
timeAndSalary是一个使用Gson转换为String的Map，键为对应的年月，值为工资。具体转换方法请到工具类模块查看。</p>
<h2 id="36-日志模块">3.6  日志模块</h2>
<p>日志模块使用了Log4j2，resources下的log4j2.xml如下：</p>
<pre><code class="language-xml">&lt;configuration status=&quot;OFF&quot;&gt;
    &lt;appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;Time:%d{HH:mm:ss}     Level:%-5level %nMessage:%msg%n&quot;/&gt;
        &lt;/Console&gt;
    &lt;/appenders&gt;
    &lt;loggers&gt;
        &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/logger&gt;
        &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<p>这是最一般的配置，pattern里面是输出格式：</p>
<pre><code class="language-css">%d{HH:mm:ss}
</code></pre>
<p>是时间格式的设置，level表示日志等级，n表示换行，msg表示日志信息,需要更多配置请自行搜索。</p>
<h2 id="37-网络模块">3.7 网络模块</h2>
<p>网络模块的核心使用了OkHttp实现，主要分为两个包：<br>
<img src="https://img-blog.csdnimg.cn/20200604164501961.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>request：封装发送到后端的各种请求</li>
<li>requestBuilder：创建request的Builder类</li>
<li>OKHTTP：封装OkHttp的工具类，对外只有一个send方法，参数只有一个，request包中的类，使用requestBuilder生成，返回一个Object，至于Object怎么处理需要在用到OKHTTP的地方与返回方法对应</li>
</ul>
<h3 id="371-request包">3.7.1 request包</h3>
<p>封装了各种网络请求：<br>
<img src="https://img-blog.csdnimg.cn/20200604165233282.png" alt="在这里插入图片描述" loading="lazy"><br>
所有请求继承自BaseRequest，BaseRequest的公有方法包括：</p>
<ul>
<li>setUrl：设置发送的url</li>
<li>setCellphone：添加cellphone参数</li>
<li>setPassword：添加password参数，注意password经过前端的SHA512加密</li>
<li>setWorker：添加Worker参数</li>
<li>setWorkers：接受一个List&lt;Worker&gt;，管理员保存所有Worker时使用</li>
<li>setAvatar：添加头像参数</li>
<li>setAvatars：接受一个HashMap&lt;String,String&gt;，键为电话，标识唯一的Worker，值为图片经过Base64转换为的String</li>
</ul>
<p>唯一一个抽象方法是：</p>
<pre><code class="language-java">public abstract Object handleResult(ReturnCode code)：
</code></pre>
<p>根据不同的请求处理返回的结果，后端返回一个ReturnCode，其中封装了状态码，错误信息与返回值，由Gson转为String，前端得到String后经Gson转为ReturnCode，从里面获取状态码以及返回值。<br>
其余的请求类继承自BaseRequest，并且实现不同的处理结果方法，以Get请求为例：</p>
<pre><code class="language-java">public class GetOneRequest extends BaseRequest {
    @Override
    public Object handleResult(ReturnCode code)
    {
        switch (code)
        {
            case EMPTY_CELLPHONE:
                MessageBox.emptyCellphone();
                return false;
            case INVALID_CELLPHONE:
                MessageBox.invalidCellphone();
                return false;
            case CELLPHONE_NOT_MATCH:
                MessageBox.show(&quot;获取失败，电话号码不匹配&quot;);
                return false;
            case EMPTY_WORKER:
                MessageBox.emptyWorker();
                return false;
            case GET_ONE_SUCCESS:
                return Conversion.JSONToWorker(code.body());
            default:
                MessageBox.unknownError(code.name());
                return false;
        }
    }
}
</code></pre>
<p>获取一个Worker，可能的返回值有（枚举值，在ReturnCode中定义，需要前后端统一）：</p>
<ul>
<li>EMPTY_CELLPHOE：表示发送的get请求中电话为空</li>
<li>INVALID_CELLPHONE：非法电话号码，判断的代码为：<code>String reg = &quot;^[1][358][0-9]{9}$&quot;;return !(Pattern.compile(reg).matcher(cellphone).matches());</code></li>
<li>CELLPHONE_NOT_MATCH：电话号码不匹配，也就是数据库没有对应的Worker</li>
<li>EMPTY_WORKER：数据库中存在这个Worker，但由于转换为String时后端处理失败，返回一个空的Worker</li>
<li>GET_ONE_SUCCESS：获取成功，使用工具类转换String为Worker</li>
<li>默认：未知错误</li>
</ul>
<h3 id="372-requestbuilder包">3.7.2 requestBuilder包</h3>
<p>包含了对应与request的Builder：<br>
<img src="https://img-blog.csdnimg.cn/20200604172444435.png" alt="在这里插入图片描述" loading="lazy"><br>
除了默认的构造方法与build方法外，只有set方法，比如：</p>
<pre><code class="language-java">public class GetOneRequestBuilder {
    private final GetOneRequest request = new GetOneRequest();

    public GetOneRequestBuilder()
    {
        request.setUrl(AllURL.GET_ONE_URL);
    }

    public GetOneRequestBuilder cellphone(String cellphone)
    {
        if(Check.isEmpty(cellphone))
        {
            MessageBox.emptyCellphone();
            return null;
        }
        request.setCellphone(cellphone);
        return this;
    }

    public GetOneRequest build()
    {
        return request;
    }
}
</code></pre>
<p>在默认构造方法里面设置了url，剩下就只需设置电话即可获取Worker。</p>
<h3 id="373-okhttp">3.7.3 OKHTTP</h3>
<p>这是一个封装了OkHttp的静态工具类，唯一一个公有静态方法如下：</p>
<pre><code class="language-java">public static Object send(BaseRequest content)
{
    Call call = client.newCall(new Request.Builder().url(content.getUrl()).post(content.getBody()).build());
    try
    {
        ResponseBody body = call.execute().body();
        if(body != null)
            return content.handleResult(Conversion.stringToReturnCode(body.string()));
    }
    catch (IOException e)
    {
        L.error(&quot;Reseponse body is null&quot;);
        MessageBox.show(&quot;服务器无法连通,响应为空&quot;);
    }
    return null;
}
</code></pre>
<p>采用同步post请求的方式，其中call中使用的url与body正是使用<code>BaseRequest</code>作为基类的原因，可以方便地获取url与body，若数据量大可以考虑异步请求。上面也提到后端返回的是经由Gson转换为String的ReturnCode，所以获取body后先转换为ReturnCode再处理。</p>
<h3 id="374-https">3.7.4 HTTPS</h3>
<p>至于HTTPS，采用了war包部署，后端服务器Tomcat，需要在Tomcat里设置证书，同时也需要在OkHttp中设置三部分：</p>
<ul>
<li>sslSocketFactory：ssl套接字工厂</li>
<li>HostnameVerifier：验证主机名</li>
<li>X509TrustManager：证书信任器管理类</li>
</ul>
<h4 id="3741-okhttp配置">3.7.4.1 OkHttp配置</h4>
<p>上面提到了需要设置三部分，下面来看看最简单的一个验证主机名部分，利用的是HostnameVerifier接口：<br>
<img src="https://img-blog.csdnimg.cn/20200604175146704.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">OkHttpClient client = new OkHttpClient.Builder()
.connectTimeout(1500, TimeUnit.MILLISECONDS)
.hostnameVerifier((hostname, sslSession) -&gt; {
    if (&quot;www.test.com&quot;.equals(hostname)) {
        return true;
    } else {
        HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();
        return verifier.verify(hostname, sslSession);
    }
}).build();
</code></pre>
<p>这里验证主机名为www.test.com就返回true（也可是使用公网ip验证），否则使用默认的HostnameVerifier。业务逻辑复杂的话可以结合配置中心，黑/白名单等进行动态校验。<br>
接着是X509TrustManager的处理（来源<a href="https://www.programcreek.com/java-api-examples/?class=java.security.cert.CertificateFactory&amp;method=generateCertificates">Java Code Example</a>）：</p>
<pre><code class="language-java">private static X509TrustManager trustManagerForCertificates(InputStream in)
            throws GeneralSecurityException
{
    CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
    Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in);
    if (certificates.isEmpty()) {
        throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;);
    }

    char[] password = &quot;www.test.com&quot;.toCharArray(); // Any password will work.
    KeyStore keyStore = newEmptyKeyStore(password);
    int index = 0;
    for (Certificate certificate : certificates) {
        String certificateAlias = Integer.toString(index++);
        keyStore.setCertificateEntry(certificateAlias, certificate);
    }

    // Use it to build an X509 trust manager.
    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
    keyManagerFactory.init(keyStore, password);
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init(keyStore);
    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager))
    {
        throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers));
    }
    return (X509TrustManager) trustManagers[0];
}
</code></pre>
<p>返回一个信任由输入流读取的证书的信任管理器，若证书没有被签名则抛出SSLHandsakeException，证书建议使用第三方签名的而不是自签名的（比如使用openssl生成），特别是在生产环境中，例子的注释也提到：<br>
<img src="https://img-blog.csdnimg.cn/20200604181619611.png" alt="在这里插入图片描述" loading="lazy"><br>
最后是ssl套接字工厂的处理：</p>
<pre><code class="language-java">private static SSLSocketFactory createSSLSocketFactory() {
    SSLSocketFactory ssfFactory = null;
    try {
        SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);
        sc.init(null, new TrustManager[]{trustManager}, new SecureRandom());
        ssfFactory = sc.getSocketFactory();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ssfFactory;
}
</code></pre>
<p>完整的OkHttpClient构造如下：</p>
<pre><code class="language-java">X509TrustManager trustManager = trustManagerForCertificates(OKHTTP.class.getResourceAsStream(&quot;/key/pem.pem&quot;));
OkHttpClient client = new OkHttpClient.Builder()
.connectTimeout(1500, TimeUnit.MILLISECONDS)
.sslSocketFactory(createSSLSocketFactory(), trustManager)
.hostnameVerifier((hostname, sslSession) -&gt; {
    if (&quot;www.test.com&quot;.equals(hostname)) {
        return true;
    } else {
        HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();
        return verifier.verify(hostname, sslSession);
    }
})
.readTimeout(10, TimeUnit.SECONDS).build();
</code></pre>
<p>其中/key/pem.pem为证书文件。</p>
<h4 id="3742-服务器设置证书">3.7.4.2 服务器设置证书</h4>
<p>使用war进行部署，jar部署的方式请自行搜索，服务器Tomcat，其他web服务器请自行搜索。<br>
首先在Tomcat配置文件中的conf/server.xml修改域名：<br>
<img src="https://img-blog.csdnimg.cn/2020060418305799.png" alt="在这里插入图片描述" loading="lazy"><br>
找到&lt;Host&gt;并复制，直接修改其中的name为对应域名：<br>
<img src="https://img-blog.csdnimg.cn/20200604183251610.png" alt="在这里插入图片描述" loading="lazy"><br>
接着从证书厂商下载文件（一般都带文档，建议查看文档），Tomcat的是两个文件，一个是pfx，一个是密码文件，继续修改server.xml，搜索8443， 找到如下位置：<br>
<img src="https://img-blog.csdnimg.cn/20200604191608212.png" alt="在这里插入图片描述" loading="lazy"><br>
其中上面的&lt;Connector&gt;是HTTP/1.1协议的，基于Nio实现，下面的&lt;Connector&gt;是HTTP/2的，基于Apr实现，使用HTTP/1.1会比较简单一些，仅仅是修改server.xml即可，使用HTTP/2的话会麻烦一点，因为需要安装Apr，Apr-util以及Tomcat-Native，可以参考<a href="https://blog.csdn.net/qq_27525611/article/details/106557158">这里</a>，下面以HTTP/1.1的为例，修改如下：</p>
<pre><code class="language-xml">&lt;Connector port=&quot;8123&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
	maxThreads=&quot;200&quot; SSLEnabled=&quot;true&quot; 
	scheme=&quot;https&quot; secure=&quot;true&quot;
	keystoreFile=&quot;/xxx/xxx/xxx/xxx.pfx&quot; keystoreType=&quot;PKCS12&quot;
	keystorePass=&quot;YOUR PASSWORD&quot; clientAuth=&quot;false&quot;
	sslProtocol=&quot;TLS&quot;&gt;
&lt;/Connector&gt;
</code></pre>
<p>修改证书位置以及密码。如果想要更加安全的话可以指定使用某个TLS版本:</p>
<pre><code class="language-xml">&lt;Connector ...
sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1.2&quot;
&gt;
</code></pre>
<h3 id="375-图片处理">3.7.5 图片处理</h3>
<p>图片原本是想使用OkHttp的MultipartBody处理的，但是处理的图片都不太，貌似没有必要，而且实体类的数据都是以字符串的形式传输的，因此，笔者的想法是能不能统一都用字符串进行传输，于是找到了图片和String互转的函数，稍微改动，原来的函数需要外部依赖，现在改为了JDK自带的Base64：</p>
<pre><code class="language-java">public static String fileToString(String path)
{
    File file = new File(path);
    FileInputStream fis = null;
    StringBuilder content = new StringBuilder();
    try {
        fis = new FileInputStream(file);
        int length = 3 * 1024 * 1024;
        byte[] byteAttr = new byte[length];
        int byteLength;
        while ((byteLength = fis.read(byteAttr, 0, byteAttr.length)) != -1) {
            String encode;
            if (byteLength != byteAttr.length) {
                byte[] temp = new byte[byteLength];
                System.arraycopy(byteAttr, 0, temp, 0, byteLength);
                encode = Base64.getEncoder().encodeToString(temp);
                content.append(encode);
            } else {
                encode = Base64.getEncoder().encodeToString(byteAttr);
                content.append(encode);
            }
        }

    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            assert fis != null;
            fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return content.toString();
}

public static void stirngToFile(String base64Code, String targetPath) {
    byte[] buffer;
    FileOutputStream out = null;
    try {
        buffer = Base64.getDecoder().decode(base64Code);
        out = new FileOutputStream(targetPath);
        out.write(buffer);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (out != null) {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>Base64是一种基于64个可打印字符来表示二进制数据的方法，可以把二进制数据（图片/视频等）转为字符,或把对应的字符解码变为原来的二进制数据。<br>
笔者实测这种方法转换速度不慢，只要有了正确的转换函数，服务器端可以轻松进行转换，但是对于大文件的支持不好：<br>
<img src="https://img-blog.csdnimg.cn/20200402174805310.png" alt="在这里插入图片描述" loading="lazy"><br>
这种方法对一般的图片来说足够了，但是对于真正的文件还是建议使用MultipartBody进行处理。</p>
<h2 id="38-动画模块">3.8 动画模块</h2>
<p><img src="https://img-blog.csdnimg.cn/20200605024239576.png" alt="在这里插入图片描述" loading="lazy"><br>
包含了四类动画：淡入/淡出，位移，缩放，旋转，这四个类都实现了CustomTransitionOperation接口：</p>
<pre><code class="language-java">import javafx.animation.Animation;

public interface CustomTransitionOperation {
    double defaultSeconds = 0.4;
    Animation build();
    void play();
}
</code></pre>
<p>其中defaultSeconds表示默认持续的秒数，build用于Transition中对各个动画类进行统一的生成操作，最后的play用于播放动画。四个动画类类似，以旋转动画类为例：</p>
<pre><code class="language-java">public class Rotate implements CustomTransitionOperation{
    private final RotateTransition transition = new RotateTransition(Duration.seconds(1));

    public Rotate(Node node)
    {
        transition.setNode(node);
    }

    public Rotate seconds(double seconds)
    {
        transition.setDuration(Duration.seconds(seconds));
        return this;
    }

    public Rotate to(double to)
    {
        transition.setToAngle(to);
        return this;
    }

    @Override
    public Animation build() {
        return transition;
    }

    @Override
    public void play() {
        transition.play();
    }
}
</code></pre>
<p>seconds设置秒数，to表示设置旋转的角度，所有动画类统一由Transition控制：</p>
<pre><code class="language-java">public class Transition {
    private final ArrayList&lt;Animation&gt; animations = new ArrayList&lt;&gt;();

    public Transition add(CustomTransitionOperation animation)
    {
        animations.add(animation.build());
        return this;
    }

    public void play()
    {
        animations.forEach(Animation::play);
    }
}
</code></pre>
<p>里面是一个动画类的集合，每次add操作时先生成对应的动画再添加进数组，最后统一播放，示例用法如下：</p>
<pre><code class="language-java">new Transition()
.add(new Move(userImage).x(-70))
.add(new Fade(userLabel).fromTo(0,1)).add(new Move(userLabel).x(95))
.add(new Scale(userPolygon).ratio(1.8)).add(new Move(userPolygon).x(180))
.add(new Scale(workloadPolygon).ratio(1.8)).add(new Move(workloadPolygon).x(180))
.play();
</code></pre>
<h2 id="39-工具类模块">3.9 工具类模块</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200605024914382.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>AvatarUtils：用于本地生成临时图片以及图片转换处理</li>
<li>Check：检查是否为空，是否合法等</li>
<li>Conversion：转换类，通过Gson在Worker/String，Map/String，List/String之间进行转换</li>
<li>Utils：加密，设置运行环境，居中Stage，检查网络连通等</li>
</ul>
<p>这里说一下Utils与Conversion。</p>
<h3 id="391-conversion">3.9.1 Conversion</h3>
<p>转换类，利用Gson在String与List/Worker/Map之间进行转换，比如String转Map：</p>
<pre><code class="language-java">public static Map&lt;String,Double&gt; stringToMap(String str)
{
    if(Check.isEmpty(str))
        return null;
    Map&lt;?,?&gt; m = gson.fromJson(str,Map.class);
    Map&lt;String,Double&gt; map = new HashMap&lt;&gt;(m.size());
    m.forEach((k,v)-&gt;map.put((String)k,(Double)v));
    return map;
}
</code></pre>
<p>大部分的转换函数类似，首先判空，接着进行对应的类型转换，这里的Conversion与后端的基本一致，后端也需要使用Conversion类进行转换操作。</p>
<h3 id="392-utils">3.9.2 Utils</h3>
<p>获取属性文件方法如下：</p>
<pre><code class="language-java">//获取属性文件
public static Properties getProperties()
{
    Properties properties = new Properties();
    //项目属性文件分成了config_dev.properties,config_test.properties,config_prod.properties
    String fileName = &quot;properties/config_&quot;+ getEnv() +&quot;.properties&quot;;
    ClassLoader loader = Thread.currentThread().getContextClassLoader();
    try(InputStream inputStream = loader.getResourceAsStream(fileName))
    {
        if(inputStream != null)
        {
        	//防止乱码
            properties.load(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
            return properties;
        }
        L.error(&quot;Can not load properties properly.InputStream is null.&quot;);
        return null;
    }
    catch (IOException e)
    {
        L.error(&quot;Can not load properties properly.Message:&quot;+e.getMessage());
        return null;
    }
}
</code></pre>
<p>另一个是检查网路连通的方法：</p>
<pre><code class="language-java">public static boolean networkAvaliable()
{
    try(Socket socket = new Socket())
    {
        socket.connect(new InetSocketAddress(&quot;www.baidu.com&quot;,443));
        return true;
    }
    catch (IOException e)
    {
        L.error(&quot;Can not connect network.&quot;);
        e.printStackTrace();
    }
    return false;
}
</code></pre>
<p>采用socket进行判断，准确来说可以分两个方法检查网络，其中一个是检查网络连通，另一个是检查后端是否连通。<br>
最后是居中Stage的方法，尽管Stage中自带了一个centerOnScreen，但是出来的效果并不好，笔者的实测是水平居中但是垂直偏上的，并不是垂直水平居中。<br>
<img src="https://img-blog.csdnimg.cn/20200605025835965.png" alt="在这里插入图片描述" loading="lazy"><br>
因此根据屏幕高宽以及Stage的大小手动设置Stage的x和y。</p>
<pre><code class="language-java">public static void centerMainStage()
{
    Rectangle2D screenRectangle = Screen.getPrimary().getBounds();
    double width = screenRectangle.getWidth();
	double height = screenRectangle.getHeight();
	
	Stage stage = GUI.getStage();
    stage.setX(width/2 - ViewSize.MAIN_WIDTH/2);
    stage.setY(height/2 - ViewSize.MAIN_HEIGHT/2);
}
</code></pre>
<h2 id="310-视图模块">3.10 视图模块</h2>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200605092558957.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>GUI：全局变量共享以及以及控制Scene的切换</li>
<li>MainScene：全局控制器，负责初始化以及绑定键盘事件</li>
<li>MessBox：提示信息框，对外提供show()等的静态方法。</li>
</ul>
<p>GUI中的方法主要为<code>switchToXxx</code>，比如：</p>
<pre><code class="language-java">public static void switchToSignInUp()
{
    if(GUI.isUserInformation())
    {
        AvatarUtils.deletePathIfExists();
        GUI.getUserInformationController().reset();
    }
    mainParent.requestFocus();
    children.clear();
    children.add(signInUpParent.lookup(PaneName.SIGN_IN_UP));
    scene.getStylesheets().add(CSSPath.SIGN_IN_UP);
    Label minimize = (Label) (mainParent.lookup(&quot;#minimize&quot;));
    minimize.setText(&quot;-&quot;);
    minimize.setFont(new Font(&quot;System&quot;, 20));
    minimize.setOnMouseClicked(v-&gt;minimize());
}
</code></pre>
<p>跳转到登录注册，公有静态，首先判断是否为用户信息界面，如果是进行一些清理操作，接着是让Parent获取焦点（为了让键盘事件响应），然后将对应的<code>AnchorPane</code>添加到Children，并添加css，最后修改按钮文字与事件。<br>
另外还在MainScene中加了一些键盘事件响应，比如Enter：</p>
<pre><code class="language-java">ObservableMap&lt;KeyCombination,Runnable&gt; keyEvent = GUI.getScene().getAcclerators();
keyEvent.put(new KeyCodeCombination(KeyCode.ENTER),()-&gt;
{
    if (GUI.isSignInUp())
        GUI.getSignInUpController().signInUp();
    else if (GUI.isRetrievePassword())
        GUI.getRetrievePasswordController().reset();
    else if(GUI.isWorker())
        GUI.switchToUserInformation();
    else if(GUI.isAdmin())
        GUI.switchToUserManagement();
    else if(GUI.isUserInformation())
    {
        UserInformationController controller = GUI.getUserInformationController();
        if(controller.isModifying())
            controller.saveInformation();
        else
            controller.modifyInformation();
    }
    else if(GUI.isSalaryEntry())
    {
        GUI.getSalaryEntryController().save();
    }
});
</code></pre>
<h1 id="4-前端ui部分">4 前端UI部分</h1>
<h2 id="41-fxml">4.1 fxml</h2>
<p><img src="https://img-blog.csdnimg.cn/20200605093219158.png" alt="在这里插入图片描述" loading="lazy"><br>
界面基本上靠这些fxml文件控制，这部分没太多内容，基本上靠IDEA自带的Scene Builder设计，少部分靠代码控制，下面说几个注意事项：</p>
<ul>
<li>根节点为AnchorPane，每个fxml设置一个独立的fxid以便切换</li>
<li>事件绑定在对应的控件中，比如在一个Label绑定鼠标进入事件，在这个Label上设置<code>onMouseEntered=&quot;#xxx&quot;</code>，其中里面的方法为对应的控制器（<code>fx:controller=&quot;xxx.xxx.xxx.xxxController&quot;</code>）中的方法</li>
<li><code>&lt;Image&gt;</code>中的url属性需要带上<code>@</code>，比如<code>&lt;Image url=&quot;@../../image/xxx.png&quot;&gt;</code></li>
</ul>
<h2 id="42-css">4.2 css</h2>
<p>JFX中集成了部分css的美化功能，比如：</p>
<pre><code class="language-css">-fx-background-radius: 25px;
-fx-background-color:#e2ff1f;
</code></pre>
<p>用法是需要先在fxml中设置id。<br>
这里注意一下两个id的不同：</p>
<ul>
<li>fx:id</li>
<li>id</li>
</ul>
<p>fx:id指的是控件的fxid，通常配合Controller中的<code>@FXML</code>使用，比如一个Label设置了fxid为label1</p>
<pre><code class="language-xml">&lt;Label fx:id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt;
   &lt;font&gt;
       &lt;Font size=&quot;18.0&quot; /&gt;
   &lt;/font&gt;
&lt;/Label&gt;
</code></pre>
<p>则可以在对应Controller中使用<code>@FXML</code>获取，名字与fxid一致：</p>
<pre><code class="language-java">@FXML
private Label label1;
</code></pre>
<p>而id指的是css的id，用法是在css引用即可，比如上面的Label又同时设置了id（可以相同，也可不同）：</p>
<pre><code class="language-xml">&lt;Label fx:id=&quot;label1&quot; id=&quot;label1&quot; layoutX=&quot;450.0&quot; layoutY=&quot;402.0&quot; text=&quot;Label&quot;&gt;
   &lt;font&gt;
       &lt;Font size=&quot;18.0&quot; /&gt;
   &lt;/font&gt;
&lt;/Label&gt;
</code></pre>
<p>然后在css文件中像引用普通id一样引用：</p>
<pre><code class="language-css">#label1
{
    -fx-background-radius: 20px; /*圆角*/
}
</code></pre>
<p>同时JFX还支持css的伪类，比如下面的最小化与关闭的鼠标移入效果是使用伪类实现的：<br>
<img src="https://img-blog.csdnimg.cn/20200605095335164.gif" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-css">#minimize:hover
{
    -fx-opacity: 1;
    -fx-background-radius: 10px;
    -fx-background-color: #323232;
    -fx-text-fill: #ffffff;
}

#close:hover
{
    -fx-opacity: 1;
    -fx-background-radius: 10px;
    -fx-background-color: #dd2c00;
    -fx-text-fill: #ffffff;
}
</code></pre>
<p>当然一些比较复杂的是不支持的，笔者尝试过使用transition之类的，不支持。<br>
最后需要在对应的Scene里面引入css：</p>
<pre><code class="language-java">Scene scene = new Scene();
scene.getStylesheets().add(&quot;xxx/xxx/xxx/xxx.css&quot;);
</code></pre>
<p>程序中的用法是：</p>
<pre><code class="language-java">scene.getStylesheets().add(CSSPath.SIGN_IN_UP);
</code></pre>
<h2 id="43-stage构建过程">4.3 Stage构建过程</h2>
<p>下面以提示框为例，说明Stage的构建过程。</p>
<pre><code class="language-java">try {
    Stage stage = new Stage();
    Parent root = FXMLLoader.load(getClass().getResource(FXMLPath.MESSAGE_BOX));
    Scene scene = new Scene(root, ViewSize.MESSAGE_BOX_WIDTH,ViewSize.MESSAGE_BOX_HEIGHT);
    scene.getStylesheets().add(CSSPath.MESSAGE_BOX);
    Button button = (Button)root.lookup(&quot;#button&quot;);
    button.setOnMouseClicked(v-&gt;stage.hide());
    Label label = (Label)root.lookup(&quot;#label&quot;);
    label.setText(message);
    stage.initStyle(StageStyle.TRANSPARENT);
    stage.setScene(scene);
    Utils.centerMessgeBoxStage(stage);
    stage.show();

    root.requestFocus();
    scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), stage::close);
    scene.getAccelerators().put(new KeyCodeCombination(KeyCode.BACK_SPACE), stage::close);
} catch (IOException e) {
	//...
}
</code></pre>
<p>首先新建一个Stage，接着利用FXMLLoader加载对应路径上的fxml文件，获取Parent后，利用该Parent生成Scene，再为Scene添加样式。<br>
接着是控件的处理，这里的<code>lookup</code>类似Android中的<code>findViewById</code>，根据id获取对应控件，注意需要加上<code>#</code>。处理好控件之后，居中并显示stage，同时，绑定键盘事件并让Parent获取焦点。</p>
<h1 id="5-后端部分">5 后端部分</h1>
<h2 id="51-后端概述">5.1 后端概述</h2>
<p>后端以Spring Boot框架为核心，部署方式为war，整体分为三层：</p>
<ul>
<li>控制器层：负责接受前端的请求并调用业务层方法</li>
<li>业务层：处理主要业务，如CRUD，图片处理等</li>
<li>持久层：数据持久化，使用Hibernate+Spring Data JPA</li>
</ul>
<p>总的来说没有用到什么高大上的东西，逻辑也比较简单。</p>
<h2 id="52-概览">5.2 概览</h2>
<h3 id="521-代码目录树">5.2.1 代码目录树</h3>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200605100638908.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="522-依赖">5.2.2 依赖</h3>
<p>主要依赖如下：</p>
<ul>
<li><a href="https://mvnrepository.com/search?q=spring%20boot%20start%20data%20jpa">Spring Boot Starter Data JPA</a></li>
<li><a href="https://mvnrepository.com/search?q=guava">Guava</a></li>
<li><a href="https://mvnrepository.com/search?q=lombok">Lombok</a></li>
<li><a href="https://mvnrepository.com/search?q=gson">Gson</a></li>
<li><a href="https://mvnrepository.com/search?q=Apache%20commons">Apache Commons</a></li>
<li><a href="https://mvnrepository.com/search?q=tencentcloud-sdk-java">TencentCloud SDK Java</a></li>
<li><a href="https://mvnrepository.com/search?q=jasypt%20spring%20boot%20starter">Jasypt Spring Boot Starter</a></li>
</ul>
<h2 id="53-控制器层">5.3 控制器层</h2>
<p>控制器分为三类，一类处理图片，一类处理CRUD请求，一类处理短信发送请求，统一接受POST忽略GET请求。大概的处理流程是接收参数后首先进行判断操作，比如判空以及判断是否合法等等，接着调用业务层的方法并对返回结果进行封装，同时进行日志记录，最后利用Gson把返回结果转为字符串。代码大部分比较简单就不贴了，说一下短信验证码的部分。<br>
验证码模块使用了腾讯云的功能，官网<a href="https://cloud.tencent.com/">这里</a>，搜索短信功能即可。<br>
<img src="https://img-blog.csdnimg.cn/20200516201123398.png" alt="在这里插入图片描述" loading="lazy"><br>
新用户默认赠送100条短信：<br>
<img src="https://img-blog.csdnimg.cn/20200516201337762.png" alt="在这里插入图片描述" loading="lazy"><br>
发送之前需要创建签名与正文模板，审核通过即可使用。<br>
<img src="https://img-blog.csdnimg.cn/20200516201411878.png" alt="在这里插入图片描述" loading="lazy"><br>
可以先根据快速开始试用一下短信功能，若能成功收到短信，可以<a href="https://github.com/TencentCloud/tencentcloud-sdk-java">戳这里</a>查看API（Java版）。<br>
下面的例子由<a href="https://github.com/TencentCloud/tencentcloud-sdk-java/blob/master/examples/sms/v20190711/SendSms.java">文档例子</a>简化而来：</p>
<pre><code class="language-java">private void sendCode()
{
    try
    {
        SmsClient client = new SmsClient(new Credential(TencentSDK.id,TencentSDK.key),&quot;&quot;);
        SendSmsRequest request = new SendSmsRequest();
        request.setSmsSdkAppid(TencentSDK.appId);
        request.setSign(TencentSDK.sign);
        request.setTemplateID(TencentSDK.templateId);

        randomCode = RandomStringUtils.randomNumeric(6);
        String [] templateParamSet = {randomCode};
        request.setTemplateParamSet(templateParamSet);

        String [] phoneNumbers = {&quot;+86&quot;+cellphone.getText()};
        request.setPhoneNumberSet(phoneNumbers);
        response = client.SendSms(request);
    } catch (Exception e) {
        L.error(&quot;Not send code or send code failed&quot;);
        AlertView.show(&quot;验证码未发送或发送验证码失败&quot;);
    }
}
</code></pre>
<p>其中<code>TencentSDK.appId,TencentSDK.sign,TencentSDK.templateID</code>分别是读应的appid，签名id与正文模板id，申请通过之后会分配的，然后随机生成六位数字的验证码。<br>
接着<code>request.setPhoneNumberSet()</code>的参数为需要发送的手机号码String数组，注意需要加上区号。发送成功的话手机会收到，失败的话请根据异常信息自行判断修改。<br>
唯一要注意一下的是appid之类的数据通过配置文件配合<code>@Value</code>获取值，如：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/&quot;)
public class SmsController {
    @Value(&quot;${tencent.secret.id}&quot;)
    private String secretId;
    ...
}
</code></pre>
<p>但是由于sign部分含有中文，所以需要进行编码转换：</p>
<pre><code class="language-java">@Value(&quot;${tencent.sign}&quot;)
private String sign;

@PostConstruct
public void init()
{
    sign = new String(sign.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
}
</code></pre>
<h2 id="54-业务层与持久层">5.4 业务层与持久层</h2>
<p>由于程序中的业务层与持久层都比较简单就合并一起说了，比如业务层的saveOne方法，保存一个Worker，先利用Gson转换为Worker后直接利用<code>CrudRespository&lt;T,ID&gt;</code>提供的save方法保存：</p>
<pre><code class="language-java">public ReturnCode saveOne(String json) {
    ReturnCode s = ReturnCode.SAVE_ONE_SUCCESS;
    Worker worker = Conversion.JSONToWorker(json);
    if (Check.isEmpty(worker)) {
        L.emptyWorker();
        s = ReturnCode.EMPTY_WORKER;
    }
    else
        workerRepository.save(worker);
    return s;
}
</code></pre>
<p>另外由于<code>CurdRepository&lt;T,ID&gt;</code>的saveAll方法参数为<code>Iterable&lt;S&gt;</code>，因此可以直接保存<code>List&lt;S&gt;</code>，比如：</p>
<pre><code class="language-java">public ReturnCode saveAll(List&lt;Worker&gt; workers)
{
    workerRepository.saveAll(workers);
    return ReturnCode.SAVE_ALL_SUCCESS;
}
</code></pre>
<p>需要在控制层中把前端发送的String转换为<code>List&lt;S&gt;</code>。</p>
<h2 id="55-日志">5.5 日志</h2>
<p>日志用的是Spring Boot自带的日志系统，只是简单地配置了一下日志路径，除此之外，日志的格式自定义（因为追求整洁输出,感觉配置文件实现得不够好,因此自定义了一个工具类）。<br>
比如日志截取如下：<br>
<img src="https://img-blog.csdnimg.cn/20200605115735519.png" alt="在这里插入图片描述" loading="lazy"><br>
自定义了标题以及每行固定输出，前后加上了提示符，内容包括方法，级别，时间以及其他信息。<br>
总的来说，除了格式化器外总共有7个类，其中L是主类，外部类只需要调用L的方法，里面都是静态方法，其余6个是L调用的类：<br>
<img src="https://img-blog.csdnimg.cn/20200605115915307.png" alt="在这里插入图片描述" loading="lazy"><br>
如备份成功时调用：</p>
<pre><code class="language-java">public Success
{
	public static void backup()
	{
	    l.info(new FormatterBuilder().title(getTitle()).info().position().time().build());
	}
	//...
}
</code></pre>
<p>其中<code>FormatterBuilder</code>是格式化器，用来格式化输出的字符串，方法包括时间，位置，级别以及其他信息：</p>
<pre><code class="language-java">public FormatterBuilder info()
{
    return level(&quot;info&quot;);
}
public FormatterBuilder time()
{
    content(&quot;time&quot;,getCurrentTime());
    return this;
}
private FormatterBuilder level(String level)
{
    content(&quot;level&quot;,level);
    return this;
}
public FormatterBuilder cellphone(String cellphone)
{
    content(&quot;cellphone&quot;,cellphone);
    return this;
}
public FormatterBuilder message(String message)
{
    content(&quot;message&quot;,message);
    return this;
}
</code></pre>
<h2 id="56-工具类">5.6 工具类</h2>
<p><img src="https://img-blog.csdnimg.cn/20200605120436102.png" alt="在这里插入图片描述" loading="lazy"><br>
四个：</p>
<ul>
<li>Backup：定时数据库备份</li>
<li>Check：检查合法性，是否为空等</li>
<li>Conversion：转换类，与前端的几乎一致，利用Gson在String与List/Map/Worker之间进行转换</li>
<li>ReturnCode：返回码枚举类</li>
</ul>
<p>重点说一下备份，代码不长就直接整个类贴出来了：</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class Backup {
    private static final long INTERVAL = 1000 * 3600 * 12;
    @Value(&quot;${backup.command}&quot;)
    private String command;
    @Value(&quot;${backup.path}&quot;)
    private String strPath;
    @Value(&quot;${spring.datasource.username}&quot;)
    private String username;
    @Value(&quot;${spring.datasource.password}&quot;)
    private String password;
    @Value(&quot;${spring.datasource.url}&quot;)
    private String url;
    @Value(&quot;${backup.dataTimeFormat}&quot;)
    private String dateTimeFormat;

    @Scheduled(fixedRate = INTERVAL)
    public void startBackup()
    {
        try
        {
            String[] commands = command.split(&quot;,&quot;);
            String dbname = url.substring(url.lastIndexOf(&quot;/&quot;)+1);
            commands[2] = commands[2] + username + &quot; --password=&quot; + password + &quot; &quot; + dbname + &quot; &gt; &quot; + strPath +
                    dbname + &quot;_&quot; + DateTimeFormatter.ofPattern(dateTimeFormat).format(LocalDateTime.now())+&quot;.sql&quot;;
            Path path = Paths.get(strPath);
            if(!Files.exists(path))
                Files.createDirectories(path);
            Process process = Runtime.getRuntime().exec(commands);
            process.waitFor();
            if(process.exitValue() != 0)
            {
                InputStream inputStream = process.getErrorStream();
                StringBuilder str = new StringBuilder();
                byte []b = new byte[2048];
                while(inputStream.read(b,0,2048) != -1)
                    str.append(new String(b));
                L.backupFailed(str.toString());
            }
            L.backupSuccess();
        }
        catch (IOException | InterruptedException e)
        {
            L.backupFailed(e.getMessage());
        }
    }
}
</code></pre>
<p>首先利用<code>@Value</code>获取配置文件中的值，接着在备份方法加上<code>@Scheduled</code>。<code>@Scheduled</code>是Spring Boot用于提供定时任务的注解，用于控制任务在某个指定时间执行或者每隔一段时间执行（这里是半天一次），主要有三种配置执行时间的方式：</p>
<ul>
<li>cron</li>
<li>fixedRate</li>
<li>fixedDelay</li>
</ul>
<p>这里不展开了，详细用法可以<a href="https://blog.csdn.net/qq_27525611/article/details/104083548">戳这里</a>。<br>
另外在使用前需要在类上加上<code>@EnableScheduling</code>。备份的方法首先利用url获取数据库名，接着拼合备份命令，注意如果本地使用win开发备份命令会与linux不同：</p>
<pre><code class="language-java">//win
command[0]=cmd
command[1]=/c
command[2]=mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot;

//linux(本地Manjaro+服务器CentOS测试通过)
command[0]=/bin/sh
command[1]=-c
command[2]=/usr/bin/mysqldump -u username --password=your_password dbname &gt; backupPath+File.separator+dbname+datetimeFormmater+&quot;.sql&quot;
</code></pre>
<p>再判断备份路径是否存在，接着利用Java自带的Process进行备份处理，若出错则利用其中的<code>getErrorStream()</code>获取错误信息并记录日志。</p>
<h2 id="57-配置文件">5.7 配置文件</h2>
<h3 id="571-配置文件分类">5.7.1 配置文件分类</h3>
<p><img src="https://img-blog.csdnimg.cn/20200605135523526.png" alt="在这里插入图片描述" loading="lazy"><br>
一个总的配置文件+三个是特定环境下（开发，测试，生产）的配置文件，可以使用<code>spring.profiles.active</code><br>
切换配置文件，比如<code>spring.profiles.active=dev</code>，注意命名有规则，中间加一杠。另外自定义的配置需要在<code>additional-spring-configuration-metadata.json</code>中添加字段（非强制，只是IDE会提示），比如：</p>
<pre><code class="language-json">&quot;properties&quot;: [
    {
        &quot;name&quot;: &quot;backup.path&quot;,
        &quot;type&quot;: &quot;java.lang.String&quot;,
        &quot;defaultValue&quot;: &quot;null&quot;
    },
]
</code></pre>
<h3 id="572-加密">5.7.2 加密</h3>
<p>都2020年了，还在配置文件中使用明文密码就不太好吧？<br>
该加密了。<br>
使用的是Jasypt Spring Boot组件，官方github请<a href="https://github.com/ulisesbocchio/jasypt-spring-boot">戳这里</a>。<br>
用法这里就不详细介绍了，详情看笔者的另一篇博客，<a href="https://www.cnblogs.com/6b7b5fc3/p/12791351.html">戳这里</a>。<br>
但是笔者实测目前最新的3.0.2版本（本文写于2020.06.05，2020.05.31作者已更新3.0.3版本，但是笔者没有测试过）会有如下问题：</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.password' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>解决方案以及问题详细描述<a href="https://blog.csdn.net/qq_27525611/article/details/106450385">戳这里</a>。</p>
<h1 id="6-部署与打包">6 部署与打包</h1>
<h2 id="61-前端打包">6.1 前端打包</h2>
<p>先说一下前端的打包过程，简单地说打成jar即可跨平台运行，但是如果是特定平台的话比如win，想打成无需额外JDK环境的exe还是需要一些额外操作，这里简单介绍一下打包过程。</p>
<h3 id="611-idea一次打包">6.1.1 IDEA一次打包</h3>
<p>打包需要用到Maven插件，常用的Maven打包插件如下：</p>
<ul>
<li>mave-jar-plugin：默认的打包jar插件，生成的jar很小，但是需要把lib放置与jar相同目录下，用来打普通的JAR包</li>
<li>maven-shade-plugin：提供了两大基本功能，将依赖的jar包打包到当前jar包，能对依赖的jar包进行重命名以及取舍过滤</li>
<li>maven-assembly-plugin：支持定制化的打包方式，更多的是对项目目录的重新组装</li>
</ul>
<p>本项目使用maven-shade-plugin打包。<br>
需要先引入（引入之后可以把原来的Maven插件去掉），最新版本<a href="https://github.com/apache/maven-shade-plugin">戳这里</a>的官方github查看：</p>
<pre><code class="language-xml">&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
			&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2.4&lt;/version&gt;
	            &lt;executions&gt;
	            	&lt;execution&gt;
	                    &lt;phase&gt;package&lt;/phase&gt;
	                    &lt;goals&gt;
	                        &lt;goal&gt;shade&lt;/goal&gt;
	                    &lt;/goals&gt;
	                    &lt;configuration&gt;
	                        &lt;transformers&gt;
	                            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
	                                &lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt;
	                            &lt;/transformer&gt;
	                        &lt;/transformers&gt;
	                    &lt;/configuration&gt;
	                &lt;/execution&gt;
	            &lt;/executions&gt;
          &lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>只需要修改主类即可：</p>
<pre><code class="language-xml">&lt;mainClass&gt;xxxx.xxx.xxx.Main&lt;/mainClass&gt;
</code></pre>
<p>接着就可以从IDEA右侧栏的Maven中一键打包：<br>
<img src="https://img-blog.csdnimg.cn/20200605141057166.png" alt="在这里插入图片描述" loading="lazy"><br>
这样在target下就有jar包了，可以跨平台运行，只需提供JDK环境。</p>
<pre><code class="language-bash">java -jar xxx.jar
</code></pre>
<p>下面的两步是使用exe4j与Enigma Virtual Box打成一个单一exe的方法，仅针对Win，使用Linux/Mac可以跳过或自行搜索其他方法。</p>
<h3 id="612-exe4j二次打包">6.1.2 exe4j二次打包</h3>
<h4 id="6121-exe4j">6.1.2.1 exe4j</h4>
<p>exe4j能集成Java应用程序到Win下的java可执行文件生成工具,无论是用于服务器还是用于GUI或者命令行的应用程序。简单地说，本项目用其将jar转换为exe。exe4j需要jre，从JDK9开始模块化，需要自行生成jre，因此，需要先生成jre再使用exe4j打包。</p>
<h4 id="6122-生成jre">6.1.2.2 生成jre</h4>
<p>各个模块的作用可以<a href="https://www.apiref.com/java11-zh/index.html">这里</a>查看：<br>
<img src="https://img-blog.csdnimg.cn/20200601095405851.png" alt="在这里插入图片描述" loading="lazy"><br>
经测试本程序所需要的模块如下：</p>
<pre><code class="language-bash">java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management
</code></pre>
<p>切换到JDK目录下，使用jlink生成jre：</p>
<pre><code class="language-bash">jlink --module-path jmods --add-modules 
java.base,java.logging,java.net.http,javafx.base,javafx.controls,javafx.fxml,javafx.graphics,java.sql,java.management
--output jre
</code></pre>
<p>由于OpenJDK11不自带JavaFX，需要<a href="https://gluonhq.com/products/javafx/">戳这里</a>自行下载Win平台的JFX jmods，并移动到JDK的jmods目录下。生成的jre大小为91M：<br>
<img src="https://img-blog.csdnimg.cn/20200605194954945.png" alt="在这里插入图片描述" loading="lazy"><br>
如果实在不清楚使用哪一些模块可以使用全部模块，但是不建议：</p>
<pre><code class="language-bash">jlink --module-path jmods --add-modules 
java.base,java.compiler,java.datatransfer,java.xml,java.prefs,java.desktop,java.instrument,java.logging,java.management,java.security.sasl,java.naming,java.rmi,java.management.rmi,java.net.http,java.scripting,java.security.jgss,java.transaction.xa,java.sql,java.sql.rowset,java.xml.crypto,java.se,java.smartcardio,jdk.accessibility,jdk.internal.vm.ci,jdk.management,jdk.unsupported,jdk.internal.vm.compiler,jdk.aot,jdk.internal.jvmstat,jdk.attach,jdk.charsets,jdk.compiler,jdk.crypto.ec,jdk.crypto.cryptoki,jdk.crypto.mscapi,jdk.dynalink,jdk.internal.ed,jdk.editpad,jdk.hotspot.agent,jdk.httpserver,jdk.internal.le,jdk.internal.opt,jdk.internal.vm.compiler.management,jdk.jartool,jdk.javadoc,jdk.jcmd,jdk.management.agent,jdk.jconsole,jdk.jdeps,jdk.jdwp.agent,jdk.jdi,jdk.jfr,jdk.jlink,jdk.jshell,jdk.jsobject,jdk.jstatd,jdk.localedata,jdk.management.jfr,jdk.naming.dns,jdk.naming.rmi,jdk.net,jdk.pack,jdk.rmic,jdk.scripting.nashorn,jdk.scripting.nashorn.shell,jdk.sctp,jdk.security.auth,jdk.security.jgss,jdk.unsupported.desktop,jdk.xml.dom,jdk.zipfs,javafx.web,javafx.swing,javafx.media,javafx.graphics,javafx.fxml,javafx.controls,javafx.base 
--output jre
</code></pre>
<p>大小为238M：<br>
<img src="https://img-blog.csdnimg.cn/20200601103313319.png" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="6123-exe4j打包">6.1.2.3 exe4j打包</h4>
<p>exe4j使用参考<a href="https://zhuanlan.zhihu.com/p/82540739">这里</a>，首先一开始的界面应该是这样的：<br>
<img src="https://img-blog.csdnimg.cn/20200601104322250.png" alt="在这里插入图片描述" loading="lazy"><br>
配置文件首次运行是没有的，next即可。<br>
选择JAR in EXE mode：<br>
<img src="https://img-blog.csdnimg.cn/20200601104408250.png" alt="在这里插入图片描述" loading="lazy"><br>
填入名称与输出目录：<br>
<img src="https://img-blog.csdnimg.cn/20200601104451728.png" alt="在这里插入图片描述" loading="lazy"><br>
这里的类型为GUI application，填上可执行文件的名称，选择图标路径，勾选允许单个应用实例运行：<br>
<img src="https://img-blog.csdnimg.cn/20200601104653221.png" alt="在这里插入图片描述" loading="lazy"><br>
重定向这里可以选择标准输出流与标准错误流的输出目录，不需要的话默认即可：<br>
<img src="https://img-blog.csdnimg.cn/20200601104849867.png" alt="在这里插入图片描述" loading="lazy"><br>
64位Win需要勾选生成64位的可执行文件：<br>
<img src="https://img-blog.csdnimg.cn/20200601104931406.png" alt="在这里插入图片描述" loading="lazy"><br>
接着是Java类与JRE路径设置：<br>
<img src="https://img-blog.csdnimg.cn/20200601105210997.png" alt="在这里插入图片描述" loading="lazy"><br>
选择IDEA生成的jar，接着填上主类路径：<br>
<img src="https://img-blog.csdnimg.cn/20200601105256915.png" alt="在这里插入图片描述" loading="lazy"><br>
设置jre的最低支持与最高支持版本：<br>
<img src="https://img-blog.csdnimg.cn/20200601105410836.png" alt="在这里插入图片描述" loading="lazy"><br>
下一步是指定JRE搜索路径，首先把默认的三个位置删除：<br>
<img src="https://img-blog.csdnimg.cn/20200601105522253.png" alt="在这里插入图片描述" loading="lazy"><br>
接着选择之前生成的jre，把jre放在与jar同一目录下，路径填上当前目录下的jre：<br>
<img src="https://img-blog.csdnimg.cn/20200601105632876.png" alt="在这里插入图片描述" loading="lazy"><br>
接下来全next即可，完成后会提示exe4j has finished，直接运行测试一遍：<br>
<img src="https://img-blog.csdnimg.cn/20200601105841227.png" alt="在这里插入图片描述" loading="lazy"><br>
首先会提示一遍这是用exe4j生成的：<br>
<img src="https://img-blog.csdnimg.cn/20200601105852398.png" alt="在这里插入图片描述" loading="lazy"><br>
若没有缺少模块应该就可以正常启动了，有缺少模块的话会默认在当前exe路径生成一个error.log，查看并添加对应模块再次使用jlink生成jre，并使用exe4j再次打包。</p>
<h3 id="613-enigma-virtual-box三次打包">6.1.3 Enigma Virtual Box三次打包</h3>
<p>使用exe4j打包后，虽然是也可以直接运行了，但是jre太大，而且笔者这种有强迫症非得装进一个exe。所幸笔者之前用过Enigma Virtual Box这个打包工具，能把所有文件打包为一个独立的exe。<br>
使用很简单，首先添加exe4j打包出来的exe：<br>
<img src="https://img-blog.csdnimg.cn/20200601095936821.png" alt="在这里插入图片描述" loading="lazy"><br>
接着新建一个jre目录，添加上一步生成的jre：<br>
<img src="https://img-blog.csdnimg.cn/20200601100021947.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200601100046712.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200601100107761.png" alt="在这里插入图片描述" loading="lazy"><br>
最后选择压缩文件：<br>
<img src="https://img-blog.csdnimg.cn/20200601100139163.png" alt="在这里插入图片描述" loading="lazy"><br>
打包出来的单独exe大小为65M，相比起exe4j还要带上的89M的jre，已经节省了空间。<br>
<img src="https://img-blog.csdnimg.cn/20200601102551409.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="62-后端部署">6.2 后端部署</h2>
<p>后端部署的方式也简单，采用war部署的方式，若项目为jar包打包可以自行转换为war包，具体转换方式不难请自行搜索。由于Web服务器为Tomcat，因此直接把war包放置于webapps下即可，其他Web服务器自请自行搜索。<br>
当然也可以使用Docker部署，但需要使用jar而不是war，具体方式自行搜索。</p>
<h1 id="7-运行">7 运行</h1>
<p>本项目已经打包，前端包括jar与exe，后端包括jar与war，首先把后端运行（先开启数据库服务）：<br>
使用jar：</p>
<pre><code class="language-bash">java -jar Backend.jar
</code></pre>
<p>使用war直接放到Tomcat的webapps下然后到bin下：</p>
<pre><code class="language-bash">./startup.sh
</code></pre>
<p>接着运行前端，Windows的话可以直接运行exe，当然也可以jar，Linux的话jar：</p>
<pre><code class="language-bash">java -jar Frontend.jar
</code></pre>
<p>若运行失败可以用IDEA打开项目直接在IDEA中运行或者自行打包运行。</p>
<h1 id="8-注意事项">8 注意事项</h1>
<h2 id="81-路径问题">8.1 路径问题</h2>
<p>对于资源文件千万千万不要直接使用什么相对路径或绝对路径，比如：</p>
<pre><code class="language-java">String path1 = &quot;/xxx/xxx/xxx/xx.png&quot;;
String path2 = &quot;xxx/xx.jpg&quot;;
</code></pre>
<p>这样会有很多问题，比如有可能在IDEA中直接运行与打成jar包运行的结果不一致，路径读取不了，另外还可能会出现平台问题，众所周知Linux的路径分隔符与Windows的不一致。所以，对于资源文件，统一使用如下方式获取：</p>
<pre><code class="language-java">String path = getClass().getResource(&quot;/image/xx.png&quot;);
</code></pre>
<p>其中<code>image</code>直接位于<code>resources</code>资源文件夹下。其他类似，也就是说这里的<code>/</code>代表在<code>resources</code>下。</p>
<h2 id="82-https">8.2 HTTPS</h2>
<p>默认没有提供HTTPS，证书文件没有摆上去，默认走的是本地8080端口，有关OkHttp使用HTTPS的文章有不少，但是大部分都是仅仅写了前端如何配置HTTPS的，没有提到后端如何部署，可以参考笔者的<a href="https://blog.csdn.net/qq_27525611/article/details/105184098">这篇文章</a>，包含Tomcat的配置教程。</p>
<h2 id="83-配置文件加密">8.3 配置文件加密</h2>
<p>配置文件使用了jasypt-spring-boot开源组件进行加密，设置口令可以有三种方式设置：</p>
<ul>
<li>命令行参数</li>
<li>应用环境变量</li>
<li>系统环境变量</li>
</ul>
<p>目前最新的版本为3.0.3（2020.05.31更新3.0.3 ，笔者之前使用3.0.2的版本进行加密时本地测试没问题，但是部署到服务器上老是提示找不到口令，无奈只好使用旧一点的2.x版本，但是新版本出了后笔者尝试过部署到本地Tomcat没有问题但是没有部署到服务器上），建议使用最新版本进行部署：<br>
<img src="https://img-blog.csdnimg.cn/20200606033459144.png" alt="在这里插入图片描述" loading="lazy"><br>
毕竟前后跨度挺大的，虽然说这是小的bug修复，但是还是建议试试，估计不会有3.0.2的问题了。<br>
另外对于含有中文的字段记得进行编码转换：</p>
<pre><code class="language-java">str = new String(str.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);)
</code></pre>
<p>另外笔者已写好了测试文件，直接首先替换掉配置文件原来的密文，填上明文重新加密：<br>
<img src="https://img-blog.csdnimg.cn/20200606111549200.png" alt="在这里插入图片描述" loading="lazy"><br>
注意如果没有在配置文件中设置<code>jasypt.encryptor.password</code>的话可以在运行配置中设置VM Options（建议不要把口令直接写在配置文件中，当然这个默认是使用PBE加密，非对称加密可以使用<code>jasypt.encryptor.private-key-string</code>或<code>jasypt.encryptor.private-key-location</code>）：<br>
<img src="https://img-blog.csdnimg.cn/20200606111736683.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="84-键盘事件">8.4 键盘事件</h2>
<p>添加键盘事件可以使用如下代码：</p>
<pre><code class="language-java">scene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), ()-&gt;{xxx});
//getAccelerators返回ObservableMap&lt;KeyCombination, Runnable&gt;
</code></pre>
<p>响应之前需要让parent获取焦点：</p>
<pre><code class="language-java">parent.requestFocus();
</code></pre>
<h2 id="85-数据库">8.5 数据库</h2>
<p>默认使用的数据库名为<code>app_test</code>，用户名<code>test_user</code>，密码<code>test_password</code>，<code>resources</code>下有一个<code>init.sql</code>，直接使用MySQL导入即可。<br>
<img src="https://img-blog.csdnimg.cn/2020060611431640.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="86-验证码">8.6 验证码</h2>
<p>默认没有自带验证码功能，由于涉及隐私问题故没有开放，需要的话可以参考笔者的腾讯云短信API使用或者自行搜索其他短信验证API。一些写在配置文件中的API需要的密钥等信息强烈建议加密。</p>
<h1 id="9-源码">9 源码</h1>
<p>前后端完整代码，带README.md说明：</p>
<ul>
<li><a href="https://github.com/2293736867/ASmallSalaryManagementSystem">github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/ASmallSalaryManagementSystem">码云</a></li>
</ul>
<h1 id="10-参考">10 参考</h1>
<p>1、<a href="https://blog.csdn.net/yangguosb/article/details/80619481">CSDN-maven-shade-plugin介绍及使用</a></p>
<p>2、<a href="https://blog.csdn.net/qq_32736999/article/details/93395246">CSDN-Maven3种打包方式之一maven-assembly-plugin的使用</a></p>
<p>3、<a href="https://zhuanlan.zhihu.com/p/82540739">知乎-制作包含Java 11和JavaFX的JRE</a></p>
<p>4、<a href="https://blog.csdn.net/zzzgd_666/article/details/80756430">CSDN-使用exe4j将java文件打成exe文件运行详细教程</a></p>
<p>5、<a href="https://github.com/ulisesbocchio/jasypt-spring-boot/issues/218">Github-jasypt-spring-boot issue</a></p>
<p>6、<a href="https://www.w3cschool.cn/java/javafx-line.html">w3cschool-JavaFX</a></p>
<p>7、<a href="https://www.jianshu.com/p/045f95c008a0">简书-Linux Tomcat+Openssl单向/双向认证</a></p>
<p>如果觉得文章好看，欢迎点赞。</p>
<p>同时欢迎关注微信公众号：氷泠之路。</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200325170404220.jpg" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JFX11+Maven+IDEA 发布跨平台应用的完美解决方案]]></title>
        <id>https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/</id>
        <link href="https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/">
        </link>
        <updated>2020-06-02T21:41:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>前几天写了两篇关于JFX+IDEA打包跨平台应用的文章，<a href="https://blog.csdn.net/qq_27525611/article/details/106444423">这篇</a>是使用IDEA自带功能打包的，<a href="https://blog.csdn.net/qq_27525611/article/details/106433723">这篇</a>是使用Maven进行打包的，但是效果不太满意，因为从JDK9开始实现模块化，同时JFX部分从JDK中独立出来了，也就是说需要默认JDK不再自带JFX。这意味着外部依赖需要手动处理module-info.java，这是一件非常麻烦的事情。</p>
<h2 id="11-不使用maven">1.1 不使用Maven</h2>
<p>其实不使用Maven也能打包发布跨平台JFX应用，但是没有使用Maven的话，虽然打包出来能直接运行无需jre环境，但是，管理依赖确实麻烦，在使用jlink打包一些外部的jar时，对于一些比较简单的jar还是比较舒服的，参照<a href="https://blog.csdn.net/weixin_44326589/article/details/86680972">这里</a>：<br>
<img src="https://img-blog.csdnimg.cn/2020060121462236.png" alt="在这里插入图片描述" loading="lazy"><br>
首先去下载jar，接着生成module-info.java，然后使用jdeps检查依赖，添加对应的jar到路径中，编译生成module-info.java接着更新原来的jar即可。看起来简单，但是笔者碰到了okhttp这种jar，依赖简直环环相扣导致笔者放弃了这种方式。</p>
<h2 id="12-使用maven">1.2 使用Maven</h2>
<p>使用Maven可以完美解决依赖问题，多亏与强大的pom.xml，几行&lt;dependency&gt;就可以解决依赖问题，但是，还是需要手动处理module-info.java，而且IDEA文档明确表明仅支持Java8的打包为jar：<br>
<img src="https://img-blog.csdnimg.cn/20200601220006821.png" alt="在这里插入图片描述" loading="lazy"><br>
因此，这篇文章采取一种最简单的方式利用Maven打包发布JFX11应用。</p>
<h1 id="2-新建maven工程">2 新建Maven工程</h1>
<p><img src="https://img-blog.csdnimg.cn/20200601220303299.png" alt="在这里插入图片描述" loading="lazy"><br>
默认即可，问题不大。<br>
<img src="https://img-blog.csdnimg.cn/20200601220333213.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-添加依赖">3 添加依赖</h1>
<pre><code class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>需要再哪个平台在classifier中指定即可。这里是linux与win。mac的话直接“mac”。<br>
同时指定编码与JDK：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
<p>否则会如此报错：<br>
<img src="https://img-blog.csdnimg.cn/20200601221410548.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-新建main">4 新建Main</h1>
<p>新建一个包再新建Main.java，Launcher.java以及Main.fxml：<br>
<img src="https://img-blog.csdnimg.cn/20200601221808669.png" alt="在这里插入图片描述" loading="lazy"><br>
Main.java：</p>
<pre><code class="language-java">package com.test;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {
    public void start(Stage stage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(&quot;/Main.fxml&quot;));
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle(&quot;Hello World&quot;);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>
<p>Launcher.java：</p>
<pre><code class="language-java">package com.test;

public class Launcher {
    public static void main(String[] args) {
        Main.main(args);
    }
}
</code></pre>
<p>Main.fxml：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;?import javafx.scene.control.*?&gt;
&lt;?import javafx.scene.layout.*?&gt;
&lt;?import javafx.scene.text.*?&gt;


&lt;AnchorPane prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/10.0.2-internal&quot;
            xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.test.Main&quot;&gt;
   &lt;Label layoutX=&quot;228.0&quot; layoutY=&quot;185.0&quot; text=&quot;Hello World&quot;&gt;
      &lt;font&gt;
         &lt;Font size=&quot;25.0&quot;/&gt;
      &lt;/font&gt;
   &lt;/Label&gt;
&lt;/AnchorPane&gt;
</code></pre>
<p>注意getResource中的fxml路径，Main.fxml文件放在resources下，直接通过根路径读取：</p>
<pre><code class="language-java">getResource(&quot;/Main.fxml&quot;);
</code></pre>
<h1 id="5-添加运行配置">5 添加运行配置</h1>
<p>此时应该是没有运行配置的状态，点击Add Configuration：<br>
<img src="https://img-blog.csdnimg.cn/20200601222437737.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Application：<br>
<img src="https://img-blog.csdnimg.cn/2020060122253724.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Launcher类作为Main class：<br>
<img src="https://img-blog.csdnimg.cn/20200601222831910.png" alt="在这里插入图片描述" loading="lazy"><br>
这时候run就没问题了：<br>
<img src="https://img-blog.csdnimg.cn/2020060122292722.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-使用默认maven打包">6 使用默认Maven打包</h1>
<p>虽然现在可以run了，但是，如果直接使用默认的Maven打包的话：<br>
<img src="https://img-blog.csdnimg.cn/20200601223021660.png" alt="在这里插入图片描述" loading="lazy"><br>
在target下有一个jar，直接右键运行：<br>
<img src="https://img-blog.csdnimg.cn/20200601223318755.png" alt="在这里插入图片描述" loading="lazy"><br>
会提示no main manifest attribute：<br>
<img src="https://img-blog.csdnimg.cn/20200601223400146.png" alt="在这里插入图片描述" loading="lazy"><br>
也就是找不到Manifest中入口类。<br>
jar实际上是一个class的压缩包，与zip的区别是jar包含了一个MANIFEST.MF，MANIFEST.MF在META-INF下，一个示例文件如下：<br>
<img src="https://img-blog.csdnimg.cn/20200601224154485.png" alt="在这里插入图片描述" loading="lazy"><br>
有点类似与键值对的格式，MANIFEST.MF包含了jar文件的内容描述，并在运行时向JVM提供应用程序信息。注意该文件有严格的格式限制，比如第一行不能为空，行与行之间不能存在空行。<br>
一个暴力的解决办法是直接解压jar并修改里面的MANIFEST.MF，添加</p>
<pre><code class="language-bash">Main-Class: com.test.Launcher
</code></pre>
<p>但是这样会报找不到Application类的异常：<br>
<img src="https://img-blog.csdnimg.cn/20200602015847355.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-添加新的打包插件">7 添加新的打包插件</h1>
<p>理论上来说，只需要jar包内的相同目录下提供了javafx的jar或者class文件就不会抛出异常了，但是，如果依赖很多需要一个一个添加，这是一个痛苦的过程。<br>
所以，为了优雅地解决这个问题，引入一个叫maven-shade-plugin的插件即可：</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;shade&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;transformers&gt;
                            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
                                &lt;mainClass&gt;com.test.Launcher&lt;/mainClass&gt;
                            &lt;/transformer&gt;
                        &lt;/transformers&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>最新版本请到<a href="https://github.com/apache/maven-shade-plugin">官方github</a>查看，使用时只需要修改：</p>
<pre><code class="language-xml">&lt;mainClass&gt;xxx.xxx.xxx&lt;/mainClass&gt;
</code></pre>
<p>修改为程序入口类。</p>
<h1 id="8-打包">8 打包</h1>
<p>此时再从右侧栏打包选中Maven，package即可：<br>
<img src="https://img-blog.csdnimg.cn/2020060202062726.png" alt="在这里插入图片描述" loading="lazy"><br>
但是会有警告：<br>
<img src="https://img-blog.csdnimg.cn/20200602020908608.png" alt="在这里插入图片描述" loading="lazy"><br>
因为一些class文件重复了，但是也提到了通常来说这是没有危害的并且可以跳过警告，或者修改pom.xml去手动排除某些依赖。</p>
<h1 id="9-运行">9 运行</h1>
<p>直接在IDEA中右键运行或者-jar运行，可以看到没有异常了：<br>
<img src="https://img-blog.csdnimg.cn/20200602021739342.png" alt="在这里插入图片描述" loading="lazy"><br>
相比起原来自带的Maven打包插件，主要是多了javafx的一些class以及对应平台所需要的一些动态库文件等，比如win上的.dll与linux上的.so文件。<br>
<img src="https://img-blog.csdnimg.cn/20200602022014735.png" alt="在这里插入图片描述" loading="lazy"><br>
这样一个跨平台的JFX jar包就制作好了，只需</p>
<pre><code class="language-bash">java -jar
</code></pre>
<p>即可跨平台运行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个开源的跨平台音乐播放与音乐下载器]]></title>
        <id>https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/</id>
        <link href="https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/">
        </link>
        <updated>2020-06-02T21:40:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="跨平台的音乐播放器">跨平台的音乐播放器</h1>
<p>目前国内的linux平台上的音乐播放器不多，除了网易云比较多人使用的。<br>
当然<a href="http://listen1.github.io/listen1/">Listen1</a>也是一个不错的选择，真正的跨平台，包括Android/Mac/Win/Linux以及Chrome插件，目前尚在维护：<br>
<img src="https://img-blog.csdnimg.cn/20200601210615418.png" alt="在这里插入图片描述" loading="lazy"><br>
Listen1其实非常不错，支持歌单功能，可以方便的播放，但美中不足的是没有下载功能。<br>
因此，这里推荐一个带下载以及播放功能的开源音乐软件：<a href="https://github.com/lyswhut/lx-music-desktop">洛雪音乐助手桌面版</a>。<br>
一个基于 Electron + Vue 开发的音乐软件。<br>
<img src="https://img-blog.csdnimg.cn/20200601211058633.png" alt="在这里插入图片描述" loading="lazy"><br>
UI：<br>
<img src="https://img-blog.csdnimg.cn/20200601211200149.png" alt="在这里插入图片描述" loading="lazy"><br>
推荐歌单列表：<br>
<img src="https://img-blog.csdnimg.cn/20200601211239373.png" alt="在这里插入图片描述" loading="lazy"><br>
排行榜：<br>
<img src="https://img-blog.csdnimg.cn/20200601211320388.png" alt="在这里插入图片描述" loading="lazy"><br>
下载功能：<br>
<img src="https://img-blog.csdnimg.cn/20200601211354966.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200601211433744.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFX获取屏幕尺寸]]></title>
        <id>https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/</id>
        <link href="https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/">
        </link>
        <updated>2020-06-02T21:40:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-awt">1 awt</h1>
<pre><code class="language-java">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
double width = screenSize.getWidth();
double height = screenSize.getHeight();
</code></pre>
<h1 id="2-javafx">2 javafx</h1>
<pre><code class="language-java">Rectangle2D screenRectangle = Screen.getPrimary().getBounds();
double width = screenRectangle.getWidth();
double height = screenRectangle.getHeight();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OkHttp:NoClassDefFoundError]]></title>
        <id>https://2293736867.github.io/post/okhttpnoclassdeffounderror/</id>
        <link href="https://2293736867.github.io/post/okhttpnoclassdeffounderror/">
        </link>
        <updated>2020-06-02T21:39:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>使用OkHttp时报错：</p>
<pre><code class="language-bash">Caused by: java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at okhttp3@4.7.2/okhttp3.FormBody$Builder.add(FormBody.kt)
</code></pre>
<h1 id="2-原因">2 原因</h1>
<p>由于OkHttp依赖于okio，目前OkHttp最新的版本为4.7.2，使用Maven/Gradle导入的话不会出现该问题，原因应该是只是单纯把OkHttp的jar导入，还需要把okio一并导入，但是需要知道OkHttp对应的okio版本，可以通过Maven导入查看，比如4.7.2对应的是2.6.0。<br>
<img src="https://img-blog.csdnimg.cn/20200531113523502.png" alt="在这里插入图片描述" loading="lazy"><br>
如果已经添加了okio则可以跳过，另外还需要添加kotlin-stdlib库，使用最新版本即可，目前最新版本为1.3.72。<br>
下载链接<a href="https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-stdlib">戳这里</a>。</p>
<h1 id="3-解决方案">3 解决方案</h1>
<p>把对应版本的okio以及kotlin-stdlib添加到依赖库即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jasypt-spring-boot提示Failed to bind properties]]></title>
        <id>https://2293736867.github.io/post/jasypt-spring-boot-ti-shi-failed-to-bind-properties/</id>
        <link href="https://2293736867.github.io/post/jasypt-spring-boot-ti-shi-failed-to-bind-properties/">
        </link>
        <updated>2020-06-02T21:39:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>在Spring Boot中使用jasypt-spring-boot进行加密，但是提示：</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.password' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>或提示</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.url' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>最后的异常是这个：<br>
<img src="https://img-blog.csdnimg.cn/20200531013232211.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-解决办法">2 解决办法</h1>
<p>查阅了相关<a href="https://github.com/ulisesbocchio/jasypt-spring-boot/issues/154">issue</a>，发现是3.0.2更改了默认的加密算法，最后的办法是把版本降到2.1.2：<br>
<img src="https://img-blog.csdnimg.cn/20200531014007872.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;
    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>接着重新加密配置，但是2.1.2不支持使用环境变量作为加密的口令，在IDEA中测试的时候需要在运行配置加上</p>
<pre><code class="language-bash">-Djasypt.encryptor.password=xxxx
</code></pre>
<p>部署到Tomcat时添加环境变量：</p>
<pre><code class="language-bash">export JAVA_OPTS=&quot;-Djasypt.encryptor.password=xxxx&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JFX11+IDEA跨平台打包发布的完美解决办法]]></title>
        <id>https://2293736867.github.io/post/jfx11idea-kua-ping-tai-da-bao-fa-bu-de-wan-mei-jie-jue-ban-fa/</id>
        <link href="https://2293736867.github.io/post/jfx11idea-kua-ping-tai-da-bao-fa-bu-de-wan-mei-jie-jue-ban-fa/">
        </link>
        <updated>2020-06-02T21:38:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>IDEA2020.1的文档中提到只有JFX8的工程才支持打成jar包，并且，如果直接使用Build Artifacts的话，会如下提示：<br>
<img src="https://img-blog.csdnimg.cn/2020053017384177.png" alt="在这里插入图片描述" loading="lazy"><br>
<a href="https://www.jetbrains.com/help/idea/packaging-javafx-applications.html">IDEA文档</a>有提到这个的解决办法，是使用一些<a href="https://openjfx.io/openjfx-docs/#install-javafx">第三方工具</a>。里面介绍了通过IDEA结合自身/Maven/Gradle打包发布JFX11以上版本的方法。但是，不足的地方有：</p>
<ul>
<li>直接创建JFX工程默认只有一个src目录，不像Maven工程还带有resources与test，给管理资源文件以及外部依赖造成了困难，getClass().getResource()会出现空指针问题，但是好处是只需具备JDK环境，打包出来的文件能带上jmods能跨平台直接运行</li>
<li>直接创建Maven项目虽然是管理依赖以及资源文件方便，但是无论是直接通过Maven打出的jar包还是通过JavaFX Maven Plugins打出来的jar包默认绑定了开发平台的JFX SDK，简单地说就是Linux开发的JFX程序不能直接跑在具有JDK环境的Win上，因为用的是Linux的JFX SDK而不是Win的JFX SDK</li>
</ul>
<p>因此，本文结合这两者的优点，参照Maven的目录管理，以JFX工程为基础，记录了从新建工程到发布跨平台JFX应用的过程。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>IDEA 2020.1</li>
<li>OpenJDK 11</li>
<li>OpenJFX 11 Linux SDK</li>
<li>OpenJFX 11 Linux/Windows/Mac OS X jmods</li>
</ul>
<p>JDK安装就不说了，JFX直接下载然后在工程中通过外部库引入即可，三种jmods解压出来即可，用于最后生成可执行文件时添加的模块。<br>
下载链接<a href="https://gluonhq.com/products/javafx/">戳这里</a>。</p>
<h1 id="3-新建jfx工程">3 新建JFX工程</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530175758622.png" alt="在这里插入图片描述" loading="lazy"><br>
这里的项目名为TestJFX，对应修改即可。<br>
<img src="https://img-blog.csdnimg.cn/20200530175913541.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-添加jfx11-sdk">4 添加JFX11 SDK</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530180127745.png" alt="在这里插入图片描述" loading="lazy"><br>
添加上一步下载的对应平台的JFX SDK。<br>
<img src="https://img-blog.csdnimg.cn/20200530180205495.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-添加module-infojava">5 添加module-info.java</h1>
<p>在src目录右键New-&gt;module-info.java，修改如下：</p>
<pre><code class="language-ruby">module TestJFX {
    requires javafx.fxml;
    requires javafx.controls;
    
    opens sample to javafx.fxml;
    exports sample;
}
</code></pre>
<p>其中TestJFX为新建项目时的项目名，这个创建module-info.java时就默认加上了，sample为默认包，对应修改。</p>
<h1 id="6-添加vm-options">6 添加VM Options</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530181426399.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200531023450900.png" alt="在这里插入图片描述" loading="lazy"><br>
添加</p>
<pre><code class="language-bash">--module-path /usr/local/jfx/lib:out/production
</code></pre>
<p>其中</p>
<pre><code class="language-bash">/usr/local/jfx/lib
</code></pre>
<p>为下载的JFX JDK的lib目录，后面的out不需要更改，是默认的编译输出的目录。</p>
<h1 id="7-运行">7 运行</h1>
<p>这时候应该可以Shift+F10或者点击绿色小三角运行了：<br>
<img src="https://img-blog.csdnimg.cn/20200530181814745.png" alt="在这里插入图片描述" loading="lazy"><br>
当然内容是空的，因为什么也没有加。</p>
<h1 id="8-添加资源文件">8 添加资源文件</h1>
<p>默认的fxml是放在与Main类同一目录下的，getResource()也没有加路径直接写上文件名：<br>
<img src="https://img-blog.csdnimg.cn/20200530195546612.png" alt="在这里插入图片描述" loading="lazy"><br>
但是这是src文件夹，放个fxml还勉强可以接受，放张图片总不合适吧？所以，新建一个资源文件夹，把css，fxml什么的都放里面：<br>
<img src="https://img-blog.csdnimg.cn/20200530195911419.png" alt="在这里插入图片描述" loading="lazy"><br>
直接在IDEA中移动fxml文件，Main中的引用路径也自动更改，不得不说这个特性是真的好用，但遗憾的是，抛出了空指针异常。<br>
因此采取绝对路径来进行读取文件，通过URL+System.getProperty()指定绝对路径：</p>
<pre><code class="language-java">@Override
public void start(Stage primaryStage) throws Exception{
    String path = System.getProperty(&quot;user.dir&quot;);
    URL fxmlUrl = new URL(&quot;file:&quot;+path+&quot;/resources/fxml/sample.fxml&quot;);
    Parent root = FXMLLoader.load(fxmlUrl);
    primaryStage.setTitle(&quot;Hello World&quot;);
    Scene scene = new Scene(root);
    scene.getStylesheets().add(new URL(&quot;file:&quot;+path+&quot;/resources/css/1.css&quot;).toString());
    primaryStage.setScene(scene);
    primaryStage.show();
}
</code></pre>
<p>其中</p>
<pre><code class="language-java">System.getProperty(&quot;user.dir&quot;)
</code></pre>
<p>获取项目路径，注意URL前面要加上“file:”，css的获取也同理，只不过是需要转换为String。</p>
<h1 id="9-外部依赖">9 外部依赖</h1>
<p>由于没有了Maven管理依赖，所以外部依赖的管理会相对麻烦一点，基本上是以jar包的形式手动添加，这里以添加Gson为例，<a href="https://mvnrepository.com/artifact/com.google.code.gson/gson">戳这里</a>下载jar包，然后在项目目录下新建一个lib文件夹，把jar包放进去：<br>
<img src="https://img-blog.csdnimg.cn/20200531023924445.png" alt="在这里插入图片描述" loading="lazy"><br>
接着在项目结构中把整个lib文件夹添加到外部库：<br>
<img src="https://img-blog.csdnimg.cn/20200531022019954.png" alt="在这里插入图片描述" loading="lazy"><br>
然后VM Options中添加lib路径，在上面的VM Options后面加一个冒号和lib就行：<br>
<img src="https://img-blog.csdnimg.cn/20200531022600107.png" alt="在这里插入图片描述" loading="lazy"><br>
但是，此时可以IDEA还不能进行补全，最后需要修改module-info.java：<br>
<img src="https://img-blog.csdnimg.cn/20200531022743664.png" alt="在这里插入图片描述" loading="lazy"><br>
加一行requires，此时IDEA能够进行补全了，每个jar包都不同，对应修改即可。</p>
<h1 id="10-制作跨平台镜像">10 制作跨平台镜像</h1>
<p>运行没问题之后就可以制作运行时镜像发布了，终端进入项目根路径：</p>
<pre><code class="language-bash">jlink --module-path jmod/linux:out/production:lib --add-modules TestJFX --output linux
linux/bin/java -m TestJFX/sample.Main
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200531030506500.png" alt="在这里插入图片描述" loading="lazy"><br>
其中</p>
<pre><code class="language-bash">jmod/linux
</code></pre>
<p>为开发平台jmod的路径，可以是绝对路径，也可以是相对与项目根目录的相对路径，out/production与上面的VM Options保持一致。</p>
<pre><code class="language-bash">--add-modules
</code></pre>
<p>后面跟的是模块名，这是在生成module-info.java时指定的，为项目名。</p>
<pre><code class="language-bash">--output
</code></pre>
<p>为输出目录。<br>
后一条命令中-m指定模块名，后面跟包名+主类名。<br>
这样linux平台的镜像就制作好了，Mac与Win的同理，只需要把jmod换成对应平台的jmod即可，但是注意语法有一些差别，Mac的语法同Linux，只需要把jmod路径换一下，但是注意需要整个工程在对应的平台进行jlink：</p>
<pre><code class="language-bash">jlink --module-path xxxxx/{MAC_JMOD}:out/production:lib --add-modules TestJFX --output mac
mac/bin/java -m TestJFX/sample.Main
</code></pre>
<p>Win的语法有些区别，一样需要在Win下进行jlink：</p>
<pre><code class="language-bash">jlink --module-path &quot;xxxxx/{WIN_JMOD};out/production&quot; --add-modules TestJFX --output win
win\bin\java -m TestJFX/sample.Main
</code></pre>
<p>下面是Win下的截图：<br>
<img src="https://img-blog.csdnimg.cn/20200531025545467.PNG" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="11-demo">11 demo</h1>
<p><a href="https://github.com/2293736867/JFX11-IDEA-Test-Project">github</a></p>
<h1 id="12-参考">12 参考</h1>
<p><a href="https://openjfx.io/openjfx-docs/#maven">Getting Started with JavaFX</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA通过Maven打包JavaFX工程（OpenJFX11）]]></title>
        <id>https://2293736867.github.io/post/idea-tong-guo-maven-da-bao-javafx-gong-cheng-openjfx11/</id>
        <link href="https://2293736867.github.io/post/idea-tong-guo-maven-da-bao-javafx-gong-cheng-openjfx11/">
        </link>
        <updated>2020-06-02T21:38:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>最近研究JFX，写出来了但是打包不了，这。。。尴尬。。。<br>
<a href="https://www.jetbrains.com/help/idea/packaging-javafx-applications.html#">IDEA的文档</a>说只支持Java8打成jar包：<br>
<img src="https://img-blog.csdnimg.cn/20200529220753361.png" alt="在这里插入图片描述" loading="lazy"><br>
尝试过直接使用Maven插件的package，不行，也尝试过Build Artifacts，也不行，各种奇奇怪怪的问题。包括下图中的</p>
<pre><code class="language-bash">Error....fx:deploy is not available in this JDK
</code></pre>
<p>不过幸好文档末尾提到可以使用一些<a href="https://openjfx.io/openjfx-docs/#maven">第三方工具</a>：<br>
<img src="https://img-blog.csdnimg.cn/20200529220849122.png" alt="在这里插入图片描述" loading="lazy"><br>
因此记录一下使用IDEA打包JFX11工程的过程。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>IDEA 2020.1</li>
<li>OpenJDK 11</li>
<li>OpenJFX 11</li>
</ul>
<p>只需安装IDEA与JDK即可，JFX可以在pom.xml中引入。</p>
<h1 id="3-创建工程">3 创建工程</h1>
<p>选择Maven，选择Create from archetype，然后Add Archetype并填上GroupId：</p>
<pre><code class="language-bash">org.openjfx
</code></pre>
<p>与ArtifactId：</p>
<pre><code class="language-bash">javafx-maven-archetypes
</code></pre>
<p>还有version：</p>
<pre><code class="language-bash">0.0.1
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200529222351159.png" alt="在这里插入图片描述" loading="lazy"><br>
下一步自定义，这里为了方便就直接默认了。<br>
<img src="https://img-blog.csdnimg.cn/20200529222436539.png" alt="在这里插入图片描述" loading="lazy"><br>
然后修改archetypeArtifactId为</p>
<pre><code class="language-bash">javafx-archetype-fxml
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200529223233339.png" alt="在这里插入图片描述" loading="lazy"><br>
完成即可。</p>
<h1 id="4-检查文件">4 检查文件</h1>
<p>Maven同步完后，检查项目目录下的module-info.java与pom.xml，其中pom.xml不应该是下图这样的：<br>
<img src="https://img-blog.csdnimg.cn/20200529222717282.png" alt="在这里插入图片描述" loading="lazy"><br>
而应该是这样的，包含了javafx.controls与javafx.fxml依赖，还有javafx-maven-plugin插件：<br>
<img src="https://img-blog.csdnimg.cn/20200529223421120.png" alt="在这里插入图片描述" loading="lazy"><br>
同时src下的module-info.java应该长这样：<br>
<img src="https://img-blog.csdnimg.cn/20200529223524571.png" alt="在这里插入图片描述" loading="lazy"><br>
module-info.java包含了所需要的javafx.controls与javafx.fxml这两个模块。</p>
<h1 id="5-修改插件依赖">5 修改插件依赖</h1>
<p>默认的javafx-maven-plugin版本应该为0.0.1：<br>
<img src="https://img-blog.csdnimg.cn/20200529223713794.png" alt="在这里插入图片描述" loading="lazy"><br>
整个去掉，修改为：</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.0.4&lt;/version&gt;
    &lt;configuration&gt;
        &lt;stripDebug&gt;true&lt;/stripDebug&gt;
        &lt;compress&gt;2&lt;/compress&gt;
        &lt;noHeaderFiles&gt;true&lt;/noHeaderFiles&gt;
        &lt;noManPages&gt;true&lt;/noManPages&gt;
        &lt;launcher&gt;launcher&lt;/launcher&gt;
        &lt;jlinkImageName&gt;output&lt;/jlinkImageName&gt;
        &lt;jlinkZipName&gt;outputzip&lt;/jlinkZipName&gt;
        &lt;mainClass&gt;org.openjfx.App&lt;/mainClass&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>其中launcher为可执行文件名，jlinkImageName为Image输出目录名，jlinkZipName为zip文件名，mainClass为主类。</p>
<h1 id="6-运行并打包">6 运行并打包</h1>
<p>从右侧栏的Maven通过javafx插件运行并打包：<br>
<img src="https://img-blog.csdnimg.cn/20200529224201517.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200529224909134.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-测试">7 测试</h1>
<p>根据修改插件时的目录，进入对应的target下的子目录直接运行即可：</p>
<pre><code class="language-bash">项目目录/target/output/bin/launcher
</code></pre>
<p>注意这个是跨平台的，只需具备JDK11环境即可，发布只需要把zip文件发布。</p>
<h1 id="8-demo">8 demo</h1>
<ul>
<li><a href="https://github.com/2293736867/IDEA-JFX-Project-Example">github</a></li>
<li><a href="https://gitee.com/imykr/IDEA-JFX-Project-Example">码云</a></li>
</ul>
<h1 id="9-扩展阅读">9 扩展阅读</h1>
<p>这篇文章是OpenJFX的文档，主要介绍了：</p>
<ul>
<li>通过三种方式（JFX+Maven+Gradle）运行Hello World</li>
<li>构建运行镜像（CLI+Maven+Gradle+自定义镜像）</li>
<li>IntelliJ/NetBeans/Eclipse通过三种方式（IDE自身+Maven+Gradle）运行与打包JFX</li>
</ul>
<p>链接<a href="https://openjfx.io/openjfx-docs/#introduction">戳这里</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA 配置文件位置]]></title>
        <id>https://2293736867.github.io/post/idea-pei-zhi-wen-jian-wei-zhi/</id>
        <link href="https://2293736867.github.io/post/idea-pei-zhi-wen-jian-wei-zhi/">
        </link>
        <updated>2020-06-02T21:37:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-idea-20201-以上">1 IDEA 2020.1 以上</h1>
<h2 id="11-win">1.1 Win</h2>
<p>语法：</p>
<pre><code class="language-bash">%APPDATA%\JetBrains\&lt;product&gt;&lt;version&gt;
</code></pre>
<p>Win上的APPDATA默认位置如下：</p>
<pre><code class="language-bash">C:\Users\用户名\AppData\Roaming
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2020.1
</code></pre>
<h2 id="12-macos">1.2 MacOS</h2>
<p>语法：</p>
<pre><code class="language-bash">~/Library/Application Support/JetBrains/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/Library/Application Support/JetBrains/IntelliJIdea2020.1
</code></pre>
<h2 id="13-linux">1.3 Linux</h2>
<p>语法：</p>
<pre><code class="language-bash">~/.config/JetBrains/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/.config/JetBrains/IntelliJIdea2020.1
</code></pre>
<h1 id="2-idea-20193x以下">2 IDEA 2019.3.x以下</h1>
<h2 id="21-win">2.1 Win</h2>
<p>语法：</p>
<pre><code class="language-bash">%HOMEPATH%\\.&lt;product&gt;&lt;version&gt;\config
</code></pre>
<p>Win的HOMEPATH默认为：</p>
<pre><code class="language-bash">\Users\用户名
</code></pre>
<p>注意，无盘符。<br>
例子：</p>
<pre><code class="language-bash">C:\Users\用户名\.IntelliJIdea2019.3\config
</code></pre>
<h2 id="22-macos">2.2 MacOS</h2>
<p>语法：</p>
<pre><code class="language-bash">~/Library/Preferences/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/Library/Preferences/IntelliJIdea2019.3
</code></pre>
<h2 id="23-linux">2.3 Linux</h2>
<p>语法：</p>
<pre><code class="language-bash">~/.&lt;product&gt;&lt;version&gt;/config
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/.IntelliJIdea2019.3/config
</code></pre>
]]></content>
    </entry>
</feed>