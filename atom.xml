<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-08-03T17:59:33.679Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第48期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-48-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-48-qi/">
        </link>
        <updated>2020-08-03T17:32:36.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596475980893.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>有时候别人对你很冷淡，可能并不是你的问题。他也许只是不喜欢丑而已。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>在香水中，海狸香是一种温暖，肉欲且类似皮革的香味，目前已经可以人工合成，这种香最初来自于成年北美海狸的腺囊，海狸会将其与粪便结合使用以标记领土。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>夜饮东坡醒复醉，归来仿佛三更。<br>
——苏轼《临江仙·夜饮东坡醒复醉》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>没有回忆就去创造回忆，没有道路就去开辟道路。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=864100237">游戏关系-钟洁</a></p>
</blockquote>
<blockquote>
<p>你放心我在学会我忘记<br>
不再自作多情我选择放弃<br>
这是我给你留下最后的赠礼<br>
再见了</p>
</blockquote>
<blockquote>
<p>关于你的回忆<br>
删除也已经来不及<br>
努力的不去想起<br>
却无能为力<br>
总是在夜深人静<br>
默默的想你<br>
和我在一起<br>
排队买奶茶一起<br>
看电影一起<br>
打游戏一起<br>
如此而已<br>
可是那又怎么样<br>
就算我们在一起<br>
他的电话响起<br>
你会音量降低<br>
然后说要回去<br>
我都知道<br>
你以为我蒙在鼓里<br>
你的家在他那里</p>
</blockquote>
<blockquote>
<p>我无能为力拥有你<br>
我无能为力拥抱你<br>
我无能为力挽留你<br>
我无能为里忘记你</p>
</blockquote>
<blockquote>
<p>所以啊直觉啊<br>
这个东西还是挺准的<br>
所以在你回家之前<br>
在你胸前吻了很多草莓印<br>
接到你男朋友的电话<br>
他问我这么晚了找你干吗<br>
你不知道当时我的内心多么痛<br>
可你却是在旁一句话都不说<br>
其实我还是抱有一丝幻想<br>
以为你会放弃他跟我走<br>
结果你就回了一个字&quot;我...&quot;<br>
我放弃了这次我没有熬夜也没喝酒<br>
这首歌不是送给你的<br>
我只是在发泄我的情绪</p>
</blockquote>
<blockquote>
<p>我无能为力拥有你<br>
我无能为力拥抱你<br>
我无能为力挽留你<br>
我无能为力忘记你</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第47期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-47-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-47-qi/">
        </link>
        <updated>2020-08-03T17:18:15.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596475118052.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你以为向生活低头就好了？生活是想让你跪下。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>新年之夜，意大利人会穿上红色内衣裤以为自己带来好运。这是一种可以追溯到中世纪的传统，当时男人们会在腹股沟披上红帘以保护珍贵的子孙根免遭女巫毒手。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>飞絮飞花何处是，层冰积雪摧残，疏疏一树五更寒。<br>
——纳兰性德《临江仙·寒柳》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>忘羡一曲远，曲终人不散。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=101085">为龙-河图</a></p>
</blockquote>
<blockquote>
<p>手心上 亘古的月光<br>
那道伤 一笑而过的苍凉<br>
翘首觐向 你伫立一方<br>
是你生而为龙的猖狂<br>
谨记你的姓名是炎黄</p>
</blockquote>
<blockquote>
<p>烽燧上 战地的残阳<br>
断刃旁 岁月悄然的流淌<br>
十二章纹 你遥祭四望<br>
血脉奔腾的黄河长江<br>
是你与生俱来的张扬</p>
</blockquote>
<blockquote>
<p>风雨打尽红墙和绿瓦<br>
丹青留下明日的黄花<br>
汉字里墨香温存的一笔一划<br>
世代传承的表达<br>
盛衰荣辱斑驳了脸颊<br>
千载过后洗净了铅华<br>
一直坚守的土壤在你脚下<br>
至死不渝的回答</p>
</blockquote>
<blockquote>
<p>烽燧上 战地的残阳<br>
断刃旁 岁月悄然的流淌<br>
十二章纹 你遥祭四望<br>
血脉奔腾的黄河长江<br>
是你与生俱来的张扬</p>
</blockquote>
<blockquote>
<p>风雨打尽红墙和绿瓦<br>
丹青留下明日的黄花<br>
汉字里温存的一笔一划<br>
世代传承的表达<br>
盛衰荣辱斑驳了脸颊<br>
千载过后洗净了铅华<br>
一直坚守的土壤在你脚下<br>
至死不渝的回答</p>
</blockquote>
<blockquote>
<p>风雨打尽红墙和绿瓦<br>
丹青留下明日的黄花<br>
汉字里墨香温存的一笔一划<br>
世代传承的表达<br>
盛衰荣辱斑驳了年华<br>
千载过后洗净了铅华<br>
一直坚守的土壤在你脚下<br>
至死不渝的回答</p>
</blockquote>
<blockquote>
<p>藏心上 亘古的月光<br>
怀中殇 不再回眸的苍凉<br>
翘首觐向 你伫立此方<br>
谨记生而为龙的模样<br>
谨记我的姓名是炎黄</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十二）：观察者模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-er-guan-cha-zhe-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-er-guan-cha-zhe-mo-shi/">
        </link>
        <updated>2020-08-03T17:16:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>观察者模式使用频率很高，用于建立一种对象之间的依赖关系，当一个对象发生改变时自动通知其他对象，其他对象将做出相应反应。在观察者模式中，<strong>发生改变的对象叫做观察目标，也叫被观察者，而被通知的对象叫做观察者。</strong></p>
<p>一个观察目标可以对应多个观察者，而且这些观察者之间没有任何相互关联，可以根据需要增加和删除观察者，使得系统便于扩展。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>观察者模式：定义对象之间的一种一对多依赖关系，使得每一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新。</strong></p>
<p>观察者模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020080310384888.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Subejct</code>（抽象目标）：又叫主题，指被观察的对象，也就是被观察者，在目标中定义了一个观察者集合，同时提供一系列方法来增加或者删除观察者对象，也定义了通知方法<code>notify</code></strong></li>
<li><strong><code>ConcreteSubject</code>（具体目标）：抽象目标的子类，通常包含有经常改变的数据，当状态发生改变时，向各个观察者发出通知，同时还实现了目标类中定义的抽象业务逻辑，如果无须扩展抽象目标类则可以省略具体目标类</strong></li>
<li><strong><code>Observer</code>（抽象观察者）：对观察目标作出响应，一般定义为接口</strong></li>
<li><strong><code>ConcreteObserver</code>（具体观察者）：具体观察者中维护一个指向具体目标的引用，存储具体观察者的有关状态，这些状态需要与具体目标的状态保持一致，同时实现了抽象观察者的<code>update</code>方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象观察者：接口/抽象类，声明状态更新方法</li>
<li>定义具体观察者：继承/实现抽象观察者，实现状态更新方法</li>
<li>定义抽象目标：包含一个存储抽象观察者的集合，与一个类似<code>notifyObserver</code>的通知观察者的抽象方法</li>
<li>定义具体目标：继承抽象目标类，实现其中通知观察者的方法</li>
</ul>
<h2 id="22-抽象观察者">2.2 抽象观察者</h2>
<pre><code class="language-java">interface Observer
{
    void update(String state);
}
</code></pre>
<p>这里实现为一个接口，<code>update</code>方法供抽象目标，也就是供被观察者调用。</p>
<h2 id="23-具体观察者">2.3 具体观察者</h2>
<pre><code class="language-java">class ConcreteObserver implements Observer
{
    public String state;
    public ConcreteObserver(String state)
    {
        this.state = state;
    }
    @Override
    public void update(String state)
    {
        System.out.println(&quot;观察者状态更新为&quot;+state);
    }
}
</code></pre>
<p>实现其中的<code>update</code>方法，这里只是简单将状态输出。</p>
<h2 id="24-抽象目标类">2.4 抽象目标类</h2>
<pre><code class="language-java">abstract class Subject
{
    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();
    public void attach(Observer observer)
    {
        list.add(observer);
    }

    public void detach(Observer observer)
    {
        list.remove(observer);
    }

    public void notifyObservers(String state)
    {
        list.forEach(t-&gt;t.update(state));
    }

    public abstract void change(String newState);
}
</code></pre>
<p>抽象目标类负责管理观察者集合，使用<code>List</code>存储抽象观察者，包含添加/删除观察者方法。<code>notifyObservers</code>中通知了所有的观察者，将状态作为具体参数进行传递。<code>change</code>作为被观察者的状态改变函数，将新状态作为参数传入。</p>
<h2 id="25-具体目标类">2.5 具体目标类</h2>
<pre><code class="language-java">class ConcreteSubject extends Subject
{
    private String state;
    public String getState()
    {
        return state;
    }

	@Override
    public void change(String newState)
    {
        state = newState;
        System.out.println(&quot;被观察者状态为:&quot;+newState);
        notifyObservers(newState);
    }
}
</code></pre>
<p>具体目标类负责实现抽象目标的<code>change</code>方法，保存新状态后，通过抽象目标的<code>notifyObservers</code>通知所有观察者。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Observer observer1 = new ConcreteObserver(&quot;111&quot;);
    Observer observer2 = new ConcreteObserver(&quot;111&quot;);
    Observer observer3 = new ConcreteObserver(&quot;111&quot;);

    Subject subject = new ConcreteSubject();
    subject.attach(observer1);
    subject.attach(observer2);
    subject.attach(observer3);
    subject.change(&quot;2222&quot;);        
}
</code></pre>
<p>客户端针对抽象观察者以及抽象目标进行编程，定义好各个观察者后，添加到抽象目标中进行管理，接着更新被观察者的状态。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200803164146531.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>一个多人联机游戏中，拥有战队机制，当基地受到攻击时，将通知该战队所有成员进入警戒状态，使用观察者模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象观察者：<code>Observer</code></li>
<li>具体观察者：<code>Player</code></li>
<li>抽象目标：<code>Subject</code></li>
<li>具体目标：<code>Base</code></li>
</ul>
<p>抽象观察者：</p>
<pre><code class="language-java">interface Observer
{
    void update(String state);
}
</code></pre>
<p>包含一个供抽象目标调用的<code>update()</code>方法。</p>
<p>接着是具体观察者：</p>
<pre><code class="language-java">class Player implements Observer
{
    public String state;
    public String name;
    public Player(String name,String state)
    {
        this.name = name;
        this.state = state;
    }
    @Override
    public void update(String state)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;状态更新为&quot;+state);
    }
}
</code></pre>
<p>在<code>update</code>中输出更新的状态。</p>
<p>抽象目标如下：</p>
<pre><code class="language-java">abstract class Subject
{
    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();
    public void attach(Observer observer)
    {
        list.add(observer);
    }

    public void detach(Observer observer)
    {
        list.remove(observer);
    }

    public void notifyObservers(String state)
    {
        System.out.println(&quot;基地通知所有战队成员&quot;);
        list.forEach(t-&gt;t.update(state));
    }

    public abstract void change(String newState);
}
</code></pre>
<p>使用<code>List</code>存储所有战队成员，在通知方法中通知所有的观察者，<code>change</code>定义为抽象方法供子类实现。</p>
<p>具体目标（被观察者）如下：</p>
<pre><code class="language-java">class Base extends Subject
{
    private String state;
    public String getState()
    {
        return state;
    }

    @Override
    public void change(String newState)
    {
        state = newState;
        System.out.println(&quot;基地状态更新为:&quot;+newState);
        notifyObservers(newState);
    }
}
</code></pre>
<p>实现抽象目标的<code>change</code>方法，里面需要调用<code>notifyObservers</code>方法通知所有观察者。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Observer player1 = new Player(&quot;A&quot;,&quot;无警戒状态&quot;);
    Observer player2 = new Player(&quot;B&quot;,&quot;无警戒状态&quot;);
    Observer player3 = new Player(&quot;C&quot;,&quot;无警戒状态&quot;);

    Subject subject = new Base();
    subject.attach(player1);
    subject.attach(player2);
    subject.attach(player3);
    subject.change(&quot;警戒状态&quot;);        
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200803165611601.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-推拉模型">4 推/拉模型</h1>
<p>在观察者模式中，可以分为推模型以及拉模型。</p>
<h2 id="41-推模型">4.1 推模型</h2>
<p>推模型是被观察者向观察者推送观察目标的详细信息，不管观察者是否需要，推送的信息通常是被观察者对象的全部或部分数据。像上面的例子就是推模型，被观察者（基地）主动把状态数据推送给观察者（战队成员）。</p>
<h2 id="42-拉模型">4.2 拉模型</h2>
<h3 id="421-概述">4.2.1 概述</h3>
<p>拉模型当被观察者通知观察者时，只传递少量信息，如果观察者需要更加详细的信息，由观察者主动到观察目标中获取，相当于时观察者从主题对象中拉去数据。这种方式一般把被观察者自身通过<code>update</code>传递给观察者，获取数据时时直接通过这个被观察者引用获取。</p>
<h3 id="422-实例">4.2.2 实例</h3>
<p>可以将上面的基地例子修改从推模型修改为拉模型，首先修改观察者中的<code>update()</code>参数：</p>
<pre><code class="language-java">interface Observer
{
    void update(Subject subject);
}
</code></pre>
<p>接着修改具体观察者：</p>
<pre><code class="language-java">class Player implements Observer
{
    public String state;
    public String name;
    public Player(String name,String state)
    {
        this.name = name;
        this.state = state;
    }
    @Override
    public void update(Subject subject)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;状态更新为&quot;+subject.getState());
    }
}
</code></pre>
<p>主要的不同是原来的推模型直接把状态作为参数传递，现在传递一个抽象目标对象，需要具体观察者从中主动获取数据。</p>
<p>然后是抽象目标：</p>
<pre><code class="language-java">abstract class Subject
{
    private String state;
    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();
    public void attach(Observer observer)
    {
        list.add(observer);
    }

    public void detach(Observer observer)
    {
        list.remove(observer);
    }

    public void notifyObservers()
    {
        System.out.println(&quot;基地通知所有战队成员&quot;);
        list.forEach(t-&gt;t.update(this));
    }

    public String getState()
    {
        return state;
    }

    public void setState(String state)
    {
        this.state = state;
    }

    public abstract void change(String newState);
}
</code></pre>
<p>主要改变是多了一个<code>state</code>成员，同时去掉<code>notifyObservers()</code>中的参数。</p>
<p>最后是具体目标：</p>
<pre><code class="language-java">class Base extends Subject
{
    @Override
    public void change(String newState)
    {
        setState(newState);
        System.out.println(&quot;基地状态更新为:&quot;+newState);
        notifyObservers();
    }
}
</code></pre>
<p>客户端代码无须任何修改，测试输出结果一致：<br>
<img src="https://img-blog.csdnimg.cn/20200803171133817.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="43-两者比较">4.3 两者比较</h2>
<ul>
<li>推模型是假定被观察者知道观察者需要的数据，主动推送相关的数据，但是当不同的观察者需要不同的数据时候会出现麻烦，因为不能根据每一个不同的观察者提供不同的数据，或者提供新的<code>update</code>方法</li>
<li>拉模型是直接把被观察者的引用传递，观察者按需要从中获取数据，适用情况比推模型要广</li>
</ul>
<h1 id="5-java中的观察者">5 Java中的观察者</h1>
<h2 id="51-observer与observable">5.1 <code>Observer</code>与<code>Observable</code></h2>
<p>观察者模式在Java中非常重要，JDK的<code>java.util</code>提供了<code>Observer</code>以及<code>Observable</code>接口作为对观察者模式的支持。</p>
<h3 id="511-observer">5.1.1 <code>Observer</code></h3>
<p><code>java.util.Observer</code>接口充当抽象观察者，只声明了一个方法：</p>
<pre><code class="language-java">void update(Observable o,Object arg);
</code></pre>
<p>当观察目标的状态发生变化时，该方法会被调用，在<code>Observer</code>子类实现<code>update</code>，不同的具体观察者具有不同的更新行为，当调用<code>Observable</code>的<code>notifyObservers()</code>时，将执行<code>update</code>方法。</p>
<p><code>update</code>的接口两个参数中，一个表示被观察者，一个表示调用<code>notifyObservers</code>的参数，换句话说，这样设计能同时支持推模型与拉模型：</p>
<ul>
<li>使用推模型时，被观察者在<code>notifyObervers()</code>中传入<code>arg</code>参数，也就是<code>update</code>中的<code>arg</code>参数</li>
<li>使用拉模型时，被观察者不需要在<code>notifyObservers</code>中传入参数，但是需要在被观察者中声明获取状态或数据的方法，方便在<code>update</code>中通过被观察者引用<code>o</code>进行强制类型转换后调用</li>
</ul>
<h3 id="512-observable">5.1.2 <code>Observable</code></h3>
<p><code>java.util.Observable</code>充当抽象目标类，其中定义了一个<code>Vector</code>存储观察者对象，包含的方法（OpenJDK11.0.2）如下：</p>
<pre><code class="language-java">public class Observable {
    private boolean changed = false;
    private Vector&lt;Observer&gt; obs;
    public Observable() {
		//构造函数，初始化 obs
    }
    public synchronized void addObserver(Observer o) {
    	//注册观察者到obs中
    }
    public synchronized void deleteObserver(Observer o) {
		//删除obs中的某个观察者
    }
    public void notifyObservers() {
    	//通知方法，内部调用每一个观察者的update()
    }
    public void notifyObservers(Object arg) {
    	//类似上面的通知方法，带参数调用update()
    }
    public synchronized void deleteObservers() {
    	//删除所有观察者
    }
    protected synchronized void setChanged() {
    	//设置changed为true，表示观察目标的状态发生变化
    }
    protected synchronized void clearChanged() {
    	//清除changed的状态，表示观察目标状态不再发生改变
    	//或者已经通知了所有的观察者
    }
    public synchronized boolean hasChanged() {
    	//返回changed，表示观察对象是否发生改变
    }
    public synchronized int countObservers() {
    	//返回观察者数量
    }
}
</code></pre>
<h3 id="513-例子">5.1.3 例子</h3>
<p>将上面基地的例子用<code>Observable</code>以及<code>Observer</code>实现如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args)
    {
        Observer player1 = new Player(&quot;A&quot;,&quot;无警戒状态&quot;);
        Observer player2 = new Player(&quot;B&quot;,&quot;无警戒状态&quot;);
        Observer player3 = new Player(&quot;C&quot;,&quot;无警戒状态&quot;);

        Base base = new Base();
        base.addObserver(player1);
        base.addObserver(player2);
        base.addObserver(player3);
        base.change(&quot;警戒状态&quot;);
    }
}

class Player implements Observer
{
    private String name;
    private String state;
    public Player(String name,String state)
    {
        this.name = name;
        this.state = state;
    }
    @Override
    public void update(Observable o,Object arg)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+arg);
    }
}

class Base extends Observable
{
    public void change(String state)
    {
        setChanged();
        notifyObservers(state);
    }
}
</code></pre>
<p>具体观察者<code>Player</code>实现<code>Observer</code>接口，具体目标<code>Base</code>（被观察者）继承<code>Observable</code>，注意需要在<code>notifyObservers</code>之前，使用<code>Observable</code>的<code>setChanged</code>表示被观察者状态改变，这样使用<code>notifyObservers</code>才能生效，否则认为被观察者没有发生状态改变：<br>
<img src="https://img-blog.csdnimg.cn/20200803173804871.png" alt="在这里插入图片描述" loading="lazy"><br>
查看源码发现<code>notifyObservers</code>中先对<code>changed</code>内部布尔变量进行了判断，如果具体目标没有使用<code>setChanged</code>方法，将导致无法通知观察者。</p>
<p>这里使用了推模型实现，具体目标在<code>notifyObservers</code>中传递状态参数：</p>
<pre><code class="language-java">class Player implements Observer
{
	//...
    @Override
    public void update(Observable o,Object arg)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+arg);
    }
}

class Base extends Observable
{
    public void change(String state)
    {
        setChanged();
        notifyObservers(state);
    }
}
</code></pre>
<p>使用拉模型修改如下：</p>
<pre><code class="language-java">class Player implements Observer
{
    //...
    public void update(Observable o,Object arg)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;更新状态为&quot;+((Base)o).getState());
    }
}

class Base extends Observable
{
    private String state;
    public String getState()
    {
        return state;
    }
    public void change(String state)
    {
        this.state = state;
        setChanged();
        notifyObservers();
    }
}
</code></pre>
<p>具体观察者的<code>update</code>中由原来的从<code>arg</code>获取状态变为从<code>Observable</code>中通过getter获取状态，同时具体目标增加了<code>state</code>成员，在<code>notifyObservers</code>中不需手动传入状态参数。</p>
<h2 id="52-新apiflow-api">5.2 新API——<code>Flow API</code></h2>
<p>虽然使用JDK的<code>Observable</code>以及<code>Observer</code>实现观察者模式很容易，不需要定义抽象目标以及抽象观察者，但是很遗憾的是从Java9开始标记为过时了（看着一条条横线也挺难受的）：<br>
<img src="https://img-blog.csdnimg.cn/20200803174359464.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>查了一下原因，标记为过时主要是因为：</p>
<ul>
<li>提供的事件模型不够完善：它们不能提供一个完善的事件模型，比如只能告知观察者某些东西被改变了，但是没有告知什么东西改变了</li>
<li>不能序列化：<code>Observable</code>没有实现序列化接口</li>
<li>非线程安全：事件可能在不同的线程中以不同的顺序进行通知</li>
</ul>
<h1 id="6-flow-api">6 <code>Flow API</code></h1>
<p>为了克服原来的缺点，从JDK9开始出现了<code>Flow API</code>，位于<code>java.util.concurrent</code>下。</p>
<p>在讲<code>Flow API</code>之前，先看一下响应式编程。</p>
<h2 id="61-响应式编程">6.1 响应式编程</h2>
<p>响应式编程可以理解为一种处理数据项的异步流，即在数据产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（<code>Publisher</code>）以及数据订阅者（<code>Subscriber</code>），后者用于异步接收发布者发布的数据。</p>
<p>在该模式中，还引入了一个更高级的特性：数据处理器（<code>Processor</code>），用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程遇到的困难，基于这个模型实现的有<code>Java 9 Flow API</code>，<code>RxJava</code>，<code>Reactor</code>等。</p>
<h2 id="62-flow-api">6.2 <code>Flow API</code></h2>
<p><code>Flow</code>是一个<code>final</code>类，里面定义了四个接口：</p>
<ul>
<li><code>Publisher&lt;T&gt;</code>：数据发布者接口</li>
<li><code>Subscriber&lt;T&gt;</code>：数据订阅者接口</li>
<li><code>Subscription</code>：发布者和订阅者之间的订阅关系</li>
<li><code>Processor&lt;T,R&gt;</code>：数据处理器</li>
<li><code>public static int defaultBufferSize()</code>：返回缓冲区长度，默认256。当发布者发送速率高于接收速率时，数据接收者缓冲区将会被填满，当缓冲区填满后，发布者会停止发送数据，直到订阅者有空闲位置时，发布者才会继续发布数据</li>
</ul>
<h3 id="621-publishert">6.2.1 <code>Publisher&lt;T&gt;</code></h3>
<p><code>Publisher</code>源码如下：</p>
<pre><code class="language-java">@FunctionalInterface
public static interface Publisher&lt;T&gt; {
    public void subscribe(Subscriber&lt;? super T&gt; subscriber);
}
</code></pre>
<p>这是一个函数式接口，只包含一个<code>subscribe</code>方法，通过该方法将数据发布出去。</p>
<h3 id="622-subscribert">6.2.2 <code>Subscriber&lt;T&gt;</code></h3>
<p><code>Subscriber</code>源码如下：</p>
<pre><code class="language-java">public static interface Subscriber&lt;T&gt; 
{
    public void onSubscribe(Subscription subscription);
    public void onNext(T item);
    public void onError(Throwable throwable);
    public void onComplete();
}
</code></pre>
<p>方法解释如下：</p>
<ul>
<li><code>onSubscribe</code>：订阅成功的回调方法，用于初始化<code>Subscription</code>，表明可以开始接收订阅数据了</li>
<li><code>onNext</code> ：接收下一项订阅数据的回调方法</li>
<li><code>onError</code>：在<code>Publisher</code>或<code>Subscriber</code>遇到不可恢复的错误时会调用该方法，<code>Subscriber</code>不再接收订阅信息</li>
<li><code>onComplete</code>：接收完所有订阅数据，并且发布者已经关闭后会回调该方法</li>
</ul>
<h3 id="623-subscription">6.2.3 <code>Subscription</code></h3>
<p><code>Subscription</code>源码如下：</p>
<pre><code class="language-java">public static interface Subscription {
    public void request(long n);
    public void cancel();
}
</code></pre>
<p>方法解释如下：</p>
<ul>
<li><code>request</code>：用于向数据发布者请求n个数据项</li>
<li><code>cancel</code>：取消消息订阅，订阅者不再接收数据</li>
</ul>
<h3 id="624-processortr">6.2.4 <code>Processor&lt;T,R&gt;</code></h3>
<p><code>Processor</code>源码如下：</p>
<pre><code class="language-java">public static interface Processor&lt;T,R&gt; 
extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; 
{}
</code></pre>
<p>这是一个空接口，继承了<code>Subscriber</code>以及<code>Publisher</code>，它既能发布数据也能订阅数据，基于这个特性它可以充当数据转换的角色，先从数据发布者接收数据，经过处理后发布给数据订阅者。</p>
<h3 id="625-简例">6.2.5 简例</h3>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args)
    {
        //JDK9自带的数据发布者,实现了Publisher&lt;T&gt;
        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();
        //创建订阅者,用于接收发布者消息
        Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;()
        {
            private Subscription subscription;
            @Override
            public void onSubscribe(Subscription subscription)
            {
                //通过Subscription和发布者保持订阅关系
                //并用它来给发布者反馈
                this.subscription = subscription;
                //请求一个数据
                this.subscription.request(1);
            }

            @Override
            public void onNext(String item)
            {
                //接收发布者发布的信息
                System.out.println(&quot;订阅者接收消息:&quot;+item);
                //接收后再次请求一个数据
                this.subscription.request(1);
                //如果不想接收直接调用cancel
                // this.subscription.cancel();
            }

            @Override
            public void onError(Throwable throwable)
            {
                //异常回调
                System.out.println(&quot;订阅者接收数据异常:&quot;+throwable);
                throwable.printStackTrace();
                this.subscription.cancel();
            }

            @Override
            public void onComplete()
            {
                //发布者发送的数据都被接收了
                //并且发布者关闭后就会回调该方法
                System.out.println(&quot;订阅者接收数据完毕&quot;);
            }
        };
        //建立发布者与订阅者的关系
        publisher.subscribe(subscriber);
        //发布数据
        for(int i=0;i&lt;10;++i)
        {
            String message = &quot;flow api &quot;+i;
            System.out.println(&quot;发布者发布消息:&quot;+message);
            publisher.submit(message);
        }
        //发布结束后关闭发布者
        publisher.close();
        //main延迟关闭,否则订阅者没接收完消息线程就被关闭
        try
        {
            Thread.currentThread().join(2000);
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>步骤：</p>
<ul>
<li>建立消息发布者：使用<code>SubmissionPublisher&lt;String&gt;</code>作为消息发布者</li>
<li>建立消息订阅者：实现<code>Subscriber&lt;String&gt;</code>作为消息订阅者</li>
<li>建立订阅关系：通过<code>publisher.subscribe(subsciber)</code>建立</li>
<li>发布数据：发布者通过<code>submit</code>发布数据</li>
<li>收尾工作：如果没有出现异常需要调用发布者的<code>close()</code>关闭发布者，同时会回调订阅者的<code>onComplete</code>方法</li>
</ul>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200803193451206.png" alt="在这里插入图片描述" loading="lazy"><br>
注意例子中最后需要延迟关闭<code>main</code>线程，如果没有这个操作，订阅者就不能完全接收所有信息：<br>
<img src="https://img-blog.csdnimg.cn/20200803193607970.png" alt="在这里插入图片描述" loading="lazy"><br>
可以从输出看到，订阅者接收到第8条消息后，线程就被关闭了。</p>
<h3 id="626-模拟缓冲区填满">6.2.6 模拟缓冲区填满</h3>
<p>前面说过<code>Flow</code>中有一个静态方法返回缓冲区大小，下面进行模拟填满，在订阅者中的订阅方法中，加入延迟：</p>
<pre><code class="language-java">@Override
public void onNext(String item)
{
    //模拟接收数据缓慢填满缓冲池
    try
    {
        TimeUnit.MILLISECONDS.sleep(300);
    }
    catch(InterruptedException e)
    {
        e.printStackTrace();
    }
    System.out.println(&quot;订阅者接收消息:&quot;+item);
    //接收后再次请求一个数据
    this.subscription.request(1);
}
</code></pre>
<p>因为默认的缓冲区大小为256，因此，发布256条信息后，可以看到不再发送，直到等到订阅者处理才继续发布：<br>
<img src="https://img-blog.csdnimg.cn/2020080319450897.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="627-processor">6.2.7 <code>Processor</code></h3>
<p><code>Processor</code>就是<code>Publisher</code>+<code>Subscriber</code>，通常是用作接收发布者发布的信息，进行相应处理后，再将数据发布，供消息者订阅接收，下面是一个简例：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args)
    {
        //JDK9自带的数据发布者,实现了Publisher&lt;T&gt;
        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();
        //创建订阅者,用于接收发布者消息
        TestProcessor processor = new TestProcessor();

        Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;()
        {
            private Subscription subscription;
            @Override
            public void onSubscribe(Subscription subscription)
            {
                this.subscription = subscription;
                this.subscription.request(1);
            }

            @Override
            public void onNext(String item)
            {
                System.out.println(&quot;订阅者接收消息:&quot;+item);
                this.subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable)
            {
                System.out.println(&quot;订阅者接收异常&quot;);
                throwable.printStackTrace();
                this.subscription.cancel();
            }

            @Override
            public void onComplete()
            {
                System.out.println(&quot;订阅者接收完毕&quot;);
            }
        };
        publisher.subscribe(processor);
        processor.subscribe(subscriber);
        //发布数据
        for(int i=0;i&lt;10;++i)
        {
            String message = &quot;flow api &quot;+i;
            System.out.println(&quot;发布者发布消息:&quot;+message);
            publisher.submit(message);
        }
        //发布结束后关闭发布者
        publisher.close();
        //main延迟关闭,否则订阅者没接收完消息线程就被关闭
        try
        {
            Thread.currentThread().join(2000);
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
}

class TestProcessor extends SubmissionPublisher&lt;String&gt; implements Processor&lt;String,String&gt;
{
    private Subscription subscription;
    @Override
    public void onSubscribe(Subscription subscription)
    {
        //通过Subscription和发布者保持订阅关系
        //并用它来给发布者反馈
        this.subscription = subscription;
        //请求一个数据
        this.subscription.request(1);
    }

    @Override
    public void onNext(String item)
    {
        //模拟接收数据缓慢填满缓冲池
        System.out.println(&quot;处理器处理消息:&quot;+item);
        item = &quot;经过处理器处理的消息:&quot;+item;
        //接收后再次请求一个数据
        this.submit(item);
        this.subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable)
    {
        //异常回调
        System.out.println(&quot;处理器处理数据异常:&quot;+throwable);
        throwable.printStackTrace();
        this.subscription.cancel();
    }

    @Override
    public void onComplete()
    {
        System.out.println(&quot;处理者处理数据完毕&quot;);
        this.close();
    }
}
</code></pre>
<p>步骤：</p>
<ul>
<li>建立消息发布者：同上使用<code>SubmissionPublisher&lt;String&gt;</code></li>
<li>建立消息处理者：这里使用了一个继承<code>SubmissionPublisher&lt;String&gt;</code>并实现<code>Processor&lt;String,String&gt;</code>的类，在其中的<code>onNext</code>方法中对消息进行处理并调用<code>submit</code>发布给订阅者，在其中的<code>onComplete</code>调用<code>close()</code>关闭处理器</li>
<li>建立消息订阅者：同上实现了<code>Subscriber&lt;String&gt;</code></li>
<li>建立订阅关系：处理者订阅发布者，订阅者订阅处理者，也就是处理者相当于中介角色，将消息处理后交给订阅者</li>
<li>发布消息：发布者发布消息</li>
<li>收尾工作：首先由于处理者订阅了发布者，因此处理者处理完数据后处理者先关闭，接着订阅者订阅完处理后的数据后订阅者再关闭</li>
</ul>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803200433627.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="628-使用flow-api实现例子">6.2.8 使用<code>Flow API</code>实现例子</h3>
<p>讲了这么多<code>Flow API</code>的例子，下面来看看如何使用<code>Flow API</code>实现基地的例子。</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args)
    {
        Base base = new Base();
        Player player1 = new Player(&quot;A&quot;, &quot;非戒备状态&quot;);
        Player player2 = new Player(&quot;B&quot;, &quot;非戒备状态&quot;);
        Player player3 = new Player(&quot;C&quot;, &quot;非戒备状态&quot;);
        base.add(player1);
        base.add(player2);
        base.add(player3);
        base.changed(&quot;戒备状态&quot;);
        base.close();
    }
}

class Base
{
    SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();
    private List&lt;Player&gt; players = new ArrayList&lt;&gt;();
    public void add(Player player)
    {
        publisher.subscribe(player);
        players.add(player);
    }
    public void remove(Player player)
    {
        player.cancel();
        players.remove(player);
    }
    public void changed(String state)
    {
        System.out.println(&quot;基地正在遭受攻击&quot;);
        publisher.submit(state);
    }
    public void close()
    {
        publisher.close();
        try
        {
            Thread.currentThread().join(2000);
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
    }
}

class Player implements Subscriber&lt;String&gt;
{
    private Subscription subscription;
    private String name;
    private String state;
    public Player(String name,String state)
    {
        this.name = name;
        this.state = state;
    }
    @Override
    public void onSubscribe(Subscription subscription)
    {
        this.subscription = subscription;
        this.subscription.request(1);
    }

    @Override
    public void onNext(String item)
    {
        System.out.println(&quot;战队成员&quot;+name+&quot;更新状态:&quot;+item);
        this.subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable)
    {
        System.out.println(&quot;战队成员接收异常&quot;);
        throwable.printStackTrace();
        this.subscription.cancel();
    }

    public void cancel()
    {
        this.subscription.cancel();
    }

    @Override
    public void onComplete()
    {
        System.out.println(&quot;战队成员接收完毕&quot;);
    }
}
</code></pre>
<p>大部分代码都与上面的例子相同，就不解释了，贴一下输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803203010768.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-主要优点">7 主要优点</h1>
<ul>
<li>分离表示层与逻辑层：定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>降低耦合：在抽象目标以及抽象观察者之间建立了一个抽象耦合，观察目标只需要维持一个抽象观察者的集合，无须了解具体观察者，由于观察目标和观察者没有紧密耦合在一起，因此它们可以属于不同的抽象层次</li>
<li>广播：观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多的系统设计难度</li>
<li>满足OCP：观察者模式满足开放闭合原则的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者之间与观察目标之间不存在关联关系的情况下，增加新的观察目标很方便</li>
</ul>
<h1 id="8-主要缺点">8 主要缺点</h1>
<ul>
<li>通知费时：如果有很多观察者，通知需要耗费较多时间</li>
<li>循环依赖导致崩溃：如果观察者模式与观察目标之间存在循环依赖，观察目标会导致触发它们之间进行循环调用，可能导致崩溃</li>
<li>不明确变化内容：观察者模式只是让观察者知道观察目标发生了变化，但是不知道变化的内容是什么</li>
</ul>
<h1 id="9-适用场景">9 适用场景</h1>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在一个独立的对象中使它们可以独立地改变和复用</li>
<li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象发生改变，也不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为会影响B对象，B对象的行为会影响C对象，可以使用观察者模式创建一种链式触发机制</li>
</ul>
<h1 id="10-总结">10 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200803215719507.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十一）：备忘录模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-yi-bei-wang-lu-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-yi-bei-wang-lu-mo-shi/">
        </link>
        <updated>2020-08-03T17:16:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E5%8E%9F%E5%8F%91%E5%99%A8">2.2 原发器</a></li>
<li><a href="#23-%E5%A4%87%E5%BF%98%E5%BD%95">2.3 备忘录</a></li>
<li><a href="#24-%E8%B4%9F%E8%B4%A3%E4%BA%BA">2.4 负责人</a></li>
<li><a href="#25-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.5 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%A4%87%E5%BF%98%E5%BD%95%E5%B0%81%E8%A3%85">4 备忘录封装</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在手机上玩象棋时，往往会提供一个悔棋的功能，实际上，悔棋就是恢复到某个历史状态，很多软件中称之为撤销，实现撤销时，需要先保存历史状态，这样撤销时，取出某个历史状态并覆盖当前状态。备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态恢复。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</strong></p>
<p>备忘录模式是一种对象行为型模式，别名为Token。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200803021243722.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Originator</code>（原发器）：一个普通类，可以创建一个备忘录，并存储当前内部状态，也可以使用备忘录恢复内部状态，一般为需要保存内部状态的类</strong></li>
<li><strong><code>Memento</code>（备忘录）：存储原发器内部状态，根据原发器决定保存哪些内部状态。除了原发器以及负责人以外，备忘录不能供其他对象直接使用</strong></li>
<li><strong><code>Caretaker</code>（负责人）：又叫管理者，负责保存备忘录，可以存储一个或多个备忘录，只负责保存备忘录对象，不能修改备忘录</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义原发器：原发器是需要保存内部状态的类，提供一个从当前状态创建备忘录的方法以及一个从备忘录中恢复内部状态的方法</li>
<li>定义备忘录：存储原发器内部状态，需要考虑封装性，不能被除原发器以及负责人以外的类访问，否则失去备忘录意义</li>
<li>定义负责人：保存备忘录对象，一般使用集合存储多个备忘录</li>
</ul>
<h2 id="22-原发器">2.2 原发器</h2>
<pre><code class="language-java">class Originator
{
    private String state;
    public String getState() 
    {
        return this.state;
    }
    public void setState(String state) 
    {
        this.state = state;
    }
    public Memento save()
    {
        return new Memento(state);
    }
    public void restore(Memento memento)
    {
        this.state = memento.getState();
    }
}
</code></pre>
<p>原发器中相应的字段表示内部状态，<code>save()</code>返回一个将内部状态封装为备忘录的对象，<code>restore()</code>获取备忘录中的内部状态并进行恢复。</p>
<h2 id="23-备忘录">2.3 备忘录</h2>
<pre><code class="language-java">class Memento
{
    private String state;

    public Memento(String state)
    {
        this.state = state;
    }

    public String getState() 
    {
        return this.state;
    }
}
</code></pre>
<p>简单的保存内部状态的类，需要保证封装性，不允许除原发器以及负责人外的类访问。</p>
<p>不同语言实现机制不同，比如C++中可以通过<code>friend</code>友元实现，Java中可通过将备忘录或者原发器防置同一个包或者将备忘录作为原发器的内部类实现。</p>
<h2 id="24-负责人">2.4 负责人</h2>
<pre><code class="language-java">class Caretaker
{
    private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
    public Memento get()
    {
        return mementos.remove(0);
    }
    public void add(Memento memento)
    {
        mementos.add(0,memento);
    }
}
</code></pre>
<p>负责人使用一个<code>LinkedList</code>保存多个备忘录，由于恢复操作是逐步进行的，也就是不能一次恢复到“撤销两次”的历史状态，只能恢复到“撤销一次”的历史状态，因此可以考虑栈来保存备忘录。</p>
<h2 id="25-客户端">2.5 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Originator originator = new Originator();
    Caretaker caretaker = new Caretaker();
    originator.setState(&quot;状态1&quot;);
    caretaker.add(originator.save());
    originator.setState(&quot;状态2&quot;);
    caretaker.add(originator.save());
    originator.setState(&quot;状态3&quot;);
    caretaker.add(originator.save());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
    originator.restore(caretaker.get());
    System.out.println(originator.getState());
}
</code></pre>
<p>对于客户端，每修改一次原发器的状态就通过负责人保存一次生成的备忘录，需要时从负责人获取备忘录并恢复到相应的状态。</p>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803023850584.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>象棋悔棋的实现，使用备忘录模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>原发器：<code>Chessman</code></li>
<li>备忘录：<code>Memento</code></li>
<li>负责人：<code>Caretaker</code></li>
</ul>
<p>原发器如下：</p>
<pre><code class="language-java">class Chessman
{
    private String label;
    private int x;
    private int y;
   
    public Chessman(int x,int y,String label)
    {
        this.x = x;
        this.y = y;
        this.label = label;
    }

    public Memento save()
    {
        return new Memento(x,y,label);
    }

    public void restore(Memento memento)
    {
        this.x = memento.getX();
        this.y = memento.getY();
        this.label = memento.getLabel();
    }
	
	//setter+getter...

    @Override
    public String toString()
    {
        return &quot;x:&quot;+x+&quot;\ty:&quot;+y+&quot;\tlabel:&quot;+label;
    }
}
</code></pre>
<p>原发器的两个核心方法就是<code>save()</code>与<code>restore</code>，<code>save()</code>将内部状态保存为备忘录，而<code>restore()</code>根据备忘录参数恢复到之前的内部状态。</p>
<p>备忘录如下：</p>
<pre><code class="language-java">class Memento
{
    private int x;
    private int y;
    private String label;

    public Memento(int x,int y,String label)
    {
        this.x = x;
        this.y = y;
        this.label = label;
    }
    //getter...
}
</code></pre>
<p>属性与原发器一致，最后是负责人：</p>
<pre><code class="language-java">class Caretaker
{
    private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
    public Memento get()
    {
        return mementos.remove(0);
    }
    public void add(Memento memento)
    {
        mementos.add(0,memento);
    }
}
</code></pre>
<p>使用<code>LinkedList</code>模拟栈的操作，<code>get</code>获取栈顶的状态。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Chessman chessman = new Chessman(1,2,&quot;车&quot;);
    Caretaker caretaker = new Caretaker();
    caretaker.add(chessman.save());
    chessman.setX(8);
    caretaker.add(chessman.save());
    chessman.setY(5);
    caretaker.add(chessman.save());

    chessman.restore(caretaker.get());
    System.out.println(chessman);
    chessman.restore(caretaker.get());
    System.out.println(chessman);
    chessman.restore(caretaker.get());
    System.out.println(chessman);
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/20200803025132367.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-备忘录封装">4 备忘录封装</h1>
<p>备忘录是一个特殊的对象，只有原发器对它拥有控制权力，负责人只负责管理备忘录，其他类无法直接访问备忘录，因此需要对备忘录进行封装。在Java中可以使用内部类对备忘录进行封装，比如上面的例子可以封装内部类如下：</p>
<pre><code class="language-java">class Chessman
{
    //...
    public class Memento
    {
        private int x;
        private int y;
        private String label;
    
        public Memento(int x,int y,String label)
        {
            this.x = x;
            this.y = y;
            this.label = label;
        }
    
        public int getX() 
        {
            return this.x;
        }
    
        public int getY() 
        {
            return this.y;
        }
    
        public String getLabel() 
        {
            return this.label;
        }
    }
    //...
}
</code></pre>
<p>这样可以最大程度地限制外部类对于备忘录的访问，如果想进一步的完全限制，可以将备忘录设置为私有内部类，将负责人类也作为原发器的内部类，这样外部类就完全不能访问备忘录：</p>
<pre><code class="language-java">class Chessman
{
    //...
    private class Memento
    {
        //...
    }
    public class Caretaker
    {
        private List&lt;Memento&gt; mementos = new LinkedList&lt;&gt;();
        public Memento get()
        {
            return mementos.remove(0);
        }
        public void add(Memento memento)
        {
            mementos.add(0,memento);
        }
    }
    public Caretaker getCaretaker()
    {
        return new Caretaker();
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>状态恢复：备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史状态</li>
<li>多次撤销：备忘录实现了对信息的封装，保存了原发器的状态，配合列表，堆栈等集合可以实现多次撤销操作</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>资源消耗大：如果需要保存的原发器状态太多，将会占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时就能恢复到先前的状态，实现撤销操作</li>
<li>防止外界对象破坏一个对象历史状态的封装性，避免将历史状态的实现细节暴露给外部对象</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200803031745173.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（二十）：中介者模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-zhong-jie-zhe-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-er-shi-zhong-jie-zhe-mo-shi/">
        </link>
        <updated>2020-08-03T17:13:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%90%8C%E4%BA%8B%E7%B1%BB">2.2 抽象同事类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E5%90%8C%E4%BA%8B%E7%B1%BB">2.3 具体同事类</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E4%B8%AD%E4%BB%8B%E8%80%85">2.4 抽象中介者</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E4%B8%AD%E4%BB%8B%E8%80%85">2.5 具体中介者</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95%E4%B8%AD%E4%BB%8B%E8%80%85%E4%B8%8E%E5%90%8C%E4%BA%8B%E7%B1%BB">4 扩展中介者与同事类</a>
<ul>
<li><a href="#41-%E6%96%B9%E6%B3%951">4.1 方法1</a></li>
<li><a href="#42-%E6%96%B9%E6%B3%952">4.2 方法2</a></li>
</ul>
</li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>如果一个系统中对象之间的联系呈现为网状结构，存在大量的多对多联系，将导致系统非常复杂，比如，一个GUI窗口中，通过一个按钮更新了文本框，也更新了组合框，更新组合框的同时反过来需要更新文本框以及按钮。</p>
<p>这些对象既会影响别的对象，也会被别的对象所影响，这些对象称为同事对象，它们之间通过彼此相互作用实现系统的行为，几乎每一个对象都需要与其他对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合，这将导致一个过度耦合的系统。</p>
<p>中介者模式可以使对象之间的关系急剧减少，通过引入中介者对象，可以将系统的网状结构：<br>
<img src="https://img-blog.csdnimg.cn/20200802164402269.png" alt="在这里插入图片描述" loading="lazy"><br>
转化为以中介者为中心的星型结构：<br>
<img src="https://img-blog.csdnimg.cn/20200802164553662.png" alt="在这里插入图片描述" loading="lazy"><br>
在这个星型结构中，同事对象不再直接与其他的同事对象联系，通过中介者对象与另一个对象发生相互作用，中介者对象的存在保证了结构上的稳定，也就是说，系统的结构不会因为新对象的引入带来大量的修改工作。</p>
<p>如果一个系统中对象之间存在多对多的相互关系，可以将对象之间的一些交互行为从各个对象之间分离出来，并集中封装在一个中介者对象中，由中介者进行统一的协调，这样对象之间多对多的复杂关系就转变为相对简单的一对多关系，通过引入中介者来简化对象之间的复杂交互。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>中介者模式：用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其松散耦合，而且可以独立地改变它们之间的交互。</strong></p>
<p>中介者模式又叫调停者模式，是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200802191610234.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Mediator</code>（抽象中介者）：定义了与各同事类之间进行通信的方法</strong></li>
<li><strong><code>ConcreteMediator</code>（具体中介者）：抽象中介者的子类，协调各个同事对象实现协作行为，维持对各个同事对象的引用</strong></li>
<li><strong><code>Colleague</code>（抽象同事类）：定义各个同事类的公有方法，并声明一些抽象方法来提供子类实现，同事维持一个抽象中介者的引用，子类可以通过该引用与中介者通信</strong></li>
<li><strong><code>ConcreteColleague</code>（具体同事类）：抽象同事的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信，在具体同事类中实现了在抽象同事类中声明的抽象方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象同事类：声明具体同事类的方法，包含一个抽象中介者成员</li>
<li>定义具体同事类：继承/实现抽象同事类，添加一个数据更改以及数据更新的方法，其中数据更改方法供客户端调用，表示更改了具体同事类的某项数据，并且在其中调用抽象中介者的通知其他同事类更新的方法。数据更新方法供抽象中介者调用，当其他同事类修改数据时，抽象中介者通过该方法更新该同事类的数据</li>
<li>定义抽象中介者：包含一个抽象同事类的集合，存储具体同事类对象，同时声明一个通知其他同事类更新的方法</li>
<li>定义具体中介者：继承抽象中介者，根据需要实现业务方法，</li>
</ul>
<p>其中第二步可能比较难理解，下面会有详细说明。</p>
<h2 id="22-抽象同事类">2.2 抽象同事类</h2>
<pre><code class="language-java">abstract class Colleague
{
	//抽象中介者引用
    protected Mediator mediator;
    public Colleague(Mediator mediator)
    {
        this.mediator = mediator;
    }
	//数据更新方法
    public abstract void update();
	//数据更改方法
    public abstract void changed();
}
</code></pre>
<p>抽象同事类包含一个抽象中介者的引用，声明了数据更新方法以及数据更改方法。</p>
<p>至于为什么需要声明这两个方法，首先可以假设有两个同事类：两个文本框，其中一个文本框表示长度，用米作单位，另一个用千米做单位，当其中一个修改时，也就是<code>changed()</code>被调用时，通过中介者调用另一个文本框的<code>update()</code>使另一个文本框更新。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200802194820442.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="23-具体同事类">2.3 具体同事类</h2>
<pre><code class="language-java">class ConcreteColleague1 extends Colleague
{
    public ConcreteColleague1(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新同事类1&quot;);
    } 

    @Override
    public void changed()
    {
        System.out.println(&quot;同事类1数据更改&quot;);
        mediator.operation(this);
    }
}

class ConcreteColleague2 extends Colleague
{
    public ConcreteColleague2(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新同事类2&quot;);
    }

    @Override
    public void changed()
    {
        System.out.println(&quot;同事类2数据更改&quot;);
        mediator.operation(this);
    }
}
</code></pre>
<p>具体同事类中通过构造方法注入抽象中介者，维持一个抽象中介者的引用。另外在数据更改方法中，需要通过中介者通知其他同事类进行更新，也就是执行其他同事类的<code>update()</code>方法。</p>
<h2 id="24-抽象中介者">2.4 抽象中介者</h2>
<pre><code class="language-java">abstract class Mediator
{
    protected ArrayList&lt;Colleague&gt; colleagues = new ArrayList&lt;&gt;();

    public void add(Colleague colleague)
    {
        colleagues.add(colleague);
    }

    public abstract void operation(Colleague colleague);
}
</code></pre>
<p>抽象中介者使用集合存储所有的具体同事类，其中的<code>operation</code>方法是通知其他同事类修改的方法，在此方法里面统一协调所有的同事类，从而避免各个同事类之间直接调用，降低耦合度。</p>
<h2 id="25-具体中介者">2.5 具体中介者</h2>
<pre><code class="language-java">class ConcreteMediator extends Mediator
{
    @Override
    public void operation(Colleague colleague)
    {
        if(colleague instanceof ConcreteColleague1)
            colleagues.get(1).update();
        else if(colleague instanceof ConcreteColleague2)
            colleagues.get(0).update();
    }
}
</code></pre>
<p>实现抽象中介者的业务方法，这里是传入一个抽象同事类参数，判断具体是哪一个同事类，按需要更新具体同事类即可。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args)
{
    Mediator mediator = new ConcreteMediator();
    Colleague colleague1 = new ConcreteColleague1(mediator);
    Colleague colleague2 = new ConcreteColleague2(mediator);
    mediator.add(colleague1);
    mediator.add(colleague2);
    colleague1.changed();
    colleague2.changed();
}
</code></pre>
<p>客户端针对抽象中介者以及抽象同事类进行编程，先创建具体中介者，通过构造方法注入到各个具体同事类中，以便同事类调用对应中介者的方法，接着还需要将各个同事类添加到抽象中介者的集合成员中，以便抽象中介者对具体同事类进行统一的管理，最后调用具体同事类的方法。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200802195613639.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个客户信息管理窗口，其中包含按钮，列表框，文本框，组合框组件，使用中介者模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象同事类：<code>Component</code></li>
<li>具体同事类：<code>Button</code>+<code>ListBox</code>+<code>TextBox</code>+<code>ComboBox</code></li>
<li>抽象中介者：<code>Mediator</code></li>
<li>具体中介者：<code>ConcreteMediator</code></li>
</ul>
<p>首先是抽象同事类，包含一个抽象中介者引用，以及数据更改和更新方法。</p>
<pre><code class="language-java">abstract class Component
{
    protected Mediator mediator;
    public Component(Mediator mediator)
    {
        this.mediator = mediator;
    }

    public abstract void update();

    public abstract void changed();
}
</code></pre>
<p>接着是具体同事类：</p>
<pre><code class="language-java">class Button extends Component
{
    public Button(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新按钮&quot;);
    } 

    @Override
    public void changed()
    {
        System.out.println(&quot;按钮数据更改&quot;);
        mediator.notifyAllComponent(this);
    }
}

class ListBox extends Component
{
    public ListBox(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新列表框&quot;);
    }

    @Override
    public void changed()
    {
        System.out.println(&quot;列表框数据更改&quot;);
        mediator.notifyAllComponent(this);
    }
}

class ComboBox extends Component
{
    public ComboBox(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新组合框&quot;);
    }

    @Override
    public void changed()
    {
        System.out.println(&quot;组合框数据更改&quot;);
        mediator.notifyAllComponent(this);
    }
}

class TextBox extends Component
{
    public TextBox(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新文本框&quot;);
    }

    @Override
    public void changed()
    {
        System.out.println(&quot;文本框数据更改&quot;);
        mediator.notifyAllComponent(this);
    }
}
</code></pre>
<p>一共四个具体同事类，每一个具体同事类代表一个UI组件，实现了其中的数据更新以及数据更改方法。</p>
<p>接着是抽象中介者类，为了更好地管理组件（具体同事对象）引入了一个组件管理类，以便在抽象中介者中可以统一使用<code>put</code>添加组件：</p>
<pre><code class="language-java">enum ComponentName
{
    BUTTON,LIST_BOX,TEXT_BOX,COMBO_BOX;
}

class AllComponent
{
    private Map&lt;ComponentName,Component&gt; map = new HashMap&lt;&gt;();
    public void put(Component component)
    {
        if(component instanceof Button)
            map.put(ComponentName.BUTTON, component);
        else if(component instanceof ListBox)
            map.put(ComponentName.LIST_BOX, component);
        else if(component instanceof ComboBox)
            map.put(ComponentName.COMBO_BOX, component);
        else if(component instanceof TextBox)
            map.put(ComponentName.TEXT_BOX, component);
    }

    public Component get(ComponentName name)
    {
        return map.containsKey(name) ? map.get(name) : null;
    }
}

abstract class Mediator
{
    protected AllComponent allComponent = new AllComponent();
    public void put(Component ... components)
    {
        for(Component component:components)
            allComponent.put(component);
    }
    public abstract void notifyAllComponent(Component Component);
}
</code></pre>
<p>引入组件类的另一个原因是方便日后扩展组件，这样就不需要修改抽象中介者的代码，抽象中介者只需要维持一个组件管理类的引用。组件管理类使用一个<code>Map</code>存储所有同事类对象，根据对应的具体同事类类型，使用枚举设置相应的键值。</p>
<p>另外抽象中介者中包含一个重要的<code>notifyAllComponent</code>方法，该方法在某个组件的数据改变时调用，通知其他所有组件进行相应的更新。</p>
<p>最后是具体中介者类：</p>
<pre><code class="language-java">class ConcreteMediator extends Mediator
{
    private Component button = null;
    private Component listBox = null;
    private Component comboBox = null;
    private Component textBox = null;
    @Override
    public void notifyAllComponent(Component component)
    {
        if(button == null)
            button = allComponent.get(ComponentName.BUTTON);
        if(listBox == null)
            listBox = allComponent.get(ComponentName.LIST_BOX);
        if(comboBox == null)
            comboBox = allComponent.get(ComponentName.COMBO_BOX);
        if(textBox == null)
            textBox = allComponent.get(ComponentName.TEXT_BOX);

        if(component instanceof Button)
        {
            listBox.update();
            textBox.update();
            comboBox.update();
        }
        else if(component instanceof ListBox)
        {
            textBox.update();
            comboBox.update();
        }
        else if(component instanceof TextBox)
        {
            button.update();
            listBox.update();
        }
        else if(component instanceof ComboBox)
        {
            textBox.update();
            listBox.update();
        }
    }
}
</code></pre>
<p>首先获取同事类对象，然后判断具体同事类的类型，按实际需要进行选择性更新同事类即可。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    Mediator mediator = new ConcreteMediator();
    Component button = new Button(mediator);
    Component listBox = new ListBox(mediator);
    Component textBox = new TextBox(mediator);
    Component comboBox = new ComboBox(mediator);
    mediator.put(button,listBox,textBox,comboBox);

    System.out.println(&quot;按钮更改事件:&quot;);
    button.changed();
    System.out.println();
    System.out.println(&quot;列表框更改事件:&quot;);
    listBox.changed();
    System.out.println();

    System.out.println(&quot;文本框更改事件:&quot;);
    textBox.changed();
    System.out.println();
    System.out.println(&quot;组合框更改事件:&quot;);
    comboBox.changed();
    System.out.println();
}
</code></pre>
<p>客户端针对抽象中介者以及抽象同事类进行编程，创建完同事类后统一添加到抽象中介者中，最后更新对应同事类即可。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200803005233579.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-扩展中介者与同事类">4 扩展中介者与同事类</h1>
<p>在上面例子的基础上，现在系统需要增加一个<code>Label</code>组件，也就是增加一个具体同事类，由于建立了抽象层，增加具体同事类很容易，对于如何在中介者中扩展有以下两种方法：</p>
<ul>
<li>在原有具体中介者中增加一个<code>Label</code>成员并在对应方法添加<code>else if</code>判断</li>
<li>继承原有具体中介者</li>
</ul>
<h2 id="41-方法1">4.1 方法1</h2>
<p>首先增加一个<code>Label</code>类：</p>
<pre><code class="language-java">class Label extends Component
{
    public Label(Mediator mediator)
    {
        super(mediator);
    }

    @Override
    public void update()
    {
        System.out.println(&quot;更新文本标签&quot;);
    }

    @Override
    public void changed()
    {
        System.out.println(&quot;文本标签数据更改&quot;);
        mediator.notifyAllComponent(this);
    }
}
</code></pre>
<p>接着需要修改组件管理类：</p>
<pre><code class="language-java">enum ComponentName
{
    BUTTON,LIST_BOX,TEXT_BOX,COMBO_BOX,LABEL;
}

class AllComponent
{
	//...
    public void put(Component component)
    {
        if(component instanceof Button)
            map.put(ComponentName.BUTTON, component);
        else if(component instanceof ListBox)
            map.put(ComponentName.LIST_BOX, component);
        else if(component instanceof ComboBox)
            map.put(ComponentName.COMBO_BOX, component);
        else if(component instanceof TextBox)
            map.put(ComponentName.TEXT_BOX, component);
        else if(component instanceof Label)
            map.put(ComponentName.LABEL, component);
    }
	//...
}
</code></pre>
<p>添加一条<code>else if</code>即可，最后修改具体中介者类：</p>
<pre><code class="language-java">class ConcreteMediator extends Mediator
{
    private Component button = null;
    private Component listBox = null;
    private Component comboBox = null;
    private Component textBox = null;
    private Component label = null;
    @Override
    public void notifyAllComponent(Component component)
    {
        if(button == null)
            button = allComponent.get(ComponentName.BUTTON);
        if(listBox == null)
            listBox = allComponent.get(ComponentName.LIST_BOX);
        if(comboBox == null)
            comboBox = allComponent.get(ComponentName.COMBO_BOX);
        if(textBox == null)
            textBox = allComponent.get(ComponentName.TEXT_BOX);
        if(label == null)
            label = allComponent.get(ComponentName.LABEL);
        //...
	}
}
</code></pre>
<p>其他无须修改，客户端一样可以针对抽象中介者以及抽象同事类进行编程。这样就顺利添加一个具体同事类了，代码需要改动的部分不多。</p>
<h2 id="42-方法2">4.2 方法2</h2>
<p>方法2也是需要像方法1一样新建一个<code>Label</code>类以及修改组件管理类的代码，但是为了不修改具体中介者的代码，从具体中介者继承了一个新的具体中介者，代码如下：</p>
<pre><code class="language-java">class SubConcreteMediator extends ConcreteMediator
{
    private Component label = null;
    @Override
    public void notifyAllComponent(Component component)
    {
        if(label == null)
            label = allComponent.get(ComponentName.LABEL);
        if(component instanceof Label)
        {
            Component textBox = allComponent.get(ComponentName.TEXT_BOX);
            if(textBox != null)
                textBox.update();
        }
        else
            super.notifyAllComponent(component);
    }
}
</code></pre>
<p>客户端需要将原来的具体中介者修改为新的具体中介者：</p>
<pre><code class="language-java">Mediator mediator = new SubConcreteMediator();
Component button = new Button(mediator);
Component listBox = new ListBox(mediator);
Component textBox = new TextBox(mediator);
Component comboBox = new ComboBox(mediator);
Component label = new Label(mediator);
mediator.put(button,listBox,textBox,comboBox,label);
label.changed();
</code></pre>
<p>继承是另一个达到目的的方法。事实上这两种方法本质上没有任何的区别，都是增加了一个<code>Label</code>对象以及一条<code>else if</code>，但是，由于方法2不需要修改原有的具体中介者类，符合开闭原则，因此推荐使用方法2，也就是对于新增具体同事类可以使用继承具体中介者类的方式进行处理。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>简化交互：中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事的多对多交互，一对多容易理解和扩展，将原本难以理解的网状结构转换为星型结构</li>
<li>解耦同事对象：中介者模式可将各个同事对象解耦，有利于各同事之间的松耦合，可以独立改变和复用每一个同事和中介者，增加新的中介者和新的同事类都很方便，更好地符合开闭原则</li>
<li>减少同事子类个数：中介者将原本分布于多个对象间的行为集中起来，改变这些行为只需要生成新的中介者子类即可，这使得各个同事类可以被重用，无须对同事类进行扩展</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>中介者类复杂：由于具体中介者中包含了大量的同事之间的交互细节，可能会导致具体中介者类变得非常复杂，使得系统难以维护</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>系统对象之间存在复杂的引用关系，系统结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类的行为，而又不想生成太多的子类</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200803014225125.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第46期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-46-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-46-qi/">
        </link>
        <updated>2020-08-03T02:31:22.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596335502108.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你要相信明天，一定会更好的，更好的把你虐成狗。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>当德国连锁超市ALDI的首席执行官西奥·阿尔布雷希特被绑架后，他不但向绑架者给自己的赎金砍了假，还在获释后在法庭上宣称这笔款项为可抵税商务开支。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>荷花五寸荷花娇，贴波不碍画船摇。<br>
——石涛《荷花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>因为痛苦太有价值，因为回忆太珍贵，所以我们更要继续往前走。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1359663981">это ли счастье? - Rauf &amp; Faik</a></p>
</blockquote>
<blockquote>
<p>В мире не осталось искренних чувств<br>
Я теперь иду и тут каждую боюсь<br>
Это ли счастье?<br>
Тут все погасло<br>
Это не счастье<br>
Не счастье<br>
Не счастье<br>
Это ли счастье?<br>
Тут все погасло<br>
Это не счастье<br>
Не счастье</p>
</blockquote>
<blockquote>
<p>Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги<br>
Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда<br>
В мире не осталось искренних чувств<br>
Я теперь иду и тут каждую боюсь<br>
Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги</p>
</blockquote>
<blockquote>
<p>Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда<br>
Ты мне говоришь «Люблю»<br>
На это в голове много мыслей у меня<br>
Что, если тебе не даю<br>
Я не даю то, что хочешь от меня<br>
В мире только подлость и грусть<br>
Тебе важны мои деньги, бери мои деньги<br>
Я тебя не люблю<br>
Уходи от меня, не возвращайся сюда</p>
</blockquote>
<blockquote>
<p>Не возвращайся сюда<br>
Не возвращайся сюда<br>
Не возвращайся сюда<br>
Не возвращайся сюда</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第45期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-45-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-45-qi/">
        </link>
        <updated>2020-08-02T02:30:33.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596335472787.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>条条大路通罗马，每条都有收费站。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>美国的阿拉斯加州，亚利桑那州，印第安纳州，肯塔基州，宾夕法尼亚州，田纳西州，犹他州和西维吉尼亚州都拥有自己的官方州枪，分别从淡动式左轮手枪到半自动狙击步枪不一。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>但满目京尘，东风竟日吹露桃。<br>
——周邦彦《忆旧游·记愁横浅黛》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我不要你忘记他，我只要你记得我。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.hifini.com/thread-38828.htm">树藤-林欣彤</a></p>
</blockquote>
<blockquote>
<p>优雅的眼妆沿十条裂纹在割下<br>
我听见指甲尖在额头磨灭计划<br>
绝望能绝吗 愿望难道能望吗<br>
三千青丝一刹变白<br>
我不信天国一到海会枯顽石会烂<br>
我只信心瘾一到便亡命投入劫难<br>
若罪名是贪 但树藤何曾未贪<br>
高攀不起孤立亦难</p>
</blockquote>
<blockquote>
<p>Take on me<br>
this misery<br>
私有得彻底 情愿吸干你一切<br>
La la la la la la la la la la<br>
Cry for me<br>
and I'm sorry<br>
死结捆到底 情愿烧光我躯体<br>
飞灰撒下烂泥才高贵</p>
</blockquote>
<blockquote>
<p>舍弃一切换不到美丽<br>
得到安慰变不出地位<br>
我像蝼蚁<br>
不知道千秋更替蔷薇藏后世<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
<blockquote>
<p>凄美的血丝沿十条泪痕在抹下<br>
脑中有千个天使在扬善提示放下<br>
道别能别吗<br>
独活难道能活吗<br>
一堆枯骨飞不出一刹那<br>
我不信天国一到海会枯顽石会烂<br>
我只信心瘾一到便亡命投入劫难<br>
若罪名是贪<br>
但树藤何曾未贪<br>
Da la la la la la la la</p>
</blockquote>
<blockquote>
<p>Take on me<br>
this misery<br>
私有得彻底<br>
情愿吸干你一切<br>
La la la la la la la la la la<br>
Cry for me<br>
say I'm sorry<br>
死结捆到底<br>
情愿烧光我躯体<br>
飞灰撒下烂泥才高贵</p>
</blockquote>
<blockquote>
<p>舍弃一切换不到美丽<br>
得到安慰变不出地位<br>
我像蝼蚁<br>
不知道千秋更替蔷薇藏后世<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
<blockquote>
<p>任由萤火将我净化带着你牵挂<br>
或能尘归土种下世花<br>
不顾一切什么都美丽<br>
给你刻上最深的毒誓<br>
我像蝼蚁<br>
不知道千秋更替明媚留不低<br>
于你枝干盛开的瑰丽<br>
伴随灵欲兴衰的姿势<br>
那样华贵<br>
扑灭前望你十秒便记住约誓</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十九）：迭代器模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-jiu-die-dai-qi-mo-shi/">
        </link>
        <updated>2020-08-02T02:30:15.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8">2.2 抽象迭代器</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%81%9A%E5%90%88%E7%B1%BB">2.3 抽象聚合类</a></li>
<li><a href="#24-%E5%85%B7%E4%BD%93%E8%81%9A%E5%90%88%E7%B1%BB">2.4 具体聚合类</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E8%BF%AD%E4%BB%A3%E5%99%A8">2.5 具体迭代器</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0">4 内部类实现</a></li>
<li><a href="#5-jdk%E8%BF%AD%E4%BB%A3%E5%99%A8">5 JDK迭代器</a>
<ul>
<li><a href="#51-iterator">5.1 <code>Iterator</code></a></li>
<li><a href="#52-listiterator">5.2 <code>ListIterator</code></a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在软件开发中，有一些类可以存储多个成员对象（元素），这些类通常称为聚合类，对应的对象称为聚合对象。聚合对象拥有两个职责，一个是存储数据，一个是遍历数据，前者是聚合对象的基本职责，后者是可以变化以及分离的，因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，又迭代器来提供遍历聚合对象内部数据的行为。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>迭代器模式：提供一种方法来访问对象，而不用暴露这个对象的内部表示，别名叫游标。</strong></p>
<p>迭代器模式是一种对象行为型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801013759371.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Iterator</code>（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，比如<code>first</code>（获取第一个元素），<code>next</code>（获取下一个元素），<code>hasNext</code>（判断是否有下一个元素），<code>currentItem</code>（获取当前元素）</strong></li>
<li><strong><code>ConcreteIterator</code>（具体迭代器）：实现了抽象迭代器，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录聚合对象中所处的当前位置，通常游标是一个非负整数</strong></li>
<li><strong><code>Aggregate</code>（抽象聚合类）：用于存储和管理元素对象，声明一个<code>createIterator</code>方法创建一个迭代器对象，充当抽象迭代器的工厂角色</strong></li>
<li><strong><code>ConcreteAggregate</code>（具体聚合类）：实现了抽象聚合类中的<code>createIterator</code>方法，返回一个具体迭代器实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象迭代器：一般为接口，声明具体迭代器的方法</li>
<li>定义抽象聚合类：一般为接口，包含管理聚合元素的方法以及创建抽象迭代器的方法</li>
<li>定义具体聚合类：内部创建集合存储聚合元素，在创建迭代器方法中将集合作为构造方法参数注入到具体迭代器中并返回该具体迭代器</li>
<li>定义具体迭代器类：实现抽象迭代器的方法，一般包含一个来自具体聚合类的集合引用以及一个表示元素位置的整型的游标</li>
</ul>
<h2 id="22-抽象迭代器">2.2 抽象迭代器</h2>
<pre><code class="language-java">interface Iterator
{
    String first();
    String next();
    boolean hasNext();
    String currentItem();
}
</code></pre>
<h2 id="23-抽象聚合类">2.3 抽象聚合类</h2>
<pre><code class="language-java">interface Aggregate
{
    Iterator createIterator();
    void add(String s);
}
</code></pre>
<p>创建迭代器通过<code>createIterator</code>，<code>add</code>用于增添元素。</p>
<h2 id="24-具体聚合类">2.4 具体聚合类</h2>
<pre><code class="language-java">class ConcreteAggregate implements Aggregate
{
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator createIterator()
    {
        return new ConcreteIterator(list);
    }
    @Override
    public void add(String s)
    {
        list.add(s);
    }
}
</code></pre>
<p>在创建迭代器方法中，通过构造方法把集合对象注入到具体迭代器中。</p>
<h2 id="25-具体迭代器">2.5 具体迭代器</h2>
<pre><code class="language-java">class ConcreteIterator implements Iterator
{
    private int cursor;
    private List&lt;String&gt; list;
    public ConcreteIterator(List&lt;String&gt; list)
    {
        this.list = list;
        this.cursor = -1;
    }

    @Override
    public String first()
    {
        return list.size() &gt; 0 ?
        list.get(cursor = 0) :
        null;
    }

    @Override
    public String next()
    {
        return list.get(
            cursor + 1 &lt; list.size() ? ++cursor : cursor
        );
    }

    @Override
    public boolean hasNext()
    {
        return cursor+1 &lt; list.size();
    }

    @Override
    public String currentItem()
    {
        return list.get(cursor);
    }
}
</code></pre>
<p>具体迭代器中包含了一个游标，用于记录当前访问的位置。构造方法中将游标初始化为-1而不是初始化为0，这样第一次使用<code>next</code>时便会访问第一个元素。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Aggregate aggregate = new ConcreteAggregate();
    aggregate.add(&quot;111&quot;);
    aggregate.add(&quot;222&quot;);
    aggregate.add(&quot;jksdfjksdjkfk&quot;);
    aggregate.add(&quot;m,xcvm,xcm,v&quot;);
    Iterator iterator = aggregate.createIterator();
    while(iterator.hasNext())
    {
        System.out.println(iterator.next());
    }
}
</code></pre>
<p>客户端针对抽象聚合类以及抽象迭代器编程，通过聚合对象创建迭代器后，首先使用<code>haxNext</code>判断，接着使用<code>next</code>获取其中元素。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个系统对客户数据以及商品数据进行遍历，使用迭代器模式进行设计。</p>
</blockquote>
<p>这个例子和上面的其实差不多，不过是反向迭代器方法，另外为了更贴近实际环境使用，抽象迭代器以及聚合类都使用了泛型设计：</p>
<ul>
<li>抽象迭代器：<code>Iterator&lt;T&gt;</code></li>
<li>抽象聚合类：<code>AbstarctList&lt;T&gt;</code></li>
<li>具体聚合类：<code>ObjectList&lt;T&gt;</code></li>
<li>具体迭代器：<code>ObjectIterator&lt;T&gt;</code></li>
<li>模拟产品以及顾客类：<code>Product</code>+<code>Customer</code></li>
</ul>
<p>首先设计抽象迭代器：</p>
<pre><code class="language-java">interface Iterator&lt;T&gt;
{
    T next();
    boolean hasNext();
    String nextName() throws UnsupportedOperationException;
    boolean hasNextName() throws UnsupportedOperationException;
    void setProduct();
}
</code></pre>
<p><code>nextName()</code>以及<code>hasNextName()</code>方法是对<code>Customer</code>类型生效的，对于<code>Product</code>会抛出异常。<code>setProduct()</code>表示设置聚合元素的类型为<code>Product</code>。</p>
<p>接着是抽象聚合类的设计：</p>
<pre><code class="language-java">interface AbstractList&lt;T&gt;
{
    Iterator&lt;T&gt; iterator();
    Iterator&lt;T&gt; reversedIterator();
    void add(T s);
}
</code></pre>
<p>添加了一个反向迭代器实现。</p>
<p>然后是具体聚合类的设计：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator&lt;T&gt;(list,false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator&lt;T&gt;(list,true);
    }
}
</code></pre>
<p>内部还有一个<code>List</code>存储聚合元素，<code>iterator</code>返回正向迭代器，构造方法里面的布尔值表示是否为反向迭代器，<code>reversedIterator</code>表示返回一个单向迭代器，与正向的唯一不同就是传入具体迭代器的构造方法中的布尔值。<code>true</code>表示是反向迭代器，否则是正向。</p>
<p>最后是具体迭代器类：</p>
<pre><code class="language-java">class ObjectIterator&lt;T&gt; implements Iterator&lt;T&gt;
{
    private int cursor;
    private List&lt;T&gt; list;
    private boolean reversed;
    private boolean isProduct = false;
    public ObjectIterator(List&lt;T&gt; list,boolean reversed)
    {
        this.list = list;
        this.reversed = reversed;
        this.cursor = (reversed ? list.size() : -1);
    }

    @Override
    public void setProduct()
    {
        isProduct = true;
    }

    @Override
    public T next()
    {
        return list.get(
            reversed ? 
            ( cursor - 1 &gt;= 0 ? --cursor : cursor ) :
            ( cursor + 1 &lt; list.size() ? ++cursor : cursor )
        );
    }

    @Override
    public boolean hasNext()
    {
        return reversed ?
        cursor-1 &gt;= 0 :
        cursor+1 &lt; list.size();
    }

    @Override
    public String nextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return ((Customer)next()).getName();
    }

    @Override
    public boolean hasNextName() throws UnsupportedOperationException
    {
        if(isProduct)
            throw new UnsupportedOperationException(&quot;商品迭代器不支持该操作&quot;);
        return hasNext();
    }
}
</code></pre>
<p>构造方法中初始化聚合元素以及一个布尔值<code>reversed</code>，表示是否为反向迭代器，游标根据<code>reversed</code>设置为<code>-1</code>或<code>list.size()</code>。对于<code>next</code>以及<code>hasNext</code>方法，都需要判断是否为反向迭代器，返回对应的结果。对于<code>nextName</code>以及<code>hasNextName</code>，由于这两个方法仅对<code>Customer</code>类生效，因此如果是<code>Product</code>类直接抛出异常。</p>
<p>其他：</p>
<pre><code class="language-java">class Product
{
    private String id;
    private int num;

    public Product(){}

    public Product(String id,int num) {
        this.id = id;
        this.num = num;
    }

    public String getId() {
        return this.id;
    }

    public int getNum() {
        return this.num;
    }

    @Override
    public String toString()
    {
        return &quot;商品id:&quot;+id+&quot;\t商品数量:&quot;+num;
    }
}

class Customer
{
    private String id;
    private String name;

    public Customer(String id,String name)
    {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    @Override
    public String toString()
    {
        return &quot;顾客id:&quot;+id+&quot;\t顾客名字:&quot;+name;
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Customer customer1 = new Customer(&quot;id1&quot;,&quot;name1&quot;);
    Customer customer2 = new Customer(&quot;id2&quot;,&quot;name2&quot;);
    Customer customer3 = new Customer(&quot;id3&quot;,&quot;name3&quot;);
    AbstractList&lt;Customer&gt; customerList = new ObjectList&lt;&gt;();
    customerList.add(customer1);
    customerList.add(customer2);
    customerList.add(customer3);

    Iterator&lt;Customer&gt; customerIterator = customerList.iterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNext())
        System.out.println(customerIterator.next());
    System.out.println();

    customerIterator = customerList.iterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    customerIterator = customerList.reversedIterator();
    while(customerIterator.hasNextName())
        System.out.println(customerIterator.nextName());
    System.out.println();
        
    Product product1 = new Product(&quot;product id 1&quot;,1);
    Product product2 = new Product(&quot;product id 2&quot;,2);
    Product product3 = new Product(&quot;product id 3&quot;,3);
    AbstractList&lt;Product&gt; productList = new ObjectList&lt;&gt;();
    productList.add(product1);
    productList.add(product2);
    productList.add(product3);

    Iterator&lt;Product&gt; productIterator = productList.iterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    productIterator = productList.reversedIterator();
    while(productIterator.hasNext())
        System.out.println(productIterator.next());
    System.out.println();
    try
    {
        productIterator = productList.iterator();
        productIterator.setProduct();
        while(productIterator.hasNextName())
            System.out.println(productIterator.nextName());
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}
</code></pre>
<p>首先创建了三个<code>Customer</code>，接着添加到<code>customerList</code>中，从<code>customerList</code>中的<code>iterator</code>获取正向迭代器以及从<code>reversedIterator</code>获取正向迭代器，两种遍历方式的迭代器可以使用同样的语句实现遍历：</p>
<pre><code class="language-java">while(customerIterator.hasNext())
	System.out.println(customerIterator.next());
</code></pre>
<p>对于<code>Product</code>，由于<code>hasNextName</code>以及<code>nextName</code>声明了抛出异常，因此测试输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801135447573.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-内部类实现">4 内部类实现</h1>
<p>上面的例子可以看到在具体聚合类以及具体迭代器之间存在关联关系，具体迭代器需要维持一个对具体聚合对象（或里面的集合）的引用，除了使用关联关系外，还可以将迭代器设计为聚合类的内部类，比如JDK中的<code>AbstractList</code>：</p>
<pre><code class="language-java">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {
	//...
	private class Itr implements Iterator&lt;E&gt; {
		//...
	}
	//...
}
</code></pre>
<p>使用类似的方式重新设计上面的例子：</p>
<pre><code class="language-java">class ObjectList&lt;T&gt; implements AbstractList&lt;T&gt;
{
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    @Override
    public Iterator&lt;T&gt; iterator()
    {
        return new ObjectIterator(false);
    }
    @Override
    public void add(T s)
    {
        list.add(s);
    }
    @Override
    public Iterator&lt;T&gt; reversedIterator()
    {
        return new ObjectIterator(true);
    }

    private class ObjectIterator implements Iterator&lt;T&gt;
    {
        private int cursor;
        private boolean reversed;
        private boolean isProduct = false;
        public ObjectIterator(boolean reversed)
        {
            this.reversed = reversed;
            this.cursor = (reversed ? list.size() : -1);
        }
        //...
    }
}
</code></pre>
<p>改变的就是具体迭代器的构造方法，不需要注入聚合对象了，另外也取消了泛型的声明。</p>
<h1 id="5-jdk迭代器">5 JDK迭代器</h1>
<h2 id="51-iterator">5.1 <code>Iterator</code></h2>
<p>JDK（OpenJDK11.0.2）中的<code>Collection</code>方法摘录如下：</p>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
	//...
	Iterator&lt;E&gt; iterator();
	//...
}
</code></pre>
<p>该方法用于返回一个迭代器，以便遍历聚合类中的元素，其中<code>Iterator</code>定于如下：</p>
<pre><code class="language-java">public interface Iterator&lt;E&gt; {
	boolean hasNext();
	E next();
	default void remove() {
		//...
	}
	default void forEachRemaining(Consumer&lt;? super E&gt; action) {
		//...
	}
}
</code></pre>
<p>其中：</p>
<ul>
<li><code>hasNext</code>：用于判断聚合对象是否存在下一个元素，需要在调用<code>next</code>之前调用</li>
<li><code>next</code>：将下标移至下一个元素，并返回游标所越过的那个元素的引用，也就是获取下一个元素</li>
<li><code>remove</code>：删除上一次<code>next</code>的返回的元素</li>
<li><code>forEachRemaining</code>：用于对剩余元素进行的操作，比如一个集合有10个元素，使用迭代器遍历了前5个，则使用该方法会遍历剩下的元素，也就是后5个</li>
</ul>
<p>Java迭代器原理如图：<br>
<img src="https://img-blog.csdnimg.cn/2020080115523623.png" alt="在这里插入图片描述" loading="lazy"><br>
第一个<code>next</code>被调用时，迭代器游标由0号位置移到1号位置，也就是移动到元素1以及元素2之间，接着返回游标越过的元素，也就是元素1。下一次调用<code>next</code>时，游标继续移动，从1号位置移动到2号位置，并返回越过的元素，也就是元素2。对于<code>remove</code>来说，删除上一次<code>next</code>返回的元素，也就是如果此时调用<code>remove</code>会删除元素2。</p>
<p>也就是在调用<code>remove</code>之前至少需要调用一次<code>next</code>，如果不调用<code>next</code>的话，会抛出异常：<br>
<img src="https://img-blog.csdnimg.cn/20200801155359430.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-listiterator">5.2 <code>ListIterator</code></h2>
<p>JDK中的<code>List</code>接口除了继承<code>Collection</code>接口的<code>iterator</code>外，还增加一个<code>listIterator</code>，专门用于创建<code>ListIterator</code>类型的迭代器。用于遍历集合已经有了<code>Iterator</code>，但是这个迭代器只能用于正向遍历，而<code>ListIterator</code>的出现能解决逆向遍历的问题，因为其中提供了<code>hasPrevious</code>以及<code>previous</code>等方法。例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;String&gt; s = new ArrayList&lt;&gt;();
    s.add(&quot;1111&quot;);
    s.add(&quot;2222&quot;);
    s.add(&quot;3333&quot;);
    ListIterator&lt;String&gt; it = s.listIterator();
    while(it.hasNext())
        System.out.println(it.next());
    System.out.println();
    while(it.hasPrevious())
        System.out.println(it.previous());
}
</code></pre>
<p>实现完整的逆向遍历时，需要先将游标移动到末尾，也就是不断调用<code>next</code>直到末尾，才能实现调用<code>previous</code>进行逆向遍历。</p>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>多种遍历方式：支持以不同方式遍历聚合对象，在同一聚合对象上可以定义多种遍历方法，只需要用一个不同的聚合器替换原来的迭代器即可改变遍历算法</li>
<li>简化聚合类：原有的聚合对象不需要再自行提供数据遍历方法</li>
<li>满足OCP：由于引入了抽象层，增加新的聚合类以及迭代器类都很方便，无须修改源码</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>复杂度增加：迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，增加了复杂性</li>
<li>抽象迭代器较难设计：考虑到以后的扩展，抽象迭代器的设计难度可能非常大，比如JDK的内置迭代器<code>Iterator</code>就无法实现逆向遍历，设计一个考虑全面的抽象迭代器并不是一件容易的事</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据存储分离，使得访问聚合对象时无须了解内部实现细节</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020080116201951.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十八）：解释器模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-ba-jie-shi-qi-mo-shi/">
        </link>
        <updated>2020-08-02T02:30:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">1.2 相关术语</a>
<ul>
<li><a href="#121-%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99">1.2.1 文法规则</a></li>
<li><a href="#122-bnf%E7%AC%A6%E5%8F%B7">1.2.2 BNF符号</a></li>
<li><a href="#123-%E7%BB%88%E7%BB%93%E7%AC%A6%E4%B8%8E%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6">1.2.3 终结符与非终结符</a></li>
<li><a href="#124-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91">1.2.4 抽象语法树</a></li>
</ul>
</li>
<li><a href="#13-%E5%AE%9A%E4%B9%89">1.3 定义</a></li>
<li><a href="#14-%E7%BB%93%E6%9E%84%E5%9B%BE">1.4 结构图</a></li>
<li><a href="#15-%E8%A7%92%E8%89%B2">1.5 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E7%8E%AF%E5%A2%83%E7%B1%BB">2.2 环境类</a></li>
<li><a href="#23-%E6%8A%BD%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.3 抽象表达式</a></li>
<li><a href="#24-%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.4 终结符表达式</a></li>
<li><a href="#25-%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.5 非终结符表达式</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95">4 扩展</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>解释器模式是一种使用频率较低但是学习难度较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。某些情况下可能需要自定义一个新语言，这种语言具有自己的文法规则，这时可以使用解释器模式进行设计，比如模拟机器人的控制程序，每一条指令对应一个动作，通过解释输入的指令来实现对机器人的控制。下面先来看一些术语定义。</p>
<h2 id="12-相关术语">1.2 相关术语</h2>
<h3 id="121-文法规则">1.2.1 文法规则</h3>
<p>文法规则是用于描述语言的语法的规则，比如，汉语中一个句子的文法规则为：</p>
<pre><code class="language-bash">主 谓 宾
</code></pre>
<p>这就是句子的文法规则，同样计算机语言也有自己的文法规则。</p>
<h3 id="122-bnf符号">1.2.2 BNF符号</h3>
<p>BNF是<code>Backus-Naur Form</code>的缩写，是由<code>John Backus</code>以及<code>Peter Naur</code>首次引入的一种形式化符号来描述给定语言的语法，BNF中定义的部分符号如下：</p>
<ul>
<li><code>::=</code>：表示<code>定义为</code>，左边的语言单位可以通过右边进行说明和定义</li>
<li><code>|</code>：表示<code>或者</code></li>
<li><code>&quot;</code>或<code>'</code>：双引号或单引号里面的字符串表示字符串本身</li>
</ul>
<h3 id="123-终结符与非终结符">1.2.3 终结符与非终结符</h3>
<p>在以下的模拟描述机器人移动的文法规则中：</p>
<pre><code class="language-bash">expression ::= direction action distance | composite   //表达式
composite ::= expression 'and' expression              //复合表达式
direction ::= 'up' | 'down' | 'left'| 'right'          //移动方向
action ::= 'move' | 'run'                              //移动方式
distance ::= an integer                                //移动距离
</code></pre>
<p>定义了5条文法规则，对应5个语言单位，这些语言单位可以分为：</p>
<ul>
<li>终结符（也叫终结符表达式）：语言的最小组成单位，不能再拆分，比如上面的<code>direction</code>或<code>action</code></li>
<li>非终结符（也叫非终结符表达式）：一个完整的句子，包含一些列终结符或非终结符</li>
</ul>
<h3 id="124-抽象语法树">1.2.4 抽象语法树</h3>
<p>除了使用文法规则定义一个语言外，还能使用一种叫抽象语法树的直观方式表示，例如表达式：</p>
<pre><code class="language-bash">1 / 2 * 3 - 4 + 1
</code></pre>
<p>可以通过如下抽象语法树定义：<br>
<img src="https://img-blog.csdnimg.cn/20200801165057650.png" alt="在这里插入图片描述" loading="lazy"><br>
在该抽象语法树中，可以通过终结符<code>value</code>以及非终结符<code>operation</code>组成复杂的语句，终结符作为抽象语法树的叶子，非终结符作为非叶子节点，可以将终结符或者包含终结符与非终结符的节点作为子节点。</p>
<h2 id="13-定义">1.3 定义</h2>
<p><strong>解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。</strong></p>
<p>这里的语言指的是使用规定格式以及语法的代码。解释器模式是一种类行为型模式。</p>
<h2 id="14-结构图">1.4 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200801195332936.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="15-角色">1.5 角色</h2>
<ul>
<li><strong><code>AbstractExpression</code>（抽象表达式）：声明了抽象的解释操作，是所有终结符表达式以及非终结符表达式的父类</strong></li>
<li><strong><code>TerminalExpression</code>（终结符表达式）：抽象表达式的子类，实现了与文法规则中的终结符相关联的解释操作，句子中的每一个终结符都是该类的一个实例，通常只有少数几个终结符表达式类</strong></li>
<li><strong><code>NonterminalExpression</code>（非终结符表达式）：也是抽象表达式的子类，实现了文法规则中非终结符的解释操作，由于非终结符表达式可以包含非终结符表达式以及终结符表达式，因此一般通过递归方式完成解释</strong></li>
<li><strong><code>Context</code>（环境类）：用于存储解释器之外的一些全局信息，通常它临时存储需要解释的语句</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>（可选）定义环境类：首先对环境类进行定义，使用集合存储相关的全局或公共信息，用于在具体解释时获取，如果无须全局信息则环境类可以省略</li>
<li>定义抽象表达式类：接口/抽象类，声明抽象解释操作</li>
<li>定义终结符表达式类：继承/实现抽象表达式，定义终结符的解释操作</li>
<li>定义非终结符表达式类：继承/实现抽象表达式，定义非终结符解释操作，一般通过递归处理</li>
</ul>
<h2 id="22-环境类">2.2 环境类</h2>
<p>这里暂时不需要环境类，为了兼容定义一个空类：</p>
<pre><code class="language-java">class Context{}
</code></pre>
<h2 id="23-抽象表达式">2.3 抽象表达式</h2>
<p>包含抽象解释操作方法：</p>
<pre><code class="language-java">interface AbstractExpression
{
    void interpret(Context context);
}
</code></pre>
<h2 id="24-终结符表达式">2.4 终结符表达式</h2>
<p>解释终结符表达式：</p>
<pre><code class="language-java">class TerminalExpression implements AbstractExpression
{
    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;终结符解析&quot;);
    }
}
</code></pre>
<h2 id="25-非终结符表达式">2.5 非终结符表达式</h2>
<pre><code class="language-java">class NonterminalExpression implements AbstractExpression
{
    private AbstractExpression left;
    private AbstractExpression right;

    public NonterminalExpression(AbstractExpression left,AbstractExpression right)
    {
        this.left = left;
        this.right = right;
    }

    @Override
    public void interpret(Context context)
    {
        System.out.println(&quot;非终结符解析&quot;);
        if(left != null)
            left.interpret(context);
        if(right != null)
            right.interpret(context);
    }
}
</code></pre>
<p>解释非终结符时一般需要递归处理，这里模拟了非终结符左右两边的表达式操作。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractExpression expression1 = new TerminalExpression();
    AbstractExpression expression2 = new TerminalExpression();
    AbstractExpression expression3 = new NonterminalExpression(expression1,expression2);
    expression3.interpret(null);
}
</code></pre>
<p>定义两个终结符表达式与一个非终结符表达式，最后对非终结符表达式进行解释。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>对机器人移动指令进行解释，移动的语法表达如下：方向 方式 距离，方向包括上下左右四个方向，方式包括跑以及一般移动，距离为一个整数，一条移动指令可以组合多条子移动指令，使用解释器模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>环境类：这里为空</li>
<li>抽象表达式类：<code>AbstractNode</code></li>
<li>终结符表达式类：<code>DirectionNode</code>+<code>ActionNode</code>+<code>DistanceNode</code></li>
<li>非终结符表达式类：<code>AndNode</code>+<code>SentenceNode</code></li>
</ul>
<p>抽象表达式类如下：</p>
<pre><code class="language-java">interface AbstractNode
{
    String interpret(String str);
}
</code></pre>
<p>终结符表达式类：</p>
<pre><code class="language-java">class DirectionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;up&quot;, &quot;向上&quot;);
        strs.put(&quot;down&quot;, &quot;向下&quot;);
        strs.put(&quot;left&quot;, &quot;向左&quot;);
        strs.put(&quot;right&quot;, &quot;向右&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class ActionNode implements AbstractNode
{
    private static final Map&lt;String,String&gt; strs;
    static
    {
        strs = new HashMap&lt;&gt;();
        strs.put(&quot;move&quot;, &quot;移动&quot;);
        strs.put(&quot;run&quot;, &quot;快速移动&quot;);
    }
    @Override
    public String interpret(String str)
    {
        return strs.containsKey(str) ? strs.get(str) : &quot;无效操作&quot;;
    }
}

class DistanceNode implements AbstractNode
{
    @Override
    public String interpret(String str)
    {
        return str;
    }
}
</code></pre>
<p>根据对应的字符串返回相应的字符串即可。</p>
<p>非终结符表达式类：</p>
<pre><code class="language-java">class SentenceNode implements AbstractNode
{
    private final AbstractNode direction = new DirectionNode();
    private final AbstractNode action = new ActionNode();
    private final AbstractNode distance = new DistanceNode();
    @Override
    public String interpret(String s)
    {
        String [] str = s.split(&quot; &quot;);
        return direction.interpret(str[0])+action.interpret(str[1])+distance.interpret(str[2]);
    }
}

class AndNode implements AbstractNode
{
    @Override
    public String interpret(String s)
    {
        if(s.contains(&quot;and&quot;))
        {
            int index = s.indexOf(&quot;and&quot;);
            String leftStr = s.substring(0, index-1);
            String rightStr = s.substring(index+4);
            AbstractNode left = (leftStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            AbstractNode right = (rightStr.contains(&quot;and&quot;) ? new AndNode() : new SentenceNode());
            return left.interpret(leftStr) + &quot; 再 &quot; + right.interpret(rightStr);
        }
        return new SentenceNode().interpret(s);
    }
}
</code></pre>
<p>其中<code>AndNode</code>采取了递归进行解释操作，如果分割后的字符串还含有<code>and</code>则赋值为<code>AndNode</code>，否则为<code>SentenceNode</code>。</p>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    AbstractNode node = new AndNode();
    System.out.println(node.interpret(&quot;up move 5 and down run 10 and down move 10 and left run -9&quot;));
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200802015840189.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-扩展">4 扩展</h1>
<p>如果项目中需要对数据表达式进行分析与计算，可以直接使用现有的库，比如：</p>
<ul>
<li>Expression4J</li>
<li>MESP</li>
<li>Jep</li>
<li>Fel</li>
</ul>
<p>等等，下面以Jep为例演示该库的使用方法。Jep是<code>Java expression parser</code>的简称，即Java表达式分析器，它是一个用来转换和计算数学表达式的Java库，用户可以以字符串形式输入一个任意公式，然后快速计算出结果。Jep支持用户自定义变量，常量，函数，包括很多常用的数学函数以及常量。</p>
<p>首先<a href="http://www.singularsys.com/jep/download-trial.php">下载</a>JAR包依赖，例子如下：</p>
<pre><code class="language-java">import com.singularsys.jep.*;

public class Test
{
    public static void main(String[] args) throws Exception
    {
        Jep jep=new Jep();
        //定义要计算的数据表达式
        String interestOnDeposit=&quot;本金*利率*时间&quot;;
        //给相关变量赋值
        jep.addVariable(&quot;本金&quot;,10000);
        jep.addVariable(&quot;利率&quot;,0.038);
        jep.addVariable(&quot;时间&quot;,2);
        jep.parse(interestOnDeposit);     //解析表达式
        Object accrual=jep.evaluate();    //计算
        System.out.println(&quot;存款利息：&quot;+accrual);
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>扩展性好：由于解释器中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>便于实现语言：每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</li>
<li>实现文法容易：抽象语法树中每一个表达式节点类的实现方式都是类似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码</li>
<li>增加解释表达式方便：如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式，原有表达式类无须修改</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>复杂文法难以维护：在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则会导致类个数急增，导致系统难以管理和维护，可以考虑使用语法分析程序来取代解释器模式</li>
<li>执行效率低：由于解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时速度很慢，而且代码的调试过程也比较麻烦</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来描述</li>
<li>一个语言的文法较为简单</li>
<li>执行效率不是关键问题</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200802081552906.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十七）：命令模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-qi-ming-ling-mo-shi/">
        </link>
        <updated>2020-08-02T02:28:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E5%91%BD%E4%BB%A4%E7%B1%BB">2.2 抽象命令类</a></li>
<li><a href="#23-%E8%B0%83%E7%94%A8%E8%80%85">2.3 调用者</a></li>
<li><a href="#24-%E6%8E%A5%E6%94%B6%E8%80%85">2.4 接收者</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%91%BD%E4%BB%A4%E7%B1%BB">2.5 具体命令类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97">4 命令队列</a></li>
<li><a href="#5-%E6%92%A4%E9%94%80%E4%B8%8E%E9%87%8D%E5%81%9A">5 撤销与重做</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>日常生活中，可以通过开关控制一些电器的开启和关闭，比如电灯和排气扇。可以将开关理解成一个请求发送者，电灯是请求的最红接收者以及处理者，开关与电灯之间不存在直接的耦合关系，两者通过电线连接在一起，使不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）既可对应不同的接收者（电器）。</p>
<p>软件开发中经常需要向某些对象发送请求，但是并不知道具体的接收者是谁，也不知道被请求的操作是哪个，此时希望以一种松耦合的方式来设计软件，使得请求发送者与请求接收者之间能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作，此时可以使用命令模式进行设计。</p>
<p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<h2 id="12-定义">1.2 定义</h2>
<p>命令模式：将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p>命令模式是一种对象行为型模式，别名为动作模式或者事务模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200731194318933.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Command</code>（抽象命令类）：抽象命令类一般是一个抽象类或者接口，在其中声明了用于执行请求的<code>execute()</code>方法，通过这些方法可以调用请求接收者的相关操作</strong></li>
<li><strong><code>ConcreteCommand</code>（具体命令类）：实现了抽象命令类中声明的方法，对应具体的接收者对象，将接收者对象的动作绑定其中，在实现<code>execute()</code>方法时，将调用接收者对象的相关操作</strong></li>
<li><strong><code>Invoker</code>（调用者）：调用者即请求发送者，通过命令对象来执行请求。一个调用者并不需要设计时确定接收者，因此它只与抽象命令类之间存在关联关系。程序运行时将具体命令对象注入，并调用其中的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作</strong></li>
<li><strong><code>Receiver</code>（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象命令类：定义执行请求的方法</li>
<li>定义调用者：在调用方法里面包含对具体命令的调用，同时需要包含一个对抽象命令的引用</li>
<li>定义接收者：定义接收请求的业务方法</li>
<li>定义具体命令类：继承/实现抽象命令类，实现其中执行请求方法，转发到接收者的接收方法</li>
</ul>
<h2 id="22-抽象命令类">2.2 抽象命令类</h2>
<p>这里实现为一个接口：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<h2 id="23-调用者">2.3 调用者</h2>
<pre><code class="language-java">class Invoker
{
    private Command command;

    public Invoker(Command command)
    {
        this.command = command;
    }

    public void call()
    {
        System.out.println(&quot;调用者操作&quot;);
        command.execute();
    }
}
</code></pre>
<p>调用者可以通过构造方法或者setter注入具体命令，对外提供一个调用方法<code>call</code>，当调用此方法时调用具体命令的<code>execute</code>。</p>
<h2 id="24-接收者">2.4 接收者</h2>
<pre><code class="language-java">class Receiver
{
    public void action()
    {
        System.out.println(&quot;接收者操作&quot;);
    }
}
</code></pre>
<p>这里的接收者只有一个<code>action</code>，表示接收方法。</p>
<h2 id="25-具体命令类">2.5 具体命令类</h2>
<pre><code class="language-java">class ConcreteCommand implements Command
{
    private Receiver receiver = new Receiver();
    @Override
    public void execute()
    {
        receiver.action();
    }
}
</code></pre>
<p>具体命令类中需要包含一个对接收者的引用，以便在<code>execute</code>中调用接收者。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Invoker invoker = new Invoker(new ConcreteCommand());
    invoker.call();
}
</code></pre>
<p>通过构造方法注入具体命令到调用者中，接着直接调用即可。</p>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200731202157394.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>自定义功能键的设置，对于一个按钮，可以根据需要由用户设置为最小化/最大化/关闭功能，使用命令模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Button</code></li>
<li>接收者：<code>MinimizeHandler</code>+<code>MaximizeHandler</code>+<code>CloseHandler</code></li>
<li>具体命令类：<code>MinimizeCommand</code>+<code>MaximizeCommand</code>+<code>CloseCommand</code></li>
</ul>
<p>首先设计抽象命令类，实现为一个接口，仅包含<code>execute</code>方法：</p>
<pre><code class="language-java">interface Command
{
    void execute();
}
</code></pre>
<p>接着是调用者类，包含一个抽象命令的引用：</p>
<pre><code class="language-java">class Button
{
    private Command command;
    public Button(Command command)
    {
        this.command = command;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        command.execute();
    }
}
</code></pre>
<p>然后是接收者类：</p>
<pre><code class="language-java">class MinimizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最小化&quot;);
    }
}

class MaximizeHandler
{
    public void handle()
    {
        System.out.println(&quot;最大化&quot;);
    }
}

class CloseHandler
{
    public void handle()
    {
        System.out.println(&quot;关闭&quot;);
    }
}
</code></pre>
<p>最后是具体命令类，对应包含一个接收者成员即可，实现其中的<code>execute</code>并转发到接收者的方法：</p>
<pre><code class="language-java">class MinimizeCommand implements Command
{
    private MinimizeHandler handler = new MinimizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class MaximizeCommand implements Command
{
    private MaximizeHandler handler = new MaximizeHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}

class CloseCommand implements Command
{
    private CloseHandler handler = new CloseHandler();
    @Override
    public void execute()
    {
        handler.handle();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Button button = new Button(new MinimizeCommand());
    button.onClick();

    button = new Button(new MaximizeCommand());
    button.onClick();

    button = new Button(new CloseCommand());
    button.onClick();
}
</code></pre>
<p>输出：<br>
<img src="https://img-blog.csdnimg.cn/2020080100022354.png" alt="在这里插入图片描述" loading="lazy"><br>
如果需要新增一个命令，只需要命令接收者以及实现了<code>Command</code>的具体命令类，客户端再将具体命令注入请求发送者（<code>Button</code>），无须直接操作请求接收者。</p>
<h1 id="4-命令队列">4 命令队列</h1>
<p>有时候需要将多个请求排队，当一个请求发送者发送完成一个请求后，不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法完成对请求的处理。这种形式可以通过命令队列实现，实现命令队列很简单，一般是增加一个叫<code>CommandQueue</code>的类，由该类负责存储多个命令对象，不同的命令对象可以对应不同的请求接收者，比如在上面的例子中增加<code>CommandQueue</code>命令队列类：</p>
<pre><code class="language-java">class CommandQueue
{
    private ArrayList&lt;Command&gt; commands = new ArrayList&lt;&gt;();
    public void add(Command command)
    {
        commands.add(command);
    }

    public void remove(Command command)
    {
        commands.remove(command);
    }

    public void execute()
    {
        System.out.println(&quot;批量执行命令&quot;);
        commands.forEach(Command::execute);
    }
}
</code></pre>
<p>接着修改调用者类<code>Button</code>（只需将原来的<code>Command</code>改为<code>CommandQueue</code>）：</p>
<pre><code class="language-java">class Button
{
    private CommandQueue queue;
    public Button(CommandQueue queue)
    {
        this.queue = queue;
    }

    public void onClick()
    {
        System.out.println(&quot;按钮被点击&quot;);
        queue.execute();
    }
}
</code></pre>
<p>最后是客户端定义命令队列并作为参数传入调用者的构造方法或者setter中，最后由调用者执行方法：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    CommandQueue queue = new CommandQueue();
    queue.add(new MinimizeCommand());
    queue.add(new MaximizeCommand());
    queue.add(new CloseCommand());
    Button button = new Button(queue);
    button.onClick();
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200801001917143.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-撤销与重做">5 撤销与重做</h1>
<blockquote>
<p>设计一个简易计算器，实现加法功能，还能够实现撤销以及重做功能，使用命令模式实现。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象命令类：<code>Command</code></li>
<li>调用者：<code>Calculator</code></li>
<li>接收者：<code>Adder</code></li>
<li>具体命令类：<code>AddCommand</code></li>
</ul>
<p>首先先不实现撤销以及重做功能：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) 
    {
        Calculator calculator = new Calculator(new AddCommand());
        calculator.add(3);
        calculator.add(9);
    }
}

interface Command
{
    int execute(int value);
}

class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }
}

class Adder
{
    private int num = 0;
    public int add(int value)
    {
        return num += value;
    }
}

class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }
}
</code></pre>
<p>代码与上面的实例类似，就不解释了。</p>
<p>这里关键的问题是如何实现撤销以及重做功能，撤销能够恢复到进行加法之前的状态，而重做能恢复到进行了加法之后的状态，而且这是有固定顺序的，因此可以联想到数组，使用下标表示当前状态，下标左移表示撤销，下标右移表示重做：<br>
<img src="https://img-blog.csdnimg.cn/2020080100442690.png" alt="在这里插入图片描述" loading="lazy"><br>
使用一个状态数组存储每次进行加法的状态，用下标表示当前状态，当撤销时，使下标左移，当重做时，使下标右移。</p>
<p>首先需要修改抽象命令类，添加撤销以及重做方法：</p>
<pre><code class="language-java">interface Command
{
    int execute(int value);
    int undo();
    int redo();
}
</code></pre>
<p>接着修改调用者类，添加撤销以及重做方法：</p>
<pre><code class="language-java">class Calculator
{
    private Command command;
    public Calculator(Command command)
    {
        this.command = command;
    }

    public void add(int value)
    {
        System.out.println(command.execute(value));
    }

    public void undo()
    {
        System.out.println(command.undo());
    }

    public void redo()
    {
        System.out.println(command.redo());
    }
}
</code></pre>
<p>核心的实现位于接收者类<code>Adder</code>，使用了<code>List&lt;Integer&gt;</code>存储了状态，<code>index</code>表示下标，在撤销或重做之前首先判断下标位置是否合法，合法则进行下一步操作：</p>
<pre><code class="language-java">class Adder
{
    private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    private int index = 0;
    public Adder()
    {
        nums.add(0);
    }

    public int add(int value)
    {
        int result = nums.get(index)+value;
        nums.add(result);
        ++index;
        return result;
    }

    public int redo()
    {
        if(index + 1 &lt; nums.size())
            return nums.get(++index);
        return nums.get(index);
    }

    public int undo()
    {
        if(index - 1 &gt;= 0)
            return nums.get(--index);
        return nums.get(index);
    }
}
</code></pre>
<p>最后具体命令类简单添加撤销以及重做方法即可：</p>
<pre><code class="language-java">class AddCommand implements Command
{
    private Adder adder = new Adder();
    @Override
    public int execute(int value)
    {
        return adder.add(value);
    }

    @Override
    public int undo()
    {
        return adder.undo();
    }

    @Override
    public int redo()
    {
        return adder.redo();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Calculator calculator = new Calculator(new AddCommand());
    calculator.add(3);
    calculator.add(9);
    
    calculator.undo();
    calculator.undo();
    calculator.undo();
    calculator.undo();
    
    calculator.redo();
    calculator.redo();
    calculator.redo();
    calculator.redo();
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200801005520961.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>降低耦合度：由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求可以对应不同的接收者，同样相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性</li>
<li>满足OCP：新的命令可以很容易添加到系统中，由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，满足OCP的要求</li>
<li>撤销+中作：为请求的撤销以及重做提供了一种设计和实现方案</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>过多具体命令类：使用命令模式可能会导致系统有过多的具体命令类，因为针对每一个请求接收者的调用操作都需要设计一个具体工具类，因此在某些系统中可能需要提供大量的具体命令类</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>系统需要将请求调用者和请求接受者解耦，使得调用者和接收者不直接交互，请求调用者无须知道接收者的存在，也无需知道接收者是谁，接收者也无须关心何时被调用</li>
<li>系统需要在不同时间指定请求，将请求排队和执行请求</li>
<li>系统需要支持撤销以及恢复操作</li>
<li>系统需要将一组操作组合一起形成宏命令，使用命令队列实现</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200801012404628.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>