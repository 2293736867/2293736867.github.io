<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-05-21T04:39:08.283Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第341期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-341-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-341-qi/">
        </link>
        <updated>2021-05-21T04:33:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别人露腿那叫美，你露腿就想让人怼。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>黄师塔前江水东，春光懒困倚微风。<br>
——杜甫《江畔独步寻花·其五》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>只要微笑就可以了。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621571697210.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>实际上是最长公共子序列：</p>
<pre><code class="language-java">public class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621571700653.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第340期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-340-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-340-qi/">
        </link>
        <updated>2021-05-20T02:04:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>为什么中国人结婚，都非要选个好日子呢？因为结完婚就没好日子过了！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>阳春布德泽，万物生光辉。<br>
——佚名《长歌行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>掉头一去是风吹黑发，回首再来已雪满白头。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621489567021.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>统计词频+优先队列（前k个）：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;String&gt; topKFrequent(String[] words, int k) {
        Map&lt;String, Node&gt; map = new HashMap&lt;&gt;();
        for (String s : words) {
            if(map.containsKey(s)){
                ++map.get(s).ct;
            }else{
                map.put(s,new Node(s));
            }
        }

        PriorityQueue&lt;Node&gt; heap = new PriorityQueue&lt;&gt;((s1,s2)-&gt; s1.ct == s2.ct ? s1.s.compareTo(s2.s) : (s2.ct - s1.ct));

        for (Node node:map.values()){
            heap.offer(node)    ;
        }

        List&lt;String&gt; list = new ArrayList&lt;&gt;(k);
        for (int i = 0; i &lt; k; i++) {
            list.add(heap.poll().s);
        }
        return list;
    }

    private static class Node{
        String s;
        int ct;

        public Node(String s){
            ct = 1;
            this.s = s;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621489575585.png" alt="" loading="lazy"></figure>
<h1 id="听说今天是520">听说今天是520</h1>
<p>真搞不懂为什么这么多人送礼物？</p>
<p>今天又不是什么特殊的日子。</p>
<p>至于吗？</p>
<p>520居然真的还会有人送礼物？</p>
<p>不会吧不会吧？</p>
<p>都2021年了，</p>
<p>不会真的有人在520送礼物吧？</p>
<p>不会吧不会吧？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第339期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-339-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-339-qi/">
        </link>
        <updated>2021-05-19T01:56:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>打工钱少就出来创业吧，保证能让你，赔个精光。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>两岸桃花烘日出，思维高柳到天垂。<br>
——姜彧《浣溪沙·山滴岚光水拍堤》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你的名字那么普通也就我听到会心头一怔。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621476068651.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>前缀和+快速选择：</p>
<pre><code class="language-java">public class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        int [][] xor = new int[m+1][n+1];

        int []result = new int[m*n];
        int resultIndex = 0;

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                result[resultIndex++] = xor[i+1][j+1] = (matrix[i][j] ^ xor[i+1][j] ^ xor[i][j+1] ^ xor[i][j]);
            }
        }

        return quickSelect(result,0,m*n-1,m*n-k+1);
    }

    private int quickSelect(int []nums,int start,int end,int k){
        if (start == end) {
            return nums[start];
        }
        int left = start;
        int right = end;
        int pivot = nums[start + (end - start) / 2];
        while (left &lt;= right) {
            if (nums[left] &lt; pivot) {
                left++;
            } else if (nums[right] &gt; pivot) {
                right--;
            } else {
                int temp = nums[left];
                nums[left++] = nums[right];
                nums[right--] = temp;
            }
        }
        if (start + k - 1 &lt;= right) {
            return quickSelect(nums, start, right, k);
        }
        if (start + k - 1 &gt;= left) {
            return quickSelect(nums, left, end, start + k - left);
        }
        return nums[right + 1];
    }

}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621489558295.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第338期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-338-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-338-qi/">
        </link>
        <updated>2021-05-17T16:32:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>岁月让我知道，除了快递，我谁也不必等。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>来时浦口花迎入，采罢江头月送归。<br>
——王昌龄《采莲曲二首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我发现，勇气根本靠不住，只有完全的疯狂才有意义。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621269247204.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>暴力<code>O(n3)</code>：</p>
<pre><code class="language-java">
public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int [] x = new int[n];
        x[0] = arr[0];
        for (int i = 1; i &lt; n; i++) {
            x[i] = arr[i] ^ x[i-1];
        }
        for (int i = 0; i &lt; n; i++) {
            for (int j = i+1; j &lt; n; j++) {
                for (int k = j; k &lt; n; k++) {
                    int a = (i-1 &gt;= 0 ? x[j-1] ^ x[i-1] : x[j-1]);
                    int b = x[k] ^ x[j-1];
                    if(a == b){
                        ++sum;
                    }
                }
            }
        }
        return sum;
    }
}
</code></pre>
<p>自己也不太看得下去：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621269284763.png" alt="" loading="lazy"></figure>
<p><s>真·时间换空间。</s></p>
<p>题解还有一个<code>O(n^2)</code>的，核心公式如下：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1621269590200.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1621269595883.png" alt="" loading="lazy"></figure>
<p>符合范围的<code>i</code>、<code>k</code>，<code>j</code>可以任意取值，也就是两者的差值：</p>
<pre><code class="language-java">public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int[] x = new int[n + 1];
        for (int i = 0; i &lt; n; i++) {
            x[i+1] = arr[i] ^ x[i];
        }
        for (int i = 0; i &lt; n; i++) {
            for (int k = i + 1; k &lt; n; k++) {
                if (x[i] == x[k + 1]) {
                    sum += k - i;
                }
            }
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1621269646584.png" alt="" loading="lazy"></figure>
<p>居然还有<code>O(n)</code>的：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int countTriplets(int[] arr) {
        int sum = 0;
        int n = arr.length;
        int[] x = new int[n + 1];
        for (int i = 0; i &lt; n; i++) {
            x[i + 1] = arr[i] ^ x[i];
        }

        Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();
        Map&lt;Integer, Integer&gt; total = new HashMap&lt;&gt;();

        for (int k = 0; k &lt; n; k++) {

            if (cnt.containsKey(x[k + 1])) {
                sum += cnt.get(x[k + 1]) * k - total.get(x[k + 1]);
            }

            cnt.put(x[k], cnt.getOrDefault(x[k], 0) + 1);
            total.put(x[k], total.getOrDefault(x[k], 0) + k);
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1621270596468.png" alt="" loading="lazy"></figure>
<p><code>O(n)</code>还要比<code>O(n^2)</code>要慢？？？？</p>
<p>好家伙。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第337期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-337-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-337-qi/">
        </link>
        <updated>2021-05-16T17:43:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>天将降大任于斯人也，必先苦其心志劳其筋骨，后来天改变主意了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>白发将军亦壮哉，西京昨夜捷书来。<br>
——陆游《闻武均州报已复西京》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>为众人抱薪者，不可使其冻毙于风雪。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621187068743.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>简单<code>DFS</code>：</p>
<pre><code class="language-java">
public class Solution {
    private int xParent;
    private boolean findX = false;
    private int yParent;
    private boolean findY = false;

    public boolean isCousins(TreeNode root, int x, int y) {
        return heightX(root,x) == heightY(root,y) &amp;&amp; xParent != yParent;
    }

    private int heightX(TreeNode root, int x) {
        if (root != null) {
            if (root.val == x) {
                findX = true;
                return 1;
            }
            if (root.left != null) {
                xParent = root.val;
                int temp = heightX(root.left, x);
                if (findX) {
                    return temp + 1;
                }
            }
            if (root.right != null) {
                xParent = root.val;
                int temp = heightX(root.right, x);
                if (findX) {
                    return temp + 1;
                }
            }
        }
        return 0;
    }

    private int heightY(TreeNode root, int y) {
        if (root != null) {
            if (root.val == y) {
                findY = true;
                return 1;
            }
            if (root.left != null) {
                yParent = root.val;
                int temp = heightY(root.left, y);
                if (findY) {
                    return temp + 1;
                }
            }
            if (root.right != null) {
                yParent = root.val;
                int temp = heightY(root.right, y);
                if (findY) {
                    return temp + 1;
                }
            }
        }
        return 0;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621187056629.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（四）：volatile关键字]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-si-volatile-guan-jian-zi/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-si-volatile-guan-jian-zi/">
        </link>
        <updated>2021-05-16T11:39:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第十二、十三章</li>
</ul>
<p>本文是两章的笔记整理。</p>
<h1 id="2-cpu缓存">2 <code>CPU</code>缓存</h1>
<h2 id="21-缓存模型">2.1 缓存模型</h2>
<p>计算机中的所有运算操作都是由<code>CPU</code>完成的，<code>CPU</code>指令执行过程需要涉及数据读取和写入操作，但是<code>CPU</code>只能访问处于内存中的数据，而内存的速度和<code>CPU</code>的速度是远远不对等的，因此就出现了缓存模型，也就是在<code>CPU</code>和内存之间加入了缓存层。一般现代的<code>CPU</code>缓存层分为三级，分别叫<code>L1</code>缓存、<code>L2</code>缓存和<code>L3</code>缓存，简略图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210515234450950.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>L1</code>缓存：三级缓存中访问速度最快，但是容量最小，另外<code>L1</code>缓存还被划分成了数据缓存（<code>L1d</code>，<code>data</code>首字母）和指令缓存（<code>L1i</code>，<code>instruction</code>首字母）</li>
<li><code>L2</code>缓存：速度比<code>L1</code>慢，但是容量比<code>L1</code>大，在现代的多核<code>CPU</code>中，<code>L2</code>一般被单个核独占</li>
<li><code>L3</code>缓存：三级缓存中速度最慢，但是容量最大，现代<code>CPU</code>中也有<code>L3</code>是多核共享的设计，比如<code>zen3</code>架构的设计</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210516000524728.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>缓存的出现，是为了解决<code>CPU</code>直接访问内存效率低下的问题，<code>CPU</code>进行运算的时候，将需要的数据从主存复制一份到缓存中，因为缓存的访问速度快于内存，在计算的时候只需要读取缓存并将结果更新到缓存，运算结束再将结果刷新到主存，这样就大大提高了计算效率，整体交互图简略如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210516001151927.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="22-缓存一致性问题">2.2 缓存一致性问题</h2>
<p>虽然缓存的出现，大大提高了吞吐能力，但是，也引入了一个新的问题，就是缓存不一致。比如，最简单的一个<code>i++</code>操作，需要将内存数据复制一份到缓存中，<code>CPU</code>读取缓存值并进行更新，先写入缓存，运算结束后再将缓存中新的刷新到内存，具体过程如下：</p>
<ul>
<li>读取内存中的<code>i</code>到缓存中</li>
<li><code>CPU</code>读取缓存<code>i</code>中的值</li>
<li>对<code>i</code>进行加1操作</li>
<li>将结果写回缓存</li>
<li>再将数据刷新到主存</li>
</ul>
<p>这样的<code>i++</code>操作在单线程不会出现问题，但在多线程中，因为每个线程都有自己的工作内存（也叫本地内存，是线程自己的缓存），变量<code>i</code>在多个线程的本地内存中都存在一个副本，如果有两个线程执行<code>i++</code>操作：</p>
<ul>
<li>假设两个线程为A、B，同时假设<code>i</code>初始值为0</li>
<li>线程A从内存中读取<code>i</code>的值放入缓存中，此时<code>i</code>的值为0，线程B也同理，放入缓存中的值也是0</li>
<li>两个线程同时进行自增操作，此时A、B线程的缓存中，<code>i</code>的值都是1</li>
<li>两个线程将<code>i</code>写入主内存，相当于<code>i</code>被两次赋值为1</li>
<li>最终结果是<code>i</code>的值为1</li>
</ul>
<p>这个就是典型的缓存不一致问题，主流的解决办法有：</p>
<ul>
<li>总线加锁</li>
<li>缓存一致性协议</li>
</ul>
<h3 id="221-总线加锁">2.2.1 总线加锁</h3>
<p>这是一种悲观的实现方式，具体来说，就是通过处理器发出<code>lock</code>指令，锁住总线，总线收到指令后，会阻塞其他处理器的请求，直到占用锁的处理器完成操作。特点是只有一个抢到总线锁的处理器运行，但是这种方式效率低下，一旦某个处理器获取到锁其他处理器只能阻塞等待，会影响多核处理器的性能。</p>
<h3 id="222-缓存一致性协议">2.2.2 缓存一致性协议</h3>
<p>图示如下：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210516002914904.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>缓存一致性协议中最出名的就是<code>MESI</code>协议，<code>MESI</code>保证了每一个缓存中使用的共享变量的副本都是一致的。大致思想是，<code>CPU</code>操作缓存中的数据时，如果发现该变量是一个共享变量，操作如下：</p>
<ul>
<li>读取：不做其他处理，只是将缓存中数据读取到寄存器中</li>
<li>写入：发出信号通知其他<code>CPU</code>将该变量的缓存行设置为无效状态（<code>Invalid</code>），其他<code>CPU</code>进行该变量的读取时需要到主存中再次获取</li>
</ul>
<p>具体来说，<code>MESI</code>中规定了缓存行使用4种状态标记：</p>
<ul>
<li><code>M</code>：<code>Modified</code>，被修改</li>
<li><code>E</code>：<code>Exclusive</code>，独享的</li>
<li><code>S</code>：<code>Shared</code>，共享的</li>
<li><code>I</code>：<code>Invalid</code>，无效的</li>
</ul>
<p>有关<code>MESI</code>详细的实现超出了本文的范围，想要详细了解可以参考<a href="https://www.cnblogs.com/yanlong300/p/8986041.html">此处</a>或<a href="http://www2.in.tum.de/hp/file?fid=1276">此处</a>。</p>
<h1 id="3-jmm">3 <code>JMM</code></h1>
<p>看完了<code>CPU</code>缓存再来看一下<code>JMM</code>，也就是<code>Java</code>内存模型，指定了<code>JVM</code>如何与计算机的主存进行工作，同时也决定了一个线程对共享变量的写入何时对其他线程可见，<code>JMM</code>定义了线程和主内存之间的抽象关系，具体如下：</p>
<ul>
<li>共享变量存储于主内存中，每个线程都可以访问</li>
<li>每个线程都有私有的工作内存或者叫本地内存</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li>
<li>工作内存和<code>JMM</code>内存模型一样也是一个抽象概念，其实并不存在，涵盖了缓存、寄存器、编译器优化以及硬件等</li>
</ul>
<p>简略图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210516104445340.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>与<code>MESI</code>类似，如果一个线程修改了共享变量，刷新到主内存后，其他线程读取工作内存的时候发现缓存失效，会从主内存再次读取到工作内存中。</p>
<p>而下图表示了<code>JVM</code>与计算机硬件分配的关系：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210516192712715.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-并发编程的三个特性">4 并发编程的三个特性</h1>
<p>文章都看了大半了还没到<code>volatile</code>？别急别急，先来看看并发编程中的三个重要特性，这对正确理解<code>volatile</code>有很大的帮助。</p>
<h2 id="41-原子性">4.1 原子性</h2>
<p>原子性就是在一次或多次操作中：</p>
<ul>
<li>要么所有的操作全部都得到了执行，且不会受到任何因素的干扰而中断</li>
<li>要么所有的操作都不执行</li>
</ul>
<p>一个典型的例子就是两个人转账，比如A向B转账1000元，那么这包含两个基本的操作：</p>
<ul>
<li>A的账户扣除1000元</li>
<li>B的账户增加1000元</li>
</ul>
<p>这两个操作，要么都成功，要么都失败，也就是不能出现A账户扣除1000但是B账户金额不变的情况，也不能出现A账户金额不变B账户增加1000的情况。</p>
<p>需要注意的是两个原子性操作结合在一起未必是原子性的，比如<code>i++</code>。本质上来说，<code>i++</code>涉及到了三个操作：</p>
<ul>
<li><code>get i</code></li>
<li><code>i+1</code></li>
<li><code>set i</code></li>
</ul>
<p>这三个操作都是原子性的，但是组合在一起（<code>i++</code>）就不是原子性的。</p>
<h2 id="42-可见性">4.2 可见性</h2>
<p>另一个重要的特性是可见性，可见性是指，一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</p>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public class Main {
    private int x = 0;
    private static final int MAX = 100000;
    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        Thread thread0 = new Thread(()-&gt;{
            while(m.x &lt; MAX) {
                ++m.x;
            }
        });

        Thread thread1 = new Thread(()-&gt;{
            while(m.x &lt; MAX){
            }
            System.out.println(&quot;finish&quot;);
        });

        thread1.start();
        TimeUnit.MILLISECONDS.sleep(1);
        thread0.start();
    }
}
</code></pre>
<p>线程<code>thread1</code>会一直运行，因为<code>thread1</code>把<code>x</code>读入工作内存后，会一直判断工作内存中的值，由于<code>thread0</code>改变的是<code>thread0</code>工作内存的值，并没有对<code>thread1</code>可见，因此永远也不会输出<code>finish</code>，使用<code>jstack</code>也可以看到结果：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210516121151277.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="43-有序性">4.3 有序性</h2>
<p>有序性是指代码在执行过程中的先后顺序，由于<code>JVM</code>的优化，导致了代码的编写顺序未必是代码的运行顺序，比如下面的四条语句：</p>
<pre><code class="language-java">int x = 10;
int y = 0;
x++;
y = 20;
</code></pre>
<p>有可能<code>y=20</code>在<code>x++</code>前执行，这就是指令重排序。一般来说，处理器为了提高程序的效率，可能会对输入的代码指令做一定的优化，不会严格按照编写顺序去执行代码，但可以保证最终运算结果是编码时的期望结果，当然，重排序也有一定的规则，需要严格遵守指令之间的数据依赖关系，并不是可以任意重排序，比如：</p>
<pre><code class="language-java">int x = 10;
int y = 0;
x++;
y = x+1;
</code></pre>
<p><code>y=x+1</code>就不能先优于<code>x++</code>执行。</p>
<p>在单线程下重排序不会导致预期值的改变，但在多线程下，如果有序性得不到保证，那么将可能出现很大的问题：</p>
<pre><code class="language-java">private boolean initialized = false;
private Context context;
public Context load(){
    if(!initialized){
        context = loadContext();
        initialized = true;
    }
    return context;
}
</code></pre>
<p>如果发生了重排序，<code>initialized=true</code>排序到了<code>context=loadContext()</code>的前面，假设两个线程A、B同时访问，且<code>loadContext()</code>需要一定耗时，那么：</p>
<ul>
<li>线程A通过判断后，先设置布尔变量的值为<code>true</code>，再进行<code>loadContext()</code>操作</li>
<li>线程B中由于布尔变量被设置为<code>true</code>，会直接返回一个未加载完成的<code>context</code></li>
</ul>
<h1 id="5-volatile">5 <code>volatile</code></h1>
<p>好了终于到了<code>volatile</code>了，前面说了这么多，目的就是为了能彻底理解和明白<code>volatile</code>。这部分分为四个小节：</p>
<ul>
<li><code>volatile</code>的语义</li>
<li>如何保证有序性以及可见性</li>
<li>实现原理</li>
<li>使用场景</li>
<li>与<code>synchronized</code>区别</li>
</ul>
<p>先来介绍一下<code>volatile</code>的语义。</p>
<h2 id="51-语义">5.1 语义</h2>
<p>被<code>volatile</code>修饰的实例变量或者类变量具有两层语义：</p>
<ul>
<li>保证了不同线程之间对共享变量操作时的可见性</li>
<li>禁止对指令进行重排序操作</li>
</ul>
<h2 id="52-如何保证可见性以及有序性">5.2 如何保证可见性以及有序性</h2>
<p>先说结论：</p>
<ul>
<li><code>volatile</code>能保证可见性</li>
<li><code>volatile</code>能保证有序性</li>
<li><code>volatile</code>不能保证原子性</li>
</ul>
<p>下面分别进行介绍。</p>
<h3 id="521-可见性">5.2.1 可见性</h3>
<p><code>Java</code>中保证可见性有如下方式：</p>
<ul>
<li><code>volatile</code>：当一个变量被<code>volatile</code>修饰时，对共享资源的读操作会直接在主内存中进行（准确来说也会读取到工作内存中，但是如果其他线程进行了修改就必须从主内存重新读取），写操作是先修改工作内存，但是修改结束后立即刷新到主内存中</li>
<li><code>synchronized</code>：<code>synchronized</code>一样能保证可见性，能够保证同一时刻只有一个线程获取到锁，然后执行同步方法，并且确保锁释放之前，变量的修改被刷新到主内存中</li>
<li>使用显式锁<code>Lock</code>：<code>Lock</code>的<code>lock</code>方法能保证同一时刻只有一个线程能够获取到锁然后执行同步方法，并且确保锁释放之前能够将对变量的修改刷新到主内存中</li>
</ul>
<p>具体来说，可以看一下之前的例子：</p>
<pre><code class="language-java">public class Main {
    private int x = 0;
    private static final int MAX = 100000;
    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        Thread thread0 = new Thread(()-&gt;{
            while(m.x &lt; MAX) {
                ++m.x;
            }
        });

        Thread thread1 = new Thread(()-&gt;{
            while(m.x &lt; MAX){
            }
            System.out.println(&quot;finish&quot;);
        });

        thread1.start();
        TimeUnit.MILLISECONDS.sleep(1);
        thread0.start();
    }
}
</code></pre>
<p>上面说过这段代码会不断运行，一直没有输出，就是因为修改后的<code>x</code>对线程<code>thread1</code>不可见，如果在<code>x</code>的定义中加上了<code>volatile</code>，就不会出现没有输出的情况了，因为此时对<code>x</code>的修改是线程<code>thread1</code>可见的。</p>
<h3 id="522-有序性">5.2.2 有序性</h3>
<p><code>JMM</code>中允许编译器和处理器对指令进行重排序，在多线程的情况下有可能会出现问题，为此，<code>Java</code>同样提供了三种机制去保证有序性：</p>
<ul>
<li><code>volatile</code></li>
<li><code>synchronized</code></li>
<li>显式锁<code>Lock</code></li>
</ul>
<p>另外，关于有序性不得不提的就是<code>Happens-before</code>原则。<code>Happends-before</code>原则说的就是如果两个操作的执行次序无法从该原则推导出来，那么就无法保证有序性，<code>JVM</code>或处理器可以任意重排序。这么做的目的是为了尽可能提高程序的并行度，具体规则如下：</p>
<ul>
<li>程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生与编写在前面的操作之后</li>
<li>锁定规则：如果一个锁处于锁定状态，则<code>unlock</code>操作要先行发生于对同一个锁的<code>lock</code>操作</li>
<li><code>volatile</code>变量规则：对一个变量的写操作要早于对这个变量之后的读操作</li>
<li>传递规则：如果操作A先于操作B，操作B先于操作C，那么操作A先于操作C</li>
<li>线程启动规则：<code>Thread</code>对象的<code>start()</code>方法先行发生于对该线程的任何动作</li>
<li>线程中断规则：对线程执行<code>interrupt()</code>方法肯定要优于捕获到中断信号，换句话说，如果收到了中断信号，那么在此之前必定调用了<code>interrupt()</code></li>
<li>线程终结规则：线程中所有操作都要先行发生于线程的终止检测，也就是逻辑单元的执行肯定要发生于线程终止之前</li>
<li>对象终结规则：一个对象初始化的完成先行发生于<code>finalize()</code>之前</li>
</ul>
<p>对于<code>volatile</code>，会直接禁止对指令重排，但是对于<code>volatile</code>前后无依赖关系的指令可以随意重排，比如：</p>
<pre><code class="language-java">int x = 0;
int y = 1;
//private volatile int z;
z = 20;
x++;
y--;
</code></pre>
<p>在<code>z=20</code>之前，先定义<code>x</code>或先定义<code>y</code>并没有要求，只需要在执行<code>z=20</code>的时候，可以保证<code>x=0,y=1</code>即可，同理，<code>x++</code>或<code>y--</code>具体先执行哪一个并没有要求，只需要保证两者执行在<code>z=20</code>之后即可。</p>
<h3 id="523-原子性">5.2.3 原子性</h3>
<p>在<code>Java</code>中，所有对基本数据类型变量的读取赋值操作都是原子性的，对引用类型的变量读取和赋值也是原子性的，但是：</p>
<ul>
<li>将一个变量赋值给另一个变量的操作不是原子性的，因为涉及到了一个变量的读取以及一个变量的写入，两个原子性操作结合在一起就不是原子性操作</li>
<li>多个原子性操作在一起就不是原子性操作，比如<code>i++</code></li>
<li><code>JMM</code>只保证基本读取和赋值的原子性操作，其他的均不保证，如果需要具备原子性，那么可以使用<code>synchronized</code>或<code>Lock</code>，或者<code>JUC</code>包下的原子操作类</li>
</ul>
<p>也就是说，<code>volatile</code>并不能保证原子性，例子如下：</p>
<pre><code class="language-java">public class Main {
    private volatile int x = 0;
    private static final CountDownLatch latch = new CountDownLatch(10);

    public void inc() {
        ++x;
    }

    public static void main(String[] args) throws InterruptedException {
        Main m = new Main();
        IntStream.range(0, 10).forEach(i -&gt; {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    m.inc();
                }
                latch.countDown();
            }).start();
        });
        latch.await();
        System.out.println(m.x);
    }
}
</code></pre>
<p>最后输出的<code>x</code>的值会少于<code>10000</code>，而且每次运行的结果也并不相同，至于原因，可以从两个线程A、B开始分析，图示如下：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202105161331204.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>0-t1</code>：线程A将<code>x</code>读入工作内存，此时<code>x=0</code></li>
<li><code>t1-t2</code>：线程A时间片完，<code>CPU</code>调度线程B，线程B将<code>x</code>读入工作内存，此时<code>x=0</code></li>
<li><code>t2-t3</code>：线程B对工作内存中的<code>x</code>进行自增操作，并更新到工作内存中</li>
<li><code>t3-t4</code>：线程B时间片完，<code>CPU</code>调度线程A，同理线程A对工作内存中的<code>x</code>自增</li>
<li><code>t4-t5</code>：线程A将工作内存中的值写回主内存，此时主内存中的值为<code>x=1</code></li>
<li><code>t5</code>以后：线程A时间片完，<code>CPU</code>调度线程B，线程B也将自己的工作内存写回主内存，再次将主内存中的<code>x</code>赋值为1</li>
</ul>
<p>也就是说，多线程操作的话，会出现两次自增但是实际上只进行一次数值修改的操作。想要<code>x</code>的值变为<code>10000</code>也很简单，加上<code>synchronized</code>即可：</p>
<pre><code class="language-java">new Thread(() -&gt; {
    synchronized (m) {
        for (int j = 0; j &lt; 1000; j++) {
            m.inc();
        }
    }
    latch.countDown();
}).start();
</code></pre>
<h2 id="53-实现原理">5.3 实现原理</h2>
<p>前面已经知道，<code>volatile</code>可以保证有序性以及可见性，那么，具体是如何操作的呢？</p>
<p>答案就是一个<code>lock;</code>前缀，该前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保障：</p>
<ul>
<li>确保指令重排序时不会将其后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将其前面的代码排到内存屏障之后</li>
<li>确保执行到内存屏障修饰的指令时前面的代码全部执行完成</li>
<li>强制将线程工作内存中的值修改刷新到主存中</li>
<li>如果是写操作，会导致其他线程工作内存中的缓存数据失效</li>
</ul>
<h2 id="54-使用场景">5.4 使用场景</h2>
<p>一个典型的使用场景是利用开关进行线程的关闭操作，例子如下：</p>
<pre><code class="language-java">public class ThreadTest extends Thread{
    private volatile boolean started = true;

    @Override
    public void run() {
        while (started){
            
        }
    }

    public void shutdown(){
        this.started = false;
    }
}
</code></pre>
<p>如果布尔变量没有被<code>volatile</code>修饰，那么很可能新的布尔值刷新不到主内存中，导致线程不会结束。</p>
<h2 id="55-与synchronized的区别">5.5 与<code>synchronized</code>的区别</h2>
<ul>
<li>使用上的区别：<code>volatile</code>只能用于修饰实例变量或者类变量，但是不能用于修饰方法、方法参数、局部变量等，另外可以修饰的变量为<code>null</code>。但<code>synchronized</code>不能用于对变量的修饰，只能修饰方法或语句块，而且<code>monitor</code>对象不能为<code>null</code></li>
<li>对原子性的保证：<code>volatile</code>无法保证原子性，但是<code>synchronized</code>可以保证</li>
<li>对可见性的保证：<code>volatile</code>与<code>synchronized</code>都能保证可见性，但是<code>synchronized</code>是借助于<code>JVM</code>指令<code>monitor enter</code>/<code>monitor exit</code>保证的，在<code>monitor exit</code>的时候所有共享资源都被刷新到主内存中，而<code>volatile</code>是通过<code>lock;</code>机器指令实现的，迫使其他线程工作内存失效，需要到主内存加载</li>
<li>对有序性的保证：<code>volatile</code>能够禁止<code>JVM</code>以及处理器对其进行重排序，而<code>synchronized</code>保证的有序性是通过程序串行化执行换来的，并且在<code>synchronized</code>代码块中的代码也会发生指令重排的情况</li>
<li>其他区别：<code>volatile</code>不会使线程陷入阻塞，但<code>synchronized</code>会</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第336期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-336-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-336-qi/">
        </link>
        <updated>2021-05-15T17:28:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>用2B形容你，人家铅笔不乐意。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>斜月照帘帷，忆君和梦稀。<br>
——毛熙震《菩萨蛮·梨花满园飘香雪》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>清晨的花朵，开在黄昏的残骸之上，一切都会过去，不是吗？</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621099875304.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>哈希表+大佬的优化，目标就是让最终的值尽可能最高位为1：</p>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Set;

public class Solution {
    public int findMaximumXOR(int[] nums) {
        int max = 0;
        for (int num:nums){
            max = Math.max(num,max);
        }
        int x = 0;
        Set&lt;Integer&gt; prefix = new HashSet&lt;&gt;();
        for (int k = 32 - Integer.numberOfLeadingZeros(max) - 1; k &gt;= 0; --k){
            prefix.clear();
            x &lt;&lt;= 1;
            int cur = x | 1;
            for (int num : nums) {
                prefix.add(num &gt;&gt; k);
                if(prefix.contains(num &gt;&gt; k ^ cur)) {
                    x |= 1;
                    break;
                }
            }
        }
        return x;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621099880145.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（三）：类加载]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-san-lei-jia-zai/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-san-lei-jia-zai/">
        </link>
        <updated>2021-05-15T12:09:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第九、十、十一章</li>
</ul>
<p>本文这三章的笔记整理。</p>
<h1 id="2-类加载简介">2 类加载简介</h1>
<p>类加载的过程可以简单分为三个阶段：</p>
<ul>
<li>加载阶段：主要负责查找并且加载类的二进制数据文件</li>
<li>连接阶段：可以细分为验证、准备、解析三个阶段，验证就是确保类文件的正确性，准备就是为类的静态变量分配内存，并且为其初始化默认值，解析就是把类中的符号引用转换为直接引用</li>
<li>初始化阶段：为类的静态变量赋予正确的初始值</li>
</ul>
<h1 id="3-主动使用与被动使用">3 主动使用与被动使用</h1>
<p><code>JVM</code>规范规定了每个类或接口在首次主动使用的时候都需要进行初始化，规定了以下六种主动使用类的场景：</p>
<ul>
<li>通过<code>new</code>关键字会导致类的初始化</li>
<li>访问类的静态变量</li>
<li>访问类的静态方法</li>
<li>对某个类进行反射操作</li>
<li>初始化子类会导致父类初始化</li>
<li>启动类（就是包含<code>main()</code>的类）也会初始化</li>
</ul>
<p>除了以上六种情况外，其余的都叫被动使用，不会导致类的加载和初始化，比如引用类的静态常量不会导致类的初始化。</p>
<h1 id="4-类加载详解">4 类加载详解</h1>
<p>前面也说了类加载可以简单分为三个阶段：</p>
<ul>
<li>加载阶段</li>
<li>连接阶段</li>
<li>初始化阶段</li>
</ul>
<p>下面先来看一下加载阶段。</p>
<h2 id="41-加载阶段">4.1 加载阶段</h2>
<p>加载阶段就是将<code>class</code>文件中的二进制数据读取到内存之中，然后将该字节流代表的静态存储结构转换为方法区中运行时数据结构，并且在堆中生成一个该类的<code>java.lang.Class</code>对象，作为访问方法区数据结构的入口。</p>
<p>类加载的最终产物就是堆内存中的<code>class</code>对象，<code>JVM</code>规范中指出类加载是通过一个全限定名去获取二进制数据流，来源包括：</p>
<ul>
<li><code>class</code>文件：这是最常见的格式，就是加载<code>javac</code>编译后的字节码文件</li>
<li>运行时动态生成：比如<code>ASM</code>可以动态生成，或者可以通过动态代理<code>java.lang.Proxy</code>生成等</li>
<li>通过网络获取：比如<code>RMI</code></li>
<li>读取压缩文件：比如<code>JAR</code>、<code>WAR</code>包</li>
<li>从数据库读取：比如读取<code>MySQL</code>中的<code>BLOB</code>字段类型的数据</li>
<li>运行时生成<code>class</code>文件并且动态加载：比如<code>Thrift</code>、<code>Avro</code>等序列化框架，将某个<code>schema</code>生成若干个<code>class</code>文件并进行加载</li>
</ul>
<p>类加载阶段结束后，<code>JVM</code>会将这些二进制字节流按照<code>JVM</code>定义的格式存放在方法区中，形成特定的数据结构后再在堆内存中实例化一个<code>java.lang.Class</code>对象。</p>
<h2 id="42-连接阶段">4.2 连接阶段</h2>
<p>该阶段可以分为三个小阶段：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p>需要注意的是这三个小阶段其实不是顺序进行的，而是交叉着进行的，也就是解析的时候其实也会有验证的过程。</p>
<h3 id="421-验证">4.2.1 验证</h3>
<p>验证是为了确保字节流所包含的内容符合<code>JVM</code>规范，并且不会出现危害<code>JVM</code>自身安全的代码，当字节流信息不符合要求的时候，会抛出<code>VerifyError</code>这样的异常或其子异常，验证的信息包括：</p>
<ul>
<li>文件格式</li>
<li>元数据</li>
<li>字节码</li>
<li>符号引用</li>
</ul>
<h4 id="4211-验证文件格式">4.2.1.1 验证文件格式</h4>
<p>包括：</p>
<ul>
<li>魔数（<code>0xCAFEBABE</code>）</li>
<li>主次版本号</li>
<li>是否存在残缺或附加信息</li>
<li>常量池常量类型是否支持</li>
<li>常量池引用是否指向不存在常量或不支持类型常量</li>
<li>其他</li>
</ul>
<h4 id="4212-验证元数据">4.2.1.2 验证元数据</h4>
<p>元数据验证其实是进行语义分析的过程，语义分析是为了确保字节流符合<code>JVM</code>规范要求，包括：</p>
<ul>
<li>检查某个类是否存在父类，是否继承某个接口，这些父类或接口是否合法，或是否存在</li>
<li>检查是否继承了<code>final</code>的类</li>
<li>检查抽象类，检查是否实现了父类的抽象方法或接口方法</li>
<li>检查重载，比如相同的方法名称、相同的参数但是返回类型不同，这是不允许的</li>
</ul>
<h4 id="4213-验证字节码">4.2.1.3 验证字节码</h4>
<p>字节码验证主要是验证程序的控制流程，包括：</p>
<ul>
<li>保证当前线程在程序计数器中的指令不会跳转到不合法的字节码指令中去</li>
<li>保证类型的转换是合法的</li>
<li>保证任意时刻虚拟机栈中的操作栈类型与指令代码都能正确被执行</li>
<li>其他验证</li>
</ul>
<h4 id="4214-验证符号引用">4.2.1.4 验证符号引用</h4>
<p>验证符号引用转换为直接引用的合法性，保证解析动作的顺利执行，包括：</p>
<ul>
<li>通过符号引用描述的字符串全限定名称是否能够顺利找到相关的类</li>
<li>符号引用中的类、字段、方法是否对当前类可见</li>
<li>其他</li>
</ul>
<h3 id="422-准备">4.2.2 准备</h3>
<p>经过验证后，就开始了准备阶段，这阶段比较简单，就是对对象的静态变量分配内存并且设置初始值，类变量的内存会被分配到方法区中。设置初始值就是为相应的类变量给定一个相关类型在没有被设置时的默认值，比如<code>Int</code>的初始值为0，引用的初始值为<code>null</code>。</p>
<h3 id="423-解析">4.2.3 解析</h3>
<p>解析就是在常量池中寻找类、字段、接口和方法的符号引用，并且将这些符号引用替换成直接引用的过程。解析主要针对类接口、字段、类方法和接口方法进行的，包括：</p>
<ul>
<li>类接口解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ul>
<h2 id="43-初始化阶段">4.3 初始化阶段</h2>
<p>初始化阶段主要就是执行<code>&lt;clinit&gt;</code>方法的过程，该方法是编译阶段生成的，也就是说包含在字节码文件中，该方法包含了所有类变量的赋值动作和静态语句块的执行代码。另一方面，<code>&lt;clinit&gt;</code>与构造方法不同，不需要显式调用父类构造器，虚拟机会保证父类的<code>&lt;clinit&gt;</code>方法最先执行。</p>
<p>还需要注意的是<code>&lt;clinit&gt;</code>只能被虚拟机执行，虚拟机还会保证多线程下的安全性，因此，如果在静态代码块中如果包含了加载其他类的操作可能会引起死锁，例子可以看<a href="https://blog.csdn.net/qq_27525611/article/details/116362061#t8">这里</a>。</p>
<h1 id="5-类加载器">5 类加载器</h1>
<h2 id="51-jvm中的三类核心类加载器">5.1 <code>JVM</code>中的三类核心类加载器</h2>
<p><code>JVM</code>中有三类核心类加载器，分别是：</p>
<ul>
<li>启动类加载器：启动类加载器是最顶层的类加载器，没有父加载器，由<code>C++</code>编写，负责<code>JVM</code>核心类库的加载，比如加载整个<code>java.lang</code>包中的类</li>
<li>扩展类加载器：扩展类加载器的父加载器是启动类加载器，主要加载<code>jre/lib/ext</code>子目录下的类库，纯<code>Java</code>实现，是<code>URLClassLoader</code>的子类</li>
<li>应用类加载器：也叫系统类加载器，负责加载<code>classpath</code>下的类库，应用类加载器的父加载器为扩展类加载器，同时它也是自定义类加载器的默认父加载器</li>
</ul>
<h2 id="52-双亲委派机制">5.2 双亲委派机制</h2>
<p>一个类加载器加载一个类的时候，并不会尝试直接加载该类，而是先交给父加载器尝试加载，一直到顶层的父加载器（启动类加载器），如果父加载器加载失败，则会自己尝试加载，图示如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210515194415207.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="6-线程上下文类加载器">6 线程上下文类加载器</h1>
<p><code>JDK</code>中提供了很多<code>SPI</code>（<code>Service Provider Interface</code>），比如<code>JDBC</code>等，<code>JDBC</code>只规定了这些接口之间的逻辑关系，但不提供具体的实现，换句话说，<code>JDBC</code>完全透明了应用程序和第三方厂商数据库驱动的具体实现，应用程序只需要面向接口编程即可。但问题是：</p>
<ul>
<li><code>java.lang.sql</code>中的所有接口都是由<code>JDK</code>提供的，加载这些接口的类加载器是启动类加载器</li>
<li>第三方厂商的类库驱动由系统类加载器加载</li>
</ul>
<p>由于双亲委派机制，<code>Connections</code>、<code>Statement</code>等都是由启动类加载器加载，而第三方<code>JDBC</code>驱动包中的实现不会被加载。解决这个问题的关键，就是使用了线程上下文类加载器打破了双亲委派机制。</p>
<p>比如<code>MySQL</code>驱动的加载过程，就是通过线程上下文类加载器加载的，</p>
<pre><code class="language-java">private static Connection getConnection(String url, Properties info, Class&lt;?&gt; caller) throws SQLException {
        //...
        if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
            callerCL = Thread.currentThread().getContextClassLoader();
        }
		while(true) {
			//...
			if (isDriverAllowed(aDriver.driver, callerCL)) {
			}
		}
		//...
}
private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {
	//...
    try {
        aClass = Class.forName(driver.getClass().getName(), true, classLoader);
    } catch (Exception var5) {
        result = false;
    }
    //...
    return result;
}
</code></pre>
<p>通过线程上下文类加载器，就变成了启动类加载器去委托子类加载器去加载实现的方式，也就是<code>JDK</code>自己亲自打破了双亲委派机制这种方式，这种加载方式几乎涉及所有的<code>SPI</code>加载，包括<code>JAXB</code>、<code>JCE</code>、<code>JBI</code>等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第335期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-335-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-335-qi/">
        </link>
        <updated>2021-05-14T16:50:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>生活不会放弃你，但也不会放过你。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>正护月云轻，嫩冰犹薄。<br>
——辛弃疾《瑞鹤仙·赋梅》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>从一开始，我就不那么喜欢你。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1621011032287.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>简单题直接判断各个字符了：</p>
<pre><code class="language-java">public class Solution {
    public int romanToInt(String s) {
        char [] ch = s.toCharArray();
        int sum = 0;
        for (int i = 0; i &lt; ch.length; i++) {
            if(ch[i] == 'M'){
                sum += 1000;
            }else if(ch[i] == 'D'){
                sum += 500;
            }else if(ch[i] == 'C'){
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'D') {
                        sum += 300;
                        ++i;
                    }else if(ch[i+1] == 'M'){
                        sum += 800;
                        ++i;
                    }
                }
                sum += 100;
            }else if(ch[i] == 'L'){
                sum += 50;
            }else if(ch[i] == 'X'){
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'L') {
                        sum += 30;
                        ++i;
                    }else if(ch[i+1] == 'C'){
                        sum += 80;
                        ++i;
                    }
                }
                sum += 10;
            }else if(ch[i] == 'V'){
                sum += 5;
            }else{
                if(i+1 &lt; ch.length){
                    if(ch[i+1] == 'V') {
                        sum += 3;
                        ++i;
                    }else if(ch[i+1] == 'X'){
                        sum += 8;
                        ++i;
                    }
                }
                sum += 1;
            }
        }
        return sum;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1621011059036.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第334期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-334-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-334-qi/">
        </link>
        <updated>2021-05-13T16:14:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>转角一般不会遇到爱，只会遇到乞丐。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>何当凯旋宴将士，三更雪压飞狐城！<br>
——陆游《长歌行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>萤火之光看起来比平常要更耀眼是错觉吗？今宵会成为永夜的吧。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620922670877.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接暴力：</p>
<pre><code class="language-java">import java.util.LinkedList;
import java.util.List;

public class Solution {
    public String intToRoman(int num) {
        StringBuilder builder = new StringBuilder();
        while (num &gt;= 1000){
            builder.append('M');
            num -= 1000;
        }
        if(num &gt;= 900){
            builder.append(&quot;CM&quot;);
            num -= 900;
        }
        if(num &gt;= 500){
            builder.append('D');
            num -= 500;
        }
        if(num &gt;= 400){
            builder.append(&quot;CD&quot;);
            num -= 400;
        }
        while(num &gt;= 100){
            builder.append('C');
            num -= 100;
        }
        if(num &gt;= 90){
            builder.append(&quot;XC&quot;);
            num -= 90;
        }
        if(num &gt;= 50){
            builder.append('L');
            num -= 50;
        }
        if(num &gt;= 40){
            builder.append(&quot;XL&quot;);
            num -= 40;
        }
        while (num &gt;= 10){
            builder.append('X');
            num -= 10;
        }
        if(num &gt;= 9){
            builder.append(&quot;IX&quot;);
            num -= 9;
        }
        if(num &gt;= 5){
            builder.append(&quot;V&quot;);
            num -= 5;
        }
        if(num &gt;= 4){
            builder.append(&quot;IV&quot;);
            num -= 4;
        }
        while (num &gt;= 1){
            builder.append('I');
            num -= 1;
        }
        return builder.toString();
    }
}
</code></pre>
<p>虽然不太优雅，快就行了：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620922731037.png" alt="" loading="lazy"></figure>
<h1 id="双100">双100</h1>
<p>记录一下今天的双100：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620971589553.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[] row = new int[9];
        int[] col = new int[9];
        int[] block = new int[9];

        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                if (board[i][j] != '.'){
                    int t = board[i][j] - 48;
                    if((col[j] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        col[j] |= 1 &lt;&lt; t;
                    }

                    if((row[i] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        row[i] |= 1 &lt;&lt; t;
                    }

                    int blockIndex = (i / 3) * 3 + j / 3;
                    if((block[blockIndex] &gt;&gt; t &amp; 1) == 1){
                        return false;
                    }else{
                        block[blockIndex] |= 1 &lt;&lt; t;
                    }
                }
            }
        }
        return true;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1620971595878.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>