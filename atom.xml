<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-06-02T21:41:42.911Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JFX11+Maven+IDEA 发布跨平台应用的完美解决方案]]></title>
        <id>https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/</id>
        <link href="https://2293736867.github.io/post/jfx11mavenidea-fa-bu-kua-ping-tai-ying-yong-de-wan-mei-jie-jue-fang-an/">
        </link>
        <updated>2020-06-02T21:41:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>前几天写了两篇关于JFX+IDEA打包跨平台应用的文章，<a href="https://blog.csdn.net/qq_27525611/article/details/106444423">这篇</a>是使用IDEA自带功能打包的，<a href="https://blog.csdn.net/qq_27525611/article/details/106433723">这篇</a>是使用Maven进行打包的，但是效果不太满意，因为从JDK9开始实现模块化，同时JFX部分从JDK中独立出来了，也就是说需要默认JDK不再自带JFX。这意味着外部依赖需要手动处理module-info.java，这是一件非常麻烦的事情。</p>
<h2 id="11-不使用maven">1.1 不使用Maven</h2>
<p>其实不使用Maven也能打包发布跨平台JFX应用，但是没有使用Maven的话，虽然打包出来能直接运行无需jre环境，但是，管理依赖确实麻烦，在使用jlink打包一些外部的jar时，对于一些比较简单的jar还是比较舒服的，参照<a href="https://blog.csdn.net/weixin_44326589/article/details/86680972">这里</a>：<br>
<img src="https://img-blog.csdnimg.cn/2020060121462236.png" alt="在这里插入图片描述" loading="lazy"><br>
首先去下载jar，接着生成module-info.java，然后使用jdeps检查依赖，添加对应的jar到路径中，编译生成module-info.java接着更新原来的jar即可。看起来简单，但是笔者碰到了okhttp这种jar，依赖简直环环相扣导致笔者放弃了这种方式。</p>
<h2 id="12-使用maven">1.2 使用Maven</h2>
<p>使用Maven可以完美解决依赖问题，多亏与强大的pom.xml，几行&lt;dependency&gt;就可以解决依赖问题，但是，还是需要手动处理module-info.java，而且IDEA文档明确表明仅支持Java8的打包为jar：<br>
<img src="https://img-blog.csdnimg.cn/20200601220006821.png" alt="在这里插入图片描述" loading="lazy"><br>
因此，这篇文章采取一种最简单的方式利用Maven打包发布JFX11应用。</p>
<h1 id="2-新建maven工程">2 新建Maven工程</h1>
<p><img src="https://img-blog.csdnimg.cn/20200601220303299.png" alt="在这里插入图片描述" loading="lazy"><br>
默认即可，问题不大。<br>
<img src="https://img-blog.csdnimg.cn/20200601220333213.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-添加依赖">3 添加依赖</h1>
<pre><code class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;linux&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
	    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
	    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
	    &lt;version&gt;11&lt;/version&gt;
	    &lt;classifier&gt;win&lt;/classifier&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;11&lt;/version&gt;
        &lt;classifier&gt;win&lt;/classifier&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>需要再哪个平台在classifier中指定即可。这里是linux与win。mac的话直接“mac”。<br>
同时指定编码与JDK：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre>
<p>否则会如此报错：<br>
<img src="https://img-blog.csdnimg.cn/20200601221410548.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-新建main">4 新建Main</h1>
<p>新建一个包再新建Main.java，Launcher.java以及Main.fxml：<br>
<img src="https://img-blog.csdnimg.cn/20200601221808669.png" alt="在这里插入图片描述" loading="lazy"><br>
Main.java：</p>
<pre><code class="language-java">package com.test;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {
    public void start(Stage stage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(&quot;/Main.fxml&quot;));
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setTitle(&quot;Hello World&quot;);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>
<p>Launcher.java：</p>
<pre><code class="language-java">package com.test;

public class Launcher {
    public static void main(String[] args) {
        Main.main(args);
    }
}
</code></pre>
<p>Main.fxml：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;?import javafx.scene.control.*?&gt;
&lt;?import javafx.scene.layout.*?&gt;
&lt;?import javafx.scene.text.*?&gt;


&lt;AnchorPane prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/10.0.2-internal&quot;
            xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.test.Main&quot;&gt;
   &lt;Label layoutX=&quot;228.0&quot; layoutY=&quot;185.0&quot; text=&quot;Hello World&quot;&gt;
      &lt;font&gt;
         &lt;Font size=&quot;25.0&quot;/&gt;
      &lt;/font&gt;
   &lt;/Label&gt;
&lt;/AnchorPane&gt;
</code></pre>
<p>注意getResource中的fxml路径，Main.fxml文件放在resources下，直接通过根路径读取：</p>
<pre><code class="language-java">getResource(&quot;/Main.fxml&quot;);
</code></pre>
<h1 id="5-添加运行配置">5 添加运行配置</h1>
<p>此时应该是没有运行配置的状态，点击Add Configuration：<br>
<img src="https://img-blog.csdnimg.cn/20200601222437737.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Application：<br>
<img src="https://img-blog.csdnimg.cn/2020060122253724.png" alt="在这里插入图片描述" loading="lazy"><br>
添加Launcher类作为Main class：<br>
<img src="https://img-blog.csdnimg.cn/20200601222831910.png" alt="在这里插入图片描述" loading="lazy"><br>
这时候run就没问题了：<br>
<img src="https://img-blog.csdnimg.cn/2020060122292722.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-使用默认maven打包">6 使用默认Maven打包</h1>
<p>虽然现在可以run了，但是，如果直接使用默认的Maven打包的话：<br>
<img src="https://img-blog.csdnimg.cn/20200601223021660.png" alt="在这里插入图片描述" loading="lazy"><br>
在target下有一个jar，直接右键运行：<br>
<img src="https://img-blog.csdnimg.cn/20200601223318755.png" alt="在这里插入图片描述" loading="lazy"><br>
会提示no main manifest attribute：<br>
<img src="https://img-blog.csdnimg.cn/20200601223400146.png" alt="在这里插入图片描述" loading="lazy"><br>
也就是找不到Manifest中入口类。<br>
jar实际上是一个class的压缩包，与zip的区别是jar包含了一个MANIFEST.MF，MANIFEST.MF在META-INF下，一个示例文件如下：<br>
<img src="https://img-blog.csdnimg.cn/20200601224154485.png" alt="在这里插入图片描述" loading="lazy"><br>
有点类似与键值对的格式，MANIFEST.MF包含了jar文件的内容描述，并在运行时向JVM提供应用程序信息。注意该文件有严格的格式限制，比如第一行不能为空，行与行之间不能存在空行。<br>
一个暴力的解决办法是直接解压jar并修改里面的MANIFEST.MF，添加</p>
<pre><code class="language-bash">Main-Class: com.test.Launcher
</code></pre>
<p>但是这样会报找不到Application类的异常：<br>
<img src="https://img-blog.csdnimg.cn/20200602015847355.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-添加新的打包插件">7 添加新的打包插件</h1>
<p>理论上来说，只需要jar包内的相同目录下提供了javafx的jar或者class文件就不会抛出异常了，但是，如果依赖很多需要一个一个添加，这是一个痛苦的过程。<br>
所以，为了优雅地解决这个问题，引入一个叫maven-shade-plugin的插件即可：</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;shade&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;transformers&gt;
                            &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
                                &lt;mainClass&gt;com.test.Launcher&lt;/mainClass&gt;
                            &lt;/transformer&gt;
                        &lt;/transformers&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>最新版本请到<a href="https://github.com/apache/maven-shade-plugin">官方github</a>查看，使用时只需要修改：</p>
<pre><code class="language-xml">&lt;mainClass&gt;xxx.xxx.xxx&lt;/mainClass&gt;
</code></pre>
<p>修改为程序入口类。</p>
<h1 id="8-打包">8 打包</h1>
<p>此时再从右侧栏打包选中Maven，package即可：<br>
<img src="https://img-blog.csdnimg.cn/2020060202062726.png" alt="在这里插入图片描述" loading="lazy"><br>
但是会有警告：<br>
<img src="https://img-blog.csdnimg.cn/20200602020908608.png" alt="在这里插入图片描述" loading="lazy"><br>
因为一些class文件重复了，但是也提到了通常来说这是没有危害的并且可以跳过警告，或者修改pom.xml去手动排除某些依赖。</p>
<h1 id="9-运行">9 运行</h1>
<p>直接在IDEA中右键运行或者-jar运行，可以看到没有异常了：<br>
<img src="https://img-blog.csdnimg.cn/20200602021739342.png" alt="在这里插入图片描述" loading="lazy"><br>
相比起原来自带的Maven打包插件，主要是多了javafx的一些class以及对应平台所需要的一些动态库文件等，比如win上的.dll与linux上的.so文件。<br>
<img src="https://img-blog.csdnimg.cn/20200602022014735.png" alt="在这里插入图片描述" loading="lazy"><br>
这样一个跨平台的JFX jar包就制作好了，只需</p>
<pre><code class="language-bash">java -jar
</code></pre>
<p>即可跨平台运行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个开源的跨平台音乐播放与音乐下载器]]></title>
        <id>https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/</id>
        <link href="https://2293736867.github.io/post/yi-ge-kai-yuan-de-kua-ping-tai-yin-le-bo-fang-yu-yin-le-xia-zai-qi/">
        </link>
        <updated>2020-06-02T21:40:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="跨平台的音乐播放器">跨平台的音乐播放器</h1>
<p>目前国内的linux平台上的音乐播放器不多，除了网易云比较多人使用的。<br>
当然<a href="http://listen1.github.io/listen1/">Listen1</a>也是一个不错的选择，真正的跨平台，包括Android/Mac/Win/Linux以及Chrome插件，目前尚在维护：<br>
<img src="https://img-blog.csdnimg.cn/20200601210615418.png" alt="在这里插入图片描述" loading="lazy"><br>
Listen1其实非常不错，支持歌单功能，可以方便的播放，但美中不足的是没有下载功能。<br>
因此，这里推荐一个带下载以及播放功能的开源音乐软件：<a href="https://github.com/lyswhut/lx-music-desktop">洛雪音乐助手桌面版</a>。<br>
一个基于 Electron + Vue 开发的音乐软件。<br>
<img src="https://img-blog.csdnimg.cn/20200601211058633.png" alt="在这里插入图片描述" loading="lazy"><br>
UI：<br>
<img src="https://img-blog.csdnimg.cn/20200601211200149.png" alt="在这里插入图片描述" loading="lazy"><br>
推荐歌单列表：<br>
<img src="https://img-blog.csdnimg.cn/20200601211239373.png" alt="在这里插入图片描述" loading="lazy"><br>
排行榜：<br>
<img src="https://img-blog.csdnimg.cn/20200601211320388.png" alt="在这里插入图片描述" loading="lazy"><br>
下载功能：<br>
<img src="https://img-blog.csdnimg.cn/20200601211354966.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200601211433744.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFX获取屏幕尺寸]]></title>
        <id>https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/</id>
        <link href="https://2293736867.github.io/post/javafx-huo-qu-ping-mu-chi-cun/">
        </link>
        <updated>2020-06-02T21:40:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-awt">1 awt</h1>
<pre><code class="language-java">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
double width = screenSize.getWidth();
double height = screenSize.getHeight();
</code></pre>
<h1 id="2-javafx">2 javafx</h1>
<pre><code class="language-java">Rectangle2D screenRectangle = Screen.getPrimary().getBounds();
double width = screenRectangle.getWidth();
double height = screenRectangle.getHeight();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OkHttp:NoClassDefFoundError]]></title>
        <id>https://2293736867.github.io/post/okhttpnoclassdeffounderror/</id>
        <link href="https://2293736867.github.io/post/okhttpnoclassdeffounderror/">
        </link>
        <updated>2020-06-02T21:39:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>使用OkHttp时报错：</p>
<pre><code class="language-bash">Caused by: java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics
	at okhttp3@4.7.2/okhttp3.FormBody$Builder.add(FormBody.kt)
</code></pre>
<h1 id="2-原因">2 原因</h1>
<p>由于OkHttp依赖于okio，目前OkHttp最新的版本为4.7.2，使用Maven/Gradle导入的话不会出现该问题，原因应该是只是单纯把OkHttp的jar导入，还需要把okio一并导入，但是需要知道OkHttp对应的okio版本，可以通过Maven导入查看，比如4.7.2对应的是2.6.0。<br>
<img src="https://img-blog.csdnimg.cn/20200531113523502.png" alt="在这里插入图片描述" loading="lazy"><br>
如果已经添加了okio则可以跳过，另外还需要添加kotlin-stdlib库，使用最新版本即可，目前最新版本为1.3.72。<br>
下载链接<a href="https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-stdlib">戳这里</a>。</p>
<h1 id="3-解决方案">3 解决方案</h1>
<p>把对应版本的okio以及kotlin-stdlib添加到依赖库即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jasypt-spring-boot提示Failed to bind properties]]></title>
        <id>https://2293736867.github.io/post/jasypt-spring-boot-ti-shi-failed-to-bind-properties/</id>
        <link href="https://2293736867.github.io/post/jasypt-spring-boot-ti-shi-failed-to-bind-properties/">
        </link>
        <updated>2020-06-02T21:39:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>在Spring Boot中使用jasypt-spring-boot进行加密，但是提示：</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.password' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>或提示</p>
<pre><code class="language-bash">Description:

Failed to bind properties under 'spring.datasource.url' to java.lang.String:

    Reason: Failed to bind properties under 'spring.datasource.password' to java.lang.String

Action:

Update your application's configuration
</code></pre>
<p>最后的异常是这个：<br>
<img src="https://img-blog.csdnimg.cn/20200531013232211.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-解决办法">2 解决办法</h1>
<p>查阅了相关<a href="https://github.com/ulisesbocchio/jasypt-spring-boot/issues/154">issue</a>，发现是3.0.2更改了默认的加密算法，最后的办法是把版本降到2.1.2：<br>
<img src="https://img-blog.csdnimg.cn/20200531014007872.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;
    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>接着重新加密配置，但是2.1.2不支持使用环境变量作为加密的口令，在IDEA中测试的时候需要在运行配置加上</p>
<pre><code class="language-bash">-Djasypt.encryptor.password=xxxx
</code></pre>
<p>部署到Tomcat时添加环境变量：</p>
<pre><code class="language-bash">export JAVA_OPTS=&quot;-Djasypt.encryptor.password=xxxx&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JFX11+IDEA跨平台打包发布的完美解决办法]]></title>
        <id>https://2293736867.github.io/post/jfx11idea-kua-ping-tai-da-bao-fa-bu-de-wan-mei-jie-jue-ban-fa/</id>
        <link href="https://2293736867.github.io/post/jfx11idea-kua-ping-tai-da-bao-fa-bu-de-wan-mei-jie-jue-ban-fa/">
        </link>
        <updated>2020-06-02T21:38:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>IDEA2020.1的文档中提到只有JFX8的工程才支持打成jar包，并且，如果直接使用Build Artifacts的话，会如下提示：<br>
<img src="https://img-blog.csdnimg.cn/2020053017384177.png" alt="在这里插入图片描述" loading="lazy"><br>
<a href="https://www.jetbrains.com/help/idea/packaging-javafx-applications.html">IDEA文档</a>有提到这个的解决办法，是使用一些<a href="https://openjfx.io/openjfx-docs/#install-javafx">第三方工具</a>。里面介绍了通过IDEA结合自身/Maven/Gradle打包发布JFX11以上版本的方法。但是，不足的地方有：</p>
<ul>
<li>直接创建JFX工程默认只有一个src目录，不像Maven工程还带有resources与test，给管理资源文件以及外部依赖造成了困难，getClass().getResource()会出现空指针问题，但是好处是只需具备JDK环境，打包出来的文件能带上jmods能跨平台直接运行</li>
<li>直接创建Maven项目虽然是管理依赖以及资源文件方便，但是无论是直接通过Maven打出的jar包还是通过JavaFX Maven Plugins打出来的jar包默认绑定了开发平台的JFX SDK，简单地说就是Linux开发的JFX程序不能直接跑在具有JDK环境的Win上，因为用的是Linux的JFX SDK而不是Win的JFX SDK</li>
</ul>
<p>因此，本文结合这两者的优点，参照Maven的目录管理，以JFX工程为基础，记录了从新建工程到发布跨平台JFX应用的过程。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>IDEA 2020.1</li>
<li>OpenJDK 11</li>
<li>OpenJFX 11 Linux SDK</li>
<li>OpenJFX 11 Linux/Windows/Mac OS X jmods</li>
</ul>
<p>JDK安装就不说了，JFX直接下载然后在工程中通过外部库引入即可，三种jmods解压出来即可，用于最后生成可执行文件时添加的模块。<br>
下载链接<a href="https://gluonhq.com/products/javafx/">戳这里</a>。</p>
<h1 id="3-新建jfx工程">3 新建JFX工程</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530175758622.png" alt="在这里插入图片描述" loading="lazy"><br>
这里的项目名为TestJFX，对应修改即可。<br>
<img src="https://img-blog.csdnimg.cn/20200530175913541.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-添加jfx11-sdk">4 添加JFX11 SDK</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530180127745.png" alt="在这里插入图片描述" loading="lazy"><br>
添加上一步下载的对应平台的JFX SDK。<br>
<img src="https://img-blog.csdnimg.cn/20200530180205495.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-添加module-infojava">5 添加module-info.java</h1>
<p>在src目录右键New-&gt;module-info.java，修改如下：</p>
<pre><code class="language-ruby">module TestJFX {
    requires javafx.fxml;
    requires javafx.controls;
    
    opens sample to javafx.fxml;
    exports sample;
}
</code></pre>
<p>其中TestJFX为新建项目时的项目名，这个创建module-info.java时就默认加上了，sample为默认包，对应修改。</p>
<h1 id="6-添加vm-options">6 添加VM Options</h1>
<p><img src="https://img-blog.csdnimg.cn/20200530181426399.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200531023450900.png" alt="在这里插入图片描述" loading="lazy"><br>
添加</p>
<pre><code class="language-bash">--module-path /usr/local/jfx/lib:out/production
</code></pre>
<p>其中</p>
<pre><code class="language-bash">/usr/local/jfx/lib
</code></pre>
<p>为下载的JFX JDK的lib目录，后面的out不需要更改，是默认的编译输出的目录。</p>
<h1 id="7-运行">7 运行</h1>
<p>这时候应该可以Shift+F10或者点击绿色小三角运行了：<br>
<img src="https://img-blog.csdnimg.cn/20200530181814745.png" alt="在这里插入图片描述" loading="lazy"><br>
当然内容是空的，因为什么也没有加。</p>
<h1 id="8-添加资源文件">8 添加资源文件</h1>
<p>默认的fxml是放在与Main类同一目录下的，getResource()也没有加路径直接写上文件名：<br>
<img src="https://img-blog.csdnimg.cn/20200530195546612.png" alt="在这里插入图片描述" loading="lazy"><br>
但是这是src文件夹，放个fxml还勉强可以接受，放张图片总不合适吧？所以，新建一个资源文件夹，把css，fxml什么的都放里面：<br>
<img src="https://img-blog.csdnimg.cn/20200530195911419.png" alt="在这里插入图片描述" loading="lazy"><br>
直接在IDEA中移动fxml文件，Main中的引用路径也自动更改，不得不说这个特性是真的好用，但遗憾的是，抛出了空指针异常。<br>
因此采取绝对路径来进行读取文件，通过URL+System.getProperty()指定绝对路径：</p>
<pre><code class="language-java">@Override
public void start(Stage primaryStage) throws Exception{
    String path = System.getProperty(&quot;user.dir&quot;);
    URL fxmlUrl = new URL(&quot;file:&quot;+path+&quot;/resources/fxml/sample.fxml&quot;);
    Parent root = FXMLLoader.load(fxmlUrl);
    primaryStage.setTitle(&quot;Hello World&quot;);
    Scene scene = new Scene(root);
    scene.getStylesheets().add(new URL(&quot;file:&quot;+path+&quot;/resources/css/1.css&quot;).toString());
    primaryStage.setScene(scene);
    primaryStage.show();
}
</code></pre>
<p>其中</p>
<pre><code class="language-java">System.getProperty(&quot;user.dir&quot;)
</code></pre>
<p>获取项目路径，注意URL前面要加上“file:”，css的获取也同理，只不过是需要转换为String。</p>
<h1 id="9-外部依赖">9 外部依赖</h1>
<p>由于没有了Maven管理依赖，所以外部依赖的管理会相对麻烦一点，基本上是以jar包的形式手动添加，这里以添加Gson为例，<a href="https://mvnrepository.com/artifact/com.google.code.gson/gson">戳这里</a>下载jar包，然后在项目目录下新建一个lib文件夹，把jar包放进去：<br>
<img src="https://img-blog.csdnimg.cn/20200531023924445.png" alt="在这里插入图片描述" loading="lazy"><br>
接着在项目结构中把整个lib文件夹添加到外部库：<br>
<img src="https://img-blog.csdnimg.cn/20200531022019954.png" alt="在这里插入图片描述" loading="lazy"><br>
然后VM Options中添加lib路径，在上面的VM Options后面加一个冒号和lib就行：<br>
<img src="https://img-blog.csdnimg.cn/20200531022600107.png" alt="在这里插入图片描述" loading="lazy"><br>
但是，此时可以IDEA还不能进行补全，最后需要修改module-info.java：<br>
<img src="https://img-blog.csdnimg.cn/20200531022743664.png" alt="在这里插入图片描述" loading="lazy"><br>
加一行requires，此时IDEA能够进行补全了，每个jar包都不同，对应修改即可。</p>
<h1 id="10-制作跨平台镜像">10 制作跨平台镜像</h1>
<p>运行没问题之后就可以制作运行时镜像发布了，终端进入项目根路径：</p>
<pre><code class="language-bash">jlink --module-path jmod/linux:out/production:lib --add-modules TestJFX --output linux
linux/bin/java -m TestJFX/sample.Main
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200531030506500.png" alt="在这里插入图片描述" loading="lazy"><br>
其中</p>
<pre><code class="language-bash">jmod/linux
</code></pre>
<p>为开发平台jmod的路径，可以是绝对路径，也可以是相对与项目根目录的相对路径，out/production与上面的VM Options保持一致。</p>
<pre><code class="language-bash">--add-modules
</code></pre>
<p>后面跟的是模块名，这是在生成module-info.java时指定的，为项目名。</p>
<pre><code class="language-bash">--output
</code></pre>
<p>为输出目录。<br>
后一条命令中-m指定模块名，后面跟包名+主类名。<br>
这样linux平台的镜像就制作好了，Mac与Win的同理，只需要把jmod换成对应平台的jmod即可，但是注意语法有一些差别，Mac的语法同Linux，只需要把jmod路径换一下，但是注意需要整个工程在对应的平台进行jlink：</p>
<pre><code class="language-bash">jlink --module-path xxxxx/{MAC_JMOD}:out/production:lib --add-modules TestJFX --output mac
mac/bin/java -m TestJFX/sample.Main
</code></pre>
<p>Win的语法有些区别，一样需要在Win下进行jlink：</p>
<pre><code class="language-bash">jlink --module-path &quot;xxxxx/{WIN_JMOD};out/production&quot; --add-modules TestJFX --output win
win\bin\java -m TestJFX/sample.Main
</code></pre>
<p>下面是Win下的截图：<br>
<img src="https://img-blog.csdnimg.cn/20200531025545467.PNG" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="11-demo">11 demo</h1>
<p><a href="https://github.com/2293736867/JFX11-IDEA-Test-Project">github</a></p>
<h1 id="12-参考">12 参考</h1>
<p><a href="https://openjfx.io/openjfx-docs/#maven">Getting Started with JavaFX</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA通过Maven打包JavaFX工程（OpenJFX11）]]></title>
        <id>https://2293736867.github.io/post/idea-tong-guo-maven-da-bao-javafx-gong-cheng-openjfx11/</id>
        <link href="https://2293736867.github.io/post/idea-tong-guo-maven-da-bao-javafx-gong-cheng-openjfx11/">
        </link>
        <updated>2020-06-02T21:38:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>最近研究JFX，写出来了但是打包不了，这。。。尴尬。。。<br>
<a href="https://www.jetbrains.com/help/idea/packaging-javafx-applications.html#">IDEA的文档</a>说只支持Java8打成jar包：<br>
<img src="https://img-blog.csdnimg.cn/20200529220753361.png" alt="在这里插入图片描述" loading="lazy"><br>
尝试过直接使用Maven插件的package，不行，也尝试过Build Artifacts，也不行，各种奇奇怪怪的问题。包括下图中的</p>
<pre><code class="language-bash">Error....fx:deploy is not available in this JDK
</code></pre>
<p>不过幸好文档末尾提到可以使用一些<a href="https://openjfx.io/openjfx-docs/#maven">第三方工具</a>：<br>
<img src="https://img-blog.csdnimg.cn/20200529220849122.png" alt="在这里插入图片描述" loading="lazy"><br>
因此记录一下使用IDEA打包JFX11工程的过程。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>IDEA 2020.1</li>
<li>OpenJDK 11</li>
<li>OpenJFX 11</li>
</ul>
<p>只需安装IDEA与JDK即可，JFX可以在pom.xml中引入。</p>
<h1 id="3-创建工程">3 创建工程</h1>
<p>选择Maven，选择Create from archetype，然后Add Archetype并填上GroupId：</p>
<pre><code class="language-bash">org.openjfx
</code></pre>
<p>与ArtifactId：</p>
<pre><code class="language-bash">javafx-maven-archetypes
</code></pre>
<p>还有version：</p>
<pre><code class="language-bash">0.0.1
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200529222351159.png" alt="在这里插入图片描述" loading="lazy"><br>
下一步自定义，这里为了方便就直接默认了。<br>
<img src="https://img-blog.csdnimg.cn/20200529222436539.png" alt="在这里插入图片描述" loading="lazy"><br>
然后修改archetypeArtifactId为</p>
<pre><code class="language-bash">javafx-archetype-fxml
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200529223233339.png" alt="在这里插入图片描述" loading="lazy"><br>
完成即可。</p>
<h1 id="4-检查文件">4 检查文件</h1>
<p>Maven同步完后，检查项目目录下的module-info.java与pom.xml，其中pom.xml不应该是下图这样的：<br>
<img src="https://img-blog.csdnimg.cn/20200529222717282.png" alt="在这里插入图片描述" loading="lazy"><br>
而应该是这样的，包含了javafx.controls与javafx.fxml依赖，还有javafx-maven-plugin插件：<br>
<img src="https://img-blog.csdnimg.cn/20200529223421120.png" alt="在这里插入图片描述" loading="lazy"><br>
同时src下的module-info.java应该长这样：<br>
<img src="https://img-blog.csdnimg.cn/20200529223524571.png" alt="在这里插入图片描述" loading="lazy"><br>
module-info.java包含了所需要的javafx.controls与javafx.fxml这两个模块。</p>
<h1 id="5-修改插件依赖">5 修改插件依赖</h1>
<p>默认的javafx-maven-plugin版本应该为0.0.1：<br>
<img src="https://img-blog.csdnimg.cn/20200529223713794.png" alt="在这里插入图片描述" loading="lazy"><br>
整个去掉，修改为：</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.0.4&lt;/version&gt;
    &lt;configuration&gt;
        &lt;stripDebug&gt;true&lt;/stripDebug&gt;
        &lt;compress&gt;2&lt;/compress&gt;
        &lt;noHeaderFiles&gt;true&lt;/noHeaderFiles&gt;
        &lt;noManPages&gt;true&lt;/noManPages&gt;
        &lt;launcher&gt;launcher&lt;/launcher&gt;
        &lt;jlinkImageName&gt;output&lt;/jlinkImageName&gt;
        &lt;jlinkZipName&gt;outputzip&lt;/jlinkZipName&gt;
        &lt;mainClass&gt;org.openjfx.App&lt;/mainClass&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>其中launcher为可执行文件名，jlinkImageName为Image输出目录名，jlinkZipName为zip文件名，mainClass为主类。</p>
<h1 id="6-运行并打包">6 运行并打包</h1>
<p>从右侧栏的Maven通过javafx插件运行并打包：<br>
<img src="https://img-blog.csdnimg.cn/20200529224201517.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200529224909134.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-测试">7 测试</h1>
<p>根据修改插件时的目录，进入对应的target下的子目录直接运行即可：</p>
<pre><code class="language-bash">项目目录/target/output/bin/launcher
</code></pre>
<p>注意这个是跨平台的，只需具备JDK11环境即可，发布只需要把zip文件发布。</p>
<h1 id="8-demo">8 demo</h1>
<ul>
<li><a href="https://github.com/2293736867/IDEA-JFX-Project-Example">github</a></li>
<li><a href="https://gitee.com/imykr/IDEA-JFX-Project-Example">码云</a></li>
</ul>
<h1 id="9-扩展阅读">9 扩展阅读</h1>
<p>这篇文章是OpenJFX的文档，主要介绍了：</p>
<ul>
<li>通过三种方式（JFX+Maven+Gradle）运行Hello World</li>
<li>构建运行镜像（CLI+Maven+Gradle+自定义镜像）</li>
<li>IntelliJ/NetBeans/Eclipse通过三种方式（IDE自身+Maven+Gradle）运行与打包JFX</li>
</ul>
<p>链接<a href="https://openjfx.io/openjfx-docs/#introduction">戳这里</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA 配置文件位置]]></title>
        <id>https://2293736867.github.io/post/idea-pei-zhi-wen-jian-wei-zhi/</id>
        <link href="https://2293736867.github.io/post/idea-pei-zhi-wen-jian-wei-zhi/">
        </link>
        <updated>2020-06-02T21:37:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-idea-20201-以上">1 IDEA 2020.1 以上</h1>
<h2 id="11-win">1.1 Win</h2>
<p>语法：</p>
<pre><code class="language-bash">%APPDATA%\JetBrains\&lt;product&gt;&lt;version&gt;
</code></pre>
<p>Win上的APPDATA默认位置如下：</p>
<pre><code class="language-bash">C:\Users\用户名\AppData\Roaming
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2020.1
</code></pre>
<h2 id="12-macos">1.2 MacOS</h2>
<p>语法：</p>
<pre><code class="language-bash">~/Library/Application Support/JetBrains/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/Library/Application Support/JetBrains/IntelliJIdea2020.1
</code></pre>
<h2 id="13-linux">1.3 Linux</h2>
<p>语法：</p>
<pre><code class="language-bash">~/.config/JetBrains/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/.config/JetBrains/IntelliJIdea2020.1
</code></pre>
<h1 id="2-idea-20193x以下">2 IDEA 2019.3.x以下</h1>
<h2 id="21-win">2.1 Win</h2>
<p>语法：</p>
<pre><code class="language-bash">%HOMEPATH%\\.&lt;product&gt;&lt;version&gt;\config
</code></pre>
<p>Win的HOMEPATH默认为：</p>
<pre><code class="language-bash">\Users\用户名
</code></pre>
<p>注意，无盘符。<br>
例子：</p>
<pre><code class="language-bash">C:\Users\用户名\.IntelliJIdea2019.3\config
</code></pre>
<h2 id="22-macos">2.2 MacOS</h2>
<p>语法：</p>
<pre><code class="language-bash">~/Library/Preferences/&lt;product&gt;&lt;version&gt;
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/Library/Preferences/IntelliJIdea2019.3
</code></pre>
<h2 id="23-linux">2.3 Linux</h2>
<p>语法：</p>
<pre><code class="language-bash">~/.&lt;product&gt;&lt;version&gt;/config
</code></pre>
<p>例子：</p>
<pre><code class="language-bash">~/.IntelliJIdea2019.3/config
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vim与系统剪贴版的交互]]></title>
        <id>https://2293736867.github.io/post/vim-yu-xi-tong-jian-tie-ban-de-jiao-hu/</id>
        <link href="https://2293736867.github.io/post/vim-yu-xi-tong-jian-tie-ban-de-jiao-hu/">
        </link>
        <updated>2020-06-02T21:37:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>vim中的复制，删除，替换（d，r，s，x，y等）的内容都会被保存到默认的未命名的寄存器中，之后可以通过p进行粘贴，但是，这个寄存器不是系统的剪贴版，很多时候需要vim与系统剪贴版的交互，那么，具体怎么做呢？</p>
<h1 id="2-暴力解决">2 暴力解决</h1>
<p>系统剪贴版复制vim时，新建一个文件，直接ctrl+v复制过去然后vim打开。<br>
vim中的内容复制到系统剪贴版，使用cat+grep，在终端ctrl+c复制即可。<br>
这是最简单也是比较通用的方法，不会受到什么vim不支持剪贴版之类的影响。<br>
<s>没错就是简单粗暴。</s></p>
<h1 id="3-优雅的方案">3 优雅的方案</h1>
<p>当然上面的方法想必也不是您想要的，因此，这里介绍一种优雅一点的方法。</p>
<h2 id="31-查看剪贴板支持">3.1 查看剪贴板支持</h2>
<p>首先需要知道vim是否支持剪贴版：</p>
<pre><code class="language-bash">vim --version | grep clipboard
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020052710391175.png" alt="在这里插入图片描述" loading="lazy"><br>
如果有</p>
<pre><code class="language-bash">+clipboard
</code></pre>
<p>就表示支持，没有的话比如笔者这个就不支持，需要安装。<br>
笔者的Manjaro，可以使用yay安装，不过提示过期了：<br>
<img src="https://img-blog.csdnimg.cn/20200527104442825.png" alt="在这里插入图片描述" loading="lazy"><br>
也可以选择安装gvim，另外，Debian系的可以安装vim-gtk：</p>
<pre><code class="language-bash">sudo apt install vim-gtk
</code></pre>
<p>Redhat系的需要安装vim-X11以及vim-enhanced，然后加个别名：</p>
<pre><code class="language-bash">alias vi='vimx'
alias vim='vimx'
</code></pre>
<p>MacOS：</p>
<pre><code class="language-bash">sudo brew install vim
</code></pre>
<h2 id="32-系统剪贴板复制到vim">3.2 系统剪贴板复制到vim</h2>
<p>很简单，使用</p>
<pre><code class="language-bash">&quot;+p
</code></pre>
<p>或</p>
<pre><code class="language-bash">&quot;*p
</code></pre>
<p>即可，vim提供了</p>
<pre><code class="language-bash">+ *
</code></pre>
<p>这两个寄存器与系统剪贴板进行交互，大多数系统上这两个系统一样，但在某些linux上可能不等价，以下是<a href="https://vim.fandom.com/wiki/Accessing_the_system_clipboard">官方文档</a>：<br>
<img src="https://img-blog.csdnimg.cn/2020052710535542.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-bash">+
</code></pre>
<p>对应ctrl+c，ctrl+v使用的系统剪贴板，</p>
<pre><code class="language-bash">*
</code></pre>
<p>对应的是鼠标选择的内容，可以使用中间粘贴。<br>
当然高版本的vim还有一种很简单的解决办法：Shift+Insert能直接粘贴。</p>
<h2 id="33-vim寄存器复制到系统剪贴板">3.3 vim寄存器复制到系统剪贴板</h2>
<p>在vim中使用y进行复制，但是是复制到默认的未命名寄存器的，想要复制到系统剪贴版只需要把y改为</p>
<pre><code class="language-bash">&quot;+y
</code></pre>
<p>或</p>
<pre><code class="language-bash">&quot;*y
</code></pre>
<p>即可。</p>
<h2 id="34-偷懒方法">3.4 偷懒方法</h2>
<p>所谓的偷懒方法就是把默认的未命名寄存器与系统剪贴板关联上，使用</p>
<pre><code class="language-bash">set clipboard=unnamed
</code></pre>
<p>即可。vim7.3.74以上的版本可以使用：</p>
<pre><code class="language-bash">set clipboard=unnamedplus
</code></pre>
<p>这样y，d，s，x等操作就和系统剪贴版关联上了。</p>
<h1 id="4-寄存器相关知识">4 寄存器相关知识</h1>
<p>vim中的y，d，c，x，s等的操作的内容会复制到寄存器中，可以使用</p>
<pre><code class="language-bash">:reg 
</code></pre>
<p>查看寄存器的内容，使用</p>
<pre><code class="language-bash">:help registers
</code></pre>
<p>查看帮助，另外，寄存器的常用操作包括：</p>
<pre><code class="language-java">&quot;{register}y 复制到寄存器，默认register为未命名寄存器
&quot;{register}p 粘贴寄存器的内容
</code></pre>
<p>比如</p>
<pre><code class="language-java">&quot;a4yy
&quot;+p
</code></pre>
<p>vim中提供了多种多样的寄存器，具体来说可以分为10种共48个寄存器。</p>
<h2 id="41-未命名寄存器">4.1 未命名寄存器</h2>
<pre><code class="language-bash">&quot;&quot;
</code></pre>
<p>也叫匿名寄存器，使用d，c，x等删除的字符会存放进匿名寄存器，换句话说，最近一次删除，修改，复制的内容都存放在这里，会覆盖。</p>
<h2 id="42-编号寄存器">4.2 编号寄存器</h2>
<pre><code class="language-bash">&quot;0
&quot;1
...
&quot;9
</code></pre>
<p>从0到9共10个，可以细分为复制专用寄存器与删除专用寄存器，因为</p>
<pre><code class="language-bash">&quot;0
</code></pre>
<p>保存着最近一次y复制的内容，而</p>
<pre><code class="language-bash">&quot;1
...
&quot;9
</code></pre>
<p>这9个寄存器保存着最近一次删除（d，c，s，x等）的内容。上一次删除的内容被存放在</p>
<pre><code class="language-bash">&quot;1
</code></pre>
<p>上上次的被存放在</p>
<pre><code class="language-bash">&quot;2
</code></pre>
<p>以此类推。</p>
<p><strong>注意，只有整行的删除，和通过段落级别的移动指令的删除才会放进</strong></p>
<pre><code class="language-bash">&quot;1
</code></pre>
<p><strong>另外当指定寄存器后，比如</strong></p>
<pre><code class="language-bash">&quot;ayy
</code></pre>
<p><strong>不会写入到</strong></p>
<pre><code class="language-bash">&quot;0
</code></pre>
<p><strong>中，但是</strong></p>
<pre><code class="language-bash">&quot;add
</code></pre>
<p><strong>会写入到</strong></p>
<pre><code class="language-bash">&quot;1
</code></pre>
<p><strong>中，也就是说，指定寄存器后复制内容不会写入0寄存器，但是删除内容会写入1寄存器。</strong></p>
<h2 id="43-小删除寄存器">4.3 小删除寄存器</h2>
<pre><code class="language-bash">&quot;-
</code></pre>
<p>不足一行的小删除会被放进去，包括s，d，c，x。与</p>
<pre><code class="language-bash">&quot;0
</code></pre>
<p>类似，用户指定寄存器后不会被写入。</p>
<h2 id="44-命名寄存器">4.4 命名寄存器</h2>
<pre><code class="language-bash">&quot;a
&quot;b
...
</code></pre>
<p>小写字母组成的26个寄存器，一般用来录制键盘宏，比如有如下内容：</p>
<pre><code class="language-cpp">iostream
string
cmath
</code></pre>
<p>可以把位置定位到第一行，然后</p>
<pre><code class="language-java">qaI#include&lt;{ESC}A&gt;{ESC}jq
</code></pre>
<p>其中</p>
<pre><code class="language-bash">{ESC}
</code></pre>
<p>表示按下ESC键，这样第一行就加上include了，同时把宏记录到了寄存器a，接下来，使用</p>
<pre><code class="language-bash">2@a
</code></pre>
<p>即可在剩余两行加上include。<br>
另外，小写对应的大写字母的寄存器用于追加内容，比如：</p>
<pre><code class="language-bash">&quot;Ayy
</code></pre>
<p>可以向</p>
<pre><code class="language-bash">&quot;a
</code></pre>
<p>追加内容。</p>
<h2 id="45-只读寄存器">4.5 只读寄存器</h2>
<pre><code class="language-java">&quot;. 上一次insert插入的内容
&quot;% 当前文件名，从vim的工作目录到该文件的路径
&quot;: 上次命令模式下键入的命令，使用@:执行上次命令， .只能进行一些简单的重复，一些复杂的命令比如替换，需要使用@:
</code></pre>
<p>共三个，只读。</p>
<h2 id="46-交替文件寄存器">4.6 交替文件寄存器</h2>
<pre><code class="language-bash">&quot;#
</code></pre>
<p>保存着当前窗口的交替文件。<br>
交替文件是缓冲区（Buffer）上的一个文件，而缓冲区其实时vim中打开文件编辑时占用的那部分内存，编辑文件时，只是编辑缓冲区中的文件，当使用</p>
<pre><code class="language-bash">:w
</code></pre>
<p>时，会把缓冲区的文件写入磁盘。</p>
<h2 id="47-表达式寄存器">4.7 表达式寄存器</h2>
<pre><code class="language-bash">&quot;=
</code></pre>
<p>计算vim脚本的返回值，输入后会跳转到命令行，此时若输入3+2，回车并p，会粘贴5。</p>
<h2 id="48-选择拖放寄存器">4.8 选择拖放寄存器</h2>
<p>上面已经介绍了两个：</p>
<pre><code class="language-java">&quot;+
&quot;*
</code></pre>
<p>还有一个是</p>
<pre><code class="language-bash">&quot;~
</code></pre>
<p>其中</p>
<pre><code class="language-java">&quot;+
&quot;*
</code></pre>
<p>在Mac与Windows上指的是系统剪贴板，在大多数X11，也就是带桌面环境的Linux发行版中是有区别的，上面也提到了一点：</p>
<pre><code class="language-java">&quot;+ 系统剪贴板
&quot;* 鼠标选中区域，可以中键粘贴
</code></pre>
<p>有文本拖拽到vim时，被存放在</p>
<pre><code class="language-java">&quot;~
</code></pre>
<p>中，默认会将其中的内容插入到光标位置。</p>
<h2 id="49-黑洞寄存器">4.9 黑洞寄存器</h2>
<pre><code class="language-java">&quot;_
</code></pre>
<p>所有进入到里面的内容会消失，通常用于脚本中。</p>
<h2 id="410-搜索寄存器">4.10 搜索寄存器</h2>
<pre><code class="language-java">&quot;/
</code></pre>
<p>存储上一次搜索的关键词。可写，通过</p>
<pre><code class="language-java">:let @/ = &quot;123&quot;
</code></pre>
<p>下一次搜索可直接</p>
<pre><code class="language-java">/
</code></pre>
<p>不输入关键词回车即可。<br>
注意不存在</p>
<pre><code class="language-java">&quot;?
</code></pre>
<p>寄存器。</p>
<h1 id="5-参考">5 参考</h1>
<p>1.<a href="https://harttle.land/2016/07/25/vim-registers.html#header-12">Vim 寄存器完全手册</a></p>
<p>2.<a href="https://vim.fandom.com/wiki/Buffers">Vim官方文档-1</a></p>
<p>3.<a href="https://vim.fandom.com/wiki/Pasting_registers">Vim官方文档-2</a></p>
<p>4.<a href="https://www.zhihu.com/question/19863631">知乎-如何将 Vim 剪贴板里面的东西粘贴到 Vim 之外的地方</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ERROR]: gitstatus failed to initialize.]]></title>
        <id>https://2293736867.github.io/post/error-gitstatus-failed-to-initialize/</id>
        <link href="https://2293736867.github.io/post/error-gitstatus-failed-to-initialize/">
        </link>
        <updated>2020-06-02T21:36:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>Manjaro升级后，zsh的主题p10k出现的问题。</p>
<pre><code class="language-bash">Your git prompt may disappear or become slow.
Run the following command to retry with extra diagnostics:
GITSTATUS_ENABLE_LOGGING=1 gitstatus_start -s 1 -u 1 -d 1 -m -1 POWERLEVEL9K

OUTPUT:

[ERROR]: gitstatus failed to initialize.
......
</code></pre>
<h1 id="2-解决方法">2 解决方法</h1>
<p>来自gitstatus官方issue，<a href="https://github.com/romkatv/gitstatus/issues/36">戳这里</a>，其实就是把p10k主题更新到最新版本就好了，用</p>
<pre><code class="language-bash">pacman -Qi zsh-theme-powerlevel10k
</code></pre>
<p>查看版本，若不是最新版本，不要使用自带的软件包升级：</p>
<pre><code class="language-bash">pcaman -S zsh-theme-powerlevel10k
</code></pre>
<p>官方说这是旧的，不要使用：<br>
<img src="https://img-blog.csdnimg.cn/2020052311011054.png" alt="在这里插入图片描述" loading="lazy"><br>
因此先把配置文件备份：</p>
<pre><code class="language-bash">sudo cp ~/.p10k.zsh ~/Desktop
</code></pre>
<p>再卸载掉，然后clone安装：</p>
<pre><code class="language-bash">pacman -R zsh-theme-powerlevel10k
git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k
# 或使用码云上的镜像
# git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k
</code></pre>
<p>在</p>
<pre><code class="language-bash">~/.zshrc
</code></pre>
<p>修改主题：</p>
<pre><code class="language-bash">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;
</code></pre>
<p>最后把配置文件覆盖：</p>
<pre><code class="language-bash">sudo cp ~/.p10k.zsh ~/.p10k.zsh.bak
sudo cp ~/Desktop/.p10k.zsh ~/.p10k.zsh
</code></pre>
]]></content>
    </entry>
</feed>