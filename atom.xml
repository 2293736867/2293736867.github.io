<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-07-29T15:14:50.543Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第44期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-44-qi/">
        </link>
        <updated>2020-08-01T14:44:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596034407830.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>现在的时代不是属于00后，是属于厚脸皮的！</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>据估计，野生动物贩卖每年市值约100亿美元，是仅次于毒品和武器的第三大最有价值的非法贸易。其中鸟类是最为常见的违禁品，每年走私的野生鸟类有200万到500万只。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>白发渔樵江渚上，惯看秋月春风。<br>
——杨慎《临江仙·滚滚长江东逝水》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>每一个人都应该明确自己的方向和位置。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=444267766">尽头-赵方婧</a></p>
</blockquote>
<blockquote>
<p>觥筹交错<br>
时光如梭<br>
迷失自我<br>
享受折磨<br>
这是你要的<br>
物质生活</p>
</blockquote>
<blockquote>
<p>一身污浊<br>
自得其乐<br>
谁的命运<br>
谁又能把握<br>
这是种孤独<br>
没有结果</p>
</blockquote>
<blockquote>
<p>精神虚伪的寄托<br>
不择手段的<br>
迷离恍惚的假想<br>
推翻不假思索<br>
如果换作是我<br>
又是何得的<br>
变作无趣的枷锁<br>
肉体诚实的反驳<br>
不合时宜的<br>
消散太快的热度<br>
假装不食烟火<br>
不由分说的我<br>
换个身份变作<br>
有趣的恶魔</p>
</blockquote>
<blockquote>
<p>觥筹交错<br>
时光如梭<br>
迷失自我<br>
享受折磨<br>
这是你要的<br>
物质生活</p>
</blockquote>
<blockquote>
<p>一身污浊<br>
自得其乐<br>
谁的命运<br>
谁又能把握<br>
这是种孤独<br>
没有结果</p>
</blockquote>
<blockquote>
<p>精神虚伪的寄托<br>
不择手段的<br>
迷离恍惚的假想<br>
推翻不假思索<br>
如果换作是我<br>
又是何得的<br>
变作无趣的枷锁<br>
肉体诚实的反驳<br>
不合时宜的<br>
消散太快的热度<br>
假装不食烟火<br>
不由分说的我<br>
换个身份变作<br>
有趣的恶魔</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第43期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-43-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-43-qi/">
        </link>
        <updated>2020-07-31T14:41:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1596034395741.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>无毒的身躯抗下有毒的疫苗，你是教育我从小就要坚强！</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>现代手术之父威廉·斯图尔特·霍尔斯特博士通过向自己注射可卡因开创了使用麻醉药的先例。他最终对可卡因成瘾，之后是吗啡，但即便如此，他始终都在促进医学培训现代化。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>金陵风景好，豪事集新亭。<br>
——李白《金陵新亭》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>即便你忘记了我，我也不回遗忘你。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=5256770">明知做戏-吴雨霏</a></p>
</blockquote>
<blockquote>
<p>等你的汽水喝一半给你加片薄冰<br>
等你的桌面满些我总会打理重整<br>
不想纯情<br>
不够聪明<br>
你未发现我的身影</p>
</blockquote>
<blockquote>
<p>得我帮你依照编码整理家里电影<br>
只会得我一个帮你选购喜爱铃声<br>
天天如常<br>
估你心情<br>
等一个眼神求证<br>
一闪擦过如流星</p>
</blockquote>
<blockquote>
<p>怎么我为我做过的感到惊怕<br>
就像爱吗我也不肯定恐怕<br>
我以为存在吗<br>
千变万化<br>
从来不肯开口可相信吗<br>
离谱吗</p>
</blockquote>
<blockquote>
<p>请你不要阻我喜欢你<br>
明明是爱但你未说话扮作闪避<br>
这个沉默冷静的你毫无办法处理<br>
其实我亦怕是错摸心理<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过仍然害羞的你<br>
还是顾忌太不争气<br>
明知做戏</p>
</blockquote>
<blockquote>
<p>即使你未在意不感到惊讶<br>
现在要说爱你请准备招架<br>
勇气还存在吗<br>
不要害怕<br>
随时真的胆敢亲手送花<br>
离谱吗</p>
</blockquote>
<blockquote>
<p>请你不要阻我喜欢你<br>
明明是爱但你未说话扮作闪避<br>
这个沉默冷静的你毫无办法处理<br>
其实我亦怕是错摸心理<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过仍然害羞的你<br>
还是顾忌太不争气<br>
明知做戏</p>
</blockquote>
<blockquote>
<p>不过不要阻我紧张你<br>
如令你不愉快让我办妥为你准备<br>
喜爱沉默冷静的你还是自信的你<br>
仍愿意为你造一些惊喜<br>
总有天会等到好天气<br>
游行示爱大叫着你在某大片草地<br>
等你无用退避不过途人目光不理<br>
期待贴着你的手臂<br>
无须做戏</p>
</blockquote>
<blockquote>
<p>等你喜爱等你不爱就凭摘毫验证<br>
想爱不爱偏爱不理亦同样难划清<br>
天天如常<br>
估你心情<br>
不想扑索来求证<br>
争取过趁还年轻<br>
终于你下定决定来答应<br>
太动听</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第42期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-42-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-42-qi/">
        </link>
        <updated>2020-07-30T15:24:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595863733090.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我是一条酸菜鱼，又酸又菜，还多余。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>《吉尼斯世界纪录》这本书持有在公共图书馆内最经常被盗的书这一记录。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>一番荷芰生池沼，槛前风送馨香。<br>
——尹鹗《临江仙·一番荷芰生池沼》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>世间本无公平可言，除非公平掌握在自己手中。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=174956">坏女孩-徐良/小凌</a></p>
</blockquote>
<blockquote>
<p>I miss you<br>
Now<br>
don't you love me<br>
Sorry I'm so sorry</p>
</blockquote>
<blockquote>
<p>那时我放开了你的手<br>
转过身只剩了保重<br>
你话都没说却哭了很久很久<br>
我喜欢坏坏的女友<br>
我喜欢刺激的感受<br>
你单纯太过多余了那些温柔</p>
</blockquote>
<blockquote>
<p>你消失在无名大街<br>
从此就没有再见面<br>
好长的时间再没有你的来电<br>
在后来酒吧的房间<br>
舞池里跳动着音乐<br>
熟悉的侧脸喂</p>
</blockquote>
<blockquote>
<p>迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
<blockquote>
<p>那时我放开了你的手<br>
转过身只剩了保重<br>
你话都没说却哭了很久很久<br>
我喜欢坏坏的女友<br>
我喜欢刺激的感受<br>
你单纯太过多余了那些温柔</p>
</blockquote>
<blockquote>
<p>你消失在无名大街<br>
从此就没有再见面<br>
好长的时间再没有你的来电<br>
在后来酒吧的房间<br>
舞池里跳动着音乐<br>
熟悉的侧脸喂</p>
</blockquote>
<blockquote>
<p>迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
<blockquote>
<p>然后我安静的发现<br>
两个人已经没有任何语言<br>
曾经你纯真的永远<br>
让我不顾一切开始怀念<br>
迷人的笑脸吸引视线<br>
慵懒的靠在陌生的肩<br>
黑色的眼线你的指间<br>
有一点轻蔑</p>
</blockquote>
<blockquote>
<p>在谁的怀中会有感觉<br>
被爱的深夜我在想念<br>
明明是为你才会改变<br>
却回不到从前</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第41期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-41-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-41-qi/">
        </link>
        <updated>2020-07-29T15:22:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595863713502.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>为什么你能智障一样活着，而我却不可以。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>螳螂虾（皮皮虾）挥动爪子的速度极好，甚至可以令周围的水沸腾并制造一道闪光。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>休言女子非英物，夜夜龙泉壁上鸣。<br>
——秋瑾《鹧鸪天·祖国沉沦感不禁》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我今天就要带她走，我看谁敢拦我！</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=165361">不分手的恋爱-汪苏泷</a></p>
</blockquote>
<blockquote>
<p>不知不觉不问<br>
不痛不痒<br>
多少的时光<br>
不确定的某个<br>
夜晚小巷<br>
泪悄悄流淌<br>
街边天气微凉<br>
淡淡月光<br>
我沿路哼唱<br>
找寻我们一直<br>
找不到的<br>
缘分被捆绑</p>
</blockquote>
<blockquote>
<p>感觉不到你为我坚强<br>
感觉得到你对我说谎<br>
我安静听着肖邦<br>
用维也纳忧伤</p>
</blockquote>
<blockquote>
<p>你的爱被埋葬<br>
恨被收藏<br>
痛应该原谅<br>
我的爱不用讲<br>
恨不用想<br>
思念在发烫<br>
看着你的脸庞<br>
背着行囊<br>
说要去远方<br>
谁还记得那年我拉着你说<br>
爱永远一样</p>
</blockquote>
<blockquote>
<p>我也搞不懂为什么那么多人真心相爱<br>
到最后都会变成两个人分开的无奈<br>
当初我们说过要谈一场永远不分手的恋爱<br>
是否今天这句话竟变成我们之间的阻碍<br>
不想太多 不想太多 也许会明白的更多<br>
不想再说 不想再说 就让我们彼此沉默<br>
现在我们终于明白 结局却也无法更改<br>
这场不分手的恋爱 我想结局注定失败</p>
</blockquote>
<blockquote>
<p>不知不觉不问 不痛不痒<br>
多少的时光<br>
不确定的某个 夜晚小巷<br>
泪悄悄流淌<br>
街边天气微凉 淡淡月光<br>
我沿路哼唱<br>
找寻我们一直 找不到的<br>
缘分被捆绑</p>
</blockquote>
<blockquote>
<p>感觉不到你为我坚强<br>
感觉得到你多我说谎<br>
我安静听着肖邦<br>
用维也纳忧伤</p>
</blockquote>
<blockquote>
<p>你的爱被埋葬<br>
恨被收藏<br>
痛应该原谅<br>
我的爱不用讲<br>
恨不用想<br>
思念在发烫<br>
看着你的脸庞<br>
背着行囊<br>
说要去远方<br>
谁还记得那年我拉着你说<br>
爱永远一样</p>
</blockquote>
<blockquote>
<p>你的爱被埋葬<br>
恨被收藏<br>
痛应该原谅<br>
我的爱不用讲<br>
恨不用想<br>
思念在发烫<br>
看着你的脸庞<br>
背着行囊<br>
说要去远方<br>
谁还记得那年我拉着你说<br>
爱永远一样</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（六）：抽象工厂模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-liu-chou-xiang-gong-han-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-liu-chou-xiang-gong-han-mo-shi/">
        </link>
        <updated>2020-07-29T14:38:45.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a>
<ul>
<li><a href="#111-%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E7%BB%93%E6%9E%84">1.1.1 产品等级结构</a></li>
<li><a href="#112-%E4%BA%A7%E5%93%81%E6%97%8F">1.1.2 产品族</a></li>
</ul>
</li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81">2.2 抽象产品</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81">2.3 具体产品</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">2.4 抽象工厂</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82">2.5 具体工厂</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%9C%89%E5%85%B3ocp">4 有关OCP</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>在了解抽象工厂模式之前，首先来了解一下两个术语：</p>
<ul>
<li>产品等级结构</li>
<li>产品族</li>
</ul>
<h3 id="111-产品等级结构">1.1.1 产品等级结构</h3>
<p>产品等级结构也就是产品的继承结构，例如一个抽象类是电视机，子类有不同品牌的电视机，比如海尔电视机，海信电视机，TCL电视机，而抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是子类。</p>
<h3 id="112-产品族">1.1.2 产品族</h3>
<p>产品族是指由一个同一个工厂产生的位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机，海尔电冰箱。海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机与海尔电冰箱共同构成了一个产品族。</p>
<p>两者示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200716202932265.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式是针对一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。</p>
<p>每一个具体工厂可以生产属于一个产品族的所有产品，所生产的产品又位于不同的产品等级结构中，在上图的例子中，如果使用工厂方法模式需要12个具体工厂类，而使用抽象工厂模式只需要4个工厂类，大大减少了系统中类的个数。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</strong></p>
<p>抽象工厂模式又叫Kit模式，是一种对象创建型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200716202048426.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>AbstractFactory</code>（抽象工厂）：声明了一组用于创建一族产品的方法，每一个方法对应一种产品</strong></li>
<li><strong><code>ConcreteFactory</code>（具体工厂）：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品的等级结构中</strong></li>
<li><strong><code>AbstractProduct</code>（抽象产品）：为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</strong></li>
<li><strong><code>ConcreteProduct</code>（具体产品）：定义具体工厂生产的具体对象，实现在抽象层产品接口中声明的业务方法</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>确定产品等级结构：也就是定义抽象产品，抽象产品的数量就是产品等级结构的数量，为抽象产品声明产品所具有的业务方法</li>
<li>确定产品族：也就是定义具体产品，对于每个抽象产品，有多少个子类就有多少个产品族，具体产品类实现或继承抽象产品，实现其中的业务方法</li>
<li>定义抽象工厂：定义为接口/抽象类，声明创建一族产品的方法，根据产品等级结构数量确定方法数量</li>
<li>定义具体工厂：实现/继承抽象工厂，实现其中的业务方法</li>
</ul>
<h2 id="22-抽象产品">2.2 抽象产品</h2>
<p>这里简单定义两个抽象产品接口，也就是假设有两个产品等级结构（A与B）：</p>
<pre><code class="language-java">interface ProductA
{
    void methodA();
}

interface ProductB
{
    void methodB();
}
</code></pre>
<h2 id="23-具体产品">2.3 具体产品</h2>
<p>声明四个具体产品，假设每种产品由分别两个工厂生产，也就是假设有两个产品族：</p>
<pre><code class="language-java">class ProductA1 implements ProductA
{
    public void methodA()
    {
        System.out.println(&quot;Product A1&quot;);
    }
}

class ProductA2 implements ProductA
{
    public void methodA()
    {
        System.out.println(&quot;Product A2&quot;);
    }
}

class ProductB1 implements ProductB
{
    public void methodB()
    {
        System.out.println(&quot;Product B1&quot;);
    }
}

class ProductB2 implements ProductB
{
    public void methodB()
    {
        System.out.println(&quot;Product B2&quot;);
    }
}
</code></pre>
<h2 id="24-抽象工厂">2.4 抽象工厂</h2>
<p>由于只有两个产品等级结构（A与B），这里的抽象工厂只需要两个方法，分别表示生产这两种产品：</p>
<pre><code class="language-java">interface Factory
{
    ProductA getProductA();
    ProductB getProductB();
}
</code></pre>
<h2 id="25-具体工厂">2.5 具体工厂</h2>
<p>由于上面已经假设为两个产品族，因此这里需要两个具体工厂：</p>
<pre><code class="language-java">//产品族Factory1
class Factory1 implements Factory
{
    public ProductA getProductA()
    {
        return new ProductA1();
    }

    public ProductB getProductB()
    {
        return new ProductB1();
    }
}

//产品族Factory2
class Factory2 implements Factory
{
    public ProductA getProductA()
    {
        return new ProductA2();
    }

    public ProductB getProductB()
    {
        return new ProductB2();
    }
}
</code></pre>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) {
    Factory factory = new Factory1();
    ProductA productA = factory.getProductA();
    ProductB productB = factory.getProductB();
    productA.methodA();
    productB.methodB();

    factory = new Factory2();
    productA = factory.getProductA();
    productB = factory.getProductB();
    productA.methodA();
    productB.methodB();
}
</code></pre>
<p>客户端针对抽象工厂以及抽象产品编程，只需要知道工厂类名即可获取同一工厂（同一产品族）不同产品等级结构的产品。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>界面皮肤库设计：开发一套皮肤库，用户可以通过菜单选择皮肤，不同的皮肤提供视觉不同的按钮，文本框等UI元素，使用抽象工厂模式进行设计。</p>
</blockquote>
<p>这里简单起见假设开发两套皮肤：</p>
<ul>
<li>春季皮肤（SpringSkin）</li>
<li>夏季皮肤（SummerSkin）</li>
</ul>
<p>每套皮肤具有以下UI元素：</p>
<ul>
<li>按钮（Button）</li>
<li>文本框（TextField）</li>
<li>组合框（ComboBox）</li>
</ul>
<p>具体设计如下：</p>
<ul>
<li>抽象产品：<code>Button</code>+<code>TextField</code>+<code>ComboBox</code></li>
<li>具体产品：<code>SpringButton</code>+<code>SummerButton</code>+<code>SpringTextField</code>+<code>SummerTextField</code>+<code>SpringComboBox</code>+<code>SummerComboBox</code></li>
<li>抽象工厂：<code>SkinFactory</code></li>
<li>具体工厂：<code>SpringSkinFactory</code>+<code>SummerSkinFactory</code></li>
</ul>
<p>先设计产品类：</p>
<pre><code class="language-java">//抽象产品
interface Button
{
    void display();
}

//具体产品
class SpringButton implements Button
{
    public void display()
    {
        System.out.println(&quot;春季皮肤按钮&quot;);
    }
}

//具体产品
class SummerButton implements Button
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤按钮&quot;);
    }
}

//抽象产品
interface TextField
{
    void display();
}

//具体产品
class SpringTextField implements TextField
{
    public void display()
    {
        System.out.println(&quot;春季皮肤文本框&quot;);
    }
}

//具体产品
class SummerTextField implements TextField
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤文本框&quot;);
    }
}

//抽象产品
interface ComboBox
{
    void display();
}

//具体产品
class SpringComboBox implements ComboBox
{
    public void display()
    {
        System.out.println(&quot;春季皮肤组合框&quot;);
    }
}

//具体产品
class SummerComboBox implements ComboBox
{
    public void display()
    {
        System.out.println(&quot;夏季皮肤组合框&quot;);
    }
}
</code></pre>
<p>接着是工厂类：</p>
<pre><code class="language-java">//抽象工厂
interface SkinFactory
{
    Button createButton();
    TextField createTextField();
    ComboBox createComboBox();
}

//具体工厂
class SpringSkinFactory implements SkinFactory
{
    public Button createButton()
    {
        return new SpringButton();
    }

    public TextField createTextField()
    {
        return new SpringTextField();
    }

    public ComboBox createComboBox()
    {
        return new SpringComboBox();
    }
}

//具体工厂
class SummerSkinFactory implements SkinFactory
{
    public Button createButton()
    {
        return new SummerButton();
    }

    public TextField createTextField()
    {
        return new SummerTextField();
    }

    public ComboBox createComboBox()
    {
        return new SummerComboBox();
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        SkinFactory factory = new SpringSkinFactory();
        factory.createButton().display();
        factory.createTextField().display();
        factory.createComboBox().display();
        
        factory = new SummerSkinFactory();
        factory.createButton().display();
        factory.createTextField().display();
        factory.createComboBox().display();
    }
}
</code></pre>
<h1 id="4-有关ocp">4 有关OCP</h1>
<p>虽然使用抽象工厂模式增加新的皮肤界面非常方便，但是如果增加一个UI元素，会修改大量的代码，需要修改抽象工厂以及每一个具体工厂类，也就是说，不能够在符合OCP（开放闭合原则）的前提下增加新的组件。</p>
<p>这是抽象工厂模式的最大缺点，<strong>尽管增加新的产品族（这里是皮肤）非常方便，但是增加新的产品等级结构（这里是UI元素）很麻烦。抽象工厂模式的这种性质叫做开闭原则的倾斜性</strong>。因此设计人员在设计之初需要全面考虑，否则新增产品结构会导致大量的代码修改。</p>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>隔离：抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离更换一个具体工厂类变得很相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</li>
<li>同一产品族对象：当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加产品族容易：增加新的产品族容易，无须修改已有系统，符合OCP</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<p>主要缺点是增加新的产品等级结构麻烦，需要对系统进行大量的修改，违背了OCP。</p>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>一个系统不当应依赖与产品类实例如何被创建，组合和表达细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建以及使用解耦</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。例如同一皮肤下的按钮以及文本框，按钮与文本框没有直接联系，但是都属于同一皮肤</li>
<li>产品等级结构稳定，设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200728225937668.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（五）：工厂方法模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-wu-gong-han-fang-fa-mo-shi/">
        </link>
        <updated>2020-07-29T14:37:18.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%BA%A7%E5%93%81">2.2 抽象产品</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E4%BA%A7%E5%93%81">2.3 具体产品</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">2.4 抽象工厂</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E5%B7%A5%E5%8E%82">2.5 具体工厂</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E9%9A%90%E8%97%8F">4 隐藏</a></li>
<li><a href="#5-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">5 主要优点</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">6 主要缺点</a></li>
<li><a href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">7 适用场景</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>尽管简单工厂模式实现了对象的创建和使用分离，但是仍然存在以下两个问题：</p>
<ul>
<li>工厂类过于庞大，包含了大量的判断代码，导致维护和测试难度增大</li>
<li>系统扩展不灵活，如果增加了新的产品类型，必须修改静态工厂方法的业务逻辑，违反了开闭原则</li>
<li>具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性</li>
</ul>
<p>一个更好的办法是使用工厂方法模式。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。</strong></p>
<p>工厂方法又简称工厂模式或虚拟构造器模式或多态工厂模式，让一个类的实例化延迟到其子类，是一种类创建型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200715162916816.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong><code>Product</code>（抽象产品）：定义产品的接口，是工厂方法模式所创建的超类型，也就是产品对象的公共父类</strong></li>
<li><strong><code>ConcreteProduct</code>（具体产品）：实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂与具体产品一一对应</strong></li>
<li><strong><code>Factory</code>（抽象工厂）：在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口</strong></li>
<li><strong><code>ConcreteFactory</code>（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象产品：定义为接口/抽象类，是所有具体产品的父类</li>
<li>定义具体产品：实现/继承抽象产品，一个类对应与一个具体产品</li>
<li>定义抽象工厂：定义为接口/抽象类，声明工厂方法，但不需要实现，在运行时确定具体工厂</li>
<li>定义具体工厂：实现/继承抽象工厂，实现其中的工厂方法</li>
</ul>
<h2 id="22-抽象产品">2.2 抽象产品</h2>
<p>这里定义为接口：</p>
<pre><code class="language-java">interface Product
{
    void method();
}
</code></pre>
<h2 id="23-具体产品">2.3 具体产品</h2>
<p>两个示例具体产品：</p>
<pre><code class="language-java">class ConcreteProductA implements Product
{
    public void method()
    {
        System.out.println(&quot;Concrete Product A&quot;);
    }
}

class ConcreteProductB implements Product
{
    public void method()
    {
        System.out.println(&quot;Concrete Product B&quot;);
    }
}
</code></pre>
<h2 id="24-抽象工厂">2.4 抽象工厂</h2>
<p>这里定义为接口：</p>
<pre><code class="language-java">interface Factory
{
    Product get();
}
</code></pre>
<p>抽象工厂中声明了工厂方法但没有实现，交由子类具体工厂负责。</p>
<h2 id="25-具体工厂">2.5 具体工厂</h2>
<pre><code class="language-java">class ConcreteFactoryA implements Factory
{
    public Product get()
    {
        return new ConcreteProductA();
    }
}

class ConcreteFactoryB implements Factory
{
    public Product get()
    {
        return new ConcreteProductB();
    }
}
</code></pre>
<p>一个具体产品对应一个具体工厂，每一个具体工厂返回不同的具体产品。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<p>客户端针对抽象产品以及抽象工厂进行编程，无需知道具体产品的类名，只需要知道具体产品对应的工厂，即可获取具体产品：</p>
<pre><code class="language-java">Factory factory = new ConcreteFactoryA();
Product product = factory.get();
product.method();
factory = new ConcreteFactoryB();
product = factory.get();
product.method();
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>日志记录器的设计：该记录器可以通过多种途径保存系统的运行日志，例如文件记录或者数据库记录，使用工厂方法模式进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象产品：<code>Logger</code></li>
<li>具体产品：<code>DatabaseLogger</code>+<code>FileLogger</code></li>
<li>抽象工厂：<code>LoggerFactory</code></li>
<li>具体工厂：<code>DatabaseLoggerFactory</code>+<code>FileLoggerFactory</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        LoggerFactory factory = new FileLoggerFactory();        
        Logger logger = factory.createLogger();
        logger.log();
    }
}

//抽象产品
interface Logger
{
    void log();
}

//具体产品:DatabaseLogger
class DatabaseLogger implements Logger
{
    public void log()
    {
        System.out.println(&quot;数据库日志记录&quot;);
    }
}

//具体产品:FileLogger
class FileLogger implements Logger
{
    public void log()
    {
        System.out.println(&quot;文件日志记录&quot;);
    }
}

//抽象工厂
interface LoggerFactory
{
    Logger createLogger();
}

//具体工厂:DatabaseLoggerFactory
class DatabaseLoggerFactory implements LoggerFactory
{
    public Logger createLogger()
    {
        return new DatabaseLogger();
    }
}

//具体工厂:FileLoggerFactory
class FileLoggerFactory implements LoggerFactory
{
    public Logger createLogger()
    {
        return new FileLogger();
    }
}
</code></pre>
<h1 id="4-隐藏">4 隐藏</h1>
<p>可以把抽象工厂设置为抽象类，工厂方法直接可以对客户端隐藏，也就是说可以直接通过抽象工厂调用具体产品类的业务方法，客户端无需创建具体产品，直接通过工厂类调用即可，代码修改如下（抽象产品以及具体产品类不用修改）：</p>
<pre><code class="language-java">//抽象工厂
abstract class LoggerFactory
{
    public void log()
    {
        this.createLogger().log();
    }
    public abstract Logger createLogger();
}

//具体工厂:DatabaseLoggerFactory
class DatabaseLoggerFactory extends LoggerFactory
{
    public Logger createLogger()
    {
        return new DatabaseLogger();
    }
}

//具体工厂:FileLoggerFactory
class FileLoggerFactory extends LoggerFactory
{
    public Logger createLogger()
    {
        return new FileLogger();
    }
}

public class Test
{
    public static void main(String[] args) {
        LoggerFactory factory = new FileLoggerFactory();
        factory.log();
    }
}
</code></pre>
<h1 id="5-主要优点">5 主要优点</h1>
<ul>
<li>封装细节：工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名</li>
<li>多态：工厂方法的多态性能够让工厂可以自主确定创建何种产品对象，而如何创建对象的细节则完全封装在具体工厂内部</li>
<li>扩展性好：加入新产品时无须修改抽象工厂，抽象产品的接口，也无须修改客户端与其他的具体产品和具体工厂，只需要增加一个具体工厂以及具体产品，系统扩展性很好，完全符合开闭原则</li>
</ul>
<h1 id="6-主要缺点">6 主要缺点</h1>
<ul>
<li>类数量多：在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度，有更多的类需要编译和运行，给系统带来额外开销</li>
<li>增加理解难度：基于系统的扩展性需要引入抽象层，在客户端中均使用了抽象层的定义，增加了系统的抽象性以及理解难度</li>
</ul>
<h1 id="7-适用场景">7 适用场景</h1>
<ul>
<li>客户端不知道其所需要的对象的类：在工厂方法模式中，客户端不需要知道具体的产品类名，只需要知道所对应的工厂即可</li>
<li>抽象工厂类通过子类来指定创建哪个对象：工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而有其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更加容易扩展</li>
</ul>
<h1 id="8-总结">8 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200728202541743.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第40期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-40-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-40-qi/">
        </link>
        <updated>2020-07-28T15:22:06.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595863586158.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>成长就是将你哭声调成静音的过程。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>希腊火厮守拜占庭人在7世纪研发出的一种燃烧武器，并且不透水。这种武器被用于船舰之间的战斗以及手持式发射管，其操作类似于火焰喷射器。其精确的化学成分是一个只有极少数人知道的秘密，并且已经被淹没在了历史长河中。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>残月出门时，美人和泪醉。<br>
——韦庄《菩萨蛮·红楼别夜惆怅》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>问君能有几多愁？恰似一部新番没看头。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=28668855">恋人心-魏新雨</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1595868393432.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>化作风<br>
化作雨<br>
化作春<br>
走向你<br>
梦如声<br>
梦如影<br>
梦是遥远的掌印<br>
化作烟<br>
化作泥<br>
化作云<br>
飘向你<br>
思如海<br>
恋如城<br>
思念最遥不可及</p>
</blockquote>
<blockquote>
<p>你问西湖水<br>
偷走她的几分美<br>
时光一去不再<br>
信誓旦旦留给谁<br>
你问长江水<br>
淘尽心酸的滋味<br>
剩半颗恋人心唤不回</p>
</blockquote>
<blockquote>
<p>化作诗<br>
化作笔<br>
化作灯<br>
写着你<br>
默念着<br>
轻叹着<br>
那些深沉的字句<br>
化作路<br>
化作怪<br>
化作情<br>
找寻你<br>
爱一次<br>
梦一场<br>
思念最遥遥无期</p>
</blockquote>
<blockquote>
<p>你问西湖水<br>
偷走她的几分美<br>
时光一去不再<br>
信誓旦旦留给谁<br>
你问长江水<br>
淘尽心酸的滋味<br>
剩半颗<br>
恋人心<br>
唤不回</p>
</blockquote>
<blockquote>
<p>你问西湖水<br>
偷走她的几分美<br>
时光一去不再<br>
信誓旦旦留给谁<br>
你问长江水<br>
淘尽心酸的滋味</p>
</blockquote>
<blockquote>
<p>剩半颗恋人心唤不回<br>
剩半颗恋人心唤不回<br>
剩半颗恋人心唤不回</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十四）：享元模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-si-xiang-yuan-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-si-xiang-yuan-mo-shi/">
        </link>
        <updated>2020-07-27T06:01:16.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81">1.2 内部状态与外部状态</a></li>
<li><a href="#13-%E5%AE%9A%E4%B9%89">1.3 定义</a></li>
<li><a href="#14-%E7%BB%93%E6%9E%84%E5%9B%BE">1.4 结构图</a></li>
<li><a href="#15-%E8%A7%92%E8%89%B2">1.5 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E4%BA%AB%E5%85%83%E7%B1%BB">2.2 抽象享元类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E4%BA%AB%E5%85%83%E7%B1%BB">2.3 具体享元类</a></li>
<li><a href="#24-%E9%9D%9E%E5%85%B1%E4%BA%AB%E5%85%B7%E4%BD%93%E4%BA%AB%E5%85%83%E7%B1%BB">2.4 非共享具体享元类</a></li>
<li><a href="#25-%E4%BA%AB%E5%85%83%E5%B7%A5%E5%8E%82%E7%B1%BB">2.5 享元工厂类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
<li><a href="#27-%E5%8F%8D%E5%B0%84%E7%AE%80%E5%8C%96">2.7 反射简化</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%8A%A0%E5%85%A5%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81">4 加入外部状态</a></li>
<li><a href="#5-%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">5 单纯享元模式与复合享元模式</a>
<ul>
<li><a href="#51-%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">5.1 单纯享元模式</a></li>
<li><a href="#52-%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">5.2 复合享元模式</a></li>
</ul>
</li>
<li><a href="#6-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">6 补充说明</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">7 主要优点</a></li>
<li><a href="#8-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">8 主要缺点</a></li>
<li><a href="#9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">9 适用场景</a></li>
<li><a href="#10-%E6%80%BB%E7%BB%93">10 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>当一个系统中运行时的产生的对象太多，会带来性能下降等问题，比如一个文本字符串存在大量重复字符，如果每一个字符都用一个单独的对象表示，将会占用较多内存空间。</p>
<p>那么该如何避免出现大量相同或相似的对象，同时又不影响客户端以面向对象的方式操作呢？</p>
<p>享元模式正为解决这一问题而生，通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对<br>
应，但是物理上却共享一个享元对象。</p>
<p>在享元模式中，<strong>存储共享实例的地方称为享元池</strong>，可以针对每一个不同的字符创建一个享元对象，放置于享元池中，需要时取<br>
出，示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200727065325512.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="12-内部状态与外部状态">1.2 内部状态与外部状态</h2>
<p>享元模式以共享的方式高效地支持大量细粒度对象的重用，能做到共享的关键是区分了内部状态以及外部状态。</p>
<ul>
<li><strong>内部状态：存储在享元对象内部并且不会随环境改变而改变，内部状态可以共享，例如字符的内容，字符a永远是字符a，不会变为字符b</strong></li>
<li><strong>外部状态：能够随环境改变而改变，不可以共享的状态，通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。外部状态之间通常是相互独立的，比如字符的颜色，字号，字体等，可以独立变化，没有影响，客户端在使用时将外部状态注入到享元对象中</strong></li>
</ul>
<p>正因为区分了内部状态以及外部状态，可以将具有相同内部状态的对象存储在享元池中，享元池的对象是可以实现共享的，需要的时候从中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象实际上只存储一份。</p>
<h2 id="13-定义">1.3 定义</h2>
<p><strong>享元模式：运用共享技术有效地支持大量细粒度对象的复用。</strong></p>
<p>系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此又叫轻量级模式，是一种对象结构型模式。</p>
<h2 id="14-结构图">1.4 结构图</h2>
<p>享元模式一般结合工厂模式一起使用，结构图如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020072707364855.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="15-角色">1.5 角色</h2>
<ul>
<li><strong><code>Flyweights</code>（抽象享元类）：通常是一个接口或者抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）</strong></li>
<li><strong><code>ConcreteFlyweight</code>（具体享元类）：实现/继承抽象共享类，实例称为共享对象，在具体享元类中为内部状态提供了存储空间，通常可以结合单例模式来设计具体享元类</strong></li>
<li><strong><code>UnsharedConcreteFlyweight</code>（非共享具体享元类）：并不是所有的抽象享元子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非具体享元对象时可以直接实例化创建</strong></li>
<li><strong><code>FlyweightFactory</code>（享元工厂类）：享元工厂类用于创建并管理享元对象，针对抽象享元类编程，将具体享元对象存储于享元池中。一般使用键值对集合（比如Java中的</strong><code>HashMap</code><strong>）作为享元池，当客户端获取享元对象时，首先判断是否存在，存在则从集合中取出并返回，不存在则创建新具体享元的实例，存储于享元池中并返回新实例</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象享元类：将抽象享元类定义为接口或者抽象类，声明业务方法</li>
<li>定义具体享元类：继承或实现抽象享元，实现其中的业务方法，同时使用单例模式设计，确保每个具体享元类提供唯一的享元对象</li>
<li>（可选）定义非共享具体享元类：继承或实现抽象享元类，不使用单例模式设计，每次客户端获取都会返回一个新实例</li>
<li>定义享元工厂类：通常使用一个键值对集合作为享元池，根据键值返回对应的具体享元对象或非共享具体享元对象</li>
</ul>
<h2 id="22-抽象享元类">2.2 抽象享元类</h2>
<p>这里使用接口实现，包含一个<code>opeartion</code>业务方法：</p>
<pre><code class="language-java">interface Flyweight
{
    void operation(String extrinsicState);
}
</code></pre>
<h2 id="23-具体享元类">2.3 具体享元类</h2>
<p>简单设计两个枚举单例的具体享元类：</p>
<pre><code class="language-java">enum ConcreteFlyweight1 implements Flyweight
{
    INSTANCE(&quot;INTRINSIC STATE 1&quot;);
    private String intrinsicState;
    private ConcreteFlyweight1(String intrinsicState)
    {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void operation(String extrinsicState)
    {
        System.out.println(&quot;具体享元操作&quot;);
        System.out.println(&quot;内部状态:&quot;+intrinsicState);
        System.out.println(&quot;外部状态:&quot;+extrinsicState);
    }
}

enum ConcreteFlyweight2 implements Flyweight
{
    INSTANCE(&quot;INTRINSIC STATE 2&quot;);
    private String intrinsicState;
    private ConcreteFlyweight2(String intrinsicState)
    {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void operation(String extrinsicState)
    {
        System.out.println(&quot;具体享元操作&quot;);
        System.out.println(&quot;内部状态:&quot;+intrinsicState);
        System.out.println(&quot;外部状态:&quot;+extrinsicState);
    }
}
</code></pre>
<h2 id="24-非共享具体享元类">2.4 非共享具体享元类</h2>
<p>两个简单的非共享具体享元类，不是枚举单例类：</p>
<pre><code class="language-java">class UnsharedConcreteFlyweight1 implements Flyweight
{
    @Override
    public void operation(String extrinsicState)
    {
        System.out.println(&quot;非共享具体享元操作&quot;);
        System.out.println(&quot;外部状态:&quot;+extrinsicState);
    }
}

class UnsharedConcreteFlyweight2 implements Flyweight
{
    @Override
    public void operation(String extrinsicState)
    {
        System.out.println(&quot;非共享具体享元操作&quot;);
        System.out.println(&quot;外部状态:&quot;+extrinsicState);
    }
}
</code></pre>
<h2 id="25-享元工厂类">2.5 享元工厂类</h2>
<p>为了方便客户端以及工厂管理具体享元以及非共享具体享元，首先建立两个枚举类作为享元池的键：</p>
<pre><code class="language-java">enum Key { KEY1,KEY2 }
enum UnsharedKey { KEY1,KEY2 }
</code></pre>
<p>这里的工厂类使用了枚举单例：</p>
<pre><code class="language-java">enum Factory
{
    INSTANCE;
    private Map&lt;Key,Flyweight&gt; map = new HashMap&lt;&gt;();
    public Flyweight get(Key key)
    {
        if(map.containsKey(key))
            return map.get(key);
        switch(key)
        {
            case KEY1:    
                map.put(key, ConcreteFlyweight1.INSTANCE);
                return ConcreteFlyweight1.INSTANCE;
            case KEY2:
                map.put(key, ConcreteFlyweight2.INSTANCE);
                return ConcreteFlyweight2.INSTANCE;
            default:
                return null;
        }
    }

    public Flyweight get(UnsharedKey key)
    {
        switch(key)
        {
            case KEY1:
                return new UnsharedConcreteFlyweight1();
            case KEY2:
                return new UnsharedConcreteFlyweight2();
            default:
                return null;
        }
    }
}
</code></pre>
<p>使用<code>HashMap&lt;String,Flyweight&gt;</code>作为享元池：</p>
<ul>
<li>对于具体享元类，根据键值判断享元池中是否存在具体享元对象，如果存在直接返回，如果不存在把具体享元的单例存入享元池，并返回该单例</li>
<li>对于非共享具体享元类，由于是“非共享”，不需要把实例对象存储于享元池中，每次调用直接返回新实例</li>
</ul>
<h2 id="26-客户端">2.6 客户端</h2>
<p>客户端针对抽象享元进行编程，首先获取享元工厂单例，接着利用工厂方法，传入对应的枚举参数获取对应的具体享元或者非共享具体享元：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Factory factory = Factory.INSTANCE;
    Flyweight flyweight1 = factory.get(Key.KEY1);
    Flyweight flyweight2 = factory.get(Key.KEY1);
    System.out.println(flyweight1 == flyweight2);

    flyweight1 = factory.get(UnsharedKey.KEY1);
    flyweight2 = factory.get(UnsharedKey.KEY1);
    System.out.println(flyweight1 == flyweight2);
}
</code></pre>
<h2 id="27-反射简化">2.7 反射简化</h2>
<p>如果具体享元对象变多，工厂类的<code>get()</code>中的<code>switch</code>会变得很长，这时候可以将键值类以及工厂类的<code>get()</code>改进以简化代码，例如在上面的基础上又增加了两个具体享元类：</p>
<pre><code class="language-java">enum ConcreteFlyweight3 implements Flyweight {...}
enum ConcreteFlyweight4 implements Flyweight {...}
</code></pre>
<p>这样工厂类的<code>switch</code>需要增加两个<code>Key</code>：</p>
<pre><code class="language-java">switch(key)
{
    case KEY1:    
        map.put(key, ConcreteFlyweight1.INSTANCE);
        return ConcreteFlyweight1.INSTANCE;
    case KEY2:
        map.put(key, ConcreteFlyweight2.INSTANCE);
        return ConcreteFlyweight2.INSTANCE;
    case KEY3:
        map.put(key, ConcreteFlyweight3.INSTANCE);
        return ConcreteFlyweight3.INSTANCE;
    case KEY4:
        map.put(key, ConcreteFlyweight4.INSTANCE);
        return ConcreteFlyweight4.INSTANCE;
    default:
        return null;
}
</code></pre>
<p>可以利用具体享元类的命名方式进行简化，这里使用了顺序编号<code>1,2,3,4...</code>的方式，因此，利用反射获取对应的类后直接获取其中的单例对象：</p>
<pre><code class="language-java">public Flyweight get(Key key)
{
    if(map.containsKey(key))
        return map.get(key);
    try
    {
        Class&lt;?&gt; cls = Class.forName(&quot;ConcreteFlyweight&quot;+key.code());
        Flyweight flyweight = (Flyweight)(cls.getField(&quot;INSTANCE&quot;).get(null));
        map.put(key,flyweight);
        return flyweight;
    }
    catch(Exception e)
    {
        e.printStackTrace();
        return null;
    }
}
</code></pre>
<p>在此之前需要修改一下<code>Key</code>类：</p>
<pre><code class="language-java">enum Key
{
    KEY1(1),KEY2(2),KEY3(3),KEY4(4);
    private int code;
    private Key(int code)
    {
        this.code = code;
    }
    public int code()
    {
        return code;
    }
}
</code></pre>
<p>增加一个<code>code</code>字段，作为区分每一个具体享元的标志。</p>
<p>对于非共享具体享元类似，首先修改<code>UnsharedKey</code>，同理添加<code>code</code>字段：</p>
<pre><code class="language-java">enum UnsharedKey
{
    KEY1(1),KEY2(2),KEY3(3),KEY4(4);
    private int code;
    private UnsharedKey(int code)
    {
        this.code = code;
    }
    public int code()
    {
        return code;
    }
}
</code></pre>
<p>接着修改<code>get</code>方法：</p>
<pre><code class="language-java">public Flyweight get(UnsharedKey key)
{
    try
    {
        Class&lt;?&gt; cls = Class.forName(&quot;UnsharedConcreteFlyweight&quot;+key.code());
        return (Flyweight)(cls.newInstance());
    }
    catch(Exception e)
    {
        e.printStackTrace();
        return null;
    }
}
</code></pre>
<p>由于笔者使用的是OpenJDK11，其中<code>newInstance</code>被标记为过时了：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200727092339417.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200727092356620.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>因此使用如下方式代替直接使用<code>newInstance()</code>：</p>
<pre><code class="language-java">return (Flyweight)(cls.getDeclaredConstructor().newInstance());
</code></pre>
<p>区别如下：</p>
<ul>
<li><code>newInstance</code>：直接调用无参构造方法</li>
<li><code>getDeclaredConstructor().newInstance()</code>：<code>getDeclaredConstructor()</code>会根据传入的参数搜索该类的构造方法并返回，没有参数就返回该类的无参构造方法，接着调用<code>newInstance</code>进行实例化</li>
</ul>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>围棋棋子的设计：一个棋盘中含有大量相同的黑白棋子，只是出现的位置不一样，使用享元模式对棋子进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象享元类：<code>IgoChessman</code>接口（如果想要具体享元类为枚举单例的话必须是接口，使用其他方式实现单例可以为抽象类），包含<code>getColor</code>以及<code>display</code>方法</li>
<li>具体享元类：<code>BlackChessman</code>+<code>WhiteChessman</code>，枚举单例类</li>
<li>非共享具体享元类：无</li>
<li>享元工厂类：<code>Factory</code>，枚举单例类，包含简单的<code>get</code>作为获取具体享元的方法，加上了<code>white</code>以及<code>balck</code>简单封装，在构造方法中初始化享元池</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">//抽象享元接口
interface IgoChessman
{
    Color getColor();
    void display();
}

//具体享元枚举单例类
enum BlackChessman implements IgoChessman
{
    INSTANCE;
    
    @Override
    public Color getColor()
    {
        return Color.BLACK;
    }

    @Override
    public void display()
    {
        System.out.println(&quot;棋子颜色&quot;+getColor().color());
    }
}

//具体享元枚举单例类
enum WhiteChessman implements IgoChessman
{
    INSTANCE;
    
    @Override
    public Color getColor()
    {
        return Color.WHITE;
    }

    @Override
    public void display()
    {
        System.out.println(&quot;棋子颜色&quot;+getColor().color());
    }
}

//享元工厂枚举单例类
enum Factory
{
    INSTANCE;
    //HashMap&lt;Color,IgoChessman&gt;作为享元池
    private Map&lt;Color,IgoChessman&gt; map = new HashMap&lt;&gt;();
    private Factory()
    {
    	//构造方法中直接初始化享元池
        map.put(Color.WHITE, WhiteChessman.INSTANCE);
        map.put(Color.BLACK, BlackChessman.INSTANCE);
    }
    public IgoChessman get(Color color)
    {
    	//由于在构造方法中已经初始化，如果不存在可以返回null或者添加新实例到享元池并返回，这里选择了返回null
        if(!map.containsKey(color))
            return null;
        return (IgoChessman)map.get(color);
    }
    //简单封装
    public IgoChessman white()
    {
        return get(Color.WHITE);
    }
    public IgoChessman black()
    {
        return get(Color.BLACK);
    }
}

enum Color
{
    WHITE(&quot;白色&quot;),BLACK(&quot;黑色&quot;);
    private String color;
    private Color(String color)
    {
        this.color = color;
    }
    public String color()
    {
        return color;
    }
}
</code></pre>
<p>在初始化享元池时，如果具体享元类过多可以使用反射简化，不需要手动逐个<code>put</code>：</p>
<pre><code class="language-java">private Factory()
{
	map.put(Color.WHITE, WhiteChessman.INSTANCE);
	map.put(Color.BLACK, BlackChessman.INSTANCE);
}
</code></pre>
<p>根据枚举值数组，结合<code>List</code>与<code>forEach</code>，逐个利用数组中的值获取对应的类，进而获取实例：</p>
<pre><code class="language-java">private Factory()
{
    List.of(Color.values()).forEach(t-&gt;
    {
        String className = t.name().substring(0,1)+t.name().substring(1).toLowerCase()+&quot;Chessman&quot;;
        try
        {
            map.put(t,(IgoChessman)(Class.forName(className).getField(&quot;INSTANCE&quot;).get(null)));
        }
        catch(Exception e)
        {
            e.printStackTrace();
            map.put(t,null);
        }    
    });
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public static void main(String[] args) 
{
    Factory factory = Factory.INSTANCE;
    IgoChessman white1 = factory.white();
    IgoChessman white2 = factory.white();
    white1.display();
    white2.display();
    System.out.println(white1 == white2);

    IgoChessman black1 = factory.black();
    IgoChessman black2 = factory.black();
    black1.display();
    black2.display();
    System.out.println(black1 == black2);
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200727101745913.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-加入外部状态">4 加入外部状态</h1>
<p>通过上面的方式已经能够实现黑白棋子的共享了，但是还有一个问题没有解决，就是如何将相同的黑白棋子放置于不同的棋盘位置上？</p>
<p>解决办法也不难，增加一个坐标类<code>Coordinates</code>，调用<code>display</code>时作为要放置的坐标参数传入函数。</p>
<p>首先增加一个坐标类：</p>
<pre><code class="language-java">class Coordinates
{
    private int x;
    private int y;    
    public Coordinates(int x,int y)
    {
        this.x = x;
        this.y = y;
    }
	//setter+getter...
}
</code></pre>
<p>接着需要修改抽象享元接口，在<code>display</code>中加入<code>Coordinates</code>参数：</p>
<pre><code class="language-java">interface IgoChessman
{
    Color getColor();
    void display(Coordinates coordinates);
}
</code></pre>
<p>然后修改具体享元类即可：</p>
<pre><code class="language-java">enum BlackChessman implements IgoChessman
{
    INSTANCE;
    
    @Override
    public Color getColor()
    {
        return Color.BLACK;
    }

    @Override
    public void display(Coordinates coordinates)
    {
        System.out.println(&quot;棋子颜色&quot;+getColor().color());
        System.out.println(&quot;显示坐标:&quot;);
        System.out.println(&quot;横坐标&quot;+coordinates.getX());
        System.out.println(&quot;纵坐标&quot;+coordinates.getY());
    }
}
</code></pre>
<p>对于客户端，创建享元对象的代码无须修改，只需修改调用了<code>display</code>的地方，传入<code>Coordinates</code>参数即可：</p>
<pre><code class="language-java">IgoChessman white1 = factory.white();
IgoChessman white2 = factory.white();
white1.display(new Coordinates(1, 2));
white2.display(new Coordinates(2, 3));
</code></pre>
<h1 id="5-单纯享元模式与复合享元模式">5 单纯享元模式与复合享元模式</h1>
<h2 id="51-单纯享元模式">5.1 单纯享元模式</h2>
<p>标准的享元模式既可以包含具体享元类，也包含非共享具体享元类。</p>
<p><strong>但是在单纯享元模式中，所有的具体享元类都是共享的，也就是不存在非共享具体享元类。</strong></p>
<p>比如上面棋子的例子，黑白棋子作为具体享元类都是共享的，不存在非共享具体享元类。</p>
<h2 id="52-复合享元模式">5.2 复合享元模式</h2>
<p><strong>将一些单纯享元对象进行使用组合模式加以组合还可以形成复合享元对象</strong>，这样的复合享元对象本身不能共享，但是它们可以分解为单纯享元对象，而后者可以共享。</p>
<p><strong>通过复合享元模式可以确保复合享元类所包含的每个单纯享元类都具有相同的外部状态，而这些单纯享元的内部状态可以不一样</strong>，比如，上面棋子的例子中：</p>
<ul>
<li>黑棋子是单纯享元</li>
<li>白棋子也是单纯享元</li>
<li>这两个单纯享元的内部状态不同（颜色不同）</li>
<li>但是可以设置相同的外部状态（比如设置为棋盘上同一位置，但是这样没有什么实际意义，或者设置显示为同一大小）</li>
</ul>
<p>例子如下，首先在抽象享元中添加一个以<code>int</code>为参数的<code>display</code>：</p>
<pre><code class="language-java">interface IgoChessman
{
    Color getColor();
    void display(int size);
}
</code></pre>
<p>在具体享元实现即可：</p>
<pre><code class="language-java">enum BlackChessman implements IgoChessman
{
    INSTANCE;
    
    @Override
    public Color getColor()
    {
        return Color.BLACK;
    }

    @Override
    public void display(int size)
    {
        System.out.println(&quot;棋子颜色&quot;+getColor().color());
        System.out.println(&quot;棋子大小&quot;+size);
    }
}
</code></pre>
<p>接着添加复合享元类，里面包含一个<code>HashMap</code>存储所有具体享元：</p>
<pre><code class="language-java">enum Chessmans implements IgoChessman
{
    INSTANCE;
    private Map&lt;Color,IgoChessman&gt; map = new HashMap&lt;&gt;();

    public void add(IgoChessman chessman)
    {
        map.put(chessman.getColor(),chessman);
    }

    @Override
    public Color getColor()
    {
        return null;
    }

    @Override
    public void display(int size)
    {
        map.forEach((k,v)-&gt;v.display(size));
    }
}
</code></pre>
<p>在<code>display</code>中，实际上是遍历了<code>HashMap</code>，给每一个具体享元的<code>display</code>传入相同的参数。<br>
测试：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Factory factory = Factory.INSTANCE;
    IgoChessman white = factory.white();
    IgoChessman black = factory.black();
    Chessmans chessmans = Chessmans.INSTANCE;
    chessmans.add(white);
    chessmans.add(black);
    chessmans.display(30);
}
</code></pre>
<p>输出：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200727115118728.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样内部状态不同（颜色不同）的两个具体享元类（黑白棋）就被复合享元类（<code>Chessmans</code>）设置为具有相同的外部状态（显示大小30）。</p>
<h1 id="6-补充说明">6 补充说明</h1>
<ul>
<li>与其他模式联用：享元模式通常需要与其他模式联用，比如工厂模式（享元工厂），单例模式（具体享元枚举单例），组合模式（复合享元模式）</li>
<li>JDK中的享元模式：JDK中的<code>String</code>使用了享元模式。大家都知道<code>String</code>是不可变类，对于类似<code>String a = &quot;123&quot;</code>这种声明方式，会创建一个值为<code>&quot;123&quot;</code>的享元对象，下次使用<code>&quot;123&quot;</code>时从享元池获取，在修改享元对象时，比如<code>a += &quot;1&quot;</code>，先将原有对象复制一份，然后在新对象上进行修改，这种机制叫做&quot;Copy On Write&quot;。基本思路是，一开始大家都在共享内容，当某人需要修改时，把内容复制出去形成一个新内容并修改</li>
</ul>
<h1 id="7-主要优点">7 主要优点</h1>
<ul>
<li>降低内存消耗：享元模式可以极大地减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而节约系统资源，提供系统性能</li>
<li>外部状态独立：享元模式外部状态相对独立，不会影响到内部状态，从而使得享元对象可以在不同环境中被共享</li>
</ul>
<h1 id="8-主要缺点">8 主要缺点</h1>
<ul>
<li>增加复杂度：享元模式使得系统变复杂，需要分离出内部状态以及外部状态，使得程序逻辑复杂化</li>
<li>运行时间变长：为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态使得运行时间变长</li>
</ul>
<h1 id="9-适用场景">9 适用场景</h1>
<ul>
<li>一个系统有大量相似或相同对象，造成大量内存浪费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li>
<li>由于需要维护享元池，造成一定的资源开销，因此在需要真正多次重复使用享元对象时才值得使用享元模式</li>
</ul>
<h1 id="10-总结">10 总结</h1>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200729140109974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十三）：外观模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-san-wai-guan-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-san-wai-guan-mo-shi/">
        </link>
        <updated>2020-07-27T06:00:47.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E5%A4%96%E8%A7%82%E8%A7%92%E8%89%B2">2.2 外观角色</a></li>
<li><a href="#23-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.3 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB">4 引入抽象外观类</a>
<ul>
<li><a href="#41-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB">4.1 为什么需要引入抽象外观类？</a></li>
<li><a href="#42-%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5">4.2 如何引入？</a></li>
</ul>
</li>
<li><a href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5 注意事项</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>根据单一权责原则，软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，使客户类与子系统之间的通信和相互依赖关系达到最小，方法之一就是引入一个外观角色，为子系统的访问提供一个简单而单一的入口。外观模式通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p>
<p>（这里的子系统是广义的概念，可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统）</p>
<p>如果没有外观角色，每个客户端可能需要和多个子系统之间进行复杂的交互，系统的耦合度很大，简化示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200726194628891.png" alt="" loading="lazy"></figure>
<p>而引入外观角色后，客户端只需直接与外观角色交互，客户端与子系统之间的原有复杂度由外观角色实现，从而降低系统耦合度，简化示意图如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200726195100190.png" alt="" loading="lazy"></figure>
<p><strong>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观角色进行，外观角色将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</strong></p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>外观模式：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口。</strong></p>
<p>外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>外观模式又叫门面模式，是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200726195644651.png" alt="" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong>Facade（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的一个或多个子系统的功能和责任，正常情况下将来自客户端的请求委派到对应的子系统中去，传递给相应的子系统对象处理</strong></li>
<li><strong>SubSystem（子系统角色）：每一个子系统是一个单独的类，也可以是一个类的集合，实现子系统的功能。每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求，子系统并不知道外观类的存在，对于子系统而已，外观角色仅仅是另一个客户端</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义子系统：首先定义子系统，实现一个单一的功能，处理由客户端传来的请求</li>
<li>定义外观角色：外观角色可以知道一个或多个子系统的功能和责任，将来自客户端的请求委派到对应的子系统去，外观角色对于子系统而言是另一个客户端</li>
</ul>
<h2 id="22-外观角色">2.2 外观角色</h2>
<p>通常实现如下：</p>
<pre><code class="language-java">class Facade
{
    private SubSystemA subSystemA = new SubSystemA();
    private SubSystemB subSystemB = new SubSystemB();
    private SubSystemC subSystemC = new SubSystemC();

    public void method()
    {
        subSystemA.method();
        subSystemB.method();
        subSystemC.method();
    }
}

class SubSystemA
{
    public void method()
    {
        System.out.println(&quot;子系统A&quot;);
    }
}

class SubSystemB
{
    public void method()
    {
        System.out.println(&quot;子系统B&quot;);
    }
}

class SubSystemC
{
    public void method()
    {
        System.out.println(&quot;子系统C&quot;);
    }
}
</code></pre>
<h2 id="23-客户端">2.3 客户端</h2>
<p>使用外观模式的原因就是简化客户端的调用，在这里只需定义外观对象并调用业务方法即可：</p>
<pre><code class="language-java">Facade facade = new Facade();
facade.method();
</code></pre>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个文件加密系统，加密流程包括三部分：读取文件，加密文件，保存文件。这三个操作相对独立，并且封装在三个不同的类中，使用外观模式设计该系统。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>子系统类：<code>FileReader</code>+<code>Encrypt</code>+<code>FileWriter</code></li>
<li>外观角色类：<code>Facade</code></li>
<li><code>FileReader</code>：文件读取类</li>
<li><code>Encrypt</code>：文件加密类</li>
<li><code>FileWriter</code>：文件保存类</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.fileEncrypt(&quot;111&quot;);
    }
}

class FileReader
{
    public void read(String name)
    {
        System.out.println(&quot;读取文件&quot;+name);
    }
}

class Encrypt
{
    public void encrypt(String name)
    {
        System.out.println(&quot;加密文件&quot;+name);
    }
}

class FileWriter
{
    public void write(String name)
    {
        System.out.println(&quot;保存文件&quot;+name);
    }
}

class Facade
{
    private FileReader reader = new FileReader();
    private Encrypt encrypt = new Encrypt();
    private FileWriter writer = new FileWriter();

    public void fileEncrypt(String name)
    {
        reader.read(name);
        encrypt.encrypt(name);
        writer.write(name);
    }
}
</code></pre>
<p>这里的例子比较简单，其实就是将读取，加密以及保存操作用外观角色包装起来，方便客户端调用。</p>
<h1 id="4-引入抽象外观类">4 引入抽象外观类</h1>
<h2 id="41-为什么需要引入抽象外观类">4.1 为什么需要引入抽象外观类？</h2>
<p>在标准的外观模式结构中，如果需要增加，删除或修改外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，比如上面的例子中需要更换一种加密方法，也就是换一个加密类，这样需要直接修改外观类。</p>
<p>可以通过引入抽象外观类来解决该问题，引入后，客户端可以针对抽象外观类进行编程，对于新的业务需求不需要修改原有的外<br>
观类，只需要新增一个对应的具体外观类即可。</p>
<h2 id="42-如何引入">4.2 如何引入？</h2>
<p>首先定义抽象外观类，接着具体外观类继承或者实线抽象外观类即可。客户端针对抽象外观类进行编程，在运行时再确定具体的外观类，比如在上面例子的基础上修改加密方法，首先定义抽象外观类（这里是接口，只有一个加密方法）：</p>
<pre><code class="language-java">interface AbstractFacade
{
    void encrypt(String name);
}
</code></pre>
<p>接着定义具体外观类：</p>
<pre><code class="language-java">class Facade1 implements AbstractFacade
{
    private FileReader reader = new FileReader();
    private Encrypt1 encrypt1 = new Encrypt1();
    private FileWriter writer = new FileWriter();

    @Override
    public void encrypt(String name)
    {
        reader.read(name);
        encrypt1.encrypt(name);
        writer.write(name);
    }
}

class Facade2 implements AbstractFacade
{
    private FileReader reader = new FileReader();
    private Encrypt2 encrypt2 = new Encrypt2();
    private FileWriter writer = new FileWriter();

    @Override
    public void encrypt(String name)
    {
        reader.read(name);
        encrypt2.encrypt(name);
        writer.write(name);
    }
}
</code></pre>
<p>这两个类除了加密方法不一样其他都一样，测试：</p>
<pre><code class="language-java">AbstractFacade facade = new Facade1();
facade.encrypt(&quot;111&quot;);
facade = new Facade2();
facade.encrypt(&quot;222&quot;);
</code></pre>
<p>引入抽象外观类后，客户端针对抽象外观类进行编程，运行时确定具体外观类，输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200726230649714.png" alt="" loading="lazy"></p>
<h1 id="5-注意事项">5 注意事项</h1>
<ul>
<li><strong>外观单例</strong>：很多情况下为了节约系统资源，系统只需要一个外观类的实例，也就是外观类可以是一个单例类，这样可以降低系统资源的消耗</li>
<li><strong>多个外观类</strong>：在一个系统中可以设计多个外观类，每个外观类负责和一些特定子对象交互，向客户端提供相应业务功能</li>
<li><strong>不要通过外观类增加新行为</strong>：外观模式的意图是为子系统提供一个集中简化的沟通渠道，而不是向子系统中增加新行为，新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现而不是通过外观类实现</li>
</ul>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>简化处理：对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易，引入外观模式后客户端代码将简化</li>
<li>松耦合：实现了子系统于客户端之间松耦合关系，使得子系统的变化不会影响到客户端，只需修改外观类</li>
<li>子系统修改灵活：一个子系统的修改对其他子系统没有影响，而且子系统内部变化也不会影响外观对象</li>
<li>唯一入口：只提供了一个访问子系统的唯一入口，但不会影响客户端直接使用子系统类</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>不能限制客户端使用子系统：外观模式不能很好地限制客户端直接使用子系统，如果客户端对访问子系统做太多的限制就会减少可变性与灵活性</li>
<li>可能需要修改外观类：如果设计不当，增加新的子系统可能需要外观类，违背OCP</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>当要为访问一系列复杂的子系统提供一个简单的入口时</li>
<li>客户端与多个子系统存在很大依赖性</li>
<li>层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200726233051374.png" alt="" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（十二）：装饰模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-shi-er-zhuang-shi-mo-shi/">
        </link>
        <updated>2020-07-27T06:00:22.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a>
<ul>
<li><a href="#11-%E5%BC%95%E8%A8%80">1.1 引言</a></li>
<li><a href="#12-%E5%AE%9A%E4%B9%89">1.2 定义</a></li>
<li><a href="#13-%E7%BB%93%E6%9E%84%E5%9B%BE">1.3 结构图</a></li>
<li><a href="#14-%E8%A7%92%E8%89%B2">1.4 角色</a></li>
</ul>
</li>
<li><a href="#2-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0">2 典型实现</a>
<ul>
<li><a href="#21-%E6%AD%A5%E9%AA%A4">2.1 步骤</a></li>
<li><a href="#22-%E6%8A%BD%E8%B1%A1%E6%9E%84%E4%BB%B6%E7%B1%BB">2.2 抽象构件类</a></li>
<li><a href="#23-%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6%E7%B1%BB">2.3 具体构件类</a></li>
<li><a href="#24-%E6%8A%BD%E8%B1%A1%E8%A3%85%E9%A5%B0%E7%B1%BB">2.4 抽象装饰类</a></li>
<li><a href="#25-%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E7%B1%BB">2.5 具体装饰类</a></li>
<li><a href="#26-%E5%AE%A2%E6%88%B7%E7%AB%AF">2.6 客户端</a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E4%B8%8E%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0">4 透明装饰与半透明装饰</a>
<ul>
<li><a href="#41-%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">4.1 透明装饰模式</a></li>
<li><a href="#42-%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">4.2 半透明装饰模式</a></li>
</ul>
</li>
<li><a href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5 注意事项</a></li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<h2 id="11-引言">1.1 引言</h2>
<p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。比如，一张照片，不改变照片本身，增加一个相框。</p>
<p>装饰模式是一种用于替代继承的技术，无须定义子类即可给对象动态增加职责，使用对象之间的关联关系来代替继承关系，在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类方法，还可以增加新的方法，以扩充原有的类功能。</p>
<h2 id="12-定义">1.2 定义</h2>
<p><strong>装饰模式：动态地给对象增加一些额外的职责。</strong></p>
<p>就增加对象功能来说，装饰模式比生成子类实现更为灵活，装饰模式是一种对象结构型模式。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200726111630913.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<ul>
<li><strong>Component（抽象构件类）：是具体构件以及抽象装饰类的父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰之后的对象，以实现客户端的透明操作</strong></li>
<li><strong>ConcreteComponent（具体构件类）：是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</strong></li>
<li><strong>Decorator（抽象装饰类）：用于给具体构件类增加职责，但是具体职责在子类实现。抽象装饰类维护一个指向抽象构件的引用，通过该引用可以调用装饰之前构件对象的方法，并通过子类扩展该方法以达到装饰的目的</strong></li>
<li><strong>ConcreteDecorator（具体装饰类）：负责向构件中添加新的职责，每一个具体装饰类都定义了一些新的行为，可以调用抽象装饰类中定义的方法，并可以增加新的职责用以扩充对象的行为</strong></li>
</ul>
<h1 id="2-典型实现">2 典型实现</h1>
<h2 id="21-步骤">2.1 步骤</h2>
<ul>
<li>定义抽象构件类：可以是抽象类或者接口，声明业务方法</li>
<li>定义具体构件类：继承或实现抽象构件，实现具体业务方法</li>
<li>定义抽象装饰类：继承或实现抽象构件，增加一个抽象构件私有成员，通过该成员可以调用装饰之前具体构件的方法</li>
<li>定义具体装饰类：继承抽象装饰类，并且增加装饰行为，在装饰之前调用具体构件方法，接着调用装饰方法</li>
</ul>
<h2 id="22-抽象构件类">2.2 抽象构件类</h2>
<p>简化只有一个业务方法：</p>
<pre><code class="language-java">abstract class Component
{
    abstract void operation();
}
</code></pre>
<h2 id="23-具体构件类">2.3 具体构件类</h2>
<p>继承抽象构件：</p>
<pre><code class="language-java">class ConcreteComponent extends Component
{
    public void operation()
    {
        System.out.println(&quot;具体构件方法&quot;);
    }
}
</code></pre>
<h2 id="24-抽象装饰类">2.4 抽象装饰类</h2>
<pre><code class="language-java">class Decorator extends Component
{
    private Component component;

    public Decorator(Component component)
    {
        this.component = component;
    }

    public void operation()
    {
        component.operation();
    }
}
</code></pre>
<p>抽象装饰类需要包含一个抽象构件的私有成员，以便可以通过setter或构造方法注入不同的具体构件，同时在业务方法中方便调用具体构件未装饰之前的方法。</p>
<h2 id="25-具体装饰类">2.5 具体装饰类</h2>
<pre><code class="language-java">class ConcreteDecorator extends Decorator
{
    public ConcreteDecorator(Component component)
    {
        super(component);
    }

    public void operation()
    {
        super.operation();
        newBehavior();
    }

    public void newBehavior()
    {
        System.out.println(&quot;装饰方法&quot;);
    }
}
</code></pre>
<p>继承抽象装饰类，在业务方法中首先调用父类（抽象装饰类）的方法再调用新的装饰方法。</p>
<h2 id="26-客户端">2.6 客户端</h2>
<pre><code class="language-java">public static void main(String[] args) 
{
    Component component = new ConcreteComponent();
    Component decorator = new ConcreteDecorator(component);
    decorator.operation();
}
</code></pre>
<p>客户端针对抽象构件编程即可，无需指定具体装饰类或者具体构件类的类型，使用装饰器时，通过构造方法注入具体构件，直接调用业务方法即可。</p>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>设计一个图形界面构件库，具体构件有窗体，文本框以及列表框，装饰方法包括添加滚动条与添加黑边框，使用装饰模式对系统进行设计。</p>
</blockquote>
<p>设计如下：</p>
<ul>
<li>抽象构件类：<code>Component</code></li>
<li>具体构件类：<code>Window</code>+<code>TextBox</code>+<code>ListBox</code></li>
<li>抽象装饰类：<code>Decorator</code></li>
<li>具体装饰类：<code>ScrollBarDecorator</code>+<code>BlackBorderDecorator</code></li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Component component = new Window();
        Component decorator = new ScrollBarDecorator(component);
        decorator.display();
    }
}

abstract class Component
{
    abstract void display();
}

class Window extends Component
{
    public void display()
    {
        System.out.println(&quot;显示窗口&quot;);
    }
}

class TextBox extends Component
{
    public void display()
    {
        System.out.println(&quot;显示文本框&quot;);
    }
}

class ListBox extends Component
{
    public void display()
    {
        System.out.println(&quot;显示列表框&quot;);
    }
}

class Decorator extends Component
{
    private Component component;

    public Decorator(Component component)
    {
        this.component = component;
    }

    public void display()
    {
        component.display();
    }
}

class ScrollBarDecorator extends Decorator
{
    public ScrollBarDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        addScrollBar();
        super.display();
    }

    public void addScrollBar()
    {
        System.out.println(&quot;添加滚动条&quot;);
    }
}

class BlackBorderDecorator extends Decorator
{
    public BlackBorderDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        addBlackBorder();
        super.display();
    }

    public void addBlackBorder()
    {
        System.out.println(&quot;添加黑边框&quot;);
    }
}
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200726114715991.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>核心部分就是客户端的代码：</p>
<pre><code class="language-java">Component component = new Window();
Component decorator = new ScrollBarDecorator(component);
decorator.display();
</code></pre>
<p>创建具体构件后，再创建具体装饰器，把具体构件传入具体装饰器的构造方法中，这样具体装饰器就能在装饰之后（在添加滚动条之后）调用具体构件的方法（调用显示窗口）。</p>
<p>另外，如果向增加新的装饰方法，比如增加了滚动条后，再增加黑边框，只需要将”滚动条装饰器“本身再装饰一次：</p>
<pre><code class="language-java">Component component = new Window();
Component decorator = new ScrollBarDecorator(component);
decorator = new BlackBorderDecorator(decorator);
decorator.display();
</code></pre>
<p><strong>也就是把已经对具体构件进行装饰之后的具体装饰器，注入到另一个具体装饰器的构造方法再一次装饰。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200726115214121.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-透明装饰与半透明装饰">4 透明装饰与半透明装饰</h1>
<h2 id="41-透明装饰模式">4.1 透明装饰模式</h2>
<p>标准的装饰模式就是透明装饰，比如上述例子。在透明装饰模式中，要求客户端完全针对抽象构件编程，也就是将对象全部声明为抽象构件类型，而不是具体构件类型或具体装饰器类型。</p>
<p>透明装饰模式的优点如下：</p>
<ul>
<li>客户端透明地使用装饰前以及装饰后的对象，无须关心两者区别</li>
<li>能对已装饰过的对象进行多次装饰</li>
</ul>
<p>在实现透明装饰模式时，要求具体装饰类的业务方法覆盖抽象装饰类的业务方法，需要调用原有具体构件对象的业务方法以及新增装饰方法。</p>
<h2 id="42-半透明装饰模式">4.2 半透明装饰模式</h2>
<p>对于有时用户需要单独调用装饰方法，这时候需要使用具体装饰类型定义装饰后的对象，而具体构件对象还是可以使用抽象构件定义，这种装饰模式就叫半透明装饰模式。对于客户端来说：</p>
<ul>
<li>具体构件类型无需关心，是透明的</li>
<li>具体装饰类型必须指定，是不透明的</li>
</ul>
<p>例子如下，修改上面的滚动条具体装饰类：</p>
<pre><code class="language-java">class ScrollBarDecorator extends Decorator
{
    public ScrollBarDecorator(Component component)
    {
        super(component);
    }

    public void display()
    {
        super.display();
    }

    public void addScrollBar()
    {
        System.out.println(&quot;添加滚动条&quot;);
    }
}
</code></pre>
<p>其中<code>addScrollBar</code>由客户端单独调用：</p>
<pre><code class="language-java">Component component = new Window();
ScrollBarDecorator decorator = new ScrollBarDecorator(component);
decorator.display();
decorator.addScrollBar();
</code></pre>
<p>半透明装饰可以带来更大的灵活性，使用起来更加方便，客户端可以单独调用装饰方法来进行装饰，但是缺点就是不能对同一个对象进行多次装饰。</p>
<h1 id="5-注意事项">5 注意事项</h1>
<ul>
<li>保持接口相同：尽量保持装饰类的接口与被装饰类的接口相同，这样对客户端而言装饰前/后的对象可以一致对待，也就是尽量使用透明装饰模式</li>
<li>减少具体构件行为：过多的行为不需要放在具体构件类中，通过具体装饰类进行扩展</li>
<li>去除抽象构件：如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类，也就是说将原来的抽象构件用具体构件代替</li>
</ul>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>动态扩展灵活：对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。通过选择不同的具体装饰类，可以动态扩展对象的行为</li>
<li>多次装饰：可以对一个对象进行多次装饰，使用不同的具体装饰类以及这些装饰类的排列组合，可以创造很多不同行为的组合</li>
<li>构件与装饰类独立变化：具体构件类以及具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类或者具体装饰类，无须修改原有代码，符合开闭原则</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>对象较多：使用装饰模式会产生很多小对象，这些对象的区别在于相互连接方式的不同，小对象过多会一定程度上影响性能</li>
<li>排查繁琐：尽管装饰模式比继承更加灵活，但也意味着比继承更加容易出错，排错也很困难，对于多次装饰后的对象可能需要逐级排查</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>在不影响其他对象的情况下，以动态和透明的方式给单个对象增加职责</li>
<li>在不能采用继承扩展系统或者采用继承不利于对系统扩展和维护时可以使用装饰模式</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200729132833584.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200711111358683.gif" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>