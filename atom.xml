<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-05-08T11:18:59.193Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[解决AUR无法正常升级WebStorm2021.1.1的问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-aur-wu-fa-zheng-chang-sheng-ji-webstorm202111-de-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-aur-wu-fa-zheng-chang-sheng-ji-webstorm202111-de-wen-ti/">
        </link>
        <updated>2021-05-08T07:19:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境<code>Manjaro</code>+<code>paru</code>，升级<code>WebStorm</code>的时候，错误提示如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210508150547587.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="2-原因">2 原因</h1>
<p>这个问题在<code>Arch</code>的<code>AUR</code>官网上<a href="https://aur.archlinux.org/packages/webstorm/">有讨论</a>：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210508150825742.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>就是<code>PKGBUILD</code>的文件中的版本号出错了，把版本号修改回来就可以了。</p>
<h1 id="3-解决方案">3 解决方案</h1>
<p>上面说了解决方案就是找到<code>WebStorm</code>的<code>PKGBUILD</code>版本并进行修改，<code>PKGBUILD</code>根据包管理工具的不同位于不同的缓存文件夹下，这里列举两个常见的<code>AUR</code>助手的缓存位置：</p>
<ul>
<li><code>yay</code>：<code>~/.cache/yay</code></li>
<li><code>paru</code>：<code>~/.cache/paru</code></li>
</ul>
<p>笔者使用的是<code>paru</code>，进入<code>~/.cache/paru/webstorm</code>，修改<code>PKGBUILD</code>，把版本从错误提示信息的<code>211.7142.468</code>改为<code>211.7142.46</code>：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2021050815155561.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210508151737504.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>修改完后重新安装：</p>
<pre><code class="language-bash">paru -S webstorm
</code></pre>
<p>这样就成功了：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210508151821713.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java高并发学习笔记（一）：Thread详解]]></title>
        <id>https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-yi-thread-xiang-jie/</id>
        <link href="https://2293736867.github.io/post/java-gao-bing-fa-xue-xi-bi-ji-yi-thread-xiang-jie/">
        </link>
        <updated>2021-05-08T02:45:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java高并发编程详解 多线程与架构设计》，汪文君著</li>
<li>章节：第一、二、三章</li>
</ul>
<p>本文是前三章的笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要讲述了线程的生命周期、<code>Thread</code>类的构造方法以及常用<code>API</code>，最后介绍了线程的关闭方法。</p>
<h1 id="3-线程生命周期">3 线程生命周期</h1>
<h2 id="31-五个阶段">3.1 五个阶段</h2>
<p>线程生命周期可以分为五个阶段：</p>
<ul>
<li><code>NEW</code></li>
<li><code>RUNNABLE</code></li>
<li><code>RUNNING</code></li>
<li><code>BLOCKED</code></li>
<li><code>TERMINATED</code></li>
</ul>
<h2 id="32-new">3.2 <code>NEW</code></h2>
<p>用<code>new</code>创建一个<code>Thread</code>对象时，但是并没有使用<code>start()</code>启动线程，此时线程处于<code>NEW</code>状态。准确地说，只是<code>Thread</code>对象的状态，这就是一个普通的<code>Java</code>对象。此时可以通过<code>start()</code>方法进入<code>RUNNABLE</code>状态。</p>
<h2 id="33-runnable">3.3 <code>RUNNABLE</code></h2>
<p>进入<code>RUNNABLE</code>状态必须调用<code>start()</code>方法，这样就在<code>JVM</code>中创建了一个线程。但是，线程一经创建，并不能马上被执行，线程执行与否需要听令于<code>CPU</code>调度，也就是说，此时是处于可执行状态，具备执行的资格，但是并没有真正执行起来，而是在等待被调度。</p>
<p><code>RUNNABLE</code>状态只能意外终止或进入<code>RUNNING</code>状态。</p>
<h2 id="34-running">3.4 <code>RUNNING</code></h2>
<p>一旦<code>CPU</code>通过轮询或其他方式从任务可执行队列中选中了线程，此时线程才能被执行，也就是处于<code>RUNNING</code>状态，在该状态中，可能发生的状态转换如下：</p>
<ul>
<li>进入<code>TERMINATED</code>：比如调用已经不推荐的<code>stop()</code>方法</li>
<li>进入<code>BLOCKED</code>：比如调用了<code>sleep()</code>/<code>wait()</code>方法，或者进行某个阻塞操作（获取锁资源、磁盘<code>IO</code>等）</li>
<li>进入<code>RUNNABLE</code>：<code>CPU</code>时间片到，或者线程主动调用<code>yield()</code></li>
</ul>
<h2 id="35-blocked">3.5 <code>BLOCKED</code></h2>
<p>也就是阻塞状态，进入阻塞状态的原因很多，常见的如下：</p>
<ul>
<li>磁盘<code>IO</code></li>
<li>网络操作</li>
<li>为了获取锁而进入阻塞操作</li>
</ul>
<p>处于<code>BLOCKED</code>状态时，可能发生的状态转换如下：</p>
<ul>
<li>进入<code>TERMINATED</code>：比如调用不推荐的<code>stop()</code>，或者<code>JVM</code>意外死亡</li>
<li>进入<code>RUNNABLE</code>：比如休眠结束、被<code>notify()</code>/<code>nofityAll()</code>唤醒、获取到某个锁、阻塞过程被<code>interrupt()</code>打断等</li>
</ul>
<h2 id="36-terminated">3.6 <code>TERMINATED</code></h2>
<p><code>TERMINATED</code>是线程的最终状态，进入该状态后，意味着线程的生命周期结束，比如在下列情况下会进入该状态：</p>
<ul>
<li>线程运行正常结束</li>
<li>线程运行出错意外结束</li>
<li><code>JVM</code>意外崩溃，导致所有线程都强制结束</li>
</ul>
<h1 id="4-thread构造方法">4 <code>Thread</code>构造方法</h1>
<h2 id="41-构造方法">4.1 构造方法</h2>
<p><code>Thread</code>的构造方法一共有八个，这里根据命名方式分类，使用默认命名的构造方法如下：</p>
<ul>
<li><code>Thread()</code></li>
<li><code>Thread(Runnable target)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target)</code></li>
</ul>
<p>命名线程的构造方法如下：</p>
<ul>
<li><code>Thread(String name)</code></li>
<li><code>Thread(Runnable target,Strintg name)</code></li>
<li><code>Thread(ThreadGroup group,String name)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target,String name)</code></li>
<li><code>Thread(ThreadGroup group,Runnable target,String name,long stackSize)</code></li>
</ul>
<p>但实际上所有的构造方法最终都是调用如下私有构造方法：</p>
<pre><code class="language-java">private Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals);
</code></pre>
<p>在默认命名构造方法中，在源码中可以看到，默认命名其实就是<code>Thread-X</code>的命令（X为数字）：</p>
<pre><code class="language-java">public Thread() {
    this((ThreadGroup)null, (Runnable)null, &quot;Thread-&quot; + nextThreadNum(), 0L);
}

public Thread(Runnable target) {
    this((ThreadGroup)null, target, &quot;Thread-&quot; + nextThreadNum(), 0L);
}

private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
</code></pre>
<p>而在命名构造方法就是自定义的名字。</p>
<p>另外，如果想修改线程的名字，可以调用<code>setName()</code>方法，但是需要注意，处于<code>NEW</code>状态的线程才能修改。</p>
<h2 id="42-线程的父子关系">4.2 线程的父子关系</h2>
<p><code>Thread</code>的所有构造方法都会调用如下方法：</p>
<pre><code class="language-java">private Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals);
</code></pre>
<p>其中的一段源码截取如下：</p>
<pre><code class="language-java">if (name == null) {
    throw new NullPointerException(&quot;name cannot be null&quot;);
} else {
    this.name = name;
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        if (security != null) {
            g = security.getThreadGroup();
        }

        if (g == null) {
            g = parent.getThreadGroup();
        }
    }
}
</code></pre>
<p>可以看到当前这里有一个局部变量叫<code>parent</code>，并且赋值为<code>currentThread()</code>，<code>currentThread()</code>是一个<code>native</code>方法。因为一个线程被创建时的最初状态为<code>NEW</code>，因此<code>currentThread()</code>代表是创建自身线程的那个线程，也就是说，结论如下：</p>
<ul>
<li>一个线程的创建肯定是由另一个线程完成的</li>
<li>被创建线程的父线程是创建它的线程</li>
</ul>
<p>也就是自己创建的线程，父线程为<code>main</code>线程，而<code>main</code>线程由<code>JVM</code>创建。</p>
<p>另外，<code>Thread</code>的构造方法中有几个具有<code>ThreadGroup</code>参数，该参数指定了线程位于哪一个<code>ThreadGroup</code>，如果一个线程创建的时候没有指定<code>ThreadGroup</code>，那么将会和父线程同一个<code>ThreadGroup</code>。<code>main</code>线程所在的<code>ThreadGroup</code>称为<code>main</code>。</p>
<h2 id="43-关于stacksize">4.3 关于<code>stackSize</code></h2>
<p><code>Thread</code>构造方法中有一个<code>stackSize</code>参数，该参数指定了<code>JVM</code>分配线程栈的地址空间的字节数，对平台依赖性较高，在一些平台上：</p>
<ul>
<li>设置较大的值：可以使得线程内调用递归深度增加，降低<code>StackOverflowError</code>出现的概率</li>
<li>设置较低的值：可以使得创建的线程数增多，可以推迟<code>OutOfMemoryError</code>出现的时间</li>
</ul>
<p>但是，在一些平台上该参数不会起任何作用。另外，如果设置为0也不会起到任何作用。</p>
<h1 id="5-thread-api">5 <code>Thread API</code></h1>
<h2 id="51-sleep">5.1 <code>sleep()</code></h2>
<p><code>sleep()</code>有两个重载方法：</p>
<ul>
<li><code>sleep(long mills)</code></li>
<li><code>sleep(long mills,int nanos)</code></li>
</ul>
<p>但是在<code>JDK1.5</code>后，引入了<code>TimeUnit</code>，其中对<code>sleep()</code>方法提供了很好的封装，建议使用<code>TimeUnit.XXXX.sleep()</code>去代替<code>Thread.sleep()</code>：</p>
<pre><code class="language-java">TimeUnit.SECONDS.sleep(1);
TimeUnit.MINUTES.sleep(3);
</code></pre>
<h2 id="52-yield">5.2 <code>yield()</code></h2>
<p><code>yield()</code>属于一种启发式方法，提醒<code>CPU</code>调度器当前线程会自愿放弃资源，如果<code>CPU</code>资源不紧张，会忽略这种提醒。调用<code>yield()</code>方法会使当前线程从<code>RUNNING</code>变为<code>RUNNABLE</code>状态。</p>
<p>关于<code>yield()</code>与<code>sleep()</code>的区别，区别如下：</p>
<ul>
<li><code>sleep()</code>会导致当前线程暂停指定的时间，没有<code>CPU</code>时间片的消耗</li>
<li><code>yield()</code>只是对<code>CPU</code>调度器的一个提示，如果<code>CPU</code>调度器没有忽略这个提示，会导致线程上下文的切换</li>
<li><code>sleep()</code>会使线程短暂阻塞，在给定时间内释放<code>CPU</code>资源</li>
<li>如果<code>yield()</code>生效，<code>yield()</code>会使得从<code>RUNNING</code>状态进入<code>RUNNABLE</code>状态</li>
<li><code>sleep()</code>会几乎百分百地完成给定时间的休眠，但是<code>yield()</code>的提示不一定能担保</li>
<li>一个线程调用<code>sleep()</code>而另一个线程调用<code>interrupt()</code>会捕获到中断信号，而<code>yield</code>则不会</li>
</ul>
<h2 id="53-setpriority">5.3 <code>setPriority()</code></h2>
<h3 id="531-优先级介绍">5.3.1 优先级介绍</h3>
<p>线程与进程类似，也有自己的优先级，理论上来说，优先级越高的线程会有优先被调度的机会，但实际上并不是如此，设置优先级与<code>yield()</code>类似，也是一个提醒性质的操作：</p>
<ul>
<li>对于<code>root</code>用户，会提醒操作系统想要设置的优先级别，否则会被忽略</li>
<li>如果<code>CPU</code>比较忙，设置优先级可能会获得更多的<code>CPU</code>时间片，但是空闲时优先级的高低几乎不会有任何作用</li>
</ul>
<p>所以，设置优先级只是很大程度上让某个线程尽可能获得比较多的执行机会，也就是让线程自己尽可能被操作系统调度，而不是设置了高优先级就一定优先运行，或者说优先级高的线程比优先级低的线程就一定优先运行。</p>
<h3 id="532-优先级源码分析">5.3.2 优先级源码分析</h3>
<p>设置优先级直接调用<code>setPriority()</code>即可，<code>OpenJDK 11</code>源码如下：</p>
<pre><code class="language-java">public final void setPriority(int newPriority) {
    this.checkAccess();
    if (newPriority &lt;= 10 &amp;&amp; newPriority &gt;= 1) {
        ThreadGroup g;
        if ((g = this.getThreadGroup()) != null) {
            if (newPriority &gt; g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }

            this.setPriority0(this.priority = newPriority);
        }

    } else {
        throw new IllegalArgumentException();
    }
}
</code></pre>
<p>可以看到优先级处于<code>[1,10]</code>之间，而且不能设置为大于当前<code>ThreadGroup</code>的优先级，最后通过<code>native</code>方法<code>setPriority0</code>设置优先级。</p>
<p>一般情况下，不会对线程的优先级设置级别，默认情况下，线程的优先级为5，因为<code>main</code>线程的优先级为5，而且<code>main</code>为所有线程的父进程，因此默认情况下线程的优先级也是5。</p>
<h2 id="54-interrupt">5.4 <code>interrupt()</code></h2>
<p><code>interrupt()</code>是一个重要的<code>API</code>，线程中断的<code>API</code>有如下三个：</p>
<ul>
<li><code>void interrupt()</code></li>
<li><code>boolean isInterrupted()</code></li>
<li><code>static boolean interrupted()</code></li>
</ul>
<p>下面对其逐一进行分析。</p>
<h3 id="541-interrupt">5.4.1 <code>interrupt()</code></h3>
<p>一些方法调用会使得当前线程进入阻塞状态，比如：</p>
<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.sleep()</code></li>
<li><code>Thread.join()</code></li>
<li><code>Selector.wakeup()</code></li>
</ul>
<p>而调用<code>interrupt()</code>可以打断阻塞，打断阻塞并不等于线程的生命周期结束，仅仅是打断了当前线程的阻塞状态。一旦在阻塞状态下被打断，就会抛出一个<code>InterruptedException</code>的异常，这个异常就像一个信号一样通知当前线程被打断了，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException{
    Thread thread = new Thread(()-&gt;{
        try{
            TimeUnit.SECONDS.sleep(10);
        }catch (InterruptedException e){
            System.out.println(&quot;Thread is interrupted.&quot;);
        }
    });
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    thread.interrupt();
}
</code></pre>
<p>会输出线程被中断的信息。</p>
<h3 id="542-isinterrupted">5.4.2 <code>isInterrupted()</code></h3>
<p><code>isInterrupted()</code>可以判断当前线程是否被中断，仅仅是对<code>interrupt()</code>标识的一个判断，并不会影响标识发生任何改变（因为调用<code>interrupt()</code>的时候会设置内部的一个叫<code>interrupt flag</code>的标识），例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException{
    Thread thread = new Thread(()-&gt;{
        while (true){}
    });
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot;+thread.isInterrupted());
    thread.interrupt();
    System.out.println(&quot;Thread is interrupted :&quot;+thread.isInterrupted());
}
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-bash">Thread is interrupted :false
Thread is interrupted :true
</code></pre>
<p>另一个例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread() {
        @Override
        public void run() {
            while (true) {
                try {
                    TimeUnit.SECONDS.sleep(3);
                } catch (InterruptedException e) {
                    System.out.println(&quot;In catch block thread is interrupted :&quot; + isInterrupted());
                }
            }
        }
    };
    thread.start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot; + thread.isInterrupted());
    thread.interrupt();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;Thread is interrupted :&quot; + thread.isInterrupted());
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-bash">Thread is interrupted :false
In catch block thread is interrupted :false
Thread is interrupted :false
</code></pre>
<p>一开始线程未被中断，结果为<code>false</code>，调用中断方法后，在循环体内捕获到了异常（信号），此时会<code>Thread</code>自身会擦除<code>interrupt</code>标识，将标识复位，因此捕获到异常后输出结果也为<code>false</code>。</p>
<h3 id="543-interrupted">5.4.3 <code>interrupted()</code></h3>
<p>这是一个静态方法，调用该方法会擦除掉线程的<code>interrupt</code>标识，需要注意的是如果当前线程被打断了：</p>
<ul>
<li>第一次调用<code>interrupted()</code>会返回<code>true</code>，并且立即擦除掉<code>interrupt</code>标识</li>
<li>第二次包括以后的调用永远都会返回<code>false</code>，除非在此期间线程又一次被打断</li>
</ul>
<p>例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread() {
        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.interrupted());
            }
        }
    };
    thread.setDaemon(true);
    thread.start();
    TimeUnit.MILLISECONDS.sleep(2);
    thread.interrupt();
}
</code></pre>
<p>输出（截取一部分）：</p>
<pre><code class="language-bash">false
false
false
true
false
false
false
</code></pre>
<p>可以看到其中带有一个<code>true</code>，也就是<code>interrupted()</code>判断到了其被中断，此时会立即擦除中断标识，并且只有该次返回<code>true</code>，后面都是<code>false</code>。</p>
<p>关于<code>interrupted()</code>与<code>isInterrupted()</code>的区别，可以从源码（<code>OpenJDK 11</code>）知道：</p>
<pre><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}

public boolean isInterrupted() {
    return this.isInterrupted(false);
}

@HotSpotIntrinsicCandidate
private native boolean isInterrupted(boolean var1);
</code></pre>
<p>实际上两者都是调用同一个<code>native</code>方法，其中的布尔变量表示是否擦除线程的<code>interrupt</code>标识：</p>
<ul>
<li><code>true</code>表示想要擦除，<code>interrupted()</code>就是这样做的</li>
<li><code>false</code>表示不想擦除，<code>isInterrupted()</code>就是这样做的</li>
</ul>
<h2 id="55-join">5.5 <code>join()</code></h2>
<h3 id="551-join简介">5.5.1 <code>join()</code>简介</h3>
<p><code>join()</code>与<code>sleep()</code>一样，都是属于可以中断的方法，如果其他线程执行了对当前线程的<code>interrupt</code>操作，也会捕获到中断信号，并且擦除线程的<code>interrupt</code>标识，<code>join()</code>提供了三个<code>API</code>，分别如下：</p>
<ul>
<li><code>void join()</code></li>
<li><code>void join(long millis,int nanos)</code></li>
<li><code>void join(long mills)</code></li>
</ul>
<h3 id="552-例子">5.5.2 例子</h3>
<p>一个简单的例子如下：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        List&lt;Thread&gt; threads = IntStream.range(1,3).mapToObj(Main::create).collect(Collectors.toList());
        threads.forEach(Thread::start);
        for (Thread thread:threads){
            thread.join();
        }
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot; # &quot;+i);
            shortSleep();
        }
    }

    private static Thread create(int seq){
        return new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(Thread.currentThread().getName()+&quot; # &quot;+i);
                shortSleep();
            }
        },String.valueOf(seq));
    }

    private static void shortSleep(){
        try{
            TimeUnit.MILLISECONDS.sleep(2);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>输出截取如下：</p>
<pre><code class="language-cpp">2 # 8
1 # 8
2 # 9
1 # 9
main # 0
main # 1
main # 2
main # 3
main # 4
</code></pre>
<p>线程1和线程2交替执行，而<code>main</code>线程会等到线程1和线程2执行完毕后再执行。</p>
<h1 id="6-线程关闭">6 线程关闭</h1>
<p><code>Thread</code>中有一个过时的方法<code>stop</code>，可以用于关闭线程，但是存在的问题是有可能不会释放<code>monitor</code>的锁，因此不建议使用该方法关闭线程。线程的关闭可以分为三类：</p>
<ul>
<li>正常关闭</li>
<li>异常退出</li>
<li>假死</li>
</ul>
<h2 id="61-正常关闭">6.1 正常关闭</h2>
<h3 id="611-正常结束">6.1.1 正常结束</h3>
<p>线程运行结束后，就会正常退出，这是最普通的一种情况。</p>
<h3 id="612-捕获信号关闭线程">6.1.2 捕获信号关闭线程</h3>
<p>通过捕获中断信号去关闭线程，例子如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while(!isInterrupted()){

            }
            System.out.println(&quot;exit...&quot;);
        }
    };
    t.start();
    TimeUnit.SECONDS.sleep(5);
    System.out.println(&quot;System will be shutdown.&quot;);
    t.interrupt();
}
</code></pre>
<p>一直检查<code>interrupt</code>标识是否设置为<code>true</code>，设置为<code>true</code>则跳出循环。另一种方式是使用<code>sleep()</code>：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while(true){
                try{
                    TimeUnit.MILLISECONDS.sleep(1);
                }catch (InterruptedException e){
                    break;
                }
            }
            System.out.println(&quot;exit...&quot;);
        }
    };
    t.start();
    TimeUnit.SECONDS.sleep(5);
    System.out.println(&quot;System will be shutdown.&quot;);
    t.interrupt();
}
</code></pre>
<h3 id="613-volatile">6.1.3 <code>volatile</code></h3>
<p>由于<code>interrupt</code>标识很有可能被擦除，或者不会调用<code>interrupt()</code>方法，因此另一种方法是使用<code>volatile</code>修饰一个布尔变量，并不断循环判断：</p>
<pre><code class="language-java">public class Main {
    static class MyTask extends Thread{
        private volatile boolean closed = false;

        @Override
        public void run() {
            System.out.println(&quot;work...&quot;);
            while (!closed &amp;&amp; !isInterrupted()){

            }
            System.out.println(&quot;exit...&quot;);
        }

        public void close(){
            this.closed = true;
            this.interrupt();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyTask t = new MyTask();
        t.start();
        TimeUnit.SECONDS.sleep(5);
        System.out.println(&quot;System will be shutdown.&quot;);
        t.close();
    }
}
</code></pre>
<h2 id="62-异常退出">6.2 异常退出</h2>
<p>线程执行单元中是不允许抛出<code>checked</code>异常的，如果在线程运行过程中需要捕获<code>checked</code>异常并且判断是否还有运行下去的必要，可以将<code>checked</code>异常封装为<code>unchecked</code>异常，比如<code>RuntimeException</code>，抛出从而结束线程的生命周期。</p>
<h2 id="63-假死">6.3 假死</h2>
<p>所谓假死就是虽然线程存在，但是却没有任何的外在表现，比如：</p>
<ul>
<li>没有日志输出</li>
<li>不进行任何的作业</li>
</ul>
<p>等等，虽然此时线程是存在的，但看起来跟死了一样，事实上是没有死的，出现这种情况，很大可能是因为线程出现了阻塞，或者两个线程争夺资源出现了死锁。</p>
<p>这种情况需要借助一些外部工具去判断，比如<code>VisualVM</code>、<code>jconsole</code>等等，找出存在问题的线程以及当前的状态，并判断是哪个方法造成了阻塞。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第328期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-328-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-328-qi/">
        </link>
        <updated>2021-05-07T17:13:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>人不能低下高贵的头，但捡钱时例外。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>五更鼓角声悲壮，三峡星河影动摇。<br>
——杜甫《阁夜》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>迎着风，拥抱彩虹！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620407692283.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>尽力了，过51个样例：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    private int[] time;
    private int k;
    private int max;

    public int minimumTimeRequired(int[] jobs, int k) {
        Arrays.sort(jobs);
        int len = jobs.length;
        time = new int[this.k = k];
        if (k &gt;= len) {
            max = jobs[0];
            for (int i = 1; i &lt; len; i++) {
                if (max &lt; jobs[i]) {
                    max = jobs[i];
                }
            }
            return max;
        }
        boolean repeated = false;
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; len; i++) {
            if(set.contains(jobs[i])){
                repeated = true;
                break;
            }else{
                set.add(jobs[i]);
            }
        }
        if(k == 2 &amp;&amp; ((len &amp; 1) == 1) &amp;&amp; repeated){
            for (int i = 0; i &lt; len/2; i++) {
                time[0] += jobs[i];
            }
            for (int i = len/2+1; i &lt; len; i++) {
                time[1] += jobs[i];
            }
            if(time[0] &lt; time[1]){
                time[0] += jobs[len/2];
            }else{
                time[1] += jobs[len/2];
            }
            return Math.max(time[0],time[1]);
        }
        time[0] = jobs[len - 1];
        max = time[0];
        for (int i = len - 2; i &gt;= 0; --i) {
            int index = findMin(jobs[i]);
            time[index] += jobs[i];
            if (time[index] &gt; max) {
                max = time[index];
            }
        }
        return max;
    }

    private int findMin(int next){
        int i;
        int min = 0;
        for (i = 0; i &lt; k &amp;&amp; time[i] != 0; i++) {
            if (time[i] + next &lt;= max) {
                return i;
            }
            if(time[i] &lt; time[min]){
                min = i;
            }
        }
        for (int j = i; j &lt; k; j++) {
            if(time[j] &lt; time[min]) {
                min = j;
            }
        }
        return min;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620407710826.png" alt="" loading="lazy"></figure>
<p>看了题解才知道是状态压缩+动态规划，表示不会，这里放上一个回溯剪枝的版本：</p>
<pre><code class="language-java">public class Solution {

    private int minId = Integer.MAX_VALUE;

    public int minimumTimeRequired(int[] jobs, int k) {
        fd(jobs, new int[k], 0, 0);
        return minId;
    }

    private void fd(int[] jobs, int[] times, int m, int minTime) {
        if (m == jobs.length) {
            minId = Math.min(minTime, minId);
            return;
        }
        boolean first = true;
        for (int i=0; i&lt;times.length; i++) {
            if (times[i] == 0L &amp;&amp; !first) {
                return;
            }
            if (times[i] == 0L) {
                first = false;
            }
            times[i] += jobs[m];
            int tmpMax = Math.max(minTime, times[i]);
            if (tmpMax &lt; minId) {
                fd(jobs, times, m + 1, Math.max(minTime, times[i]));
            }
            times[i] -= jobs[m];
        }
    }
}
</code></pre>
<p>居然还有0ms的，惨无人性：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620408017415.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第327期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-327-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-327-qi/">
        </link>
        <updated>2021-05-07T01:35:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>这么多年来没掉入桃色陷阱，靠的就是两个字，没钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>沾衣欲湿杏花雨，吹面不寒杨柳风。<br>
——志南《绝句·古木阴中系短篷》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你的败因只有一个，就是与我为敌。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620351469814.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>遍历异或即可：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int xorOperation(int n, int start) {
        int end = start + 2*(n-1);
        int result = start;
        for (int i = start+2;i&lt;=end;i+=2){
            result ^= i;
        }
        return result;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620351533258.png" alt="" loading="lazy"></figure>
<p>当然也有<code>O(1)</code>时间空间的：</p>
<pre><code class="language-java">class Solution {
    public int xorOperation(int n, int start) {
        int s = start &gt;&gt; 1, e = n &amp; start &amp; 1;
        int ret = sumXor(s - 1) ^ sumXor(s + n - 1);
        return ret &lt;&lt; 1 | e;
    }

    public int sumXor(int x) {
        if (x % 4 == 0) {
            return x;
        }
        if (x % 4 == 1) {
            return 1;
        }
        if (x % 4 == 2) {
            return x + 1;
        }
        return 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第326期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-326-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-326-qi/">
        </link>
        <updated>2021-05-06T04:31:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>只要坚持不懈，嘲笑你的人，迟早被你笑死。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>长风怒卷高浪，飞洒日光寒。<br>
——元好问《水调歌头·赋三门津》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>兜里不硬气，啥都不敢买。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620275719877.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接错位异或即可得出答案：</p>
<pre><code class="language-java">public class Solution {
    public int[] decode(int[] encoded, int first) {
        int n = encoded.length;
        int [] arr = new int[n+1];
        arr[0] = first;
        for (int i = 1; i &lt;= n; i++) {
            arr[i] = arr[i-1] ^ encoded[i-1];
        }
        return arr;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620275746195.png" alt="" loading="lazy"></figure>
<h1 id="补课补课">补课补课</h1>
<p>周六要补课，但是好像那天没课？</p>
<p>好家伙。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第325期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-325-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-325-qi/">
        </link>
        <updated>2021-05-05T07:43:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>退一步海阔天空，没想到脚下落空。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>海棠糝径铺香绣，依旧成春瘦。<br>
——陈亮《虞美人·东风荡飏轻云缕》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果温柔是罪，那就只能用拳头来清洗我们犯下的罪孽。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620203196313.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一维<code>dp</code>，<code>dp</code>数组空间可以优化为<code>O(1)</code>，累计数字的出现个数后转化为“打家劫舍”问题：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        int [] sum = new int[10002];
        int max = 0;
        for (int num:nums){
            ++sum[num];
            max = Math.max(max,num);
        }
        int first = sum[1];
        int second = Math.max(first,sum[2]*2);
        int result = Math.max(first,second);
        for (int i = 3; i &lt;= max; i++) {
            int temp = Math.max(second,first+sum[i]*i);
            if(temp &gt; result){
                result = temp;
            }
            first = second;
            second = temp;
        }
        return result;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620203228100.png" alt="" loading="lazy"></figure>
<h1 id="五一续费">五一续费</h1>
<p>难得的五天假期就这样没有了。。。</p>
<p>好想为五一续费。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（八）：类加载]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-ba-lei-jia-zai/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-ba-lei-jia-zai/">
        </link>
        <updated>2021-05-04T08:38:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第十章</li>
</ul>
<p>本文是第十章的一些笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要讲述了类加载器以及类加载的详细流程。</p>
<h1 id="3-类加载流程">3 类加载流程</h1>
<p>类加载的流程可以简单分为三步：</p>
<ul>
<li>加载</li>
<li>连接</li>
<li>初始化</li>
</ul>
<p>而其中的连接又可以细分为三步：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p>下面会分别对各个流程进行介绍。</p>
<h2 id="31-类加载条件">3.1 类加载条件</h2>
<p>在了解类接在流程之前，先来看一下触发类加载的条件。</p>
<p><code>JVM</code>不会无条件加载类，只有在一个类或接口在初次使用的时候，必须进行初始化。这里的使用是指主动使用，主动使用包括如下情况：</p>
<ul>
<li>创建一个类的实例的时候：比如使用<code>new</code>创建，或者使用反射、克隆、反序列化</li>
<li>调用类的静态方法的时候：比如使用<code>invokestatic</code>指令</li>
<li>使用类或接口的静态字段：比如使用<code>getstatic</code>/<code>putstatic</code>指令</li>
<li>使用<code>java.lang.reflect</code>中的反射类方法时</li>
<li>初始化子类时，要求先初始化父类</li>
<li>含有<code>main()</code>方法的类</li>
</ul>
<p>除了以上情况外，其他情况属于被动使用，不会引起类的初始化。</p>
<p>比如下面的例子：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args){
        System.out.println(Child.v);
    }
}

class Parent{
    static{
        System.out.println(&quot;Parent init&quot;);
    }
    public static int v = 100;
}

class Child extends Parent{
    static {
        System.out.println(&quot;Child init&quot;);
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code class="language-bash">Parent init
100
</code></pre>
<p>而加上类加载参数<code>-XX:+TraceClassLoading</code>后，可以看到<code>Child</code>确实被加载了：</p>
<pre><code class="language-bash">[0.068s][info   ][class,load] com.company.Main
[0.069s][info   ][class,load] com.company.Parent
[0.069s][info   ][class,load] com.company.Child
Parent init
100
</code></pre>
<p>但是并没有进行初始化。另外一个例子是关于<code>final</code>的，代码如下：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args){
        System.out.println(Test.STR);
    }
}

class Test{
    static{
        System.out.println(&quot;Test init&quot;);
    }
    public static final String STR = &quot;Hello&quot;;
}
</code></pre>
<p>输出如下：</p>
<pre><code class="language-bash">[0.066s][info   ][class,load] com.company.Main
Hello
</code></pre>
<p><code>Test</code>类根本没有被加载，因为<code>final</code>被做了优化，编译后的<code>Main.class</code>中，并没有引用<code>Test</code>类：</p>
<pre><code class="language-bash">0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc           #4                  // String Hello
5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
</code></pre>
<p>在字节码偏移3的位置，通过<code>ldc</code>将常量池第4项入栈，此时在字节码文件中常量池第4项为：</p>
<pre><code class="language-bash">#3 = Class              #24            // com/company/Test
#4 = String             #25            // Hello
#5 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V
</code></pre>
<p>因此并没有对<code>Test</code>类进行加载，只是直接引用常量池中的常量，因此输出没有<code>Test</code>的加载日志。</p>
<h2 id="32-加载">3.2 加载</h2>
<p>类加载的时候，<code>JVM</code>必须完成以下操作：</p>
<ul>
<li>通过类的全名获取二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型</li>
</ul>
<p>第一步获取二进制数据流，途径有很多，包括：</p>
<ul>
<li>字节码文件</li>
<li><code>JAR</code>/<code>ZIP</code>压缩包</li>
<li>从网络加载</li>
</ul>
<p>等等，获取到二进制数据流后，<code>JVM</code>进行处理并转化为一个<code>java.lang.Class</code>实例。</p>
<h2 id="33-验证">3.3 验证</h2>
<p>验证的操作是确保加载的字节码是合法、合理并且规范的。步骤简略如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210504112255540.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>格式检查：判断二进制数据是否符合格式要求和规范，比如是否以魔数开头，主版本号和小版本号是否在当前<code>JVM</code>支持范围内等等</li>
<li>语义检查：比如是否所有类都有父类存在，一些被定义为<code>final</code>的方法或类是否被重载了或者继承了，是否存在不兼容方法等等</li>
<li>字节码验证：会试图通过对字节码流的分析，判断字节码是否可以正确被执行，比如是否会跳转到一条不存在的指令，函数调用是否传递了正确的参数等等，但是却无法100%判断一段字节码是否可以被安全执行，只是尽可能检查出可以预知的明显问题。如果无法通过检查，则不会加载这个类，如果通过了检查，也不能说明这个类完全没有问题</li>
<li>符号引用验证：检查类或方法是否确实存在，并且确定当前类有没有权限访问这些数据，比如无法找到一个类就抛出<code>NoClassDefFoundError</code>，无法找到方法就抛出<code>NoSuchMethodError</code></li>
</ul>
<h2 id="34-准备">3.4 准备</h2>
<p>类通过验证后，就会进入准备阶段，在这个阶段，<code>JVM</code>为会类分配相应的内存空间，并设置初始值，比如：</p>
<ul>
<li><code>int</code>初始化为<code>0</code></li>
<li><code>long</code>初始化为<code>0L</code></li>
<li><code>double</code>初始化为<code>0f</code></li>
<li>引用初始化为<code>null</code></li>
</ul>
<p>如果存在常量字段，那么这个阶段也会为常量赋值。</p>
<h2 id="35-解析">3.5 解析</h2>
<p>解析就是将类、接口、字段和方法的符号引用转为直接引用。符号引用就是一些字面量引用，和<code>JVM</code>的内存数据结构和内存布局无关，由于在字节码文件中，通过常量池进行了大量的符号引用，这个阶段就是将这些引用转为直接引用，得到类、字段、方法在内存中的指针或直接偏移量。</p>
<p>另外，由于字符串有着很重要的作用，<code>JVM</code>对<code>String</code>进行了特别的处理，直接使用字符串常量时，就会在类中出现<code>CONSTANT_String</code>，并且会引用一个<code>CONSTANT_UTF8</code>常量项。<code>JVM</code>运行时，内部的常量池中会维护一张字符串拘留表（<code>intern</code>），会保存其中出现过的所有字符串常量，并且没有重复项。使用<code>String.intern()</code>可以获得一个字符串在拘留表的引用，比如下面代码：</p>
<pre><code class="language-java">public static void main(String[] args){
    String a = 1 + String.valueOf(2) + 3;
    String b = &quot;123&quot;;
    System.out.println(a.equals(b));
    System.out.println(a == b);
    System.out.println(a.intern() == b);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">true
false
true
</code></pre>
<p>这里<code>b</code>就是常量本身，因此<code>a.intern()</code>返回在拘留表的引用后就是<code>b</code>本身，比较结果为真。</p>
<h2 id="36-初始化">3.6 初始化</h2>
<p>初始化阶段会执行类的初始化方法<code>&lt;clint&gt;</code>，<code>&lt;clint&gt;</code>是由编译期生成的，由静态成员的赋值语句以及<code>static</code>语句共同产生。</p>
<p>另外，加载一个类的时候，<code>JVM</code>总是会试图加载该类的父类，因此父类的<code>&lt;clint&gt;</code>方法总是在子类的<code>&lt;clint&gt;</code>方法之前被调用。另一方面，需要注意的是<code>&lt;clint&gt;</code>会确保在多线程环境下的安全性，也就是多个线程同时初始化同一个类时，只有一个线程可以进入<code>&lt;clint&gt;</code>方法，换句话说，在多线程下可能会出现死锁，比如下面代码：</p>
<pre><code class="language-java">package com.company;

import java.util.concurrent.TimeUnit;

public class Main extends Thread{
    private char flag;
    public Main(char flag){
        this.flag = flag;
    }
    
    public static void main(String[] args){
        Main a = new Main('A');
        a.start();
        Main b = new Main('B');
        b.start();
    }

    @Override
    public void run() {
        try{
            Class.forName(&quot;com.company.Static&quot;+flag);
        }catch (ClassNotFoundException e){
            e.printStackTrace();
        }
    }
}

class StaticA{
    static {
        try {
            TimeUnit.SECONDS.sleep(1);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        try{
            Class.forName(&quot;com.company.StaticB&quot;);
        }catch (ClassNotFoundException e){
            e.printStackTrace();
        }
        System.out.println(&quot;StaticA init ok&quot;);
    }
}

class StaticB{
    static {
        try {
            TimeUnit.SECONDS.sleep(1);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        try{
            Class.forName(&quot;com.company.StaticA&quot;);
        }catch (ClassNotFoundException e){
            e.printStackTrace();
        }
        System.out.println(&quot;StaticB init ok&quot;);
    }
}
</code></pre>
<p>在加载<code>StaticA</code>的时候尝试加载<code>StaticB</code>，但是由于<code>StaticB</code>已经被加载中，因此加载<code>StaticA</code>的线程会阻塞在<code>Class.forName(&quot;com.company.StaticB&quot;)</code>处，同理加载<code>StaticB</code>的线程会阻塞在<code>Class.forName(&quot;com.company.StaticA&quot;)</code>处，这样就出现死锁了。</p>
<h1 id="4-classloader">4 <code>ClassLoader</code></h1>
<h2 id="41-classloader简介">4.1 <code>ClassLoader</code>简介</h2>
<p><code>ClassLoader</code>是类加载的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>加载的，<code>ClassLoader</code>通过各种各样的方式将<code>Class</code>信息的二进制数据流读入系统，然后交给<code>JVM</code>进行连接、初始化等操作。因此<code>ClassLoader</code>负责类的加载流程，无法通过<code>ClassLoader</code>改变类的连接和初始化行为。</p>
<p><code>ClassLoader</code>是一个抽象类，提供了一些重要接口定义加载流程和加载方式，主要方法如下：</p>
<ul>
<li><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>：给定一个类名，加载一个类，返回这个类的<code>Class</code>实例，找不到抛出异常</li>
<li><code>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</code>：根据给定字节流定义一个类，<code>off</code>和<code>len</code>表示在字节数组中的偏移和长度，这是一个<code>protected</code>方法，在自定义子类中才能使用</li>
<li><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code>：查找一个类，会在<code>loadClass</code>中被调用，用于自定义查找类的逻辑</li>
<li><code>protected Class&lt;?&gt; findLoadedClass(String name)</code>：寻找一个已经加载的类</li>
</ul>
<h2 id="42-类加载器分类">4.2 类加载器分类</h2>
<p>在标准的<code>Java</code>程序中，<code>JVM</code>会创建3类加载器为整个应用程序服务，分别是：</p>
<ul>
<li>启动类加载器：<code>Bootstrap ClassLoader</code></li>
<li>扩展类加载器：<code>Extension ClassLoader</code></li>
<li>应用类加载器（也叫系统类加载器）：<code>App ClassLoader</code></li>
</ul>
<p>另外，在程序中还可以定义自己的类加载器，从总体看，层次结构如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210504143259172.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>一般来说各个加载器负责的范围如下：</p>
<ul>
<li>启动类加载器：负责加载系统的核心类，比如<code>rt.jar</code>包中的类</li>
<li>扩展类加载器：负责加载<code>lib/ext/*.jar</code>下的类</li>
<li>应用类加载器：负责加载用户程序的类</li>
<li>自定义加载器：加载一些特殊途径的类，一般是用户程序的类</li>
</ul>
<h2 id="43-双亲委派">4.3 双亲委派</h2>
<p>默认情况下，类加载使用双亲委派加载的模式，具体来说，就是类在加载的时候，会判断当前类是否已经被加载，如果已经被加载，那么直接返回已加载的类，如果没有，会先请求双亲加载，双亲也是按照一样的流程先判断是否已加载，如果没有在此委托双亲加载，如果双亲加载失败，则会自己加载。</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210504143259172.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在上图中，应用类加载器的双亲为扩展类加载器，扩展类加载器的双亲为启动类加载器，当系统需要加载一个类的时候，会先从底层类加载器开始进行判断，当需要加载的时候会从顶层开始加载，依次向下尝试直到加载成功。</p>
<p>在所有加载器中，启动类加载器是最特别的，并不是使用<code>Java</code>语言实现，在<code>Java</code>中没有对象与之相对应，系统核心类就是由启动类加载器进行加载的。换句话说，如果尝试在程序中获取启动类加载器，得到的值是<code>null</code>：</p>
<pre><code class="language-java">System.out.println(String.class.getClassLoader() == null);
</code></pre>
<p>输出结果为真。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第324期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-324-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-324-qi/">
        </link>
        <updated>2021-05-03T16:59:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>能有钱解决的问题都不是问题，但如何有钱，才是你最大的问题。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>北风吹雪四更初，嘉瑞天教及岁除。<br>
——陆游《除夜雪》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你搅散一池星光成为我的月亮。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1620061928390.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>有点复杂，三维<code>dp</code>，其中<code>dp[i][j][k]</code>表示：</p>
<ul>
<li>第<code>i</code>个房子</li>
<li>目前已形成<code>j</code>个街区</li>
<li>第<code>i</code>个房子的颜色为<code>k</code></li>
<li>符合以上三种条件下所花费的最小费用</li>
</ul>
<p>转移方程需要根据当前房子有没有涂色去讨论：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1620093981955.png" alt="" loading="lazy"></figure>
<p>代码：</p>
<pre><code class="language-java">public class Solution {
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        int[][][] dp = new int[m][target + 1][n + 1];
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt;= target; j++) {
                for (int k = 0; k &lt;= n; k++) {
                    dp[i][j][k] = 0x3f3f3f3f;
                }
            }
        }

        if (houses[0] == 0) {
            System.arraycopy(cost[0], 0, dp[0][1], 1, n);
        } else {
            dp[0][1][houses[0]] = 0;
        }

        for (int i = 1; i &lt; m; i++) {
            if (houses[i] == 0) {
                for (int curColor = 1; curColor &lt;= n; ++curColor) {
                    for (int preColor = 1; preColor &lt;= n; ++preColor) {
                        for (int j = 1; j &lt;= target; j++) {
                            dp[i][j][curColor] = (curColor == preColor ?
                                    Math.min(dp[i][j][curColor], dp[i - 1][j][curColor] + cost[i][curColor - 1]) :
                                    Math.min(dp[i][j][curColor], dp[i - 1][j - 1][preColor] + cost[i][curColor - 1])
                            );
                        }
                    }
                }
            } else {
                int curColor = houses[i];
                for (int preColor = 1; preColor &lt;= n; ++preColor) {
                    for (int j = 1; j &lt;= target; j++) {
                        dp[i][j][curColor] = (curColor == preColor ?
                                Math.min(dp[i][j][curColor], dp[i - 1][j][curColor]) :
                                Math.min(dp[i][j][curColor], dp[i - 1][j - 1][preColor])
                        );
                    }
                }
            }
        }

        int min = dp[m - 1][target][1];
        for (int i = 2; i &lt;= n; i++) {
            if (min &gt; dp[m - 1][target][i]) {
                min = dp[m - 1][target][i];
            }
        }
        return min == 0x3f3f3f3f ? -1 : min;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1620093851892.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第323期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-323-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-323-qi/">
        </link>
        <updated>2021-05-02T18:04:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>三观没用，你得靠五官。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>参横斗转欲三更，苦雨终风也解晴。<br>
——苏轼《六月二十日夜渡海》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我本身得不到答案。所以，我希望能够有答出来之物的诞生。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1619978807809.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1619978812784.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习笔记（七）：Class文件结构]]></title>
        <id>https://2293736867.github.io/post/jvm-xue-xi-bi-ji-qi-class-wen-jian-jie-gou/</id>
        <link href="https://2293736867.github.io/post/jvm-xue-xi-bi-ji-qi-class-wen-jian-jie-gou/">
        </link>
        <updated>2021-05-02T14:17:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-来源">1 来源</h1>
<ul>
<li>来源：《Java虚拟机 JVM故障诊断与性能优化》——葛一鸣</li>
<li>章节：第九章</li>
</ul>
<p>本文是第九章的一些笔记整理。</p>
<h1 id="2-概述">2 概述</h1>
<p>本文主要介绍了<code>Class</code>文件的主要组成，包括魔数、版本号、常量池、访问标志等。</p>
<h1 id="3-class文件概览">3 <code>Class</code>文件概览</h1>
<p>根据<code>JVM</code>规范，一个<code>Class</code>文件可以非常严谨地描述为：</p>
<pre><code class="language-java">ClassFile{
	u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<p>下面会按顺序详细介绍里面的各个字段。</p>
<h1 id="4-魔数">4 魔数</h1>
<p>魔数（<code>Magic Number</code>）作为<code>Class</code>的标志，用来告诉<code>JVM</code>这是一个<code>Class</code>文件，魔数是一个4字节的无符号整数，固定为<code>0xCAFEBABE</code>。如果一个<code>Class</code>文件不以<code>0xCAFEBABE</code>开头，那么会抛出如下错误：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210501092555377.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><code>Linux</code>下可以直接使用<code>vim</code>打开<code>class</code>文件进行查看，比如需要打开一个<code>Test.class</code>文件，可以输入如下命令：</p>
<pre><code class="language-bash">vim -b Test.class
:%!xxd
</code></pre>
<p>切换到十六进制后就可以看到魔数了：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210501092757413.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-版本">5 版本</h1>
<p>魔数后面紧跟着<code>Class</code>的小版本和大版本号，这表示当前<code>Class</code>文件是由哪个版本的编译期产生的。小版本和大版本后都是占用两个字节，比如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210501093335313.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>0000</code>是小版本号</li>
<li><code>0037</code>是大版本号，十进制为<code>55</code>，也就是对应<code>JDK 11</code>版本的编译期</li>
</ul>
<h1 id="6-常量池">6 常量池</h1>
<p>在版本号后面，紧跟着就是常量池的数量以及若干个常量池表项：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210501094528106.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210501094538627.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其中每一个常量池表项都具有标签属性：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20210501095154980.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>对应关系举例如下：</p>
<ul>
<li><code>tag</code>为3：类型为<code>CONSTANT_Integer</code></li>
<li><code>tag</code>为4：类型为<code>CONSTANT_Float</code></li>
</ul>
<p>等等，比如<code>CONSTANT_Integer</code>结构如下：</p>
<pre><code class="language-java">CONSTANT_Integer_info {
    u1 tag;
    u4 bytes;
}
</code></pre>
<p>一个<code>tag</code>加上一个四字节的无符号整数。其他类型大部分类似，篇幅限制，详细请看<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4.1">JVM规范</a>。</p>
<h1 id="7-访问标记">7 访问标记</h1>
<p>访问标记使用两个字节表示，用于表明该类的访问信息，比如<code>public</code>/<code>abstract</code>等，对应关系如下：</p>
<ul>
<li><code>ACC_PUBLIC</code>：<code>0x0001</code>，表示<code>public</code>类</li>
<li><code>ACC_FINAL</code>：<code>0x0010</code>，表示是否为<code>final</code>类</li>
<li><code>ACC_SUPER</code>：<code>0x0020</code>，表示使用增强的方法调用父类的方法</li>
<li><code>ACC_INTERFACE</code>：<code>0x0200</code>，表示是否为接口</li>
<li><code>ACC_ABSTRACT</code>：<code>0x0400</code>，表示是否为抽象类</li>
<li><code>ACC_SYNTHETIC</code>：<code>0x1000</code>，由编译期产生的类，没有源码对应</li>
<li><code>ACC_ANNOTATION</code>：<code>0x2000</code>，表示是否是注释</li>
<li><code>ACC_ENUM</code>：<code>0x4000</code>，表示是否为枚举</li>
</ul>
<h1 id="8-当前类-父类和接口">8 当前类、父类和接口</h1>
<p>格式如下：</p>
<pre><code class="language-java">u2             this_class;                                    
u2             super_class;
u2             interfaces_count;
u2             interfaces[interfaces_count];
</code></pre>
<p>其中<code>this_class</code>与<code>super_class</code>都是两个字节的无符号整数，指向常量池中的一个<code>CONSTANT_Class</code>，表示当前的类型以及父类。另外，由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，如果没有实现任何接口，则<code>interfaces_count</code>为0。</p>
<h1 id="9-字段">9 字段</h1>
<p>字段的格式如下：</p>
<pre><code class="language-java">u2             fields_count;
field_info     fields[fields_count];
</code></pre>
<p><code>fields_count</code>是一个2字节的无符号整数，字段数量之后是具体的字段信息，每个字段都是一个<code>field_info</code>的结构，如下所示：</p>
<pre><code class="language-java">field_info {
    u2             access_flags;                         //访问标记，类似于类的访问标记，可以表示public/private/static等等
    u2             name_index;                           //两字节整数，指向常量池中的CONSTANT_Utf8
    u2             descriptor_index;                     //也是两字节整数，用于描述字段类型，也指向常量池中的CONSTANT_Utf8
    u2             attributes_count;                     //属性数量
    attribute_info attributes[attributes_count];         //属性，比如存储初始化值，一些注释信息等，需要使用attribute_info
}

attribute_info {
    u2 attribute_name_index;                             //属性名字，指向常量池的索引
    u4 attribute_length;                                 //属性长度
    u1 info[attribute_length];                           //字节数组表示的信息
}
</code></pre>
<h1 id="10-方法">10 方法</h1>
<h2 id="101-方法基本结构">10.1 方法基本结构</h2>
<p>方法的格式如下：</p>
<pre><code class="language-java">u2             methods_count;
method_info    methods[methods_count];
</code></pre>
<p>其中每一个<code>method_info</code>结构表示一个方法：</p>
<pre><code class="language-java">method_info {
    u2             access_flags;                            //访问标记，标记方法为public/private等等
    u2             name_index;                              //方法名称，一个指向常量池的索引
    u2             descriptor_index;                        //方法描述符，也是一个指向常量符的索引
    u2             attributes_count;                        //属性数量
    attribute_info attributes[attributes_count];            //属性，和字段类似，方法也可以携带属性，一个属性数量+一个属性描述数组
}
</code></pre>
<h2 id="102-code属性">10.2 <code>Code</code>属性</h2>
<p>方法的主要内容存放在属性中，在属性里面最重要的一个属性就是<code>Code</code>，<code>Code</code>存放着方法的字节码等信息，结构如下：</p>
<pre><code class="language-java">Code_attribute {
    u2 attribute_name_index;                      //属性名称，指向常量池的索引
    u4 attribute_length;                          //属性长度，不包括前6字节（u2+u4）
    u2 max_stack;                                 //操作数栈最大深度
    u2 max_locals;                                //局部变量表的最大值
    u4 code_length;                               //字节码长度
    u1 code[code_length];                         //字节码内容本身
    u2 exception_table_length;                    //异常处理表长度
    {   u2 start_pc;                              //四个字段表示在start_pc到end_pc两个偏移量之间
        u2 end_pc;                                //如果遇到了catch_type指向的异常
        u2 handler_pc;                            //代码就跳转到handler_pc位置执行
        u2 catch_type;                            
    } exception_table[exception_table_length];    //异常表
    u2 attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<p><code>Code</code>属性本身也包含其他属性以进一步存储一些额外信息，主要包括：</p>
<ul>
<li><code>LineNumberTable</code></li>
<li><code>LocalVariableTable</code></li>
<li><code>StackMapTable</code></li>
</ul>
<h3 id="1021-linenumbertable">10.2.1 <code>LineNumberTable</code></h3>
<p><code>LineNumberTable</code>用于记录字节码偏移量和行号的对应关系，结构如下：</p>
<pre><code class="language-java">LineNumberTable_attribute {
    u2 attribute_name_index;                             //指向常量池的索引
    u4 attribute_length;                                 //属性长度
    u2 line_number_table_length;                         //表项记录条数
    {   u2 start_pc;                                     //字节码偏移量
        u2 line_number;	                                 //字节码偏移量对应的行号
    } line_number_table[line_number_table_length];       //表数组，每一个元素对应的是一个&lt;start_pc,line_number&gt;元组
}
</code></pre>
<h3 id="1022-localvariabletable">10.2.2 <code>LocalVariableTable</code></h3>
<p>这个属性也叫局部变量表，记录了一个方法中所有的局部变量，结构如下：</p>
<pre><code class="language-java">LocalVariableTable_attribute {
    u2 attribute_name_index;                                     //当前属性名字，指向常量池的索引
    u4 attribute_length;                                         //属性长度
    u2 local_variable_table_length;                              //局部变量表的表项条目
    {   u2 start_pc;                                             //当前局部变量开始位置
        u2 length;                                               //当前局部变量长度（可用于计算结束位置）
        u2 name_index;                                           //局部变量名称，指向常量池的索引
        u2 descriptor_index;                                     //局部变量的类型描述，指向常量池的索引
        u2 index;                                                //局部变量在当前栈帧的局部变量表中的槽位
    } local_variable_table[local_variable_table_length];         
}
</code></pre>
<h3 id="1023-stackmaptable">10.2.3 <code>StackMapTable</code></h3>
<p><code>StackMapTable</code>中含有若干个栈映射帧（<code>Stack Map Frame</code>）的数据，不包含运行时所需要的信息，仅用作<code>Class</code>文件的类型校验，结构如下：</p>
<pre><code class="language-java">StackMapTable_attribute {
    u2              attribute_name_index;                         //常量池索引，恒为&quot;StackMapTable&quot;
    u4              attribute_length;                             //属性长度
    u2              number_of_entries;                            //栈映射帧的数量
    stack_map_frame entries[number_of_entries];                   //具体的栈映射帧
}

union stack_map_frame {                                           //每个栈映射帧被定义为一个枚举值，取值如下
    same_frame;                                                   //具体每个取值的意义可以查看JVM规范
    same_locals_1_stack_item_frame;                               //https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7.4
    same_locals_1_stack_item_frame_extended;
    chop_frame;
    same_frame_extended;
    append_frame;
    full_frame;
}
</code></pre>
<p>每个栈映射帧是为了说明在一个特定的字节码偏移位置上，系统的数据类型是什么，包括局部变量表的类型和操作数栈的类型。</p>
<h1 id="11-附录asm简单使用">11 附录：<code>ASM</code>简单使用</h1>
<p><code>ASM</code>是一个<code>Java</code>字节码操作库，很多著名的库都依赖于该库，比如<code>AspectJ</code>、<code>CGLIB</code>等等。但是<code>ASM</code>的性能远远超过<code>CGLIB</code>等高层字节码库，因为<code>ASM</code>更加接近底层，使用更为灵活且功能更为强大。</p>
<p>下面是一个简单的使用<code>ASM</code>输出<code>Hello World</code>的例子：</p>
<pre><code class="language-java">package com.company;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

public class Main extends ClassLoader implements Opcodes {
    public static void main(String[] args) throws Exception{
    	//创建ClassWriter，指定COMPUTE_MAXS和COMPUTE_FRAMES，分别表示计算最大局部变量表以及最深操作数栈
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
        //通过ClassWriter设置类的基本信息，比如public访问标记，类名为Example
        cw.visit(V11,ACC_PUBLIC,&quot;Example&quot;,null,&quot;java/lang/Object&quot;,null);
        //生成Example的构造方法
        MethodVisitor mw = cw.visitMethod(ACC_PUBLIC ,&quot;&lt;init&gt;&quot;,&quot;()V&quot;,null,null);
        mw.visitVarInsn(ALOAD,0);
        mw.visitMethodInsn(INVOKESPECIAL,&quot;java/lang/Object&quot;,&quot;&lt;init&gt;&quot;,&quot;()V&quot;,false);
        mw.visitInsn(RETURN);
        mw.visitMaxs(0,0);
        mw.visitEnd();

		//生成public static void main(String []args)方法，并生成了main()方法的字节码
		//要求运行时调用System.out.println()，并输出&quot;Hello world&quot;：
        mw = cw.visitMethod(ACC_PUBLIC+ACC_STATIC,&quot;main&quot;,&quot;([Ljava/lang/String;)V&quot;,null,null);
        mw.visitFieldInsn(GETSTATIC,&quot;java/lang/System&quot;,&quot;out&quot;,&quot;Ljava/io/PrintStream;&quot;);
        mw.visitLdcInsn(&quot;Hello world!&quot;);
        mw.visitMethodInsn(INVOKEVIRTUAL,&quot;java/io/PrintStream&quot;,&quot;println&quot;,&quot;(Ljava/lang/String;)V&quot;,false);
        mw.visitInsn(RETURN);
        mw.visitMaxs(0,0);
        mw.visitEnd();

		//获取二进制表示
        byte[] code = cw.toByteArray();
        Main m = new Main();
        //将class文件载入系统，通过反射调用`main()`方法，输出结果
        Class&lt;?&gt; mainClass = m.defineClass(&quot;Example&quot;,code,0,code.length);
        mainClass.getMethods()[0].invoke(null, new Object[]{null});
    }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20210501150243207.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>