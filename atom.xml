<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-11-21T04:57:22.528Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第162期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-162-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-162-qi/">
        </link>
        <updated>2020-11-23T05:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>如果我有什么，让你不喜欢的地方，麻烦你自己克服一下。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>惟有河边雁，秋来南向飞。<br>
——庾信《重别周尚书》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>路是脚踏出来的，历史是人写出来的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第161期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-161-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-161-qi/">
        </link>
        <updated>2020-11-22T05:21:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>做人如果没点追求，那么，该多轻松啊。。。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>泉眼无声惜细流，树阴照水爱晴柔。<br>
——杨万里《小吃》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不管风吹浪打，胜似闲庭信步。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第160期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-160-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-160-qi/">
        </link>
        <updated>2020-11-21T05:12:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>所谓复习就是，把不会的东西再确认一遍，你确实不会。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>西宫南内多秋草，落叶满阶红不扫。<br>
——白居易《长恨歌》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>从善如登，从恶如崩。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java实现操作系统中四种动态内存分配算法：BF+NF+WF+FF]]></title>
        <id>https://2293736867.github.io/post/java-shi-xian-cao-zuo-xi-tong-zhong-si-chong-dong-tai-nei-cun-fen-pei-suan-fa-bfnfwfff/</id>
        <link href="https://2293736867.github.io/post/java-shi-xian-cao-zuo-xi-tong-zhong-si-chong-dong-tai-nei-cun-fen-pei-suan-fa-bfnfwfff/">
        </link>
        <updated>2020-11-21T04:56:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>本文是利用<code>Java</code>实现操作系统中的四种动态内存分配方式 ，分别是：</p>
<ul>
<li><code>BF</code></li>
<li><code>NF</code></li>
<li><code>WF</code></li>
<li><code>FF</code></li>
</ul>
<p>分两部分，第一部分是介绍四种分配方式的概念以及例子，第二部分是代码实现以及讲解。</p>
<h1 id="2-四种分配方式">2 四种分配方式</h1>
<h2 id="21-概念">2.1 概念</h2>
<p>操作系统中有一个动态分区分配的概念，内存在初始化的时候不会划分区域，而是在进程装入的时候，根据所要装入的进程动态地对内存空间进行划分，以提高内存空间的利用率，降低碎片的大小，主要的方法有一下四种：</p>
<ul>
<li>首次适应算法（<code>First Fit</code>）：从空闲分区链首开始查找，直到找到一个满足其大小要求的空闲分区为止</li>
<li>循环首次适应算法（<code>Next Fit</code>）：从上次找到的空闲分区的下一个开始查找</li>
<li>最佳适应算法（<code>Best Fit</code>）：把空闲分区按大小递增的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
<li>最坏适应算法（<code>Worst Fit</code>）：与最佳适应算法相反，把空闲分区按大小递减的方式形成分区链，找到第一个能满足要求的空闲分区就进行分配</li>
</ul>
<h2 id="22-例子">2.2 例子</h2>
<p>假设现在有<code>100MB</code>的内存空间，某一时刻先后分配了<code>20MB</code>、<code>4MB</code>、<code>10MB</code>内存，示意图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201121154826958.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>现在需要再分配<code>5MB</code>内存。</p>
<p>若采用<code>FF</code>，因为<code>FF</code>是直接按顺序分配内存，从低地址开始搜索空闲分区，因此便会从第一块空闲分区分配<code>5MB</code>（地址<code>0-5</code>），示意图：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020112115543974.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>NF</code>，<code>NF</code>与<code>FF</code>类似，只不过<code>NF</code>是从上一次找到的空闲分区的下一块开始查找，因为上一次分配的是<code>10MB</code>，因此会从最后一块空闲分区（地址<code>80-100</code>）分配内存：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201121155703771.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>BF</code>，<code>BF</code>是遍历所有空闲分区并找到一个能满足要求的最小分区，也就会找到一个比<code>5MB</code>大的空闲分区，且该空闲分区是所有空闲分区中最小的，也就是地址为<code>64-70</code>的空闲分区：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201121155908288.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>若采用<code>WF</code>，<code>WF</code>与<code>BF</code>相反，总是从最大的空闲分区开始分配，因此会从地址为<code>30-60</code>的空闲分区进行分配：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201121160047113.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-代码实现">3 代码实现</h1>
<h2 id="31-总览">3.1 总览</h2>
<p>代码分成了四个类：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2020112116032076.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><code>Main</code>：测试</li>
<li><code>Print</code>：输出打印</li>
<li><code>Table</code>：表示每一个分区</li>
<li><code>TableList</code>：对分区进行控制，包括初始化，分配，回收等</li>
</ul>
<h2 id="32-main">3.2 <code>Main</code></h2>
<p><code>Main</code>是测试类，代码如下：</p>
<pre><code class="language-java">public class Main {

    private final static TableList list = new TableList(64);

    public static void main(String[] args) {
        list.useWF();
//        list.useBF();
//        list.useNF();
//        list.useFF();

        list.allocate(10);
        list.allocate(20);
        list.free(10);
        list.show();
        list.allocate(8);
        list.show();
        list.allocate(13);
        list.allocate(1);
        list.show();
        list.free(1);
        list.allocate(9);
        list.free(13);
        list.show();
        list.allocate(18);
        list.show();
        list.allocate(3);
        list.allocate(4);
        list.free(20);
        list.free(8);
        list.show();
        list.allocate(8);
        list.free(9);
        list.show();
        list.clear();
        list.show();
    }
}
</code></pre>
<p>通过<code>TableList</code>对内存进行分配以及释放，初始化分配<code>64MB</code>大小内存，切换分配算法时使用前四行的其中一行即可。</p>
<h2 id="33-table">3.3 <code>Table</code></h2>
<p><code>Table</code>类表示每一个分区，无论是空闲的还是已分配的，成员变量有四个，分别是：</p>
<ul>
<li>起始地址</li>
<li>大小</li>
<li>是否空闲（只有两种状态，空闲或分配）</li>
<li>是否是上一次分配（<code>NF</code>专用）</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">@AllArgsConstructor
public class Table {
    @Getter
    @Setter
    private int address;
    @Setter
    @Getter
    private int size;
    private boolean free;
    @Getter
    @Setter
    private boolean lastAllocated;

    public static Table freeTable(int address,int size)
    {
        return new Table(address,size,true,false);
    }

    public static Table allocatedTable(int address,int size)
    {
        return new Table(address,size,false,false);
    }

    public boolean isFree()
    {
        return free;
    }

    public boolean isAllocated()
    {
        return !isFree();
    }

    public void setFree()
    {
        free = true;
    }
}
</code></pre>
<p>只有一些<code>Getter</code>和<code>Setter</code>，为了方便提供了一个创建空闲分区或已分配分区的静态方法，指定起始地址和大小即可。</p>
<h2 id="34-tablelist">3.4 <code>TableList</code></h2>
<p><code>TableList</code>是整个算法的核心类，成员变量如下：</p>
<pre><code class="language-java">private final List&lt;Table&gt; list = new ArrayList&lt;&gt;();
private final int totalSize;
private boolean ff = false;
private boolean nf = false;
private boolean bf = false;
private boolean wf = false;
private boolean first = true;
private final static Print print = new Print();
</code></pre>
<p><code>list</code>就是所有的空闲分区与已分配分区组成的数组，<code>totalSize</code>是总大小，接着是四个控制算法的布尔变量，<code>first</code>表示是否是第一次分配内存，因为第一次的话四种算法都是固定的从地址为<code>0</code>处开始分配。</p>
<p>接下来就是内存分配算法以及释放算法。</p>
<h3 id="341-ff">3.4.1 <code>FF</code></h3>
<pre><code class="language-java">if (ff)
{
    for (int i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.add(i,allocated);
            return;
        }
    }
}
</code></pre>
<p><code>FF</code>的实现还是比较简单的，直接遍历列表，如果是空闲分区并满足大小要求，直接进行分配，修改空闲分区的起始地址和大小并插入一个新的已分配分区到列表中即可。</p>
<h3 id="342-nf">3.4.2 <code>NF</code></h3>
<pre><code class="language-java">else if (nf)
{
    int lastNFIndex = findLastAllocated();
    int i = lastNFIndex;
    do
    {
        if(i == list.size())
            i = 0;
        Table table = list.get(i);
        if(table.isFree() &amp;&amp; table.getSize() &gt;= size)
        {
            int address = table.getAddress();
            Table allocated = Table.allocatedTable(address,size);
            table.setAddress(address+size);
            table.setSize(table.getSize()-size);
            list.get(lastNFIndex).setLastAllocated(false);
            table.setLastAllocated(true);
            list.add(i,allocated);
            return;
        }
        ++i;
    }
    while (i != lastNFIndex);
}
</code></pre>
<p><code>NF</code>的话需要提前记录上一次分配的位置，通过<code>Table</code>中的<code>lastAllocated</code>确定上一次分配的位置，找到后从该位置开始遍历列表，注意需要进行绕回处理，因为到末尾位置后有可能还没有能满足的空闲分区，此时需要将下标绕回到<code>0</code>并再次遍历直到到达上一次分配的位置。</p>
<h3 id="343-bfwf">3.4.3 <code>BF</code>+<code>WF</code></h3>
<p>由于<code>BF</code>与<code>WF</code>都需要遍历所有的空闲分区，只是前者是选择最小满足要求的，后者是选择最大满足要求的，因此两者的实现差别在于一个判断大小的符号，代码如下：</p>
<pre><code class="language-java">else
{
    int i;
    int target = -1;
    for (i = 0; i &lt; list.size(); i++) {
        Table table = list.get(i);
        if(table.isFree())
        {
            if(table.getSize() &gt;= size)
            {
                if(target == -1)
                    target = i;
                else
                {
                    if(bf)
                    {
                        if(list.get(target).getSize() &gt; table.getSize())
                            target = i;
                    }
                    else
                    {
                        if(list.get(target).getSize() &lt; table.getSize())
                            target = i;
                    }
                }
            }
        }
    }
    if(target != -1)
    {
        Table table = list.get(target);
        int address = table.getAddress();
        table.setAddress(address+size);
        table.setSize(table.getSize()-size);
        list.add(target,Table.allocatedTable(address,size));
        return;
    }
}
</code></pre>
<p>首先遍历找到符合条件的空闲分区的下标，接着通过判断<code>target</code>，也就是目标空闲分区的下标，如果为<code>-1</code>表示没有找到符合条件的空闲分区，如果不为<code>-1</code>直接分配空间。</p>
<h3 id="344-释放算法">3.4.4 释放算法</h3>
<p>释放算法的设计是比较复杂的，代码如下：</p>
<pre><code class="language-java">public void free(int size)
{
    int index = 0;
    while(index &lt; list.size())
    {
        if(list.get(index).isAllocated() &amp;&amp; list.get(index).getSize() == size)
            break;
        ++index;
    }
    if(index &gt;= list.size())
    {
        print.freeFailed(size);
        return;
    }
    int address = list.get(index).getAddress();
    if(index == 0)
    {
        list.get(0).setFree();
        if(index+1 &lt; list.size())
        {
            Table nextTable = list.get(index+1);
            if(nextTable.isFree())
            {
                list.get(0).setSize(nextTable.getSize()+size);
                list.remove(index+1);
            }
        }
    }
    else if(index == list.size()-1)
    {
        list.get(index).setFree();
        Table lastTable = list.get(index-1);
        if(lastTable.isFree())
        {
            lastTable.setSize(lastTable.getSize()+size);
            list.remove(index);
        }
    }
    else
    {
        Table before = list.get(index-1);
        Table after = list.get(index+1);

        if(before.isFree() &amp;&amp; after.isFree())
        {
            before.setSize(before.getSize()+size+after.getSize());
            list.remove(index+1);
            list.remove(index);
        }
        else if(before.isFree() &amp;&amp; after.isAllocated())
        {
            before.setSize(before.getSize()+size);
            list.remove(index);
        }
        else if(before.isAllocated() &amp;&amp; after.isFree())
        {
            after.setSize(after.getSize()+size);
            after.setAddress(address);
            list.remove(index);
        }
        else
        {
            list.get(index).setFree();
        }
    }
}
</code></pre>
<p>主要考虑了六种情况（黄色代表需要释放的空间，橙色是已分配的内存空间）：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201121170701544.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>第一种情况就是需要释放首部的分区，此时需要修改后面空闲分区的起始地址和大小，并删除目标分区</li>
<li>第二种情况是释放尾部的分区，此时需要修改前面空闲分区的大小即可，无需修改起始地址，并删除目标分区</li>
<li>第三种情况是后面是已分配的分区，前面的空闲分区，需要修改前面空闲分区的大小，并删除目标分区</li>
<li>第四种情况是前面是已分配的分区，后面是空闲分区，需要修改后面的空闲分区的起始地址以及大小，并删除目标分区</li>
<li>第五种情况是前后都是已分配的分区，此时只需要修改目标分区的标志为空闲即可，无需额外操作</li>
<li>第六种情况是前后都是空闲分区，这种情况下需要进行连接操作，具体来说就是先修改前面空闲分区的大小，接着删除目标分区以及后面的空闲分区</li>
</ul>
<p>下面回到代码，首先是判断第一种情况：</p>
<pre><code class="language-java">if(index == 0)
{
    list.get(0).setFree();
    if(index+1 &lt; list.size())
    {
        Table nextTable = list.get(index+1);
        if(nextTable.isFree())
        {
            list.get(0).setSize(nextTable.getSize()+size);
            list.remove(index+1);
        }
    }
}
</code></pre>
<p>也就是需要释放首部的分区，通过<code>setFree()</code>设置标志位表示空闲状态，接着判断是否需要修改后面空闲分区的大小，因为有可能后面是一个已分配的分区而不是空闲分区。</p>
<pre><code class="language-java">else if(index == list.size()-1)
{
    list.get(index).setFree();
    Table lastTable = list.get(index-1);
    if(lastTable.isFree())
    {
        lastTable.setSize(lastTable.getSize()+size);
        list.remove(index);
    }
}
</code></pre>
<p>这里是判断第二种情况，也就是释放尾部的分区，同样需要判断前一个分区是已分配的分区还是空闲的分区，是空闲分区的话修改大小并移除目标分区。</p>
<pre><code class="language-java">else
{
    Table before = list.get(index-1);
    Table after = list.get(index+1);

    if(before.isFree() &amp;&amp; after.isFree())
    {
        before.setSize(before.getSize()+size+after.getSize());
        list.remove(index+1);
        list.remove(index);
    }
    else if(before.isFree() &amp;&amp; after.isAllocated())
    {
        before.setSize(before.getSize()+size);
        list.remove(index);
    }
    else if(before.isAllocated() &amp;&amp; after.isFree())
    {
        after.setSize(after.getSize()+size);
        after.setAddress(address);
        list.remove(index);
    }
    else
    {
        list.get(index).setFree();
    }
}
</code></pre>
<p>接下来是最后四种情况的判断，首先获取前一个以及后一个分区，接着按上面算法的思路进行判断即可。</p>
<h1 id="4-测试">4 测试</h1>
<p>以<code>WF</code>为例，默认大小<code>64MB</code>，测试顺序如下：</p>
<ul>
<li>分配<code>10MB</code></li>
<li>分配<code>20MB</code></li>
<li>释放<code>10MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>13MB</code></li>
<li>分配<code>1MB</code></li>
<li>打印结果</li>
<li>释放<code>1MB</code></li>
<li>分配<code>9MB</code></li>
<li>释放<code>13MB</code></li>
<li>打印结果</li>
<li>分配<code>18MB</code></li>
<li>打印结果</li>
<li>分配<code>3MB</code></li>
<li>分配<code>4MB</code></li>
<li>释放<code>20MB</code></li>
<li>释放<code>8MB</code></li>
<li>打印结果</li>
<li>分配<code>8MB</code></li>
<li>释放<code>9MB</code></li>
<li>打印结果</li>
<li>清空</li>
<li>打印结果</li>
</ul>
<p>输出：</p>
<pre><code class="language-java">Free           :      0-10MB
Allocated      :      10-30MB
Free           :      30-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Allocated      :      38-51MB
Allocated      :      51-52MB
Free           :      52-64MB

----------------------------------------------------------------

Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Do nothing.
Allocated failed, out of memory
Free           :      0-10MB
Allocated      :      10-30MB
Allocated      :      30-38MB
Free           :      38-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Free           :      4-38MB
Allocated      :      38-41MB
Free           :      41-51MB
Allocated      :      51-60MB
Free           :      60-64MB

----------------------------------------------------------------

Allocated      :      0-4MB
Allocated      :      4-12MB
Free           :      12-38MB
Allocated      :      38-41MB
Free           :      41-64MB

----------------------------------------------------------------

Free           :      0-64MB

----------------------------------------------------------------
</code></pre>
<p>读者可以自行画图验证。</p>
<h1 id="5-源码">5 源码</h1>
<ul>
<li><a href="https://github.com/2293736867/FourDynamicAllocatedAlgorithm">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/FourDynamicAllocatedAlgorithm">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/FourDynamicAllocatedAlgorithm">CODE.CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Linux无法读写U盘中的NTFS问题]]></title>
        <id>https://2293736867.github.io/post/jie-jue-linux-wu-fa-du-xie-u-pan-zhong-de-ntfs-wen-ti/</id>
        <link href="https://2293736867.github.io/post/jie-jue-linux-wu-fa-du-xie-u-pan-zhong-de-ntfs-wen-ti/">
        </link>
        <updated>2020-11-20T05:36:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>由于笔者因为某些需要把<code>Windows</code>装在了<code>U盘</code>上面（在这里建议一下如果有需要请使用固态<code>U盘</code>），在<code>Linux</code>下挂载时，能读取但并不能写。</p>
<h1 id="2-尝试的解决方案">2 尝试的解决方案</h1>
<h2 id="21-remount">2.1 <code>remount</code></h2>
<p>一开始是因为没有读写权限，所以就重新挂载，命令如下：</p>
<pre><code class="language-bash">mount -o rw,remount /dev/sda2
</code></pre>
<p>（<code>/dev/sda2</code>是因为笔者的<code>U盘</code>大小<code>64G</code>，把<code>Windows</code>直接装在了里面，默认分了两个分区，一个是启动分区<code>/dev/sda1</code>，一个是系统分区<code>/dev/sda2</code>）</p>
<p>但是还是不能写入。</p>
<h2 id="22-ntfs-3g">2.2 <code>ntfs-3g</code></h2>
<p>首先安装了<code>ntfs-3g</code>，然后再次尝试挂载：</p>
<pre><code class="language-bash">sudo mount -t ntfs-3g /dev/sda2 /run/media/point
sudo ntfs-3g /dev/sda2 /run/media/point
</code></pre>
<p>还是不能写入。</p>
<h2 id="23-ntfsfix">2.3 <code>ntfsfix</code></h2>
<p><code>ntfsfix</code>能修复常见的错误以及<code>NTFS</code>分区不一致的问题，尝试了一下：</p>
<pre><code class="language-bash">sudo ntfsfix /dev/sda2
</code></pre>
<p>还是不能写入。</p>
<h1 id="3-最终解决方案">3 最终解决方案</h1>
<p>再次查了一下资料（<a href="https://itsfoss.com/solve-ntfs-mount-problem-ubuntu-windows-8-dual-boot/">戳这里</a>）发现这个可能是因为<code>Windows</code>的快速启动导致的：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201120111553555.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>把快速启动关了就行。</p>
<p>但是这<code>U盘</code>里面的快速启动貌似关闭不了。。。</p>
<p>最后在<code>StackExchange</code>（<a href="https://unix.stackexchange.com/questions/107978/cant-access-windows-drive-windows-is-hibernated-refused-to-mount">戳这里</a>）上找到了答案：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/2020112011181392.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>核心是<code>remove_hiberfile</code>这个挂载选项，同时也查了一下<code>man</code>：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201120112112981.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在启动<code>Linux</code>时，<code>Windows</code>是有可能处于<code>hibernate</code>状态的，该状态下是不能写的并且强制只读挂载，加入<code>remove_hiberfile</code>参数后，去除了<code>hibernation file</code>，这样在笔者的环境上测试就能正常写入了，但是要注意使用该参数可能会导致保存的<code>Windows session</code><br>
数据全部丢失：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201120112642753.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>所以最终挂载命令如下：</p>
<pre><code class="language-bash">sudo ntfs-3g -o remove_hiberfile /dev/sda2 /run/media/point
</code></pre>
<p>测试了一下<code>Windows</code>并没有任何损坏，因此如果出现上述的问题可以尝试加上<code>remove_hiberfile</code>参数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第159期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-159-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-159-qi/">
        </link>
        <updated>2020-11-20T04:53:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你还不算惨，惨的人，都没手机用。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>山光物态弄春晖，莫为轻阴便拟归。<br>
——张旭《山中留客》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>所以我松开拳头用手握紧笔，作为自己作为人类页作为你。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第158期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-158-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-158-qi/">
        </link>
        <updated>2020-11-19T04:49:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>爱一个人一定要告诉她，那样你才会直到，她有多讨厌你。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>炎炎日正午，灼灼火俱燃。<br>
——韦应物《夏花明》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我伤心的时候，你会不会认为我也是在搞笑？</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第157期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-157-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-157-qi/">
        </link>
        <updated>2020-11-18T11:34:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你不能因为你胖，就忽略了你的丑。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>塞下秋来风景异，衡阳雁去无留意。<br>
——范仲淹《渔家傲·秋思》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>一个人有一个故事，别让你的故事留白。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第156期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-156-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-156-qi/">
        </link>
        <updated>2020-11-16T23:54:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别说自己是单身狗，狗还可以三清四妾。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>休问梁园旧宾客，茂陵秋雨病相如。<br>
——李商隐《寄令狐郎中》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>时代变了，但有些事情可还没变呢，大人。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一句 151-200期合集]]></title>
        <id>https://2293736867.github.io/post/mei-ri-yi-ju-151-200-qi-he-ji/</id>
        <link href="https://2293736867.github.io/post/mei-ri-yi-ju-151-200-qi-he-ji/">
        </link>
        <updated>2020-11-15T23:57:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第151期">第151期</h1>
<blockquote>
<p>你说过等我的......</p>
</blockquote>
<h1 id="第152期">第152期</h1>
<blockquote>
<p>今日的余晖和你最后那天给我的拥抱，同一个温度。</p>
</blockquote>
<h1 id="第153期">第153期</h1>
<blockquote>
<p>她爱海只爱海的惊涛骇浪，爱青草仅仅爱青草遍生于废墟之间。</p>
</blockquote>
<h1 id="第154期">第154期</h1>
<blockquote>
<p>何必怕鬼，折磨你的永远是人。何必怕死，折磨你的是生。</p>
</blockquote>
<h1 id="第155期">第155期</h1>
<blockquote>
<p>梦里与现实的距离，仅仅是双眸的一合一闭。</p>
</blockquote>
<h1 id="第156期">第156期</h1>
<blockquote>
<p>时代变了，但有些事情可还没变呢，大人。</p>
</blockquote>
<h1 id="第157期">第157期</h1>
<blockquote></blockquote>
<h1 id="第158期">第158期</h1>
<blockquote></blockquote>
<h1 id="第159期">第159期</h1>
<blockquote></blockquote>
<h1 id="第160期">第160期</h1>
<blockquote></blockquote>
<h1 id="第161期">第161期</h1>
<blockquote></blockquote>
<h1 id="第162期">第162期</h1>
<blockquote></blockquote>
<h1 id="第163期">第163期</h1>
<blockquote></blockquote>
<h1 id="第164期">第164期</h1>
<blockquote></blockquote>
<h1 id="第165期">第165期</h1>
<blockquote></blockquote>
<h1 id="第166期">第166期</h1>
<blockquote></blockquote>
<h1 id="第167期">第167期</h1>
<blockquote></blockquote>
<h1 id="第168期">第168期</h1>
<blockquote></blockquote>
<h1 id="第169期">第169期</h1>
<blockquote></blockquote>
<h1 id="第170期">第170期</h1>
<blockquote></blockquote>
<h1 id="第171期">第171期</h1>
<blockquote></blockquote>
<h1 id="第172期">第172期</h1>
<blockquote></blockquote>
<h1 id="第173期">第173期</h1>
<blockquote></blockquote>
<h1 id="第174期">第174期</h1>
<blockquote></blockquote>
<h1 id="第175期">第175期</h1>
<blockquote></blockquote>
<h1 id="第176期">第176期</h1>
<blockquote></blockquote>
<h1 id="第177期">第177期</h1>
<blockquote></blockquote>
<h1 id="第178期">第178期</h1>
<blockquote></blockquote>
<h1 id="第179期">第179期</h1>
<blockquote></blockquote>
<h1 id="第180期">第180期</h1>
<blockquote></blockquote>
<h1 id="第181期">第181期</h1>
<blockquote></blockquote>
<h1 id="第182期">第182期</h1>
<blockquote></blockquote>
<h1 id="第183期">第183期</h1>
<blockquote></blockquote>
<h1 id="第184期">第184期</h1>
<blockquote></blockquote>
<h1 id="第185期">第185期</h1>
<blockquote></blockquote>
<h1 id="第186期">第186期</h1>
<blockquote></blockquote>
<h1 id="第187期">第187期</h1>
<blockquote></blockquote>
<h1 id="第188期">第188期</h1>
<blockquote></blockquote>
<h1 id="第189期">第189期</h1>
<blockquote></blockquote>
<h1 id="第190期">第190期</h1>
<blockquote></blockquote>
<h1 id="第191期">第191期</h1>
<blockquote></blockquote>
<h1 id="第192期">第192期</h1>
<blockquote></blockquote>
<h1 id="第193期">第193期</h1>
<blockquote></blockquote>
<h1 id="第194期">第194期</h1>
<blockquote></blockquote>
<h1 id="第195期">第195期</h1>
<blockquote></blockquote>
<h1 id="第196期">第196期</h1>
<blockquote></blockquote>
<h1 id="第197期">第197期</h1>
<blockquote></blockquote>
<h1 id="第198期">第198期</h1>
<blockquote></blockquote>
<h1 id="第199期">第199期</h1>
<blockquote></blockquote>
<h1 id="第200期">第200期</h1>
<blockquote></blockquote>
]]></content>
    </entry>
</feed>