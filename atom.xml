<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-08-17T08:05:15.174Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第67期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-67-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-67-qi/">
        </link>
        <updated>2020-08-23T07:55:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597651219898.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>每当我找到成功的钥匙，就发现有人把锁芯给换了。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>研究表明，人体中的细菌细胞（约39万亿个微生物细胞）比人类细胞（约30万亿个细胞）更多，甚至有多达40个人类基因被认为起源于细菌。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>阴阴溪曲绿交加，小雨翻坪上浅沙。<br>
——晁冲之《春日》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我们生活在阴沟里，但有人依然仰望星空。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第66期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-66-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-66-qi/">
        </link>
        <updated>2020-08-22T07:54:55.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597651497345.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>如果你的前半声过得很坎坷，也不必太担心，下半生你就会适应的。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>德国空军曾在英吉利海峡安放了许多大型救生浮标，以供被击落的飞行员在其中生存下去。浮标内装有食物，酒精，衣物和纸牌游戏。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>只知逐胜忽忘寒，小立春风夕照间。<br>
——杨万里《雪后晚晴四山皆青惟东山全白赋最爱东山晴后雪二绝句》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我决定以人类的一个方法来感激你，我打算以身相许！</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote></blockquote>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第65期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-65-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-65-qi/">
        </link>
        <updated>2020-08-20T18:03:06.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597514634440.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>穷你就努力啊！不努力折腾，你怎么负债百万。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>自2000年以来，归功于辛迪加特许权使用费，《老友记》演员阵容中的每位成员每年都可以赚取2000万美元。华纳兄弟每年可由此赚取将近10亿美元。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>今宵酒醒何处，杨柳岸，晓风残月。<br>
——柳永《雨霖铃·寒蝉凄切》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>一个人的思想等于一个人的素养。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.kugou.com/song/#hash=0447BBC83D182D954645313153C376BB&amp;album_id=10496483">退-蒋蒋</a></p>
</blockquote>
<blockquote>
<p>我们乐此不疲<br>
沉迷情感游戏<br>
大雨总在纷纷扰扰中断句<br>
往事今非昔比<br>
回忆如一滩泥<br>
陷入沼泽的你遇到了天敌<br>
谎言变本加厉的说客<br>
好多委屈无法平复的过客</p>
</blockquote>
<blockquote>
<p>后退<br>
退到没了绝路我好狼狈<br>
撑到最后我不敢再奉陪<br>
流着眼泪装什么大无畏<br>
现在尝到无路可退孤独的滋味<br>
后退<br>
退到悬崖绝壁我好心碎<br>
粉身碎骨我不怕成野鬼<br>
你的眼角为什么还有泪<br>
终于明白我们都在黑夜里沉醉<br>
沉醉</p>
</blockquote>
<blockquote>
<p>往事今非昔比<br>
回忆如一滩泥<br>
陷入沼泽的你遇到了天敌<br>
谎言变本加厉的说客<br>
好多委屈无法平复的过客</p>
</blockquote>
<blockquote>
<p>后退<br>
退到没了绝路我好狼狈<br>
撑到最后我不敢再奉陪<br>
流着眼泪装什么大无畏<br>
现在尝到无路可退孤独的滋味<br>
后退<br>
退到悬崖绝壁我好心碎<br>
粉身碎骨我不怕成野鬼<br>
你的眼角为什么还有泪<br>
终于明白我们都在黑夜里沉醉</p>
</blockquote>
<blockquote>
<p>后退<br>
退到没了绝路我好狼狈<br>
撑到最后我不敢再奉陪<br>
流着眼泪装什么大无畏<br>
现在尝到无路可退孤独的滋味<br>
后退<br>
退到悬崖绝壁我好心碎<br>
粉身碎骨我不怕成野鬼<br>
你的眼角为什么还有泪<br>
终于明白我们都在黑夜里沉醉<br>
沉醉</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第64期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-64-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-64-qi/">
        </link>
        <updated>2020-08-19T17:43:45.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597514541881.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我的脑袋不是空的。我是要大作为的人，只是混沌初开。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>在安德鲁·朗格的另一版本《三只小猪》中，这些小猪被命名为：小棕，小白和小黑，敌人是一只狐狸而不是狼。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>烟横水际，映带几点归鸦，东风销尽龙沙雪。<br>
——贺铸《石州引·薄雨初寒》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>冰雪林中著此身，不同桃李混芳尘。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.kugou.com/song/#hash=559F29F094F1ABF732A8B3B433BBABCB&amp;album_id=1405819">炮火-郑子威</a></p>
</blockquote>
<blockquote>
<p>心死得不会痛<br>
像个英雄<br>
只管舍身去冲<br>
为你心动<br>
静默后患无穷<br>
泪眼通红<br>
锥心刻骨我懂<br>
如迎着炮火<br>
追赶你的脸庞<br>
少不了痛楚<br>
甘心放手一博<br>
从泥泞踏过<br>
看散落的花火<br>
捉不到一角</p>
</blockquote>
<blockquote>
<p>末路乐极迷途<br>
渐到荒芜<br>
辗转反侧跌倒<br>
未退一步<br>
自问误入歧途<br>
没听忠告<br>
一心只等破土</p>
</blockquote>
<blockquote>
<p>如迎着炮火<br>
充当炮灰的我<br>
将所有结果<br>
统统都抛给我<br>
如同着了魔<br>
勉强幸福好么<br>
真心未够多<br>
漠视着炮火<br>
充当炮兵不过<br>
想得到更多<br>
得到太多沮丧<br>
流言亦划破<br>
你却让我搜索</p>
</blockquote>
<blockquote>
<p>找不到一个</p>
</blockquote>
<blockquote>
<p>只得我一个</p>
</blockquote>
<blockquote>
<p>怎么我一个</p>
</blockquote>
<blockquote>
<p>用苦闷陪我</p>
</blockquote>
<blockquote>
<p>就向着炮火<br>
充当炮灰的我<br>
少不免痛楚<br>
撕心痛苦一个<br>
从泥泞踏过<br>
看散落的花火<br>
捉不到半颗<br>
别理会炮火<br>
充当炮兵不过<br>
想得到更多<br>
得到太多沮丧<br>
流言亦划破<br>
你却让我搜索<br>
他不会等我</p>
</blockquote>
<blockquote>
<p>道路上极疲劳<br>
患上孤独<br>
奄奄一息也好<br>
亦要追逐<br>
就是命运难逃<br>
被你俘虏<br>
早知一早结束</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第63期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-63-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-63-qi/">
        </link>
        <updated>2020-08-19T05:13:28.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597514572193.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>再努力一点，你就能走向，人生癫疯。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>将近50%的巴西模特来自巴西的南里奥格兰德州，而巴西的总人口中只有6%居住在那个州。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>楼头残梦五更钟，花底离愁三月雨。<br>
——晏殊《玉楼春·春恨》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我命令你，喜欢我！</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.kugou.com/song/#hash=E032025080D9ACB5F5ACD5918D8A1758&amp;album_id=38339036">飞鸟和婵-任然</a></p>
</blockquote>
<blockquote>
<p>你说青涩最搭初恋<br>
如小雪落下海岸线<br>
第五个季节某一天上演<br>
我们有相遇的时间<br>
你说空瓶适合许愿<br>
在风暖月光的地点<br>
第十三月你就如期出现<br>
海之角不再遥远</p>
</blockquote>
<blockquote>
<p>你骄傲的飞远<br>
我栖息的夏天<br>
听不见的宣言<br>
重复过很多年<br>
北纬线的思念被季风吹远<br>
吹远默念的侧脸<br>
吹远鸣唱的诗篇<br>
你骄傲的飞远<br>
我栖息的叶片<br>
去不同的世界<br>
却从不曾告别<br>
沧海月的想念羽化我昨天<br>
在我成熟的笑脸<br>
你却未看过一眼</p>
</blockquote>
<blockquote>
<p>你说空瓶适合许愿<br>
在风暖月光的地点<br>
第十三月你就如期出现<br>
海之角也不再遥远</p>
</blockquote>
<blockquote>
<p>你骄傲的飞远<br>
我栖息的夏天<br>
听不见的宣言<br>
重复过很多年<br>
北纬线的思念被季风吹远<br>
吹远默念的侧脸<br>
吹远鸣唱的诗篇<br>
你骄傲的飞远<br>
我栖息的叶片<br>
去不同的世界<br>
却从不曾告别<br>
沧海月的想念羽化我昨天<br>
在我成熟的笑脸<br>
你却未看过一眼</p>
</blockquote>
<blockquote>
<p>你骄傲的飞远<br>
我栖息的夏天<br>
听不见的宣言<br>
重复过很多年<br>
北纬线的思念被季风吹远<br>
吹远默念的侧脸<br>
吹远鸣唱的诗篇<br>
你骄傲的飞远<br>
我栖息的叶片<br>
去不同的世界<br>
却从不曾告别<br>
沧海月的想念羽化我昨天<br>
在我成熟的笑脸<br>
你却未看过一眼</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第62期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-62-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-62-qi/">
        </link>
        <updated>2020-08-18T03:00:26.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597202118445.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>其实表白未必是件好事，因为那样显得手黑。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>香蕉之所以具有弯曲的形状，是因为它们在生长时会趋向于阳光，这种独特的过程被称作“负向地性”。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>接天莲叶无穷碧，映日荷花别样红。<br>
——杨万里《晓出净慈寺送林子方》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>在不同的遭遇里我发现你的瞬间，有种不可言说的温柔直觉。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://www.kugou.com/song/f0m36d.html?frombaidu?frombaidu#hash=07B302EABC338A0B7E680A301C61AF9C&amp;album_id=542933">唐人-孙子涵</a></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1597209177220.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>一如昨日烛火<br>
伴扁舟相随<br>
哪有唐人不懂的陶醉<br>
我孤舟<br>
你窈窕<br>
岸上有隐晦<br>
一踏万里与谁相随<br>
你穿错了嫁妆怎能有快乐<br>
再上一层胭脂也华美<br>
一声戛然而止庭前的鞭炮<br>
妄想同你华发的心作废</p>
</blockquote>
<blockquote>
<p>你说不要自作自受自己创造伤悲<br>
谁都可以彻底忘记谁<br>
你说过往不及回首<br>
别后悔了才会<br>
想方设法地把你追回<br>
你说孤独是诗人应该具有的体会<br>
写歌的人就该有伤悲<br>
我点一丝烛火一时泛滥了思念<br>
写首小调名字叫后悔</p>
</blockquote>
<blockquote>
<p>你说不要自作自受自己创造伤悲<br>
谁都可以彻底忘记谁<br>
你说过往不及回首别后悔了才会<br>
想方设法地把你追回<br>
你说孤独是诗人应该具有的体会<br>
写歌的人就该有伤悲<br>
我点一丝烛火一时泛滥了思念<br>
写首小调名字叫后悔</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux终端更改字体]]></title>
        <id>https://2293736867.github.io/post/linux-zhong-duan-geng-gai-zi-ti/</id>
        <link href="https://2293736867.github.io/post/linux-zhong-duan-geng-gai-zi-ti/">
        </link>
        <updated>2020-08-17T07:10:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>这里的终端是指通过<code>F1-F6</code>/<code>F2-F7</code>进入的纯命令终端。</p>
<p>修改字体可以通过<code>setfont</code>命令。</p>
<h1 id="2-查看字体">2 查看字体</h1>
<p>可以通过查找目录<code>consolefonts</code>来确定本地机器上的字体位于哪里：</p>
<pre><code class="language-bash">find / -name consolefonts -type d
updatedb
locate consolefonts
</code></pre>
<p>比如笔者的<code>Manjaro</code>位于<code>/usr/share/kbd/consolefonts</code>，<code>CentOS8</code>则位于<code>/usr/lib/kbd/consolefonts</code>，而其他的一些可能位于<code>/lib/usr/consolefonts</code>，其中的文件如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200817151552939.png" alt="在这里插入图片描述" loading="lazy"><br>
一般为<code>.cp.gz</code>/<code>.psfu.gz</code>/<code>psf.gz</code>格式，后面的<code>.gz</code>表示<code>gzip</code>压缩，而其他的区别如下：</p>
<ul>
<li><code>.cp</code>：<code>CP</code>字体是<code>CPI</code>（<code>Code Page Information</code>）的<code>碎片</code>（<code>fragments</code>）,通过连接<code>CPEntryHeader</code>、<code>FontDataHeader</code>、<code>ScreenFontHeader</code>、<code>ScreenFontData</code>得到</li>
<li><code>.psf</code>/<code>.psfu</code>：<code>PC Screen Fonts</code>缩写，通常以<code>.psfu</code>形式存储</li>
</ul>
<h1 id="3-设置字体">3 设置字体</h1>
<p>很简单，使用<code>setfont</code>即可：</p>
<pre><code class="language-bash">setfont xxx.cp.gz/xxx.psfu.gz/xxx.psf.gz
</code></pre>
<p>对于<code>psfu</code>/<code>psf</code>文件名上面有字体大小，一般为<code>8</code>/<code>14</code>/<code>16</code>，对于<code>.cp.gz</code>字体需要指定大小，也是<code>8</code>/<code>14</code>/<code>16</code>。</p>
<h1 id="4-安装额外字体">4 安装额外字体</h1>
<p>如果系统提供的字体过小可以选择安装额外的字体包<code>Termius-fonts</code>，<a href="http://terminus-font.sourceforge.net/">戳这里</a>下载。</p>
<p>接着需要编译安装：</p>
<pre><code class="language-bash">./configure --prefix=/usr/local/consolefonts
make -j n # n为CPU核心数
sudo make install
</code></pre>
<p>然后就可以在对应的文件夹（<code>/usr/share/kbd/consolefonts</code>等）看到新增的字体了：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200817154328829.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这些字体以<code>ter-</code>开头，后面标注了大小，<code>b</code>表示粗体，<code>n</code>表示正常大小，提供了以下大小的字体：</p>
<ul>
<li><code>6x12</code></li>
<li><code>8x14</code></li>
<li><code>8x16</code></li>
<li><code>10x18</code></li>
<li><code>10x20</code></li>
<li><code>11x22</code></li>
<li><code>12x24</code></li>
<li><code>14x28</code></li>
<li><code>16x32</code></li>
</ul>
<p>使用<code>setfont</code>设置后即可看到效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot-如何设计优秀的后端接口?]]></title>
        <id>https://2293736867.github.io/post/springboot-ru-he-she-ji-you-xiu-de-hou-duan-jie-kou/</id>
        <link href="https://2293736867.github.io/post/springboot-ru-he-she-ji-you-xiu-de-hou-duan-jie-kou/">
        </link>
        <updated>2020-08-17T07:09:21.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B">2 新建工程</a></li>
<li><a href="#3-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">3 参数校验</a>
<ul>
<li><a href="#31-hibernate-validator">3.1 <code>Hibernate Validator</code></a>
<ul>
<li><a href="#311-%E4%BB%8B%E7%BB%8D">3.1.1 介绍</a></li>
<li><a href="#312-%E4%BD%BF%E7%94%A8">3.1.2 使用</a></li>
<li><a href="#313-%E6%B5%8B%E8%AF%95">3.1.3 测试</a></li>
</ul>
</li>
<li><a href="#32-%E6%A0%A1%E9%AA%8C%E6%A8%A1%E5%BC%8F%E8%AE%BE%E7%BD%AE">3.2 校验模式设置</a></li>
<li><a href="#33-valid%E4%B8%8Evalidated">3.3 <code>@Valid</code>与<code>@Validated</code></a></li>
<li><a href="#34-%E5%88%86%E7%BB%84">3.4 分组</a></li>
<li><a href="#35-%E7%BB%84%E5%BA%8F%E5%88%97">3.5 组序列</a></li>
<li><a href="#36-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C">3.6 自定义校验</a>
<ul>
<li><a href="#361-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">3.6.1 自定义注解</a></li>
<li><a href="#362-%E8%87%AA%E5%AE%9A%E4%B9%89validator">3.6.2 自定义<code>Validator</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">4 异常处理</a>
<ul>
<li><a href="#41-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">4.1 基本使用</a></li>
<li><a href="#42-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">4.2 自定义异常</a></li>
</ul>
</li>
<li><a href="#5-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94">5 数据响应</a>
<ul>
<li><a href="#51-%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E4%BD%93">5.1 统一响应体</a></li>
<li><a href="#52-%E5%93%8D%E5%BA%94%E7%A0%81%E6%9E%9A%E4%B8%BE">5.2 响应码枚举</a></li>
<li><a href="#53-%E5%85%A8%E5%B1%80%E5%8C%85%E8%A3%85%E5%93%8D%E5%BA%94%E4%BD%93">5.3 全局包装响应体</a></li>
<li><a href="#54-%E7%BB%95%E8%BF%87%E5%85%A8%E5%B1%80%E5%8C%85%E8%A3%85">5.4 绕过全局包装</a></li>
</ul>
</li>
<li><a href="#6-%E6%80%BB%E7%BB%93">6 总结</a></li>
<li><a href="#7-%E6%BA%90%E7%A0%81">7 源码</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83">8 参考</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>本篇文章以<code>Spring Boot</code>为基础，从以下三个方向讲述了如何设计一个优秀的后端接口体系：</p>
<ul>
<li>参数校验：涉及<code>Hibernate Validator</code>的各种注解，快速失败模式，分组，组序列以及自定义注解/<code>Validator</code></li>
<li>异常处理：涉及<code>ControllerAdvice</code>/<code>@RestControllerAdvice</code>以及<code>@ExceptionHandler</code></li>
<li>数据响应：涉及如何设计一个响应体以及如何包装响应体</li>
</ul>
<p>有了一个优秀的后端接口体系，不仅有了规范，同时扩展新的接口也很容易，本文演示了如何从零一步步构建一个优秀的后端接口体系。</p>
<h1 id="2-新建工程">2 新建工程</h1>
<p>打开熟悉的IDEA，选择依赖：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020081219161034.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>首先创建如下文件：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200812195604994.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p><code>TestController.java</code>：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/&quot;)
@CrossOrigin(value = &quot;http://localhost:3000&quot;)
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class TestController {
    private final TestService service;
    @PostMapping(&quot;test&quot;)
    public String test(@RequestBody User user)
    {
        return service.test(user);
    }
}
</code></pre>
<p>使用了<code>@RequiredArgsConstructor</code>代替<code>@Autowired</code>，由于笔者使用Postwoman测试，因此需要加上跨域注解<code>@CrossOrigin</code>，默认3000端口（Postwoman端口）。</p>
<p><code>TestService.java</code>：</p>
<pre><code class="language-java">@Service
public class TestService {
    public String test(User user)
    {
        if(StringUtils.isEmpty(user.getEmail()))
            return &quot;邮箱不能为空&quot;;
        if(StringUtils.isEmpty(user.getPassword()))
            return &quot;密码不能为空&quot;;
        if(StringUtils.isEmpty(user.getPhone()))
            return &quot;电话不能为空&quot;;
//        持久化操作
        return &quot;success&quot;;
    }
}
</code></pre>
<p>业务层首先进行了参数校验，这里省略了持久化操作。</p>
<p><code>User.java</code>：</p>
<pre><code class="language-java">@Data
public class User {
    private String phone;
    private String password;
    private String email;
}
</code></pre>
<h1 id="3-参数校验">3 参数校验</h1>
<p>首先来看一下参数校验，上面的例子中在业务层完成参数校验，这是没有问题的，但是，还没进行业务操作就需要进行这么多的校验显然这不是很好，更好的做法是，使用<code>Hibernate Validator</code>。</p>
<h2 id="31-hibernate-validator">3.1 <code>Hibernate Validator</code></h2>
<h3 id="311-介绍">3.1.1 介绍</h3>
<p><code>JSR</code>是<code>Java Specification Requests</code>的缩写，意思是Java规范提案，是指向<code>JCP(Java Community Process)</code>提出新增一个标准化技术规范的正式请求。<code>JSR-303</code>是<code>Java EE6</code>中的一项子规范，叫作<code>Bean Validation</code>，<code>Hibernate Validator</code>是<code>Bean Validator</code>的参考实现，除了实现所有<code>JSR-303</code>规范中的内置<code>constraint</code>实现，还有附加的<code>constraint</code>，详细如下：</p>
<ul>
<li><code>@Null</code>：被注解元素必须为<code>null</code>（为了节省篇幅下面用“元素”代表“被注解元素必须为”）</li>
<li><code>@NotNull</code>：元素不为<code>null</code></li>
<li><code>@AssertTrue</code>：元素为<code>true</code></li>
<li><code>@AssertFalse</code>：元素为<code>false</code></li>
<li><code>@Min(value)</code>：元素大于或等于指定值</li>
<li><code>@Max(value)</code>：元素小于或等于指定值</li>
<li><code>@DecimalMin(value)</code>：元素大于指定值</li>
<li><code>@DecimalMax(value)</code>：元素小于指定值</li>
<li><code>@Size(max,min)</code>：元素大小在给定范围内</li>
<li><code>@Digits(integer,fraction)</code>：元素字符串中的整数位数规定最大<code>integer</code>位，小数位数规定最大<code>fraction</code>位</li>
<li><code>@Past</code>：元素是一个过去日期</li>
<li><code>@Future</code>：元素是将来日期</li>
<li><code>@Pattern</code>：元素需要符合正则表达式</li>
</ul>
<p>其中<code>Hibernate Validator</code>附加的<code>constraint</code>如下：</p>
<ul>
<li><code>@Eamil</code>：元素为邮箱</li>
<li><code>@Length</code>：字符串大小在指定范围内</li>
<li><code>@NotEmpty</code>：字符串必须非空（目前最新的<code>6.1.5</code>版本已弃用，建议使用标准的<code>@NotEmpty</code>）</li>
<li><code>@Range</code>：数字在指定范围内</li>
</ul>
<p>而在<code>Spring</code>中，对<code>Hibernate Validation</code>进行了二次封装，添加了自动校验，并且校验信息封装进了特定的<code>BindingResult</code>中。下面看看如何使用。</p>
<h3 id="312-使用">3.1.2 使用</h3>
<p>在各个字段加上<code>@NotEmpty</code>，并且邮箱加上<code>@Email</code>，电话加上11位限制，并且在各个注解加上<code>message</code>，表示对应的提示信息：</p>
<pre><code class="language-java">@Data
public class User {
    @NotEmpty(message = &quot;电话不能为空&quot;)
    @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;)
    private String phone;
    @NotEmpty(message = &quot;密码不能为空&quot;)
    @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;)
    private String password;
    @NotEmpty(message = &quot;邮箱不能为空&quot;)
    @Email(message = &quot;邮箱格式不正确&quot;)
    private String email;
}
</code></pre>
<p>对于<code>String</code>来说有时候会使用<code>@NotNull</code>或<code>@NotBlank</code>，它们的区别如下：</p>
<ul>
<li><code>@NotEmpty</code>：不能为<code>null</code>并且长度必须大于0，除了<code>String</code>外，对于<code>Collection</code>/<code>Map</code>/数组也适用</li>
<li><code>@NotBlank</code>：只用于<code>String</code>，不能为<code>null</code>，并且调用<code>trim()</code>后，长度必须大于0，也就是必须有除空格外的实际字符</li>
<li><code>@NotNull</code>：不能为<code>null</code></li>
</ul>
<p>接着把业务层的参数校验操作删除，并把控制层修改如下：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
public String test(@RequestBody @Valid User user, BindingResult bindingResult)
{
    if(bindingResult.hasErrors())
    {
        for(ObjectError error:bindingResult.getAllErrors())
            return error.getDefaultMessage();
    }
    return service.test(user);
}
</code></pre>
<p>在需要校验的对象上加上<code>@Valid</code>，并且加上<code>BindingResult</code>参数，可以从中获取错误信息并返回。</p>
<h3 id="313-测试">3.1.3 测试</h3>
<p>全部都使用错误的参数设置，返回”邮箱格式不正确“：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200812213449630.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第二次测试中除了密码都使用正确的参数，返回”密码必须为6-20位“：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200812213537714.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>第三次测试全部使用正确的参数，返回”success“：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200812213700229.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="32-校验模式设置">3.2 校验模式设置</h2>
<p><code>Hibernate Validator</code>有两种校验模式：</p>
<ul>
<li>普通模式：默认模式，会校验所有属性，然后返回所有的验证失败信息</li>
<li>快速失败模式：只要有一个验证失败就返回</li>
</ul>
<p>使用快速失败模式需要通过<code>HibernateValidateConfiguration</code>以及<code>ValidateFactory</code>创建<code>Validator</code>，并且使用<code>Validator.validate()</code>进行手动验证。</p>
<p>首先添加一个生成<code>Validator</code>的类：</p>
<pre><code class="language-java">@Configuration
public class FailFastValidator&lt;T&gt; {
    private final Validator validator;
    public FailFastValidator()
    {
        validator = Validation
        .byProvider(HibernateValidator.class).configure()
		.failFast(true).buildValidatorFactory()
		.getValidator();
    }

    public Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T user)
    {
        return validator.validate(user);
    }
}
</code></pre>
<p>修改控制层的代码，通过<code>@RequiredArgsConstructor</code>注入<code>FailFastValidator&lt;User&gt;</code>，并把原来的在<code>User</code>上的<code>@Valid</code>去掉，在方法体进行手动验证：</p>
<pre><code class="language-java">@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class TestController {
    private final TestService service;
    private final FailFastValidator&lt;User&gt; validator;
    @PostMapping(&quot;test&quot;)
    public String test(@RequestBody User user, BindingResult bindingResult)
    {
        Set&lt;ConstraintViolation&lt;User&gt;&gt; message = validator.validate(user);
        message.forEach(t-&gt; System.out.println(t.getMessage()));
//        if(bindingResult.hasErrors())
//        {
//            bindingResult.getAllErrors().forEach(t-&gt;System.out.println(t.getDefaultMessage()));
//            for(ObjectError error:bindingResult.getAllErrors())
//                return error.getDefaultMessage();
//        }
        return service.test(user);
    }
}
</code></pre>
<p>测试（连续三次校验的结果）：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200812223302826.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>如果是普通模式（修改<code>.failFast(false)</code>），一次校验便会连续输出三个信息：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200812223038484.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="33-valid与validated">3.3 <code>@Valid</code>与<code>@Validated</code></h2>
<p><code>@Valid</code>是<code>javax.validation</code>包里面的，而<code>@Validated</code>是<code>org.springframework.validation.annotation</code>里面的，是<code>@Valid</code>的一次封装，相当于是<code>@Valid</code>的增强版，供Spring提供的校验机制使用，相比起<code>@Valid</code>，<code>@Validated</code>提供了分组以及组序列的功能。下面分别进行介绍。</p>
<h2 id="34-分组">3.4 分组</h2>
<p>当需要在不同的情况下使用不同的校验方式时，可以使用分组校验。比如在注册时不需要校验<code>id</code>，修改信息时需要校验<code>id</code>，但是默认的校验方式在两种情况下全部都校验，这时就需要使用分组校验。</p>
<p>下面以不同的组别校验电话号码长度的不同进行说明，修改<code>User</code>类如下：</p>
<pre><code class="language-java">@Data
public class User {
    @NotEmpty(message = &quot;电话不能为空&quot;)
    @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;,groups = {GroupA.class})
    @Length(min = 12,max = 12,message = &quot;电话号码必须12位&quot;,groups = {GroupB.class})
    private String phone;
    @NotEmpty(message = &quot;密码不能为空&quot;)
    @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;)
    private String password;
    @NotEmpty(message = &quot;邮箱不能为空&quot;)
    @Email(message = &quot;邮箱格式不正确&quot;)
    private String email;

    public interface GroupA{}
    public interface GroupB{}
}
</code></pre>
<p>在<code>@Length</code>中加入了组别，<code>GroupA</code>表示电话需要为11位，<code>GroupB</code>表示电话需要为12位，<code>GroupA</code>/<code>GroupB</code>是<code>User</code>中的两个空接口，然后修改控制层：</p>
<pre><code class="language-java">public String test(@RequestBody @Validated({User.GroupB.class}) User user, BindingResult bindingResult)
{
    if(bindingResult.hasErrors())
    {
        bindingResult.getAllErrors().forEach(t-&gt;System.out.println(t.getDefaultMessage()));
        for(ObjectError error:bindingResult.getAllErrors())
            return error.getDefaultMessage();
    }
    return service.test(user);
}
</code></pre>
<p>在<code>@Validated</code>中指定为<code>GroupB</code>，电话需要为12位，测试如下：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202008122243331.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="35-组序列">3.5 组序列</h2>
<p>默认情况下，不同组别的约束验证的无序的，也就是说，对于下面的<code>User</code>类：</p>
<pre><code class="language-java">@Data
public class User {
    @NotEmpty(message = &quot;电话不能为空&quot;)
    @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;)
    private String phone;
    @NotEmpty(message = &quot;密码不能为空&quot;)
    @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;)
    private String password;
    @NotEmpty(message = &quot;邮箱不能为空&quot;)
    @Email(message = &quot;邮箱格式不正确&quot;)
    private String email;
}
</code></pre>
<p>每次进行校验的顺序不同，三次测试结果如下：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2020081223504541.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200812235126903.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>有些时候顺序并不重要，而有些时候顺序很重要，比如：</p>
<ul>
<li>第二个组中的约束验证依赖于一个稳定状态运行，而这个稳定状态由第一个组来进行验证</li>
<li>某个组的验证比较耗时，CPU和内存的使用率相对较大，最优的选择是将其放在最后进行验证</li>
</ul>
<p>因此在进行组验证的时候需要提供一种有序的验证方式，一个组可以定义为其他组的序列，这样就可以固定每次验证的顺序而不是随机顺序，另外如果验证组序列中，前面的组验证失败，则后面的组不会验证。</p>
<p>例子如下，首先修改<code>User</code>类并定义组序列：</p>
<pre><code class="language-java">@Data
public class User {
    @NotEmpty(message = &quot;电话不能为空&quot;,groups = {First.class})
    @Length(min = 11,max = 11,message = &quot;电话号码必须11位&quot;,groups = {Second.class})
    private String phone;
    @NotEmpty(message = &quot;密码不能为空&quot;,groups = {First.class})
    @Length(min = 6,max = 20,message = &quot;密码必须为6-20位&quot;,groups = {Second.class})
    private String password;
    @NotEmpty(message = &quot;邮箱不能为空&quot;,groups = {First.class})
    @Email(message = &quot;邮箱格式不正确&quot;,groups = {Second.class})
    private String email;

    public interface First{}
    public interface Second{}
    @GroupSequence({First.class,Second.class})
    public interface Group{}
}
</code></pre>
<p>定义了两个空接口<code>First</code>和<code>Second</code>表示顺序，同时在<code>Group</code>中使用<code>@GroupSequence</code>指定了顺序。</p>
<p>接着修改控制层，在<code>@Validated</code>中定义组：</p>
<pre><code class="language-java">public String test(@RequestBody @Validated({User.Group.class}) User user, BindingResult bindingResult)
</code></pre>
<p>这样就能按照固定的顺序进行参数校验了。</p>
<h2 id="36-自定义校验">3.6 自定义校验</h2>
<p>尽管<code>Hibernate Validator</code>中的注解适用情况很广了，但是有时候需要特定的校验规则，比如密码强度，人为判定弱密码还是强密码。也就是说，此时需要添加自定义校验的方式，有两种处理方法：</p>
<ul>
<li>自定义注解</li>
<li>自定义<code>Validator</code></li>
</ul>
<p>首先来看一下自定义注解的方法。</p>
<h3 id="361-自定义注解">3.6.1 自定义注解</h3>
<p>这里添加一个判定弱密码的注解<code>WeakPassword</code>：</p>
<pre><code class="language-java">@Documented
@Constraint(validatedBy = WeakPasswordValidator.class)
@Target({ElementType.METHOD,ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface WeakPassword{
    String message() default &quot;请使用更加强壮的密码&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>
<p>同时添加一个实现了<code>ConstraintValidator&lt;A,T&gt;</code>的<code>WeakPasswordValidator</code>，当密码长度大于10位时才符合条件，否则返回<code>false</code>表示校验不通过：</p>
<pre><code class="language-java">public class WeakPasswordValidator implements ConstraintValidator&lt;WeakPassword,String&gt; {
    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        return s.length() &gt; 10;
    }
    @Override
    public void initialize(WeakPassword constraintAnnotation) {}
}
</code></pre>
<p>接着可以修改<code>User</code>如下，在对应的字段加上自定义注解<code>@WeakPassword</code>：</p>
<pre><code class="language-java">@Data
public class User {
	//...
    @WeakPassword(groups = {Second.class})
    private String password;
    //...
}
</code></pre>
<p>测试如下：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200813004854630.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="362-自定义validator">3.6.2 自定义<code>Validator</code></h3>
<p>除了自定义注解之外，还可以自定义<code>Validator</code>来实现自定义的参数校验，需要实现<code>Validator</code>接口：</p>
<pre><code class="language-java">@Component
public class WeakPasswordValidator implements Validator{
    @Override
    public boolean supports(Class&lt;?&gt; aClass) {
        return User.class.equals(aClass);
    }

    @Override
    public void validate(Object o, Errors errors) {
        ValidationUtils.rejectIfEmpty(errors,&quot;password&quot;,&quot;password.empty&quot;);
        User user = (User)o;
        if(user.getPassword().length() &lt;= 10)
            errors.rejectValue(&quot;password&quot;,&quot;Password is not strong enough!&quot;);
    }
}
</code></pre>
<p>实现其中的<code>supports</code>以及<code>validate</code>：</p>
<ul>
<li><code>support</code>：可以验证该类是否是某个类的实例</li>
<li><code>validate</code>：当<code>supports</code>返回<code>true</code>后，验证给定对象<code>o</code>，当出现错误时，向<code>errors</code>注册错误</li>
</ul>
<p><code>ValidationUtils.rejectIfEmpty</code>校验当对象<code>o</code>中某个字段属性为空时，向其中的<code>errors</code>注册错误，注意并不会中断语句的运行，也就是即使<code>password</code>为空，<code>user.getPassword()</code>还是会运行，这时会抛出空指针异常。下面的<code>errors.rejectValue</code>同样道理，并不会中断语句的运行，只是注册了错误信息，中断的话需要手动抛出异常。</p>
<p>修改控制层中的返回值，改为<code>getCode()</code>：</p>
<pre><code class="language-java">if(bindingResult.hasErrors())
{
    bindingResult.getAllErrors().forEach(t-&gt; System.out.println(t.getCode()));
    for(ObjectError error:bindingResult.getAllErrors())
        return error.getCode();
}
return service.test(user);
</code></pre>
<p>测试：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200813010112193.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-异常处理">4 异常处理</h1>
<p>到这里参数校验就完成了，下一步是处理异常。</p>
<p>如果将参数校验中的<code>BindingResult</code>去掉，就会将整个后端异常返回给前端：</p>
<pre><code class="language-java">//public String test(@RequestBody @Validated({User.Group.class}) User user, BindingResult bindingResult)
public String test(@RequestBody @Validated({User.Group.class}) User user)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200813010442652.png" alt="在这里插入图片描述" loading="lazy"><br>
这样虽然后端是方便了，不需要每一个接口都加上<code>BindingResult</code>，但是前端不好处理，整个异常都返回了，因此后端需要捕捉这些异常，但是，不能手动去捕捉每一个，这样还不如之前使用<code>BindingResult</code>，这种情况下就需要用到全局的异常处理。</p>
<h2 id="41-基本使用">4.1 基本使用</h2>
<p>处理全局异常的步骤如下：</p>
<ul>
<li>创建全局异常处理的类：加上<code>@ControllerAdvice</code>/<code>@RestControllerAdvice</code>注解（取决于控制层用的是<code>@Controller</code>/<code>@RestController</code>，<code>@Controller</code>可以跳转到相应页面，返回<code>JSON</code>等加上<code>@ResponseBody</code>即可，而<code>@RestController</code>相当于<code>@Controller</code>+<code>@ResponseBody</code>，返回<code>JSON</code>无需加上<code>@ResponseBody</code>，但是视图解析器无法解析<code>jsp</code>以及<code>html</code>页面）</li>
<li>创建异常处理方法：加上<code>@ExceptionHandler</code>指定想要处理的异常类型</li>
<li>处理异常：在对应的处理异常方法中处理异常</li>
</ul>
<p>这里增加一个全局异常处理类<code>GlobalExceptionHandler</code>：</p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public String methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e)
    {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        return error.getDefaultMessage();
    }
}
</code></pre>
<p>首先加上<code>@RestControllerAdvice</code>，并在异常处理方法上加上<code>@ExceptionHandler</code>。</p>
<p>接着修改控制层，去掉其中的<code>BindingResult</code>：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
public String test(@RequestBody @Validated({User.Group.class}) User user)
{
    return service.test(user);
}
</code></pre>
<p>然后就可以进行测试了：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200813014101131.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>全局异常处理相比起原来的每一个接口都加上<code>BindingResult</code>方便很多，而且可以集中处理所有异常。</p>
<h2 id="42-自定义异常">4.2 自定义异常</h2>
<p>很多时候都会用到自定义异常，这里新增一个测试异常<code>TestException</code>：</p>
<pre><code class="language-java">@Data
public class TestException extends RuntimeException{
    private int code;
    private String msg;

    public TestException(int code,String msg)
    {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    public TestException()
    {
        this(111,&quot;测试异常&quot;);
    }

    public TestException(String msg)
    {
        this(111,msg);
    }
}
</code></pre>
<p>接着在刚才的全局异常处理类中添加一个处理该异常的方法：</p>
<pre><code class="language-java">@ExceptionHandler(TestException.class)
public String testExceptionHandler(TestException e)
{
    return e.getMsg();
}
</code></pre>
<p>在控制层进行测试：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
public String test(@RequestBody @Validated({User.Group.class}) User user)
{
    throw new TestException(&quot;出现异常&quot;);
//        return service.test(user);
}
</code></pre>
<p>结果如下：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200813015033222.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-数据响应">5 数据响应</h1>
<p>在处理好了参数校验以及异常处理之后，下一步就是要设置统一的规范化的响应数据，一般来说无论响应成功还是失败都会有一个状态码，响应成功还会携带响应数据，响应失败则携带相应的失败信息，因此，第一步是设计一个统一的响应体。</p>
<h2 id="51-统一响应体">5.1 统一响应体</h2>
<p>统一响应体需要创建响应体类，一般来说，响应体需要包含：</p>
<ul>
<li>状态码：<code>String</code>/<code>int</code></li>
<li>响应信息：<code>String</code></li>
<li>响应数据：<code>Object</code>/<code>T</code>（泛型）</li>
</ul>
<p>这里简单的定义一个统一响应体<code>Result</code>：</p>
<pre><code class="language-java">@Data
@AllArgsConstructor
public class Result&lt;T&gt; {
    private String code;
    private String message;
    private T data;
}
</code></pre>
<p>接着修改全局异常处理类：</p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e)
    {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        return new Result&lt;&gt;(error.getCode(),&quot;参数校验失败&quot;,error.getDefaultMessage());
    }

    @ExceptionHandler(TestException.class)
    public Result&lt;String&gt; testExceptionHandler(TestException e)
    {
        return new Result&lt;&gt;(e.getCode(),&quot;失败&quot;,e.getMsg());
    }
}
</code></pre>
<p>使用<code>Result&lt;String&gt;</code>封装返回值，测试如下：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200813020245943.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到返回了一个比较友好的信息，无论是响应成功还是响应失败都会返回同一个响应体，当需要返回具体的用户数据时，可以修改控制层接口直接返回<code>Result&lt;User&gt;</code>：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
public Result&lt;User&gt; test(@RequestBody @Validated({User.Group.class}) User user)
{
    return service.test(user);
}
</code></pre>
<p>测试：</p>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200813020749494.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="52-响应码枚举">5.2 响应码枚举</h2>
<p>通常来说可以把响应码做成枚举类：</p>
<pre><code class="language-java">@Getter
public enum ResultCode {
    SUCCESS(&quot;111&quot;,&quot;成功&quot;),FAILED(&quot;222&quot;,&quot;失败&quot;);

    private final String code;
    private final String message;
    ResultCode(String code,String message)
    {
        this.code = code;
        this.message = message;
    }
}
</code></pre>
<p>枚举类封装了状态码以及信息，这样在返回结果时，只需要传入对应的枚举值以及数据即可：</p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e)
    {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        return new Result&lt;&gt;(ResultCode.FAILED,error.getDefaultMessage());
    }

    @ExceptionHandler(TestException.class)
    public Result&lt;String&gt; testExceptionHandler(TestException e)
    {
        return new Result&lt;&gt;(ResultCode.FAILED,e.getMsg());
    }
}
</code></pre>
<h2 id="53-全局包装响应体">5.3 全局包装响应体</h2>
<p>统一响应体是个很好的想法，但是还可以再深入一步去优化，因为每次返回之前都需要对响应体进行包装，虽然只是一行代码但是每个接口都需要包装一下，这是个很麻烦的操作，为了更进一步“偷懒”，可以选择实现<code>ResponseBodyAdvice&lt;T&gt;</code>来进行全局的响应体包装。</p>
<p>修改原来的全局异常处理类如下：</p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler implements ResponseBodyAdvice&lt;Object&gt; {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result&lt;String&gt; methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e)
    {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        return new Result&lt;&gt;(ResultCode.FAILED,error.getDefaultMessage());
    }

    @ExceptionHandler(TestException.class)
    public Result&lt;String&gt; testExceptionHandler(TestException e)
    {
        return new Result&lt;&gt;(ResultCode.FAILED,e.getMsg());
    }

    @Override
    public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) {
        return !methodParameter.getParameterType().equals(Result.class);
    }

    @Override
    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {
        return new Result&lt;&gt;(o);
    }
}
</code></pre>
<p>实现了<code>ResponseBodyAdvice&lt;Object&gt;</code>：</p>
<ul>
<li><code>supports</code>方法：判断是否支持控制器返回方法类型，可以通过<code>supports</code>判断哪些类型需要包装，哪些不需要包装直接返回</li>
<li><code>beforeBodyWrite</code>方法：当<code>supports</code>返回<code>true</code>后，对数据进行包装，这样在返回数据时就无需使用<code>Result&lt;User&gt;</code>手动包装，而是直接返回<code>User</code>即可</li>
</ul>
<p>接着修改控制层，直接返回实体类<code>User</code>而不是响应体包装类<code>Result&lt;User&gt;</code>：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
public User test(@RequestBody @Validated({User.Group.class}) User user)
{
    return service.test(user);
}
</code></pre>
<p>测试输出如下：</p>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/2020081302330331.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="54-绕过全局包装">5.4 绕过全局包装</h2>
<p>虽然按照上面的方式可以使后端的数据全部按照统一的形式返回给前端，但是有时候并不是返回给前端而是返回给其他第三方，这时候不需要<code>code</code>以及<code>msg</code>等信息，只是需要数据，这样的话，可以提供一个在方法上的注解来绕过全局的响应体包装。</p>
<p>比如添加一个<code>@NotResponseBody</code>注解：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface NotResponseBody {
}
</code></pre>
<p>接着需要在处理全局包装的类中，在<code>supports</code>中进行判断：</p>
<pre><code class="language-java">@Override
public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) {
    return !(
    	methodParameter.getParameterType().equals(Result.class) 
    	||
    	methodParameter.hasMethodAnnotation(NotResponseBody.class)
    );
}
</code></pre>
<p>最后修改控制层，在需要绕过的方法上添加自定义注解<code>@NotResponseBody</code>即可：</p>
<pre><code class="language-java">@PostMapping(&quot;test&quot;)
@NotResponseBody
public User test(@RequestBody @Validated({User.Group.class}) User user)
</code></pre>
<h1 id="6-总结">6 总结</h1>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200813163748104.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="7-源码">7 源码</h1>
<p>直接clone下来使用IDEA打开即可，每一次优化都做了一次提交，可以看到优化的过程，喜欢的话欢迎给个star：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootValidation-ExceptionHandler-DataResponse">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootValidation-ExceptionHandler-DataResponse">码云</a></li>
</ul>
<h1 id="8-参考">8 参考</h1>
<p>1、<a href="http://unclechen.github.io/2018/12/15/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/">UncleChen的博客-SpringBoot自定义请求参数校验</a><br>
2、<a href="https://www.jianshu.com/p/1dff31a1649d">简书-@Valid和@Validated的总结区分</a><br>
3、<a href="https://www.cnblogs.com/shuaifing/p/8119664.html">博客园-@Controller与@RestController的区别</a><br>
4、<a href="https://www.jianshu.com/p/b5b8613769db">简书-【项目实践】-SpringBoot三招组合拳，手把手教你打出优雅的后端接口</a><br>
5、<a href="https://www.jianshu.com/p/ecc41e873fe3">简书-【项目实践】后端接口统一规范的同时，如何优雅得扩展规范</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第61期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-61-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-61-qi/">
        </link>
        <updated>2020-08-17T02:59:10.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597201421205.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>失败不可怕，可怕的是，你还相信这句话。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>在一群小丑鱼中，只有一条雌鱼处于严格等级制度的顶部，只有两条小丑鱼通过外部受精进行繁殖。由于它们雌雄同体，因此当为首的雌鱼死亡后，最大，最占优势的雄鱼就会变成雌鱼。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>阳羡溪声冷骇人，洞庭山翠晚凝神。<br>
——高蟾《秋》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>为什么要担心？如果努力了，担心不会让结果变得更好。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="http://bd.kuwo.cn/play_detail/1225720?from=baidu">撕心-钟洁</a></p>
</blockquote>
<blockquote>
<p>来跟着我唱<br>
好<br>
咳 我想就这样牵着你的手不妨开<br>
我想就这样<br>
唉呀不是你那样的是我这样的<br>
唉呀<br>
我想就这样牵着你的手不妨开<br>
我想就这样<br>
你找打是吧 故意瞎唱</p>
</blockquote>
<blockquote>
<p>你还记得么<br>
两年前<br>
我们这么幸福快乐<br>
一起唱着<br>
可现在<br>
你在哪里<br>
牵着谁的手呢</p>
</blockquote>
<blockquote>
<p>沉默<br>
是因为情绪的低落<br>
考虑好久<br>
才会选择分手<br>
心好痛<br>
是因为爱划了一道伤口<br>
泪在流<br>
声音开始颤抖</p>
</blockquote>
<blockquote>
<p>沉默<br>
是因为找不到理由<br>
冷战很久<br>
最后还是开口<br>
别难过<br>
你会遇到给你幸福的人<br>
原谅我<br>
配不上你的温柔</p>
</blockquote>
<blockquote>
<p>你承诺爱我很久很久<br>
怎么现在<br>
你让我猜不透<br>
对不起<br>
我不能满足你所有<br>
茫茫路口只能擦肩而过<br>
爱停留<br>
你离开以后我哭了很久<br>
躲在房间<br>
我看不到彩虹<br>
夜太深<br>
是谁还徘徊在门口<br>
有些梦关了灯才能拥有<br>
你的吻</p>
</blockquote>
<blockquote>
<p>开门<br>
你别来找我了好吧 我不是已经对你讲过了我们已经分手了<br>
哎你有毛病吧 谁答应跟你分手了<br>
你不要再背着我去问我朋友我怎么怎么样<br>
你能不能听我说两句啊<br>
这就够了 就这样<br>
好 你别后悔<br>
拜拜</p>
</blockquote>
<blockquote>
<p>爱情<br>
怎么让我百感交集<br>
太多惊喜<br>
害我措手不及<br>
背着你<br>
无时无刻打听你的消息<br>
很爱你<br>
所以不愿放弃</p>
</blockquote>
<blockquote>
<p>爱情<br>
只会让人得意忘形<br>
哭红眼睛<br>
也躲不过伤心<br>
仔细听<br>
是回忆狠狠撕碎你的心<br>
在梦里<br>
却痛得好清醒</p>
</blockquote>
<blockquote>
<p>你离开以后我哭了很久<br>
躲在房间<br>
我看不到彩虹<br>
夜太深<br>
是谁还徘徊在门口<br>
有些梦关了灯才能拥有<br>
你的吻</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第60期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-60-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-60-qi/">
        </link>
        <updated>2020-08-15T16:40:51.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1597164791511.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>人都需要努力的，努力过后你就会发现，你还真的是很普通。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>米开朗基罗是第三位接手制造大卫雕像的雕刻家。这块卡拉拉大理石本身品质平庸，遭到第二位雕刻家嫌弃后废置约25年，最后由米开朗基罗出手将其雕刻成了杰作。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>梧桐叶上三更雨，叶叶声声是别离。<br>
——周紫芝《鹧鸪天·一点红残欲尽时》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>农民家的孩子啊，他们的第一堂功课就是劳动！</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=440241194">樱花樱花想见你-李蚊香/满汉全席</a></p>
</blockquote>
<blockquote>
<p>『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
だいじょうぶ もう泣かないで<br>
私は風 あなたを包んでいるよ<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
ありがとう ずっと大好き<br>
私は星 あなたを見守り続ける<br>
あなたに出会えてよかった<br>
本当に本当によかった<br>
ここにもういれなくなっちゃった<br>
もう行かなくちゃ ホントゴメンね<br>
私はもう一人で遠いところに行かなくちゃ<br>
どこへ?って聞かないで<br>
なんで?って聞かないで ホントゴメンね<br>
私はもうあなたのそばにいられなくなったの<br>
いつもの散歩道 桜並木を抜けてゆき<br>
よく遊んだ川面の上の 空の光る方へと<br>
もう会えなくなるけど<br>
寂しいけど 平気だよ<br>
生まれてよかった ホントよかった<br>
あなたに出会ってよかった<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
だいじょうぶ もう泣かないで<br>
私は風 あなたを包んでいるよ<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
ありがとう ずっと大好き<br>
私は星 あなたを見守り続ける<br>
あなたに出会えてよかった<br>
本当に本当によかった<br>
あなたの帰りを待つ午後<br>
あなたの足音 何げないこと<br>
私はそう、一番の喜びを知りました<br>
あなたが話してくれたこと<br>
一日のこと いろいろなこと<br>
私はそう、一番の悲しみも知りました<br>
それはあなたの笑顔 あなたの涙 その優しさ<br>
私の名を呼ぶ声 抱き締める腕 その温もり<br>
もう触れられないけど 忘れないよ 幸せだよ<br>
生まれてよかった ホントよかった<br>
あなたに出会ってよかった<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
だいじょうぶだよ ここにいる<br>
私は春 あなたを抱く空<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
ありがとう ずっと大好き<br>
私は鳥 あなたに歌い続ける<br>
桜の舞う空の彼方<br>
目を閉じれば心の中<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
いいんだよ 微笑んでごらん<br>
私は花 あなたの指先の花<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
ありがとう ずっと大好き<br>
私は愛 あなたの胸に<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
だいじょうぶ もう泣かないで<br>
私は風 あなたを包んでいるよ<br>
『さくら さくら 会いたいよ<br>
いやだ 君に今すぐ会いたいよ<br>
ありがとう ずっと大好き<br>
私は星 あなたを見守り続ける<br>
あなたに出会えてよかった<br>
本当に本当によかった<br>
本当に本当によかった</p>
</blockquote>
]]></content>
    </entry>
</feed>