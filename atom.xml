<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-01-02T03:56:43.791Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第204期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-204-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-204-qi/">
        </link>
        <updated>2021-01-04T03:53:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>没有什么事情能把人一次击倒，只要足够坚强，它会持续的把你击倒。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>红影湿幽窗，瘦尽春光。<br>
——纳兰性德《浪淘沙·红影湿幽窗》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>心系一处，守口如瓶。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第203期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-203-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-203-qi/">
        </link>
        <updated>2021-01-03T03:51:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>自古情深留不住，总是套路得人心。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>雨暗初疑夜，风回忽报晴。<br>
——苏轼《南歌子·寓意》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>是个男人就要对自己的人生负责。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第202期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-202-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-202-qi/">
        </link>
        <updated>2021-01-02T03:47:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>以前我每天都会买彩票，终于有一天，我连彩票都买不起了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>地晴丝冉冉，江白草纤纤。<br>
——杜甫《绝句六首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>祈愿万家灯火熨烫过脉络，刀山与火海多深刻，都陪你渡过。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第201期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-201-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-201-qi/">
        </link>
        <updated>2021-01-01T03:44:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>出卖自己的灵魂和原则并不丢人，丢人的是没能卖一个好价钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>青海长云暗雪山，孤城遥望玉门关。<br>
——王昌龄《从军行七首·其四》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>忘掉生日，忘掉青涩的诗，忘掉他不厌其烦夜夜追逐他影子。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第200期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-200-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-200-qi/">
        </link>
        <updated>2020-12-31T12:50:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你要是喜欢一个女生，就好好学习找个好工作挣好多好多钱，等她结婚的时候多出点份子钱。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>石燕拂云晴亦雨，江豚吹浪夜还风。<br>
——许浑《金陵怀古》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>跌跌撞撞的成长，又美又疼才是本质。</p>
</blockquote>
<h1 id="跨年">跨年</h1>
<p>2020，就是结束了啊。</p>
<p>感觉，过得很快。</p>
<p>害。</p>
<p>又，</p>
<p>老了一年。</p>
<p>青春啊。</p>
<h1 id="200期总结">200期总结</h1>
<p>不知不觉，这东西已经，200期了。</p>
<p>有时需要做不到日更，但是有空还是补了回来。</p>
<p>虽然不知道这东西有多少读者看，</p>
<p>但是起码也是一种坚持吧。</p>
<p>当然有时候在这里写一些感叹还是挺合适的，</p>
<p>哈哈哈哈。</p>
<h1 id="祝各位读者新年快乐啦">祝各位读者新年快乐啦！</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECDSA密钥对生成以及在Token中的应用]]></title>
        <id>https://2293736867.github.io/post/ecdsa-mi-yao-dui-sheng-cheng-yi-ji-zai-token-zhong-de-ying-yong/</id>
        <link href="https://2293736867.github.io/post/ecdsa-mi-yao-dui-sheng-cheng-yi-ji-zai-token-zhong-de-ying-yong/">
        </link>
        <updated>2020-12-31T12:46:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p>本文主要讲述了如何利用<code>Openssl</code>生成<code>ECDSA</code>密钥对，并利用<code>Auth0</code>库进行<code>Token</code>生成及验证的过程。</p>
<h1 id="2-ecdsa">2 <code>ECDSA</code></h1>
<h2 id="21-简介">2.1 简介</h2>
<p><code>ECC</code>（<code>Elliptic Curve Cryptography</code>，椭圆曲线加密）是一种基于椭圆曲线数学的公钥加密算法，而<code>ECDSA</code>是使用<code>ECC</code>对数字签名算法（<code>DSA</code>）的模拟，总的来说<code>ECC</code>相比起常见的<code>RSA</code>更加安全并且生成密钥对的过程会更快。本文不会涉及过多原理性的东西，只是作简单的介绍，想要详情了解这些算法的可以<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">戳这里</a>。</p>
<h2 id="22-密钥对生成">2.2 密钥对生成</h2>
<p>在<code>Openssl</code>中生成<code>ECDSA</code>密钥对的流程如下：</p>
<pre><code class="language-bash">openssl ecparam -genkey -name secp521r1 -out private.pem #生成私钥
openssl ec -in private.pem -pubout -out public.pem #生成公钥
</code></pre>
<p>参数说明如下：</p>
<ul>
<li><code>ecparam</code>：<code>EC</code>参数设置以及生成命令</li>
<li><code>-genkey</code>：使用特定参数生成<code>EC</code>私钥</li>
<li><code>-name</code>：<code>ec</code>参数，可以使用<code>openssl ecparam -list_curves</code>查看，这里用的是<code>secp521r1</code></li>
<li><code>-out</code>：输出文件名</li>
<li><code>ec</code>：<code>EC</code>密钥处理命令</li>
<li><code>-in</code>：输入文件</li>
<li><code>-pubout</code>：默认情况下会输出私钥，加上该选项会变成输出公钥（如果输入是公钥的情况下该参数会自动设置）</li>
</ul>
<p>执行完命令后就成功生成密钥对了，可以查看一下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201231184510714.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>密钥对生成之后就可以准备一下生成<code>Token</code>了。</p>
<h1 id="3-auth0中的token应用">3 <code>Auth0</code>中的<code>Token</code>应用</h1>
<h2 id="31-auth0">3.1 <code>Auth0</code></h2>
<p><code>Auth0</code>提供了验证以及授权服务，这里利用官方提供的<code>Java</code>实现去生成<code>Token</code>（这里插一句题外话，<code>Java</code>常用的<code>Token</code>实现还有一个叫<code>JJWT</code>的库），首先引入包：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.auth0&lt;/groupId&gt;
    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;
    &lt;version&gt;3.12.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>：</p>
<pre><code class="language-bash">compile group: 'com.auth0', name: 'java-jwt', version: '3.12.0'
</code></pre>
<p>引入后来看一下支持的加密算法，如下图：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201231184815559.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>最简单的使用<code>HMAC</code>算法生成的<code>Token</code>如下：</p>
<pre><code class="language-java">System.out.println(JWT.create().withIssuer(&quot;issuer&quot;).withAudience(&quot;content&quot;).sign(Algorithm.HMAC512(&quot;password&quot;)));
</code></pre>
<p>当然这不是本文的重点，本文的重点是介绍如何利用<code>ECDSA</code>去生成<code>Token</code>。</p>
<p>首先<code>Auth0</code>提供的签名<code>api</code>如下：</p>
<pre><code class="language-java">JWT.create().sign(Algorithm)
</code></pre>
<p>其中<code>Algorithm</code>可以取值如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20201231185509373.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201231185539866.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>想要使用<code>ECDSA</code>算法需要提供一个<code>ECDSAKeyProvider</code>或一个<code>ECPublicKey</code>和一个<code>ECPrivateKey</code>，这里选择后一种方式实现。</p>
<h2 id="32-密钥对处理">3.2 密钥对处理</h2>
<p>官方并没有提供如何生成<code>ECPublicKey</code>/<code>ECPrivateKey</code>的方法，甚至连从文件读取密钥对的方法都没有提供，笔者从官方提供的<a href="https://github.com/auth0/java-jwt/blob/6b802545d97d40208ea0c3945f5300da904fcf45/lib/src/test/java/com/auth0/jwt/algorithms/ECDSAAlgorithmTest.java">测试代码</a>中发现了如下方法：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20201231190113708.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>其中核心就是读取密钥对的两个方法：</p>
<ul>
<li><code>readPublicKeyFromFile</code></li>
<li><code>readPrivateKeyFromFile</code></li>
</ul>
<p>从<code>import</code>结果可以看到这是一个工具类：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20201231190230365.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>但问题是官方该工具类是测试使用的，换句话说不对外暴露的，在<code>IDEA</code>中直接引入会报错：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201231190332726.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>因此直接找到该工具类的源码（链接可以<a href="https://github.com/auth0/java-jwt/blob/6b802545d97d40208ea0c3945f5300da904fcf45/lib/src/test/java/com/auth0/jwt/PemUtils.java">戳这里</a>，需要引入<code>bouncycastle</code>包，<code>Maven</code>仓库链接可以<a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on">戳这里</a>）</p>
<pre><code class="language-java">package com.auth0.jwt;

import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class PemUtils {

    private static byte[] parsePEMFile(File pemFile) throws IOException {
        if (!pemFile.isFile() || !pemFile.exists()) {
            throw new FileNotFoundException(String.format(&quot;The file '%s' doesn't exist.&quot;, pemFile.getAbsolutePath()));
        }
        PemReader reader = new PemReader(new FileReader(pemFile));
        PemObject pemObject = reader.readPemObject();
        byte[] content = pemObject.getContent();
        reader.close();
        return content;
    }

    private static PublicKey getPublicKey(byte[] keyBytes, String algorithm) {
        PublicKey publicKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
            publicKey = kf.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException e) {
            System.out.println(&quot;Could not reconstruct the public key, the given algorithm could not be found.&quot;);
        } catch (InvalidKeySpecException e) {
            System.out.println(&quot;Could not reconstruct the public key&quot;);
        }

        return publicKey;
    }
    
    private static PrivateKey getPrivateKey(byte[] keyBytes, String algorithm) {
        PrivateKey privateKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
            privateKey = kf.generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException e) {
            System.out.println(&quot;Could not reconstruct the private key, the given algorithm could not be found.&quot;);
        } catch (InvalidKeySpecException e) {
            System.out.println(&quot;Could not reconstruct the private key&quot;);
        }

        return privateKey;
    }

    public static PublicKey readPublicKeyFromFile(String filepath, String algorithm) throws IOException {
        byte[] bytes = PemUtils.parsePEMFile(new File(filepath));
        return PemUtils.getPublicKey(bytes, algorithm);
    }

    public static PrivateKey readPrivateKeyFromFile(String filepath, String algorithm) throws IOException {
        byte[] bytes = PemUtils.parsePEMFile(new File(filepath));
        return PemUtils.getPrivateKey(bytes, algorithm);
    }
}
</code></pre>
<p>直接复制该工具类后，将前一步生成的<code>private.pem</code>以及<code>public.pem</code>放置合适位置，通过工具类读取并生成<code>Token</code>：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        try {
            ECPublicKey publicKey = (ECPublicKey) PemUtils.readPublicKeyFromFile(&quot;src/main/resources/public.pem&quot;,&quot;EC&quot;);
            ECPrivateKey privateKey = (ECPrivateKey) PemUtils.readPrivateKeyFromFile(&quot;src/main/resources/private.pem&quot;,&quot;EC&quot;);
            Algorithm algorithm = Algorithm.ECDSA512(publicKey,privateKey);
            String token = JWT.create()
                    .withIssuer(&quot;issuer&quot;)
                    .sign(algorithm);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(JWT.decode(token));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>但是会报错说私钥是<code>null</code>：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20201231191117155.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>从官方<code>issue</code>中查到了类似的<a href="https://github.com/auth0/java-jwt/issues/270">问题</a>：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20201231191417875.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>回答说是密钥格式的问题，其中提到的<code>pkcs8</code>是<a href="https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html">私钥格式转换命令</a>：</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20201231191634348.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>将私钥的格式进行转换：</p>
<pre><code class="language-bash">openssl pkcs8 -topk8 -inform pem -in private.pem -outform pem -nocrypt -out newprivate.pem
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>pkcs8</code>：私钥格式转换命令</li>
<li><code>-topk8</code>：读取私钥并转换为<code>PKCS#8</code>格式</li>
<li><code>-inform</code>：指定输入格式，默认<code>pem</code>，使用该参数并配合<code>-topk8</code>后会生成加密后的<code>PKCS#8</code>格式的私钥</li>
<li><code>-in</code>：输入文件</li>
<li><code>-outform</code>：与<code>-inform</code>类似</li>
<li><code>-nocrypt</code>：在这里主要配合<code>-inform</code>+<code>-topk8</code>使用，生成不加密的<code>PrivateKeyInfo</code>而不是加密的<code>PKCS#8 EncryptedPrivateKeyInfo</code>，因为一些软件（比如某些版本的<code>Java</code>代码）使用的是不加密格式的私钥</li>
<li><code>-out</code>：输出文件</li>
</ul>
<p>转换后就可以生成<code>Token</code>了。</p>
<h2 id="33-生成token">3.3 生成<code>Token</code></h2>
<p>最后<code>readPrivateKeyFromFile</code>中的参数修改为新的私钥即可：</p>
<pre><code class="language-bash">ECPrivateKey privateKey = (ECPrivateKey) PemUtils.readPrivateKeyFromFile(&quot;src/main/resources/newprivate.pem&quot;,&quot;EC&quot;);
</code></pre>
<h1 id="4-参考源码">4 参考源码</h1>
<p>包含了示例密钥对以及如何使用（<code>Gradle</code>版的）：</p>
<ul>
<li><a href="https://github.com/2293736867/ECDSA-Auth0-Token-Demo">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/ECDSA-Auth0-Token-Demo">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/ECDSA-Auth0-Token-Demo">CODE.CHINA</a></li>
</ul>
<h1 id="5-参考网站">5 参考网站</h1>
<p>1、<a href="https://zhuanlan.zhihu.com/p/36326221">知乎-ECC椭圆曲线加密算法：介绍</a></p>
<p>2、<a href="https://www.chainnode.com/tutorial/140">什么是椭圆曲线数字签名算法（ECDSA）？</a></p>
<p>3、<a href="https://andrea.corbellini.name/2015/06/08/elliptic-curve-cryptography-breaking-security-and-a-comparison-with-rsa/">Elliptic Curve Cryptography: breaking security and a comparison with RSA</a></p>
<p>4、<a href="https://www.openssl.org/docs/manmaster/man1/">OpenSSL doc</a></p>
<p>5、<a href="https://superuser.com/questions/1103401/generate-an-ecdsa-key-and-csr-with-openssl">StackExange-https://superuser.com/questions/1103401/generate-an-ecdsa-key-and-csr-with-openssl</a></p>
<p>6、<a href="https://github.com/auth0/java-jwt/issues/270">auth0/java-jwt Issue - ECDSA key version mismatch from openssl pem files #270</a></p>
<p>7、<a href="https://github.com/auth0/java-jwt">auth0/java-jwt Github</a></p>
<p>8、<a href="https://www.codota.com/code/java/methods/com.auth0.jwt.algorithms.Algorithm/ECDSA512">codota-How to useECDSA512methodincom.auth0.jwt.algorithms.Algorithm</a></p>
<p><strong>如果觉得文章好看，欢迎点赞。</strong></p>
<p><strong>同时欢迎关注微信公众号：氷泠之路。</strong></p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200806194605566.gif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第199期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-199-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-199-qi/">
        </link>
        <updated>2020-12-30T12:47:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你的晚安，只是想让我闭嘴。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>东风晚来更恶，怕飞红，怕絮入书楼。<br>
——万俟咏 《木兰花慢·恨莺花渐老》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果忘记你那么容易，那我爱你干嘛！</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第198期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-198-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-198-qi/">
        </link>
        <updated>2020-12-29T03:35:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你虽有没有出过国，但是你每天都在倒时差。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>青青园中葵，朝露待日晞。<br>
——佚名《长歌行》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>你凭什么喜欢我，就凭你眼光好吗？</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第197期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-197-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-197-qi/">
        </link>
        <updated>2020-12-28T03:32:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>熟练地运用，关我屁事和关你屁事，可以节省人生80%的时间。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>早杨柳，趁晴飞絮。<br>
——杨炎正《贺新郎》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>一场秋雨一场凉，秋心酌满泪为霜。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js/Vue.js使用jsSHA库进行SHA1/2/3加密]]></title>
        <id>https://2293736867.github.io/post/nodejsvuejs-shi-yong-jssha-ku-jin-xing-sha123-jia-mi/</id>
        <link href="https://2293736867.github.io/post/nodejsvuejs-shi-yong-jssha-ku-jin-xing-sha123-jia-mi/">
        </link>
        <updated>2020-12-28T00:29:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-概述">1 概述</h1>
<p><code>jsSHA</code>是一个用<code>JS</code>+<code>TS</code>实现完整<code>SHA</code>系列加密算法的加密库，包括：</p>
<ul>
<li><code>SHA1</code></li>
<li><code>SHA-224/256/384/512</code></li>
<li><code>SHA3-224/256/384/512</code></li>
<li><code>SHAKE128/256</code></li>
<li><code>cSHAKE128/256</code></li>
<li><code>KMAC128/256</code></li>
</ul>
<p>官方Github<a href="https://github.com/Caligatio/jsSHA">戳这里</a>，目前已有2k的star，这里是一些使用加密算法的例子。</p>
<h1 id="2-安装并引入">2 安装并引入</h1>
<p>安装使用<code>npm</code>或<code>cnpm</code>：</p>
<pre><code class="language-bash">npm install --save jssha
# 或
cnpm install --save jssha
</code></pre>
<p>引入时，根据<code>package.json</code>中的<code>type</code>进行相应引入：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;) //commonjs
import jsSHA from &quot;jssha&quot;      //module
</code></pre>
<p>若为</p>
<pre><code class="language-js">&quot;type&quot;:&quot;commonjs&quot;
</code></pre>
<p>则使用</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
</code></pre>
<h1 id="3-哈希">3 哈希</h1>
<p>一个简单的例子如下：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
const shaObj = new jsSHA(&quot;SHA-512&quot;,&quot;TEXT&quot;,{encoding:&quot;UTF8&quot;})

shaObj.update(&quot;test&quot;)
console.log(shaObj.getHash(&quot;HEX&quot;))
</code></pre>
<p>首先声明了一个<code>shaObj</code>，通过<code>update</code>传递明文，并通过<code>getHash(&quot;HEX&quot;)</code>即得到哈希值，另外<code>update</code>可以调用多次，最后使用<code>getHash</code>即可。</p>
<p><code>jsSHA()</code>有三个参数：哈希算法、输入格式以及参数设置（可选）。</p>
<h2 id="31-哈希算法">3.1 哈希算法</h2>
<p>第一个参数是哈希算法，支持的算法如下：</p>
<ul>
<li><code>SHA-1</code></li>
<li><code>SHA-224</code></li>
<li><code>SHA-256</code></li>
<li><code>SHA-384</code></li>
<li><code>SHA-512</code></li>
<li><code>SHA3-224</code></li>
<li><code>SHA3-256</code></li>
<li><code>SHA3-384</code></li>
<li><code>SHA3-512</code></li>
<li><code>SHAKE128</code></li>
<li><code>SHAKE256</code></li>
</ul>
<p>目前不建议使用<code>SHA-1</code>，建议使用<code>SHA-2</code>（<code>SHA-224、256/384/512</code>）或<code>SHA-3</code>（<code>SHA3-224/256/384/512</code>）。</p>
<p>而<code>SHAKE</code>是<code>Secure Hash Algorithm and KECCAK</code>的缩写，在<code>FISP 202</code><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">标准</a>中定义，与<code>SHA-3</code>类似，但是输出是无限位数的。因此定义的时候需要指定输出的位数，不然的话会得到如下报错：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20201227165049196.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>在<code>getHash</code>中加上参数即可：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
const shaObj = new jsSHA(&quot;SHAKE128&quot;,&quot;TEXT&quot;,{encoding:&quot;UTF8&quot;})

shaObj.update(&quot;test&quot;)
console.log(shaObj.getHash(&quot;HEX&quot;,{outputLen:1024}))
</code></pre>
<h2 id="32-输入格式">3.2 输入格式</h2>
<p>输入格式的取值如下：</p>
<ul>
<li><code>HEX</code></li>
<li><code>TEXT</code></li>
<li><code>B64</code></li>
<li><code>BYTES</code></li>
<li><code>ARRAYBUFFER</code></li>
<li><code>UNIT8ARRAY</code></li>
</ul>
<h2 id="33-参数选项">3.3 参数选项</h2>
<p>一般常用两个：</p>
<ul>
<li><code>encoding</code>：编码，允许取值<code>UTF8</code>/<code>UTF16BE</code>/<code>UTF16LE</code></li>
<li><code>numRounds</code>：哈希轮数</li>
</ul>
<p>其他的参数可以查看源码。</p>
<h2 id="34-gethash">3.4 <code>getHash</code></h2>
<p><code>getHash</code>是获取哈希结果的函数，第一个参数可以是：</p>
<ul>
<li><code>HEX</code></li>
<li><code>B64</code></li>
<li><code>BYTES</code></li>
<li><code>UINT8ARRAY</code></li>
<li><code>ARRAYBUFFER</code></li>
</ul>
<p>与上面的输入格式对应，可以带上输出长度选项，对于<code>HEX</code>可以带上<code>outputUpper</code>表示是否大写：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20201227170912988.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-hmac">4 <code>HMAC</code></h1>
<p><code>HMAC</code>是一种基于哈希函数和密钥进行消息认证的方法，使用时需要指定密钥：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
const shaObj = new jsSHA(&quot;SHA3-512&quot;,&quot;TEXT&quot;,{
    hmacKey:{value:'secret key',format:'TEXT'}
})

shaObj.update(&quot;test&quot;)
console.log(shaObj.getHash(&quot;HEX&quot;))
</code></pre>
<h1 id="5-cshake">5 <code>cSHAKE</code></h1>
<p><code>cSHAKE</code>可以看作一个&quot;定制版&quot;的<code>SHAKE</code>，需要使用额外的<code>customization</code>参数：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
const shaObj = new jsSHA(&quot;CSHAKE128&quot;,&quot;TEXT&quot;,{
    customization:{value:&quot;test&quot;,format:&quot;TEXT&quot;}
})

shaObj.update(&quot;test&quot;)
console.log(shaObj.getHash(&quot;HEX&quot;,{outputLen:1024}))
</code></pre>
<h1 id="6-kmac">6 <code>KMAC</code></h1>
<p><code>KMAC</code>（<code>KECCAK Message Authentication Code</code>）是一个基于<code>KECCAK</code>的算法，需要提供<code></code>kmacKey`参数：</p>
<pre><code class="language-js">const jsSHA = require(&quot;jssha&quot;)
const shaObj = new jsSHA(&quot;KMAC128&quot;,&quot;TEXT&quot;,{
    kmacKey:{value:&quot;secret key&quot;,format:&quot;TEXT&quot;}
})

shaObj.update(&quot;test&quot;)
console.log(shaObj.getHash(&quot;HEX&quot;,{outputLen:1024}))
</code></pre>
]]></content>
    </entry>
</feed>