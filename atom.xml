<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-07-14T08:04:57.077Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第394期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-394-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-394-qi/">
        </link>
        <updated>2021-07-14T07:50:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>我知道虚度年华不对，但是这样，真的过得好瘾啊。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>千家山郭静朝晖，日日江楼座翠微。<br>
——杜甫《秋兴八首》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>真正走掉那次，关门声最小。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1626249211179.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>排序+二分搜索，<code>O(n log n)</code>：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long diff = 0;
        int n = nums1.length;
        int[] nums1Copy = Arrays.copyOf(nums1, n);
        Arrays.sort(nums1Copy);
        for (int i = 0; i &lt; n; i++) {
            diff += Math.abs(nums1[i] - nums2[i]);
        }
        if (diff == 0) {
            return 0;
        }

//        int[] nums2Copy = Arrays.copyOf(nums2, n);
//        Arrays.sort(nums2Copy);
//        System.out.println(Arrays.toString(nums1Copy));
//        System.out.println(Arrays.toString(nums2Copy));
//        System.out.println(&quot;diff is &quot; + diff);
        int max = 0;
        int originDiff = 0;
        for (int i = 0; i &lt; n; i++) {
            int closest = find(nums1Copy, nums2[i]);
//            System.out.println(&quot;closest is &quot;+closest);
//            System.out.println(&quot;nums[i] is &quot;+nums1[i]);
            int abs = Math.abs(nums1[i] - nums2[i]) - Math.abs(closest - nums2[i]);
//            if(nums2[i] == 7){
//                System.out.println(&quot;closest is &quot;+closest);
//                System.out.println(&quot;abs is &quot;+abs);
//            }
//            int abs = Math.min(Math.abs(closest-nums2[i]),Math.abs(nums1[i]-nums2[i]));
//            if(closest &lt; nums1[i]){
//                abs = nums2[i] - closest;
//            }else{
//                abs = closest - nums2[i];
//            }
//            int abs = Math.max(Math.abs(nums1[i] - closest),);
            if (abs &gt; max) {
                max = abs;
//                System.out.println(&quot;max is &quot;+max);
//            System.out.println(&quot;closest is &quot;+closest);
//            System.out.println(&quot;nums[i] is &quot;+nums1[i]);
//                originDiff = Math.abs(nums2[i] - nums1[i]);
//                System.out.println(&quot;max is &quot;+max);
//                System.out.println(&quot;originDiff is &quot;+originDiff);
//                System.out.println(&quot;nums1[i] is &quot;+nums1[i]);
//                System.out.println(&quot;nums2[i] is &quot;+nums2[i]);
            }
        }
//        System.out.println(&quot;max is &quot;+max);
        return (int) ((diff - max) % 1_000_000_007);
    }

    private int find(int[] arr, int val) {
        int n = arr.length;
        int l = 0;
        int r = n - 1;
        while (l &lt; r) {
            int m = (l + r) &gt;&gt; 1;
            if (arr[m] == val) {
                return arr[m];
            } else if (arr[m] &gt; val) {
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
//        if (val == 97) {
//            System.out.println(&quot;arr[l] is &quot; + arr[l]);
//        }
//        System.out.println(&quot;arr[l] is &quot;+arr[l]);
        if (n == 1) {
            return arr[0];
        }
        if (l &gt; 0) {
            if (Math.abs(arr[l - 1] - val) &lt; Math.abs(arr[l] - val)) {
                return arr[l - 1];
            }
        }
        if(l &lt; n-1){
            if(Math.abs(arr[l+1] - val) &lt; Math.abs(arr[l] - val)){
                return arr[l+1];
            }
        }
        return arr[l];
    }
}
</code></pre>
<p>核心思想是遍历<code>nums2</code>中的每一个数，在<code>nums1</code>中找到一个最接近的，同时计算它们的差值，如果大于最大值，则更新最大值，公式为：</p>
<pre><code class="language-java">int abs = Math.abs(nums1[i] - nums2[i]) - Math.abs(closest - nums2[i])
</code></pre>
<p>其中<code>closest</code>表示<code>nums1</code>中最接近<code>nums2[i]</code>的那个数。</p>
<p>找到<code>closest</code>的算法如下：</p>
<pre><code class="language-java">private int find(int[] arr, int val) {
        int n = arr.length;
        int l = 0;
        int r = n - 1;
        while (l &lt; r) {
            int m = (l + r) &gt;&gt; 1;
            if (arr[m] == val) {
                return arr[m];
            } else if (arr[m] &gt; val) {
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        if (l &gt; 0) {
            if (Math.abs(arr[l - 1] - val) &lt; Math.abs(arr[l] - val)) {
                return arr[l - 1];
            }
        }
        if (l &lt; n - 1) {
            if (Math.abs(arr[l + 1] - val) &lt; Math.abs(arr[l] - val)) {
                return arr[l + 1];
            }
        }
        return arr[l];
}
</code></pre>
<p><code>arr</code>从<code>nums1</code>复制而来，并且已进行排序，搜索算法为二分搜索。注意找到索引下标后，需要判断前一个以及后一个，也就是假设找到下标<code>i</code>为最接近的数的下标，需要判断<code>i-1</code>以及<code>i+1</code>是不是比<code>i</code>更接近。</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1626249812199.png" alt="" loading="lazy"></figure>
<p>因为数字不大，使用计排优化，同时进行小幅度优化：</p>
<pre><code class="language-java">public class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long diff = 0;
        int n = nums1.length;
        int[] nums1Copy = new int[n];
        int[] count = new int[100_000 + 1];
        int max = 0;
        for (int i = 0; i &lt; n; i++) {
            diff += Math.abs(nums1[i] - nums2[i]);
            ++count[nums1[i]];
            max = Math.max(nums1[i], max);
        }

        if (diff == 0) {
            return 0;
        }

        int index = 0;
        for (int i = 1; i &lt;= max; i++) {
            int val = count[i];
            for (int j = 0; j &lt; val; j++) {
                nums1Copy[index++] = i;
            }
        }

        max = 0;
        for (int i = 0; i &lt; n; i++) {
            int closest = find(nums1Copy, nums2[i]);
            int abs = Math.abs(nums1[i] - nums2[i]) - Math.abs(closest - nums2[i]);
            if (abs &gt; max) {
                max = abs;
            }
        }
        return (int) ((diff - max) % 1_000_000_007);
    }

    private int find(int[] arr, int val) {
        int n = arr.length;
        int l = 0;
        int r = n - 1;
        while (l &lt; r) {
            int m = (l + r) &gt;&gt; 1;
            if (arr[m] == val) {
                return arr[m];
            } else if (arr[m] &gt; val) {
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        if (l &gt; 0) {
            if (Math.abs(arr[l - 1] - val) &lt; Math.abs(arr[l] - val)) {
                return arr[l - 1];
            }
        }
        if (l &lt; n - 1) {
            if (Math.abs(arr[l + 1] - val) &lt; Math.abs(arr[l] - val)) {
                return arr[l + 1];
            }
        }
        return arr[l];
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1626249849956.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第393期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-393-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-393-qi/">
        </link>
        <updated>2021-07-13T08:59:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>别人一看你就说你是学生，不是因为你看着年轻，而是因为穿的土。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>竹色溪下绿，荷花镜里香。<br>
——李白《别储邕之剡中》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我会穿越那七大海洋，去和你相见。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1626166806315.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>真心不会做，直接放官方题解了：</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) {
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;((a, b) -&gt; b[1] - a[1]);
        List&lt;Integer&gt; boundaries = new ArrayList&lt;Integer&gt;();
        for (int[] building : buildings) {
            boundaries.add(building[0]);
            boundaries.add(building[1]);
        }
        Collections.sort(boundaries);

        List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        int n = buildings.length, idx = 0;
        for (int boundary : boundaries) {
            while (idx &lt; n &amp;&amp; buildings[idx][0] &lt;= boundary) {
                pq.offer(new int[]{buildings[idx][1], buildings[idx][2]});
                idx++;
            }
            while (!pq.isEmpty() &amp;&amp; pq.peek()[0] &lt;= boundary) {
                pq.poll();
            }

            int maxn = pq.isEmpty() ? 0 : pq.peek()[1];
            if (ret.size() == 0 || maxn != ret.get(ret.size() - 1).get(1)) {
                ret.add(Arrays.asList(boundary, maxn));
            }
        }
        return ret;
    }
}
</code></pre>
<p>不明白为什么是遇到左端点就入栈/入队，然后遇到右端点就出栈/出队。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第392期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-392-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-392-qi/">
        </link>
        <updated>2021-07-12T00:29:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>世界上脑残那么多，你却成了佼佼者。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>此花此叶常相映，翠减红哀愁杀人。<br>
——李商隐《赠荷花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>少年心意，一如明月松间的青石流水，那些年里看到了，却看不懂。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1626050178521.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>昨天顺便做了，直接上二分：</p>
<pre><code class="language-java">class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int l = 0;
        int r = n - 1;
        while (l &lt;= r) {
            int m = (r + l) &gt;&gt; 1;
            if (citations[m] == n - m) {
                return n - m;
            }
            if (citations[m] &lt; n - m) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }
        return n - l;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1626050206739.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第391期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-391-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-391-qi/">
        </link>
        <updated>2021-07-11T03:06:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>出身好的努力是为了成功，而你是为了活下去。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>荷叶罗裙一色裁，芙蓉向脸两边开。<br>
——王昌龄《采莲曲》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>小太阳很忙，小云朵想吃糖，长颈鹿嫌脖子不够长，喜欢你太难忘。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625972805479.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>其实一开始是没什么思路的，看了一下<code>275</code>题，<code>275</code>题是已经排序好的，并且有提示时间<code>O(log N)</code>，所以就直接排序上二分：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int n = citations.length;
        int l = 0;
        int r = n - 1;
        while (l &lt;= r) {
            int m = (r + l) &gt;&gt; 1;
            if (citations[m] == n - m) {
                return n - m;
            }
            if (citations[m] &lt; n - m) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }
        return n - l;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625972789942.png" alt="" loading="lazy"></figure>
<p>第一次的1ms是因为直接<code>O(n)</code>扫描。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第390期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-390-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-390-qi/">
        </link>
        <updated>2021-07-09T17:21:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>和对象吵架，先不要追究吵架原因，要弄明白他胆子怎么肥了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>五月畲田收火米，三更津吏报潮鸡。<br>
——李德裕《请岭南道中作》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>夕阳真实耀眼无比啊。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625851358861.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>简单题，因为时间戳单调递增，使用双链表存储即可，也就是<code>LinkedList</code>，操作如下：</p>
<ul>
<li><code>set</code>：首先判断是否出现过，出现过直接调用<code>addLast</code>，否则新增链表</li>
<li><code>get</code>：首先判断是否存在<code>key</code>，不存在返回空，存在的话从链表末尾开始遍历，直到找到结点的时间戳小于给定的时间戳的结点值，并返回，如果没有找到，也就是链表遍历结束，则返回空</li>
</ul>
<pre><code class="language-java">import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

public class TimeMap {
    private final Map&lt;String, LinkedList&lt;Node&gt;&gt; map = new HashMap&lt;&gt;();

    public void set(String key, String value, int timestamp) {
        Node node = new Node(value,timestamp);
        if(map.containsKey(key)){
            map.get(key).addLast(node);
        }else{
            LinkedList&lt;Node&gt; list = new LinkedList&lt;&gt;();
            list.add(node);
            map.put(key,list);
        }
    }

    public String get(String key, int timestamp) {
        if(!map.containsKey(key)){
            return &quot;&quot;;
        }
        LinkedList&lt;Node&gt; list = map.get(key);
        for (int i = list.size()-1; i &gt;= 0; --i) {
            Node node = list.get(i);
            if(node.timestamp &lt;= timestamp){
                return node.value;
            }
        }
        return &quot;&quot;;
    }

    private static class Node{
        String value;
        int timestamp;

        public Node(String value,int timestamp){
            this.value = value;
            this.timestamp = timestamp;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625851346173.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第389期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-389-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-389-qi/">
        </link>
        <updated>2021-07-08T18:00:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>倘若互不相欠，怎会再次相见。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>朔风吹散三更雪，倩魂犹恋桃花月。<br>
——纳兰性德《菩萨蛮·朔风吹散三更雪》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>记忆，总会传承下去，无论是用何种方式。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625767355965.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p><code>Boyer-Moore</code>投票算法：</p>
<ul>
<li>初始化计数<code>count=0</code>，结果用<code>res</code>保存</li>
<li>遍历数组中的每个数<code>v</code></li>
<li>如果<code>count==0</code>，更新<code>count=1,res=v</code></li>
<li>否则如果<code>res==v</code>，<code>++count</code></li>
<li>否则<code>--count</code></li>
</ul>
<p>得出来的就是最后可能的结果<code>res</code>，也就是说如果存在的话，<code>res</code>就一定是主要元素，否则可能是数组中的任意一个元素，需要第二次遍历，计算<code>res</code>的出现次数，判断是否大于其他元素的出现次数。</p>
<pre><code class="language-java">public class Solution {
    public int majorityElement(int[] nums) {
        int res = 0;
        int count = 0;
        for(int v:nums){
            if(count == 0){
                res = v;
                count = 1;
            }else if(res == v){
                ++count;
            }else {
                --count;
            }
        }

        count = 0;
        for(int v:nums){
            if(v == res){
                ++count;
            }
        }
        return count &gt; nums.length/2 ? res : -1;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625767374739.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第388期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-388-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-388-qi/">
        </link>
        <updated>2021-07-08T04:45:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>这年头有些人靠脸吃饭，而有些人，靠不要脸吃饭。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>坐睡觉来无一事，满窗晴日看蚕生。<br>
——范成大《春日田园杂兴》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>别的禅，我都不修。独你是我的禅，秀色可餐。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625719676250.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>用哈希表存储前缀和为<code>sum</code>的个数，如果当前的前缀和大于目标，直接加上<code>前缀和-目标</code>对应的哈希表的个数：</p>
<pre><code class="language-java">public class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int [] pre = new int[nums.length+1];
        pre[0] = 1;
        int sum = 0;
        int res = 0;
        for (int num:nums){
            sum += num;
            if(sum &gt;= goal){
                res += pre[sum-goal];
            }
            ++pre[sum];
        }
        return res;
    }
}
</code></pre>
<p>官方题解还有个滑动窗口解法：</p>
<pre><code class="language-java">class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int left1 = 0, left2 = 0, right = 0;
        int sum1 = 0, sum2 = 0;
        int ret = 0;
        while (right &lt; n) {
            sum1 += nums[right];
            while (left1 &lt;= right &amp;&amp; sum1 &gt; goal) {
                sum1 -= nums[left1];
                left1++;
            }
            sum2 += nums[right];
            while (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) {
                sum2 -= nums[left2];
                left2++;
            }
            ret += left2 - left1;
            right++;
        }
        return ret;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot demo系列（十四）：ShardingSphere + MyBatisPlus 分库分表 + 读写分离]]></title>
        <id>https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-si-shardingsphere-mybatisplus-fen-ku-fen-biao-du-xie-fen-chi/</id>
        <link href="https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-si-shardingsphere-mybatisplus-fen-ku-fen-biao-du-xie-fen-chi/">
        </link>
        <updated>2021-07-07T07:15:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">3 数据库环境准备</a></li>
<li><a href="#4-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">4 新建项目</a></li>
<li><a href="#5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5 配置文件</a></li>
<li><a href="#6-%E5%87%86%E5%A4%87%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">6 准备测试代码</a></li>
<li><a href="#7-%E6%B5%8B%E8%AF%95">7 测试</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81">8 参考代码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>之前笔者写过两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_27525611/article/details/118218614?spm=1001.2014.3001.5501">ShardingSphere 读写分离</a></li>
<li><a href="https://blog.csdn.net/qq_27525611/article/details/118521446">ShardingSphere 分库分表</a></li>
</ul>
<p>这里将两者结合起来，实现读写分离+分库分表的功能。关于环境的配置本文将进行简化叙述，详细可以参考前两篇文章。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li><code>MySQL 8.0.25</code>（<code>Docker</code>）</li>
<li><code>MyBatis Plus 3.4.3.1</code></li>
<li><code>MyBatis Plus Generator 3.5.0</code></li>
<li><code>Druid 1.2.6</code></li>
<li><code>ShardingSphere 4.1.1</code></li>
<li><code>Yitter 1.0.6</code>（一个雪花<code>id</code>生成器）</li>
</ul>
<h1 id="3-数据库环境准备">3 数据库环境准备</h1>
<p>由于环境准备不是本文的重点，一主一从的主从复制环境可以参考<a href="https://blog.csdn.net/qq_27525611/article/details/118218614">此处</a>搭建。</p>
<p>准备好环境，本地启动两个<code>MySQL</code>，主节点环境：</p>
<ul>
<li>名字：<code>master</code></li>
<li>端口：<code>3306</code></li>
<li>数据库：两个库（<code>test0</code>、<code>test1</code>）</li>
<li>数据表：六个表，每个库三个（<code>test0.user0</code>、<code>test0.user1</code>、<code>test0.user2</code>、<code>test1.user0</code>、<code>test1.user1</code>、<code>test1.user2</code>）</li>
</ul>
<p>从节点环境：</p>
<ul>
<li>名字：<code>slave</code></li>
<li>端口：<code>3307</code></li>
<li>数据库：两个库（<code>test0</code>、<code>test1</code>）</li>
<li>数据表：六个表，每个库三个（<code>test0.user0</code>、<code>test0.user1</code>、<code>test0.user2</code>、<code>test1.user0</code>、<code>test1.user1</code>、<code>test1.user2</code>）</li>
</ul>
<p>主库配置文件：</p>
<pre><code class="language-bash">[mysqld]
server-id=1
binlog-do-db=test0
binlog-do-db=test1
</code></pre>
<p>从库配置文件：</p>
<pre><code class="language-bash">[mysqld]
server-id=2
replicate-do-db=test0
replicate-do-db=test1
</code></pre>
<p>完整的数据库脚本和<code>MySQL</code>配置文件放在文末的源码链接中。</p>
<h1 id="4-新建项目">4 新建项目</h1>
<p>新建项目并引入如下依赖：</p>
<ul>
<li><code>Druid</code></li>
<li><code>MyBatis Plus starter</code></li>
<li><code>MyBaits Plus Generator</code></li>
<li><code>Velocity core</code></li>
<li><code>ShardingSphere</code></li>
<li><code>Yitter</code></li>
</ul>
<p><code>Maven</code>如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.5.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.realityforge.org.jetbrains.annotations&lt;/groupId&gt;
    &lt;artifactId&gt;org.jetbrains.annotations&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.yitter&lt;/groupId&gt;
    &lt;artifactId&gt;yitter-idgenerator&lt;/artifactId&gt;
    &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>如下：</p>
<pre><code class="language-bash">implementation 'com.baomidou:mybatis-plus-boot-starter:3.4.3.1'
implementation 'org.apache.velocity:velocity-engine-core:2.3'
implementation 'org.realityforge.org.jetbrains.annotations:org.jetbrains.annotations:1.7.0'
implementation 'com.alibaba:druid:1.2.6'
implementation 'org.apache.shardingsphere:sharding-jdbc-spring-boot-starter:4.1.1'
implementation 'com.github.yitter:yitter-idgenerator:1.0.6'
</code></pre>
<h1 id="5-配置文件">5 配置文件</h1>
<pre><code class="language-yml">spring:
  shardingsphere:
    datasource:
      names: master-test0,master-test1,slave-test0,slave-test1                 # 数据源节点名字
                                                                               # master-test0表示主节点的test0库，master-test1表示主节点的test1库
                                                                               # slave-test0表示从节点的test0库，slave-test1表示从节点的test1库
      master-test0:
        type: com.alibaba.druid.pool.DruidDataSource                           # 连接池
        url: jdbc:mysql://127.0.0.1:3306/test0                                 # 主节点的test0库
        username: root
        password: 123456
      master-test1:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3306/test1                                 # 主节点的test1库
        username: root
        password: 123456
      slave-test0:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3307/test0                                 # 从节点的test0库，端口3307
        username: root
        password: 123456
      slave-test1:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3307/test1                                 # 从节点的test1库，端口3307
        username: root
        password: 123456
    sharding:
      default-database-strategy:
        inline:
          sharding-column: age                                                 # 按照哪一列分库
          algorithm-expression: master-test$-&gt;{age % 2}                        # 分库规则为对年龄取模
      tables:
        user:
          actual-data-nodes: master-test$-&gt;{0..1}.user$-&gt;{0..2}                # 分表的节点，格式为 [数据源.表名]
          table-strategy:
            inline:
              sharding-column: id                                              # 按照哪一列分表
              algorithm-expression: user$-&gt;{id%3}                              # 分表规则，对id取模

      master-slave-rules:                                                      # 读写分离的规则
        master-test0:                                                          # 哪一个主节点
          master-datasource-name: master-test0                                 # 指定主节点名字
          slave-data-source-names: slave-test0                                 # 指定从节点名字
        master-test1:
          master-datasource-name: master-test1
          slave-data-source-names: slave-test1
    props:
      sql:
        show:
          true                                                                 # 打印SQL
</code></pre>
<h1 id="6-准备测试代码">6 准备测试代码</h1>
<p>使用<code>MyBatis Plus Generator</code>生成器类生成代码：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;

public class MyBatisPlusGenerator {
    public static void main(String[] args) {
        DataSourceConfig dataSourceConfig = new DataSourceConfig.Builder(&quot;jdbc:mysql://localhost:3306/test0&quot;, &quot;root&quot;, &quot;123456&quot;).build();
        String projectPath = System.getProperty(&quot;user.dir&quot;);
        StrategyConfig strategyConfig = new StrategyConfig.Builder().addInclude(&quot;user&quot;).build();
        GlobalConfig globalConfig = new GlobalConfig.Builder().outputDir(projectPath + &quot;/src/main/java&quot;).openDir(false).build();
        PackageConfig packageConfig = new PackageConfig.Builder().moduleName(&quot;user&quot;).parent(&quot;com.example.demo&quot;).serviceImpl(&quot;service&quot;).build();
        new AutoGenerator(dataSourceConfig).global(globalConfig).packageInfo(packageConfig).strategy(strategyConfig).execute();
    }
}
</code></pre>
<p>实体类加上<code>@Builder</code>，同时设置<code>id</code>类型为<code>IdType.ASSIGN_ID</code>：</p>
<pre><code class="language-java">@Builder
public class User implements Serializable {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    //...
}
</code></pre>
<p>修改<code>Controller</code>类：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class UserController {
    private final Random random = new Random();
    private final UserServiceImpl service;
    @GetMapping(&quot;/select&quot;)
    public List&lt;User&gt; select(){
        return service.list();
    }

    @GetMapping(&quot;/insert&quot;)
    public boolean insert(){
        return service.save(User.builder().age(random.nextInt(80)+20).name(&quot;test name&quot;).email(&quot;test@test.com&quot;).build());
    }
}
</code></pre>
<p>同时新增一个雪花<code>id</code>生成器类（具体配置方法可以参考<code>MyBatis Plus</code><a href="https://mybatis.plus/guide/id-generator.html">官方文档</a>）：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
import com.github.yitter.contract.IdGeneratorOptions;
import com.github.yitter.idgen.YitIdHelper;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class IdGenerator implements IdentifierGenerator {
    final IdGeneratorOptions options = new IdGeneratorOptions((short) 1);

    @PostConstruct
    public void init() {
        YitIdHelper.setIdGenerator(options);
    }

    @Override
    public Long nextId(Object entity) {
        return YitIdHelper.nextId();
    }
}
</code></pre>
<h1 id="7-测试">7 测试</h1>
<p>刷新几次插入页面：</p>
<pre><code class="language-bash">http://localhost:8080/user/insert
</code></pre>
<p>从输出可以看到插入都是在主节点中进行的：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210707004418800.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而查询的时候：</p>
<pre><code class="language-bash">http://localhost:8080/user/select
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210707004509588.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>是在从节点查询的。</p>
<h1 id="8-参考代码">8 参考代码</h1>
<p><code>Java</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoJava/-/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">CODE CHINA</a></li>
</ul>
<p><code>Kotlin</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoKotlin/-/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">CODE CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第387期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-387-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-387-qi/">
        </link>
        <updated>2021-07-07T02:53:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>脱发怎么办？要健康饮食保持良好心态，这样就能接受这个事实了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>黄沙百战穿金甲，不破楼兰终不还。<br>
——王昌龄《从军行七首·其四》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果有一个喜欢你的人出现，一定不要凶她哦！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625626553273.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>使用哈希表存储个数，键就是美味程度，值就是该美味程度出现的个数，重复出现的时候直接从哈希表里面<code>get</code>：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int countPairs(int[] deliciousness) {
        int n = deliciousness.length;
        int ans = 0;
        final int MOD = 1_0000_0000_0 + 7;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(n);
        for (int i = 0; i &lt; n; i++) {
            int val = deliciousness[i];
            for (int sum = 1; sum &gt; 0; sum &lt;&lt;= 1) {
                int count = map.getOrDefault(sum - val, 0);
                if (count != 0) {
                    ans = (ans + count) % MOD;
                }
            }
            map.put(val, map.getOrDefault(val,0) + 1);
        }
        return ans;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625626628192.png" alt="" loading="lazy"></figure>
<p>中规中矩的时间。</p>
<p>参考第一名优化了一下：</p>
<ul>
<li>使用数组代替<code>HashMap</code></li>
<li>利用最大值与最小值减小<code>map</code>数组需要开辟的空间（<code>int []map = new int [max - min + 1]</code>）</li>
<li>使用<code>long</code>代替<code>int</code>存储结果，减小求模的次数</li>
</ul>
<pre><code class="language-java">public class Solution {
    public int countPairs(int[] deliciousness) {
        long ans = 0;
        int max = deliciousness[0];
        int min = deliciousness[0];
        for (int v : deliciousness) {
            if (v &gt; max) {
                max = v;
            }
            if (v &lt; min) {
                min = v;
            }
        }
        int[] map = new int[max - min + 1];
        for (int v : deliciousness) {
            for (int s = 1; ; s &lt;&lt;= 1) {
                int x = s - v;
                if(x &lt; min){
                    continue;
                }
                if(x &gt; max){
                    break;
                }
                ans += map[x-min];
            }
            ++map[v-min];
        }
        return (int)(ans % 1_000_000_007L);
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625626543216.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot demo系列（十三）：ShardingSphere + MyBatisPlus 分库分表]]></title>
        <id>https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-san-shardingsphere-mybatisplus-fen-ku-fen-biao/</id>
        <link href="https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-san-shardingsphere-mybatisplus-fen-ku-fen-biao/">
        </link>
        <updated>2021-07-06T10:30:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83">2 准备数据库环境</a>
<ul>
<li><a href="#21-%E4%B8%A4%E5%BA%93%E5%85%AD%E8%A1%A8">2.1 两库六表</a></li>
<li><a href="#22-%E5%8F%AF%E9%80%89mybatis-plus-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%A1%A8">2.2 （可选）<code>MyBatis Plus Generator</code>代码生成表</a></li>
</ul>
</li>
<li><a href="#3-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">3 新建项目</a></li>
<li><a href="#4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4 配置文件</a></li>
<li><a href="#5-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">5 测试代码生成</a></li>
<li><a href="#6-%E5%A2%9E%E5%8A%A0%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%99%A8">6 增加雪花<code>id</code>生成器</a></li>
<li><a href="#7-%E6%B5%8B%E8%AF%95">7 测试</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E6%BA%90%E7%A0%81">8 参考源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>本文主要讲述了如何使用<code>ShardingSphere</code>（其中的<code>Sharding-JDBC</code>）和<code>MyBatisPlus</code>进行分库分表，具体步骤包括：</p>
<ul>
<li>准备数据库环境</li>
<li>准备依赖</li>
<li>编写配置文件</li>
<li>测试</li>
</ul>
<h1 id="2-准备数据库环境">2 准备数据库环境</h1>
<h2 id="21-两库六表">2.1 两库六表</h2>
<p>准备好两个库：</p>
<ul>
<li><code>test0</code></li>
<li><code>test1</code></li>
</ul>
<p>在两个库中分别建立三个字段一样的表：</p>
<ul>
<li><code>user0</code></li>
<li><code>user1</code></li>
<li><code>user2</code></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210706152233931.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>字段如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210706152320541.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样就准备了两个库以及其中的六个表了。</p>
<h2 id="22-可选mybatis-plus-generator代码生成表">2.2 （可选）<code>MyBatis Plus Generator</code>代码生成表</h2>
<p>因为<code>MyBatis Plus Generator</code>生成的<code>Controller</code>等代码默认是按照表名命名的，这样就会生成类似<code>User0</code>、<code>User0Controller</code>这样的命名，因此这里创建一个叫<code>user</code>的表，仅仅用于代码的生成，里面不会存放任何的数据：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210706153020483.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-新建项目">3 新建项目</h1>
<p>新建<code>Spring Boot</code>项目并引入如下依赖：</p>
<ul>
<li><code>Druid</code></li>
<li><code>MyBatis Plus starter</code></li>
<li><code>MyBaits Plus Generator</code></li>
<li><code>Velocity core</code></li>
<li><code>ShardingSphere</code></li>
<li><code>Yitter</code>（一个雪花<code>id</code>生成器）</li>
</ul>
<p><code>Maven</code>如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.5.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.realityforge.org.jetbrains.annotations&lt;/groupId&gt;
    &lt;artifactId&gt;org.jetbrains.annotations&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.yitter&lt;/groupId&gt;
    &lt;artifactId&gt;yitter-idgenerator&lt;/artifactId&gt;
    &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>如下：</p>
<pre><code class="language-bash">implementation 'com.baomidou:mybatis-plus-boot-starter:3.4.3.1'
implementation 'org.apache.velocity:velocity-engine-core:2.3'
implementation 'org.realityforge.org.jetbrains.annotations:org.jetbrains.annotations:1.7.0'
implementation 'com.alibaba:druid:1.2.6'
implementation 'org.apache.shardingsphere:sharding-jdbc-spring-boot-starter:4.1.1'
implementation 'com.github.yitter:yitter-idgenerator:1.0.6'
</code></pre>
<h1 id="4-配置文件">4 配置文件</h1>
<p>配置文件可以参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/yaml/sharding/">ShardingSphere文档</a>，这里给出一个示例配置：</p>
<pre><code class="language-yml">spring:
  shardingsphere:
    datasource:
      names: test0,test1                                        # 数据源，这里为了方便直接使用库名的名称
      test0:                                                   
        type: com.alibaba.druid.pool.DruidDataSource            # Druid连接池
        url: jdbc:mysql://127.0.0.1:3306/test0                  # 连接test0的url
        username: root
        password: 123456
      test1:
        type: com.alibaba.druid.pool.DruidDataSource            # Druid连接池
        url: jdbc:mysql://127.0.0.1:3306/test1                  # 连接test1的url
        username: root
        password: 123456
    sharding:
      default-database-strategy:                                # 默认分库策略
        inline:  
          sharding-column: age                                  # 表示根据age列进行分库
          algorithm-expression: test$-&gt;{age % 2}                # 根据age对2的模进行分库，模为0表示test0库，模为1表示test1库
      tables:
        user:
          actual-data-nodes: test$-&gt;{0..1}.user$-&gt;{0..2}        # 表的名字，test$-&gt;{0..1}可以表示test0、test1两个库
                                                                # user$-&gt;{0..2}表示user0、user1、user2三个库
          table-strategy:                                       # 分表策略
            inline:
              sharding-column: id                               # 根据哪一列进行分表，id表示根据列名为&quot;id&quot;的列分表
              algorithm-expression: user$-&gt;{id%3}               # 分表规则为id对3取模，id%3为0表示分到user0表
                                                                # id%3为1表示分到user1表，id%3为2表示分到user2表
    props:
      sql:
        show:
          true                                                  # 打印sql
</code></pre>
<p>这里使用自动取模分片策略，<code>ShardingShphere</code>内置了如下分片算法：</p>
<ul>
<li>自动分片算法：取模分片、哈希取模分片、基于分片容量的范围分片、基于分片边界的范围分片、自动时间段分片</li>
<li>标准分片算法：行表达式分片、时间范围分片</li>
<li>复合行表达式分片</li>
<li><code>Hint</code>行表达式分片</li>
</ul>
<p>如果不能满足需要还可以自定义分片算法，具体请看<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding/">官方文档</a>。</p>
<h1 id="5-测试代码生成">5 测试代码生成</h1>
<p>使用<code>MyBaits Plus Generator</code>生成相应代码，具体使用可以参考笔者之前的文章，这里直接放上生成类的代码：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;

public class MyBatisPlusGenerator {
    public static void main(String[] args) {
        DataSourceConfig dataSourceConfig = new DataSourceConfig.Builder(&quot;jdbc:mysql://localhost:3306/test0&quot;, &quot;root&quot;, &quot;123456&quot;).build();
        String projectPath = System.getProperty(&quot;user.dir&quot;);
        StrategyConfig strategyConfig = new StrategyConfig.Builder().addInclude(&quot;user&quot;).build();
        GlobalConfig globalConfig = new GlobalConfig.Builder().outputDir(projectPath + &quot;/src/main/java&quot;).openDir(false).build();
        PackageConfig packageConfig = new PackageConfig.Builder().moduleName(&quot;user&quot;).parent(&quot;com.example.demo&quot;).serviceImpl(&quot;service&quot;).build();
        new AutoGenerator(dataSourceConfig).global(globalConfig).packageInfo(packageConfig).strategy(strategyConfig).execute();
    }
}
</code></pre>
<p>把<code>UserController</code>类修改如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class UserController {
    private final Random random = new Random();
    private final UserServiceImpl service;
    @GetMapping(&quot;/select&quot;)
    public List&lt;User&gt; select(){
        return service.list();
    }

    @GetMapping(&quot;/insert&quot;)
    public boolean insert(){
        return service.save(User.builder().age(random.nextInt(80)+20).name(&quot;test name&quot;).email(&quot;test@test.com&quot;).build());
    }
}
</code></pre>
<h1 id="6-增加雪花id生成器">6 增加雪花<code>id</code>生成器</h1>
<p>首先修改<code>User</code>类，增加一个<code>@Builder</code>注解，同时修改<code>id</code>的生成策略，使用<code>IdType.ASSIGN_ID</code>：</p>
<pre><code class="language-java">@Builder
public class User implements Serializable {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    //...
}
</code></pre>
<p>新建<code>id</code>生成器类：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
import com.github.yitter.contract.IdGeneratorOptions;
import com.github.yitter.idgen.YitIdHelper;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class IdGenerator implements IdentifierGenerator {
    final IdGeneratorOptions options = new IdGeneratorOptions((short) 1);

    @PostConstruct
    public void init() {
        YitIdHelper.setIdGenerator(options);
    }

    @Override
    public Long nextId(Object entity) {
        return YitIdHelper.nextId();
    }
}
</code></pre>
<p>这样生成<code>id</code>的时候，就会自动调用<code>nextId()</code>方法，其中的<code>id</code>生成器可以根据需要进行替换，换成其他雪花<code>id</code>生成器或分布式<code>id</code>生成器。</p>
<p>配置的时候可以参考<a href="https://mybatis.plus/guide/id-generator.html">MyBaits Plus 自定义ID生成器文档</a>。</p>
<h1 id="7-测试">7 测试</h1>
<p>先随机插入三条数据，刷新三次如下页面：</p>
<pre><code class="language-bash">localhost:8080/test/user/insert
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210706155553392.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到执行了三次插入操作，插入的三个表分别是：</p>
<ul>
<li><code>test0.user2</code></li>
<li><code>test0.user0</code></li>
<li><code>test0.user2</code></li>
</ul>
<p>因为这里测试的时候年龄都恰好是偶数，都插入到了<code>test0</code>表。</p>
<p>查看数据：</p>
<pre><code class="language-bash">http://localhost:8080/user/select
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210706160020660.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>日志输出如下：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2021070616012131.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>表示这是对六个表查询的结果，并将最后的结果进行聚合返回。</p>
<h1 id="8-参考源码">8 参考源码</h1>
<p><code>Java</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataSharding">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataSharding">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoJava/-/tree/main/ShardingSphereMyBatisPlusDataSharding">CODE.CHINA</a></li>
</ul>
<p><code>Kotlin</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataSharding">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataSharding">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoKotlin/-/tree/main/ShardingSphereMyBatisPlusDataSharding">CODE.CHINA</a></li>
</ul>
]]></content>
    </entry>
</feed>