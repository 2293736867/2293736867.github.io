<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-07-23T06:48:55.269Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JetBrains系列IDE无法输入中文]]></title>
        <id>https://2293736867.github.io/post/jetbrains-xi-lie-ide-wu-fa-shu-ru-zhong-wen/</id>
        <link href="https://2293736867.github.io/post/jetbrains-xi-lie-ide-wu-fa-shu-ru-zhong-wen/">
        </link>
        <updated>2020-07-23T06:48:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-问题描述">1 问题描述</h1>
<p>环境Linux+fcitx，JetBrains的IDE无法输入中文，包括IDEA，PyCharm，WebStorm，CLion等等。</p>
<h1 id="2-解决方案">2 解决方案</h1>
<p>Linux下一般使用fcitx进入中文输入，安装的时候教程一般都会提到以下三个环境变量：</p>
<pre><code class="language-bash">export XMODIFIERS=&quot;@im=fcitx&quot;
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
</code></pre>
<p>安装的时候一般在<code>~/.bashrc</code>或<code>~/.bash_profile</code>或<code>~/.xprofile</code>中输入以上三个环境变量，这样fcitx就能输入中文了。</p>
<p>但是对于JetBrains的IDE，需要进行全局环境变量的设置，也就是说需要在<code>/etc/profile</code>输入以上三个环境变量，这样就能输入中文了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第35期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-36-qi/">
        </link>
        <updated>2020-07-22T22:36:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457502173.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>黑夜从来不会亏待晚睡的人，它会赐予你黑眼圈，和即将猝死的身体。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其婴儿出生后，被大人拎着腌火腿一样在盐堆里滚几圈，直到浑身满盐才结束。当地人相信，这样可以赋予新生儿抵御疾病的力量。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=1300885683">38度6-黑龙</a></p>
</blockquote>
<blockquote>
<p>逃不出你的左右<br>
像鱼在沙里游<br>
明知道没尽头<br>
却不怕头破血流<br>
爱你是海市蜃楼<br>
像泡沫般游走<br>
虚幻和无所求<br>
第一次我见你情难开口心跳在发抖</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森丽留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙像温度充满了电流<br>
在38度6</p>
</blockquote>
<blockquote>
<p>逃不出你的左右<br>
像鱼在沙里游<br>
明知道没尽头<br>
却不怕头破血流<br>
爱你是海市蜃楼<br>
像泡沫般游走<br>
虚幻和无所求<br>
第一次我见你情难开口 心跳在发抖</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森林留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙温度像充满了电流<br>
在38度6</p>
</blockquote>
<blockquote>
<p>拥抱这片绿洲 那热烈的温柔<br>
我放弃整个森林留下眷恋和哀愁<br>
像初见你眼眸 时间停止倒流<br>
我燃烧了宇宙温度像充满了电流<br>
拥抱到白了头 不放开你的手<br>
我卸下了等候和全部爱你的理由<br>
全世界跟我走 从黑夜到白昼<br>
我唯一的要求我们的爱永远停留<br>
在38度6</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第34期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-35-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-35-qi/">
        </link>
        <updated>2020-07-21T22:36:14.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457523821.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>年轻人不要老想着走捷径，父母强才是硬道理。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其的十二生肖，将龙换成了鳄鱼，其他相同。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=190072">黄昏-周传雄</a></p>
</blockquote>
<blockquote>
<p>过完整个夏天<br>
忧伤并没有好一些<br>
开车行驶在公路无际无边<br>
有离开自己的感觉</p>
</blockquote>
<blockquote>
<p>唱不完一首歌<br>
疲倦还剩下黑眼圈<br>
感情的世界伤害在所难免<br>
黄昏再美终要黑夜</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
<blockquote>
<p>唱不完一首歌<br>
疲倦还剩下黑眼圈<br>
感情的世界伤害在所难免<br>
黄昏再美终要黑夜</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
<blockquote>
<p>依然记得从你口中说出再见坚决如铁<br>
昏暗中有种烈日灼身的错觉<br>
黄昏的地平线<br>
划出一句离别<br>
爱情进入永夜</p>
</blockquote>
<blockquote>
<p>依然记得从你眼中滑落的泪伤心欲绝<br>
混乱中有种热泪烧伤的错觉<br>
黄昏的地平线<br>
割断幸福喜悦<br>
相爱已经幻灭</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第33期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-34-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-34-qi/">
        </link>
        <updated>2020-07-20T22:35:50.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457535932.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>明日复明日，明日何其多！既然这么多，不妨再拖拖。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>土耳其的英文Turkey，另一个意思是火鸡。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=545350530">有些爱情放不下-唐伯虎</a></p>
</blockquote>
<blockquote>
<p>你说着那些美丽的谎话<br>
在我的心上定格成伤疤<br>
你说的那些承诺未抵达<br>
热情就慢慢融化</p>
</blockquote>
<blockquote>
<p>走不进你描述的那个家<br>
却迷失我幻想的那幅画<br>
深夜里想着你心乱如麻<br>
我的爱旧伤复发</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做的太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
<blockquote>
<p>你说着那些美丽的谎话<br>
在我的心上定格成伤疤<br>
你说的那些承诺未抵达<br>
热情就慢慢融化</p>
</blockquote>
<blockquote>
<p>走不进你描述的那个家<br>
却迷失我幻想的那幅画<br>
深夜里想着你心乱如麻<br>
我的爱旧伤复发</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做得太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
<blockquote>
<p>有些爱情真的想放放不下<br>
有些人真的可恨却牵挂<br>
谁的爱对了谁的爱错了<br>
爱本就真真假假<br>
有些爱情真的想放放不下<br>
有些梦真的做得太浮夸<br>
眼泪虽渺小但爱却伟大<br>
告诉我还爱我吗</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第32期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-33-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-33-qi/">
        </link>
        <updated>2020-07-19T22:35:32.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595457549236.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>加我回来吧，我给你发我的婚礼请柬。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>一项新研究发现，蟒蛇实际上并非通过令猎物窒息而将其杀死，而是通过切断血液循环导致猎物心脏病发作而死。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>尽虽设柴门，长是闭斜晖。<br>
——杨万里《归去来兮引》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我们终将在没有黑暗的地方相见。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="http://www.9ku.com/play/658598.htm">残雪-蒋蒋</a></p>
</blockquote>
<blockquote>
<p>时光它荏苒了所有<br>
它蹉跎了回眸<br>
它和我撒了泼<br>
它揭开我的伤<br>
浑然不知的痛<br>
眼泪滑过所有的梦<br>
绕过你眼神的汹涌<br>
你内心的躁动<br>
你为谁发了疯<br>
我百般的包容<br>
你什么都不懂<br>
却把承诺千穿百孔</p>
</blockquote>
<blockquote>
<p>你曾说过陪我去看一场雪<br>
我在漫漫黑夜静候你的约<br>
可谁又知道<br>
寒冬守不住枯叶<br>
被风分裂留下一个缺<br>
你说爱情就像缠绵的蝴蝶<br>
注定躲不过昙花残谢的夜<br>
你赌的誓约还可以改写<br>
绕来绕去的结败给了诀别</p>
</blockquote>
<blockquote>
<p>时光它荏苒了所有<br>
它蹉跎了回眸<br>
它和我撒了泼<br>
它揭开我的伤<br>
浑然不知的痛<br>
眼泪滑过所有的梦<br>
绕过你眼神的汹涌<br>
你内心的躁动<br>
你为谁发了疯<br>
我百般的包容<br>
你什么都不懂<br>
却把承诺千穿百孔</p>
</blockquote>
<blockquote>
<p>你曾说过陪我去看一场雪<br>
我在漫漫黑夜静候你的约<br>
可谁又知道寒冬守不住枯叶<br>
被风分裂留下一个缺<br>
你说爱情就像缠绵的蝴蝶<br>
注定躲不过昙花残谢的夜<br>
你赌的誓约还可以改写<br>
绕来绕去的结败给了诀别</p>
</blockquote>
<blockquote>
<p>你曾说过陪我去看一场雪<br>
我在漫漫黑夜静候你的约<br>
可谁又知道<br>
寒冬守不住枯叶<br>
被风分裂留下一个缺<br>
你说爱情就像缠绵的蝴蝶<br>
注定躲不过昙花残谢的夜<br>
你赌的誓约还可以改写<br>
绕来绕去的结败给了诀别</p>
</blockquote>
<blockquote>
<p>你曾说过陪我去看去看一场雪<br>
我在漫漫黑夜静候静候你的誓约<br>
可谁又知道呢<br>
这寒冬守不住枯叶<br>
我被风分裂留下一个缺缺缺缺缺<br>
你说爱情就像缠缠缠缠绵的蝴蝶<br>
注定躲不过谢了又谢的黑夜<br>
你赌的誓约呢<br>
还怎么能改写<br>
绕来绕去的结败给了诀别</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第31期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-31-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-31-qi/">
        </link>
        <updated>2020-07-19T07:31:34.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595057531699.jpeg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>爱情是把双刃剑，一边把你割得很疼，另一边也把你割得很疼。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>美洲虎的下颚力量惊人，甚至可以直接从猎物头骨咬其大脑，以此杀死猎物。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>更无柳絮因风起，惟有葵花向日倾。<br>
——司马光《客中初夏》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>不管风吹浪打，胜似闲庭信步。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="https://music.163.com/#/song?id=27646687">玫瑰花的葬礼-许嵩</a></p>
</blockquote>
<blockquote>
<p>离开你一百个星期<br>
我回到了这里<br>
寻找我们爱过的证据<br>
没有人愿意提起<br>
玫瑰花它的过去<br>
今天这里的主题<br>
我把它叫作回忆</p>
</blockquote>
<blockquote>
<p>我知道 爱情这东西<br>
他没什么道理<br>
过去我和你在一起<br>
是我太叛逆<br>
现在只剩我自己<br>
偷偷的想你</p>
</blockquote>
<blockquote>
<p>玫瑰花的葬礼<br>
埋葬关于你的回忆<br>
感觉双手麻痹<br>
不能自已<br>
已拉不住你<br>
真的好美丽<br>
那天的烟花雨<br>
我说要娶穿碎花洋裙的你</p>
</blockquote>
<blockquote>
<p>玫瑰花的葬礼<br>
埋葬深深爱着的你<br>
残朵停止呼吸<br>
深入大地<br>
没人会注意<br>
一片小雨滴<br>
陪着我等天明<br>
我用这最后一分钟怀念你</p>
</blockquote>
<blockquote>
<p>我在夜幕笼罩的天桥上潜行<br>
每一级阶梯<br>
都留着你我昔日印迹<br>
温存迷醉 吵闹清醒<br>
都还在我的脚畔兜兜兜兜兜转转不清<br>
没来得及把红色玫瑰递给你<br>
爱就像是一场雨<br>
已经离我而去<br>
你说过<br>
太过鲜艳的爱情 终将凋零</p>
</blockquote>
<blockquote>
<p>玫瑰花的葬礼<br>
埋葬关于你的回忆<br>
感觉双手麻痹<br>
不能自已<br>
已拉不住你<br>
真的好美丽<br>
那天的烟花雨<br>
我说要娶穿碎花洋裙的你</p>
</blockquote>
<blockquote>
<p>玫瑰花的葬礼<br>
埋葬深深爱着的你<br>
残朵停止呼吸<br>
深入大地<br>
没人会注意<br>
一片小雨滴<br>
陪着我等天明<br>
我用这最后一分钟怀念你</p>
</blockquote>
<blockquote>
<p>总是回想过去埋怨我自己<br>
总是不经意间想起了你<br>
现在的你已经太遥不可及<br>
只能留在我记忆<br>
玫瑰花的葬礼<br>
埋葬关于你的回忆<br>
感觉双手麻痹<br>
不能自已<br>
已拉不住你<br>
真的好美丽<br>
那天的烟花雨<br>
我说要娶穿碎花洋裙的你</p>
</blockquote>
<blockquote>
<p>玫瑰花的葬礼<br>
埋葬深深爱着的你<br>
残朵停止呼吸<br>
渗入大地<br>
没人会注意<br>
一片小雨滴<br>
陪着我等天明<br>
我用这最后一分钟怀念你<br>
我用这最后一分钟</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习笔记（三）]]></title>
        <id>https://2293736867.github.io/post/vue-xue-xi-bi-ji-san/</id>
        <link href="https://2293736867.github.io/post/vue-xue-xi-bi-ji-san/">
        </link>
        <updated>2020-07-19T00:24:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-监听">1 监听</h1>
<p>在Vue.js中可以通过<code>watch</code>来监听数据的变化，比如通过<code>watch</code>实现的简单计数器：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;计数器：{{count}}&lt;/p&gt;
    &lt;button @click=&quot;count++&quot;&gt;点我增加&lt;/button&gt;
    &lt;p id=&quot;info&quot;&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
	el: '#app',
	data:
	{
	    count:0
	}
})

vm.$watch('count',function(newValue,oldValue)
{
	document.getElementById(&quot;info&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue;
})
</code></pre>
<p>效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200718175810847.gif" alt="在这里插入图片描述" loading="lazy"><br>
<code>watch</code>有两个参数，一个是要监听的变量，另一个是回调函数，回调函数接受两个参数，第一个参数是新值，第二个参数是旧值。</p>
<p>下面再来看一下有关单位换算的例子：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    吨：&lt;input type=&quot;text&quot; v-model=&quot;ton&quot;&gt;
    千克：&lt;input type=&quot;text&quot; v-model=&quot;kilograms&quot;&gt;&lt;br&gt;
    吨：&lt;p id=&quot;tonInfo&quot;&gt;&lt;/p&gt;
    千克：&lt;p id=&quot;kilogramsInfo&quot;&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data:
    {
        ton:0,
        kilograms:0
    },
    watch:
    {
        ton:function(val)
        {
            this.kilograms = (this.ton = val) * 1000;
        },
        kilograms:function(val)
        {
            this.ton = (this.kilograms = val) / 1000;
        }
    }
})

vm.$watch('ton',function(newValue,oldValue)
{
    document.getElementById(&quot;tonInfo&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue;
})
vm.$watch('kilograms',function(newValue,oldValue)
{
    document.getElementById(&quot;kilogramsInfo&quot;).innerHTML = &quot;修改前：&quot;+oldValue+&quot;&lt;br&gt;修改后：&quot;+newValue;
})
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200718180937921.gif" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="2-样式绑定">2 样式绑定</h1>
<p><code>class</code>与<code>style</code>是HTML元素的属性，用于设置元素的样式，可以利用<code>v-bind</code>来设置样式属性。<code>v-bind</code>在处理<code>class</code>以及<code>style</code>时专门增强了，表达式的结果类型除了是字符串外，还能是对象或者数组。</p>
<h2 id="21-class绑定">2.1 <code>class</code>绑定</h2>
<p>可以为<code>v-bind:class</code>设置一个对象，从而动态切换<code>class</code>：</p>
<pre><code class="language-html">&lt;style&gt;
    .active
    {
        width:100px;
        height: 100px;
        background: green;
    }
&lt;/style&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:class=&quot;{'active':isActive}&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">vm = new Vue({
	el: '#app',
	data:
	{
	    isActive:true
	}
})
</code></pre>
<p>也可以传入多个属性来动态切换多个<code>class</code>：</p>
<pre><code class="language-css">.class0
{
    width:100px;
    height: 100px;
}
.class1
{
    background: green;
}
.class2
{
    background: red;
}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div class=&quot;class0&quot; v-bind:class=&quot;{'class1':active1,'class2':active2}&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data:
    {
        active1:true,
        active2:true
    }
})
</code></pre>
<p>效果：<br>
<img src="https://img-blog.csdnimg.cn/20200719065142231.png" alt="在这里插入图片描述" loading="lazy"><br>
也可以利用对象进行简化：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div class=&quot;class0&quot; v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data:
    {
        classObject:
        {
            class1:true,
            class2:true
        }
    }
})
</code></pre>
<h2 id="22-计算属性">2.2 计算属性</h2>
<p>在<code>v-bind:class</code>中除了是一个对象还能绑定返回对象的计算属性，比如：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data:
    {
        active1:true,
        error:{
            value:true,
            type:'fatal'
        }
    },
    computed:{
        classObject:function() {
            return {
                class0:true,
                class1: this.active1 &amp;&amp; !this.error.value,
                class2: this.error.value &amp;&amp; this.error.type === 'fatal'
            }
        }
    }
})
</code></pre>
<p>效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200719070149891.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="23-数组">2.3 数组</h2>
<p>也可以传递给<code>v-bind:class</code>一个数组，数组的元素为变量，变量的内容为对应的CSS类名：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:class=&quot;[active1,active2]&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
	el: '#app',
	data: {
	    active1:'class0',
	    active2:'class1'
	}
})
</code></pre>
<p>也可以利用三元表达式来切换：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:class=&quot;[active1,active2 ? 'class1' : 'class2']&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="3-内联样式">3 内联样式</h1>
<p>可以在<code>v-bind:style</code>中直接设置样式（注意前后带<code>{}</code>）：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:style=&quot;{color:color,fontSize:fontSize+'px'}&quot;&gt;测试&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
        color:'#FF0000',
        fontSize:30
    }
})
</code></pre>
<p>当然也可以像绑定<code>class</code>一样直接绑定到一个对象上：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:style=&quot;styleObject&quot;&gt;测试&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
        styleObject: {
            color:'#FF0000',
            fontSize:'30px'
        }
    }
})
</code></pre>
<p>也可以使用数组进行绑定多个样式：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-bind:style=&quot;[styleObject1,styleObject2]&quot;&gt;测试&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
        styleObject1: {
            color:'#FF0000',
        },
        styleObject2:{
            fontSize:'30px'
        }
    }# 5 
})
</code></pre>
<p>另外当<code>v-bind:style</code>需要特殊前缀的CSS时，比如<code>transform</code>，Vue会自动侦测并添加相应前缀。</p>
<h1 id="4-事件处理">4 事件处理</h1>
<h2 id="41-v-on">4.1 <code>v-on</code></h2>
<p>事件监听可以使用<code>v-on</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;count += 1&quot;&gt;点击增加1&lt;/button&gt;
    &lt;p&gt;这个按钮被点击了{{count}}次&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
        count:0
    }
})
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020071907495115.gif" alt="在这里插入图片描述" loading="lazy"><br>
通常来说单击按钮会触发一个方法调用，在<code>methods</code>中指定即可：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;test&quot;&gt;点击触发事件&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    methods:{
        test:function(){
            alert('Hello')
            //event表示是原生DOM事件
            if(event) {
                alert(event.target.tagName)
            }
        }
    }
})
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200719075352186.gif" alt="在这里插入图片描述" loading="lazy"><br>
当然也可以使用内联的JS语句：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;say('hi')&quot;&gt;Say hi&lt;/button&gt;
    &lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    methods:{
        say:function(val){
            alert(val)
        }
    }
})
</code></pre>
<h2 id="42-事件修饰符">4.2 事件修饰符</h2>
<p>Vue为<code>v-on</code>提供了事件修饰符来处理DOM事件细节，如<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>，通过<code>.</code>表示的指令调用修饰符：</p>
<ul>
<li><code>.stop</code>：阻止事件冒泡</li>
<li><code>.prevent</code>：提交事件不再重载页面，如<code>&lt;form v-on.submit.prevent=&quot;onSumbit&quot;&gt;&lt;/form&gt;</code></li>
<li><code>.capture</code>：事件捕获模式</li>
<li><code>.self</code>：只当事件在该元素本身（而不是子元素）触发时回调</li>
<li><code>.once</code>：事件只能点击一次</li>
</ul>
<h2 id="43-按键修饰符">4.3 按键修饰符</h2>
<p>Vue允许在v-on在监听键盘事件时添加按键修饰提示符：</p>
<pre><code class="language-html">&lt;!--只有keyCode为13时调用submit()--&gt;
&lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre>
<p>keyCode值对应ASCII表，为了方便，Vue为常用的按键提供了别名：</p>
<ul>
<li><code>.esc</code></li>
<li><code>.delete</code>（删除+退格）</li>
<li><code>.enter</code>/<code>.space</code>/<code>.tab</code></li>
<li><code>.up</code>/<code>.down</code>/<code>.left</code>/<code>.right</code></li>
<li><code>.ctrl</code>/<code>.alt</code>/<code>.shift</code>/<code>.meta</code></li>
</ul>
<p>当然也可以进行按键的组合，使用<code>.</code>连接即可。<br>
例子如下：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请按下空格&quot; v-on:keyup.space=&quot;spacePressed&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请按下Ctrl+C&quot; v-on:keyup.ctrl.67=&quot;ctrlCPressed&quot;&gt;
    &lt;!-- &lt;input type=&quot;text&quot; placeholder=&quot;请按下Ctrl+C&quot; @keyup.ctrl.67=&quot;ctrlCPressed&quot;&gt; --&gt;
    &lt;p id=&quot;info&quot;&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    methods:{
        spacePressed:function(){
            document.getElementById(&quot;info&quot;).innerHTML = &quot;您按下了空格&quot;;
        },
        ctrlCPressed:function(){
            document.getElementById(&quot;info&quot;).innerHTML = &quot;您按下了Ctrl+C&quot;;
        }
    }
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式学习笔记（八）：建造者模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-ba-jian-zao-zhe-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-xue-xi-bi-ji-ba-jian-zao-zhe-mo-shi/">
        </link>
        <updated>2020-07-19T00:22:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-建造者模式">1 建造者模式</h1>
<h2 id="11-定义">1.1 定义</h2>
<p><strong>建造者模式：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong><br>
<strong>建造者模式是一种对象创建型模式。</strong></p>
<p>建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需的建造者类型即可。建造者模式关注一步一步地创建一个复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p>
<h2 id="12-复杂对象">1.2 复杂对象</h2>
<p>建造者模式中用到了复杂对象这个概念。<br>
<strong>复杂对象就是指那些包含多个成员变量的对象，这些成员变量也叫部件或者零件</strong>，例如汽车包括方向盘，发动机，轮胎等 ，<br>
汽车就是复杂对象，方向盘，发动机以及轮胎就是汽车的部件。</p>
<h2 id="13-结构图">1.3 结构图</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200718102523398.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="14-角色">1.4 角色</h2>
<p>建造者模式包含以下四个角色：</p>
<ul>
<li><code>Builder</code>（抽象建造者）：为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类是<code>buildXXX()</code>方法，用于创建复杂对象的各个部分（部件），另一类是是<code>getResult()</code>，用于返回复杂对象。<code>Builder</code>既可以是抽象类，也可以是接口</li>
<li><code>ConcreteBuilder</code>（具体建造者）：实现了<code>Builder</code>接口或者继承了<code>Builder</code>类，实现各个部件的具体构造和装配方法，定义并明确其所创建的复杂对象，也可以提供一个方法返回创建好的复杂对象</li>
<li><code>Product</code>（产品角色）：是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义其装配过程</li>
<li><code>Director</code>（指挥者）：指挥者又叫导演类，复杂安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造以及装配方法，完成复杂对象的建造。客户端一般只需要与导演类进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象，然后通过导演类的构造函数或者setter将该对象传入导演类中</li>
</ul>
<h3 id="141-product">1.4.1 <code>Product</code></h3>
<p>一般来说<code>Product</code>是一个复杂对象，典型的定义如下：</p>
<pre><code class="language-java">class Product
{
	private type1 part1;
	private type2 part2;
	private type3 part3;
	//getter + setter ...
}
</code></pre>
<p>其中<code>type1</code>，<code>type2</code>等指各种不同的类型，一般来说会有嵌套类。</p>
<h3 id="142-builder">1.4.2 <code>Builder</code></h3>
<p>抽象建造者的典型定义如下：</p>
<pre><code class="language-java">abstract class Builder
{
	protected Product product = new Product();
	public abstract void buildPart1();
	public abstract void buildPart2();
	public abstract void buildPart3();
	public Product getResult()
	{
		return product;
	}
}
</code></pre>
<p>抽象建造者中声明了一系列<code>buildXXX</code>方法，用于创建<code>Product</code>的各个部件，具体创建过程在<code>ConcreteBuilder</code>中实现，<code>getResult()</code>返回已创建完成的<code>Product</code>。</p>
<h3 id="143-concretebuilder">1.4.3 <code>ConcreteBuilder</code></h3>
<p><code>ConcreteBuilder</code>实现了<code>Builder</code>中的<code>buildXXX</code>方法，通过调用<code>Product</code>的setter来实现给产品对象的各部分赋值。<br>
不同的<code>ConcreteBuilder</code>在实现<code>buildXXX</code>是将有所区别，比如传入<code>Product</code>的setter参数的不同。<br>
另外在有些<code>ConcreteBuilder</code>中某些<code>buildXXX</code>无须实现（提供一个空实现），这些对客户端来说无须关心，客户端只需要知道具体建造者的类型即可。<br>
典型定义如下：</p>
<pre><code class="language-java">class ConcreteBuilder extends Builder
{
	public void buildPart1()
	{
		product.setPart1(&quot;part1&quot;);
	}
	public void buildPart2()
	{
		product.setPart2(&quot;part2&quot;);		
	}
	public void buildPart3()
	{
		product.setPart3(&quot;part3&quot;);
	}
	public Product getResult()
	{
		return product;
	}
}
</code></pre>
<h3 id="144-director">1.4.4 <code>Director</code></h3>
<p><code>Director</code>类主要有两个作用：</p>
<ul>
<li>隔离了客户与创建过程</li>
<li>控制产品的创建过程，包括某个<code>buildXXX</code>方法是否被调用，以及调用时的先后次序等等</li>
</ul>
<p>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者调用建造者的相关方法，返回一个完整的产品对象。典型实现如下：</p>
<pre><code class="language-java">class Director
{
	private Builder builder;
	public Director(Builder builder)
	{
		this.builder = builder;
	}
	
	public void setBuilder(Builder builder)
	{
		this.builder = builder;		
	}
	
	public Product construct()
	{
		builder.buildPart1();
		builder.buildPart2();
		builder.buildPart3();
		return builder.getResult();
	}
}
</code></pre>
<h1 id="2-实例">2 实例</h1>
<blockquote>
<p>游戏角色的创建：不同的角色具有差别极大的外部特征，而且要求随着游戏的进行会不断出现新的角色，也就是说扩展性要好。这里例子简化就创建三个角色：英雄，天使与恶魔。</p>
</blockquote>
<p>思路：</p>
<ul>
<li><code>Actor</code>为复杂产品</li>
<li><code>ActorController</code>为指挥者</li>
<li><code>ActorBuilder</code>为抽象建造者</li>
<li><code>HeroBuilder</code>/<code>AngelBuilder</code>/<code>DevilBuilder</code>为具体建造者</li>
</ul>
<pre><code class="language-java">// 复杂产品
class Actor
{
    private String type;
    private String face;
    private String costume;
    private String hairstyle;
    //getter and setter ...
}

//抽象建造者
abstract class ActorBuilder
{
    protected Actor actor = new Actor();

    public abstract void buildType();
    public abstract void buildFace();
    public abstract void buildCostume();
    public abstract void buildHairstyle();

    public Actor createActor()
    {
        return actor;
    }
}

//具体建造者
class HeroBuilder extends ActorBuilder
{
    public void buildType(){ actor.setType(&quot;英雄&quot;); }
    public void buildFace(){ actor.setFace(&quot;英俊&quot;); }
    public void buildCostume(){ actor.setCostume(&quot;盔甲&quot;); }
    public void buildHairstyle(){ actor.setHairstyle(&quot;飘逸&quot;); }
}

class AngleBuilder extends ActorBuilder
{
    public void buildType(){ actor.setType(&quot;天使&quot;); }
    public void buildFace(){ actor.setFace(&quot;漂亮&quot;); }
    public void buildCostume(){ actor.setCostume(&quot;白裙&quot;); }
    public void buildHairstyle(){ actor.setHairstyle(&quot;披肩长发&quot;); }
}

class DevilBuilder extends ActorBuilder
{
    public void buildType(){ actor.setType(&quot;恶魔&quot;); }
    public void buildFace(){ actor.setFace(&quot;帅气&quot;); }
    public void buildCostume(){ actor.setCostume(&quot;黑衣&quot;); }
    public void buildHairstyle(){ actor.setHairstyle(&quot;红色&quot;); }
}

// 指挥者类
class ActorController
{
    public Actor construct(ActorBuilder builder)
    {
        builder.buildType();
        builder.buildFace();
        builder.buildHairstyle();
        builder.buildCostume();
        return builder.createActor();
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        ActorBuilder builder = new AngleBuilder();
        ActorController controller = new ActorController();
        Actor actor = controller.construct(builder);
        System.out.println(actor.getType());
        System.out.println(actor.getCostume());
        System.out.println(actor.getHairstyle());
        System.out.println(actor.getFace());
    }
}
</code></pre>
<h1 id="3-优化">3 优化</h1>
<h2 id="31-省略director">3.1 省略<code>Director</code></h2>
<p>其实<code>Director</code>是可以省略的，直接与<code>Builder</code>合并，在<code>Builder</code>中提供类似<code>Direcotr</code>中的<code>construct()</code>方法，并定义为静态方法，如：</p>
<pre><code class="language-java">abstract class ActorBuilder
{
    protected static Actor actor = new Actor();

    public abstract void buildType();
    public abstract void buildFace();
    public abstract void buildCostume();
    public abstract void buildHairstyle();

    public static Actor build(ActorBuilder builder)
    {
        builder.buildType();
        builder.buildFace();
        builder.buildHairstyle();
        builder.buildCostume();
        return actor;
    }
}
</code></pre>
<p>同时客户端代码修改如下：</p>
<pre><code class="language-java">Actor actor = ActorBuilder.build(new AngleBuilder());
//Actor actor = ActorBuilder.build(new HeroBuilder());
//Actor actor = ActorBuilder.build(new DevilBuilder());
</code></pre>
<p>再简单一点的可以省略<code>createActor</code>中的参数：</p>
<pre><code class="language-java">abstract class ActorBuilder
{
    protected Actor actor = new Actor();

    public abstract void buildType();
    public abstract void buildFace();
    public abstract void buildCostume();
    public abstract void buildHairstyle();

    public Actor build()
    {
        buildType();
        buildFace();
        buildHairstyle();
        buildCostume();
        return actor;
    }
}
</code></pre>
<p>同时客户端简化如下：</p>
<pre><code class="language-java">Actor actor = new AngleBuilder().build();
</code></pre>
<p>这两种方式简化了系统结构的同时又不影响灵活性以及可扩展性，但是加重了抽象建造者的职责，如果<code>build</code>方法较为复杂，待构建的产品组成部分较多，建议还是将其单独封装在<code>Director</code>中，这样更加符合SRP（单一权责原则）。</p>
<h2 id="32-钩子方法">3.2 钩子方法</h2>
<p>钩子方法是一种可以控制是否调用某个<code>buildXXX</code>的方法，特征如下：</p>
<ul>
<li>返回类型为<code>boolean</code></li>
<li>方法名一般为<code>isXXX</code></li>
</ul>
<p>例如修改<code>ActorBuilder</code>如下：</p>
<pre><code class="language-java">abstract class ActorBuilder
{
    protected Actor actor = new Actor();

    public abstract void buildType();
    public abstract void buildFace();
    public abstract void buildCostume();
    public abstract void buildHairstyle();

    public boolean isBareheaded()
    {
        return false;
    }

    public Actor createActor()
    {
        return actor;
    }
}
</code></pre>
<p>并修改<code>DevilBuilder</code>，覆盖默认方法：</p>
<pre><code class="language-java">class DevilBuilder extends ActorBuilder
{
    public void buildType(){ actor.setType(&quot;恶魔&quot;); }
    public void buildFace(){ actor.setFace(&quot;帅气&quot;); }
    public void buildCostume(){ actor.setCostume(&quot;黑衣&quot;); }
    public void buildHairstyle(){ actor.setHairstyle(&quot;红色&quot;); }
    public boolean isBareheaded(){ return true; }
}
</code></pre>
<p>最后修改<code>ActorController</code>：</p>
<pre><code class="language-java">class ActorController
{
    public Actor construct(ActorBuilder builder)
    {
        builder.buildType();
        builder.buildFace();
        builder.buildCostume();
        if(builder.isBareheaded())
            builder.buildHairstyle();
        return builder.createActor();
    }
}
</code></pre>
<p>相比起之前的<code>ActorController</code>多了一次判断，测试如下：</p>
<pre><code class="language-java">public static void main(String[] args) {
    ActorController controller = new ActorController();
    Actor actor = controller.construct(new AngleBuilder());
    System.out.println(actor.getType());
    System.out.println(actor.getCostume());
    System.out.println(actor.getHairstyle());
    System.out.println(actor.getFace());
    System.out.println();

    actor = controller.construct(new DevilBuilder());
    System.out.println(actor.getType());
    System.out.println(actor.getCostume());
    System.out.println(actor.getHairstyle());
    System.out.println(actor.getFace());
}
</code></pre>
<p>输出如下：<br>
<img src="https://img-blog.csdnimg.cn/20200718142036116.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="33-返回builder">3.3 返回Builder</h2>
<p>在实际应用中<code>Director</code>较少出现，通常只有<code>Builder</code>以及<code>Product</code>，而且<code>Builder</code>是作为<code>Product</code>的内部类，提供一系列<code>set</code>方法，这些<code>set</code>方法返回一个<code>Builder</code>方便后续调用，最后以一个<code>build()</code>结尾，比如OkHttp中的<code>Request</code>/<code>OkHttpClient</code>：</p>
<pre><code class="language-java">OkHttpClient client = new OkHttpClient.Builder()
.connectTimeout(5000,TimeUnit.MILLISECONDS)
.readTimeout(10,TimeUnit.SECONDS)
.build();

Request request = new Request.Builder()
.url(&quot;https://xxx&quot;)
.post(requestBody)
.build();
</code></pre>
<h1 id="4-主要优点">4 主要优点</h1>
<ul>
<li>封装细节：建造者模式中客户端不需要知道产品内部组成细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>扩展性好：每一个具体建造者都相对独立，而与其他建造者无关，伊尼茨可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，扩展方便，符合开闭原则</li>
<li>控制创建过程：将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，更加精细地控制创建过程</li>
</ul>
<h1 id="5-主要缺点">5 主要缺点</h1>
<ul>
<li>范围受限：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分不相同，就不适合使用建造者模式，因此使用范围收到一定限制</li>
<li>建造者多：如果产品内部结构复杂多变，可能会需要定义很多具体建造者类来实现这种变化，增大系统的理解难度与运行成本</li>
</ul>
<h1 id="6-适用场景">6 适用场景</h1>
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不再建造者类或者客户类中</li>
<li>隔离复杂对象的创建与使用，并使得相同的创建过程可以创建不同的产品</li>
</ul>
<h1 id="7-总结">7 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200718143426156.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第30期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-30-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-30-qi/">
        </link>
        <updated>2020-07-17T17:34:58.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1595007375325.jpg" alt="" loading="lazy"></figure>
<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>知道为何自古红颜多薄命吗？因为没人在意丑的人活多久。</p>
</blockquote>
<h1 id="每日冷知识">每日冷知识</h1>
<blockquote>
<p>为了便于将石料运到现场，建造北京紫禁城的工人修建了一条冰路。这条冰路通过雪橇运输石料，以水进行润滑，从而减少摩擦，并使雪橇在水重新冷冻之前更容易滑动。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>白发渔樵江渚上，惯看秋月春风。<br>
——杨慎《临江仙·滚滚长江东逝水》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>末将于禁，愿为曹家世代赴汤蹈火。</p>
</blockquote>
<h1 id="每日音乐">每日音乐</h1>
<blockquote>
<p><a href="http://www.kugou.com/song/132nvb3e.html#hash=B7B91C42239189D7299DDFB4CDCCBFB8&amp;album_id=0">我热情如火，你冰冻成河-黄静美</a></p>
</blockquote>
<blockquote>
<p>我该如何去厮守<br>
你才觉得不将就<br>
互相折磨到白头<br>
渐渐消逝的温柔<br>
难道非你不可 是有多难得<br>
这样的感情对我来说</p>
</blockquote>
<blockquote>
<p>或许不知道<br>
自己到底要的是什么<br>
遇见你就像飞蛾扑火<br>
不管值不值得<br>
最美的承诺<br>
只是一时快乐惹的祸<br>
而如今只剩孤独的我<br>
注定没有结果</p>
</blockquote>
<blockquote>
<p>我懂你要的自由<br>
别再惯性找借口<br>
你从未被我拥有<br>
随时都可能放开手<br>
而我热情如火 你冰冻成河<br>
被爱的权利你都占有</p>
</blockquote>
<blockquote>
<p>我该如何去厮守<br>
你才觉得不将就<br>
互相折磨到白头<br>
渐渐消逝的温柔<br>
难道非你不可 是有多难得<br>
这样的感情对我来说<br>
不值得</p>
</blockquote>
<blockquote>
<p>或许不知道<br>
自己到底要的是什么<br>
遇见你就像飞蛾扑火<br>
不管值不值得<br>
最美的承诺<br>
只是一时快乐惹的祸<br>
而如今只剩孤独的我<br>
注定没有结果</p>
</blockquote>
<blockquote>
<p>我懂你要的自由<br>
别再惯性找借口<br>
你从未被我拥有<br>
随时都能放开手<br>
而我热情如火 你冰冻成河<br>
被爱的权利你都占有</p>
</blockquote>
<blockquote>
<p>我该如何厮守<br>
你才觉得不将就<br>
互相折磨到白头<br>
渐渐消逝的温柔<br>
难道非你不可 是有多难得<br>
这样的感情对我来说</p>
</blockquote>
<blockquote>
<p>我懂你要的自由<br>
别再惯性找借口<br>
你从未被我拥有<br>
随时都能放开手<br>
而我热情如火 你冰冻成河<br>
被爱的权利你都占有</p>
</blockquote>
<blockquote>
<p>我该如何去厮守<br>
你才觉得不将就<br>
互相折磨到白头<br>
渐渐消逝的温柔<br>
难道非你不可 是有多难得<br>
这样的感情对我来说<br>
不值得</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式（七）：原型模式]]></title>
        <id>https://2293736867.github.io/post/she-ji-mo-shi-qi-yuan-xing-mo-shi/</id>
        <link href="https://2293736867.github.io/post/she-ji-mo-shi-qi-yuan-xing-mo-shi/">
        </link>
        <updated>2020-07-17T17:33:11.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%9A%E4%B9%89">1 定义</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">2 实现方法</a>
<ul>
<li><a href="#21-%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">2.1 通用实现方法</a></li>
<li><a href="#22-clone">2.2 <code>clone()</code></a></li>
</ul>
</li>
<li><a href="#3-%E5%AE%9E%E4%BE%8B">3 实例</a></li>
<li><a href="#4-%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86">4 浅克隆与深克隆</a>
<ul>
<li><a href="#41-%E6%B5%85%E5%85%8B%E9%9A%86">4.1 浅克隆</a></li>
<li><a href="#42-%E6%B7%B1%E5%85%8B%E9%9A%86">4.2 深克隆</a></li>
</ul>
</li>
<li><a href="#5-%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8">5 原型管理器</a>
<ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89">5.1 定义</a></li>
<li><a href="#52-%E5%AE%9E%E4%BE%8B">5.2 实例</a></li>
</ul>
</li>
<li><a href="#6-%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">6 主要优点</a></li>
<li><a href="#7-%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9">7 主要缺点</a></li>
<li><a href="#8-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">8 适用场景</a></li>
<li><a href="#9-%E6%80%BB%E7%BB%93">9 总结</a></li>
</ul>
</p>
<h1 id="1-定义">1 定义</h1>
<p><strong>原型模式：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。<br>
原型模式是一种对象创建型模式。</strong></p>
<p>原型模式的工作原理很简单，将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。原型模式是一种另类的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法实现。</p>
<p>通过克隆方法创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆多产生的对象进行的修改不会对原型对象造成任何的影响，每一个克隆的对象都是相互独立的，通过不同的方式对克隆对象进行修改之后，可以得到一系列相似但不完全相同的对象。</p>
<p>结构图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200717155947994.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>原型模式包含以下三个角色：</p>
<ul>
<li>Prototype（原型抽象类）：声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，还能是具体实现类</li>
<li>ConcretePrototypr（具体原型类）：实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</li>
<li>Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。</li>
</ul>
<h1 id="2-实现方法">2 实现方法</h1>
<p>在Java中常用的实现方法有两种：</p>
<ul>
<li>通用实现方法</li>
<li><code>clone()</code>方法</li>
</ul>
<h2 id="21-通用实现方法">2.1 通用实现方法</h2>
<p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证成员变量相同。<br>
示例代码：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        Prototype prototype1 = new ConcretePrototype();
        prototype1.setField(&quot;test&quot;);
        Prototype prototype2 = prototype1.clone();
        System.out.println(prototype1.getField() == prototype2.getField());
        System.out.println(prototype1 == prototype2);
    }
}

interface Prototype
{
    Prototype clone();
    void setField(String f);
    String getField();
}


class ConcretePrototype implements Prototype
{
    private String field;

    public void setField(String f)
    {
        field = f;
    }

    public String getField()
    {
        return field;
    }

    public Prototype clone()
    {
        Prototype prototype = new ConcretePrototype();
        prototype.setField(this.field);
        return prototype;
    }
}
</code></pre>
<h2 id="22-clone">2.2 <code>clone()</code></h2>
<p><code>java.lang.Object</code>提供了一个<code>clone()</code>，可以将一个Java对象克隆一份，利用<code>clone()</code>可以直接将对象克隆一份，但是必须实现<code>Cloneable</code>接口，否则<code>clone()</code>时会抛出<code>CloneNotSupportedException</code>。<br>
示例代码如下：</p>
<pre><code class="language-java">// 在2.1的基础上修改ConcreteProtoype即可
class ConcretePrototype implements Prototype,Cloneable
{
    private String field;

    public void setField(String f)
    {
        field = f;
    }

    public String getField()
    {
        return field;
    }

    public Prototype clone()
    {
        Object object = null;
        try
        {
            object = super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return (Prototype)object;
    }
}
</code></pre>
<p>一般而言，Java中的<code>clone()</code>满足：</p>
<ul>
<li>对任何对象<code>x</code>都有<code>x.clone() != x</code>，也就是克隆的对象与原型对象不是同一个对象</li>
<li>对任何对象<code>x</code>都有<code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样</li>
<li>如果<code>x</code>的<code>equals()</code>定义恰当，那么<code>x.clone().equals(x)</code>应该成立</li>
</ul>
<p>具体实现步骤如下：</p>
<ul>
<li>覆盖<code>clone()</code>，并声明为<code>public</code></li>
<li><code>clone()</code>中调用<code>super.clone()</code></li>
<li>派生类需要实现<code>Cloneable</code>接口</li>
</ul>
<h1 id="3-实例">3 实例</h1>
<blockquote>
<p>开发一个工作周报系统，工作周报的内容都大同小异，只有一些小地方存在差异，但是系统每次默认创建的都是空白报表，用户不断复制粘贴来填写重复内容。使用原型模式对其进行优化，快速创建相同或类似的工作周报。</p>
</blockquote>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        WeeklyLog weeklyLog1 = new WeeklyLog();
        weeklyLog1.setContent(&quot;content&quot;);
        weeklyLog1.setName(&quot;Weekly log 1&quot;);
        weeklyLog1.setDateTime(LocalDateTime.now());

        System.out.println(weeklyLog1.getName());
        System.out.println(weeklyLog1.getContent());
        System.out.println(weeklyLog1.getDateTime());

        WeeklyLog weeklyLog2 = weeklyLog1.clone();
        weeklyLog2.setName(&quot;Weekly log 2&quot;);
        System.out.println(weeklyLog2.getName());
        System.out.println(weeklyLog2.getContent());
        System.out.println(weeklyLog2.getDateTime());
    }
}

class WeeklyLog implements Cloneable
{
    private String name;
    private LocalDateTime dateTime;
    private String content;

    //getter and setter
    //...

    public WeeklyLog clone()
    {
        Object obj = null;
        try
        {
            obj = super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return (WeeklyLog)obj;
    }
    
}
</code></pre>
<h1 id="4-浅克隆与深克隆">4 浅克隆与深克隆</h1>
<p>一般来说，工作周报可能会携带附件，使用上面的原型模式来进行工作周报的复制没有问题，但是附件（一般是另一个类）不会进行复制。这是因为浅克隆与深克隆的原因，下面具体来看一下。</p>
<h2 id="41-浅克隆">4.1 浅克隆</h2>
<p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象。（在Java中）值类型包括：</p>
<ul>
<li>int</li>
<li>double</li>
<li>byte</li>
<li>boolean</li>
<li>char</li>
<li>float</li>
<li>long</li>
<li>short</li>
</ul>
<p>也就是这些类型的值都会完整复制一份给克隆对象，对于引用类型，则将引用对象的地址复制一份给克隆对象。（在Java中）引用类型就是除了基本类型之外的所有类型，常见的有：</p>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
<p>对于引用类型，原型对象与克隆对象指向相同的内存地址，也就是其实并没有被复制，而是共享一份地址相同的值。<br>
在Java中可以通过<code>Object</code>的<code>clone()</code>实现浅克隆，也就是上面例子的做法。</p>
<h2 id="42-深克隆">4.2 深克隆</h2>
<p>在深克隆中，无论变量是值类型还是引用类型都会完整复制一份给克隆对象。<br>
在Java中实现深克隆可以通过序列化等方式实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制品，而原对象仍然存在于内存中。想要进行序列化必须实现<code>Serializable</code>接口。</p>
<p>代码如下：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        WeeklyLog weeklyLog1 = new WeeklyLog();
        WeeklyLog weeklyLog2 = null;
        Attachement attachement = new Attachement();
        weeklyLog1.setAttachement(attachement);
        try
        {
            weeklyLog2 = weeklyLog1.deepClone(); 
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(weeklyLog1 == weeklyLog2);
        System.out.println(weeklyLog1.getAttachement() == weeklyLog2.getAttachement());
    }
}

class Attachement implements Serializable
{
    private String name;
    //getter and setter
    //...
}

class WeeklyLog implements Serializable
{
    private String name;
    private LocalDateTime dateTime;
    private String content;
    private Attachement attachement;

    //getter and setter
    //...

    public WeeklyLog deepClone() throws IOException , ClassNotFoundException , OptionalDataException
    {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(this);

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

        return (WeeklyLog)objectInputStream.readObject();
    }
}
</code></pre>
<p>当然除了使用<code>ByteArrayOutput/InputStream</code>以及<code>ObjectInput/OutputStream</code>外，还可以利用以下工具类进行深克隆：</p>
<ul>
<li><code>org.apache.commons.lang3.SerializationUtils.clone()</code>：需要实现<code>Serializable</code>接口</li>
<li><code>Gson</code>：无需实现<code>Serializable</code>接口，<code>toJson()+fromJson()</code></li>
<li><code>Jackson</code>：也是无需实现<code>Serializable</code>接口，<code>readValue()+writeValueAsString()</code>等</li>
</ul>
<h1 id="5-原型管理器">5 原型管理器</h1>
<h2 id="51-定义">5.1 定义</h2>
<p>原型管理器是将多个原型对象存储在一个集合中供客户端使用的专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的克隆，可以通过复制集合中对应的原型对象来获取。在原型管理器中针对抽象原型类进行编程。<br>
结构图如下：<br>
<img src="https://img-blog.csdnimg.cn/2020071800411674.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-实例">5.2 实例</h2>
<blockquote>
<p>日常办公中会有许多公文需要创建，例如《可行性分析报告》，《立项建议书》，《软件需求规格说明书》，《项目进展报告》等，为了提高工作效率需要为各类公文创建模板，用户可以通过这些模板快速创建新的公文，这些公文模板进行统一的管理，系统根据用户的请求的不同生成不同的新公文。</p>
</blockquote>
<p>首先是抽象原型以及具体原型的代码：</p>
<pre><code class="language-java">interface OfficialDocument extends Cloneable
{
    OfficialDocument clone();
    void display();
}

//可行性分析报告
class FAR implements OfficialDocument 
{
    public OfficialDocument clone()
    {
        OfficialDocument far = null;
        try
        {
            far = (OfficialDocument)super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return far;
    }

    public void display()
    {
        System.out.println(&quot;可行性分析报告&quot;);
    }
}

//软件需求规格说明书
class SRS implements OfficialDocument
{
    public OfficialDocument clone()
    {
        OfficialDocument srs = null;
        try
        {
            srs = (OfficialDocument)super.clone();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return srs;
    }

    public void display()
    {
        System.out.println(&quot;软件需求规格说明书&quot;);
    }
}
</code></pre>
<p>接着是原型管理器的代码，使用枚举单例实现：</p>
<pre><code class="language-java">enum PrototypeManager 
{
    INSTANCE;

    private Hashtable&lt;String,OfficialDocument&gt; hashtable = new Hashtable&lt;&gt;();
    private PrototypeManager()
    {
        add(&quot;far&quot;,new FAR());
        add(&quot;srs&quot;,new SRS());
    }

    public void add(String key,OfficialDocument document)
    {
        hashtable.put(key, document);
    }

    public OfficialDocument get(String key)
    {
        return ((OfficialDocument)hashtable.get(key)).clone();
    }
}
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java">public class Test
{
    public static void main(String[] args) {
        PrototypeManager manager = PrototypeManager.INSTANCE;
        OfficialDocument document1,document2,document3,document4;

        document1 = manager.get(&quot;far&quot;);
        document1.display();

        document2 = manager.get(&quot;far&quot;);
        document2.display();
        System.out.println(document1 == document2);

        document3 = manager.get(&quot;srs&quot;);
        document3.display();

        document4 = manager.get(&quot;srs&quot;);
        document4.display();
        System.out.println(document3 == document4);
    }
}
</code></pre>
<h1 id="6-主要优点">6 主要优点</h1>
<ul>
<li>简化创建过程：当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li>
<li>扩展性较好：由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对系统都没有任何影响</li>
<li>简化创建结构：原型模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无需专门的工厂类来创建产品</li>
<li>保存状态：可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作</li>
</ul>
<h1 id="7-主要缺点">7 主要缺点</h1>
<ul>
<li>修改不方便：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造的时候，需要修改源代码，违背了OCP（开放闭合原则）</li>
<li>深克隆需要嵌套类支持：在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象都必须支持深克隆，实现起来可能比较麻烦</li>
</ul>
<h1 id="8-适用场景">8 适用场景</h1>
<ul>
<li>创建新对象成本较大，比如初始化需要较长时间，占用太多的CPU资源或网络资源，新的对象可以通过原型模式对已有对象进行复制获取，如果是相似对象可以对成员变量稍作修改</li>
<li>如果系统要保存对象的状态，而对象的变化状态很小，或者对象本身占用内存较少，可以使用原型模式配合备忘录模式</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个实例方便</li>
</ul>
<h1 id="9-总结">9 总结</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200718011132428.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
</feed>