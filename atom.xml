<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-06-02T19:33:34.279Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[后端spring boot+前端Android交互+mysql增删查改]]></title>
        <id>https://2293736867.github.io/post/hou-duan-spring-bootqian-duan-android-jiao-hu-mysql-zeng-shan-cha-gai/</id>
        <link href="https://2293736867.github.io/post/hou-duan-spring-bootqian-duan-android-jiao-hu-mysql-zeng-shan-cha-gai/">
        </link>
        <updated>2020-06-02T19:32:46.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E6%A6%82%E8%BF%B0">1.概述</a></li>
<li><a href="#2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">2.开发环境</a></li>
<li><a href="#3%E5%90%8E%E7%AB%AF">3.后端</a>
<ul>
<li><a href="#1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAspring-boot%E9%A1%B9%E7%9B%AE">(1)新建一个spring boot项目</a></li>
<li><a href="#2entity">(2)Entity</a></li>
<li><a href="#3repository">(3)Repository</a></li>
<li><a href="#4service">(4)Service</a></li>
<li><a href="#5controller">(5)Controller</a></li>
</ul>
</li>
<li><a href="#4%E5%89%8D%E7%AB%AF">4.前端</a>
<ul>
<li><a href="#1%E5%A2%9E">(1)增</a></li>
<li><a href="#2%E5%88%A0">(2)删</a></li>
<li><a href="#3%E6%9F%A5">(3)查</a></li>
<li><a href="#4%E6%94%B9">(4)改</a></li>
<li><a href="#5%E7%95%8C%E9%9D%A2">(5)界面</a></li>
<li><a href="#6%E4%BE%9D%E8%B5%96%E4%B8%8E%E5%85%B6%E4%BB%96">(6)依赖与其他</a></li>
<li><a href="#7%E7%BD%91%E7%BB%9C%E6%9D%83%E9%99%90">(7)网络权限</a></li>
</ul>
</li>
<li><a href="#5%E6%B5%8B%E8%AF%95">5.测试</a></li>
<li><a href="#6%E6%BA%90%E7%A0%81">6.源码</a></li>
</ul>
</p>
<h1 id="1概述">1.概述</h1>
<p>使用spring boot作为后端框架与Android端配合mysql进行基本的交互,包含了最基本的增删查改功能.</p>
<h1 id="2开发环境">2.开发环境</h1>
<ul>
<li>win10</li>
<li>IDEA</li>
<li>tomcat9.0.27</li>
<li>mysql8.0.17</li>
<li>spring boot</li>
</ul>
<h1 id="3后端">3.后端</h1>
<h2 id="1新建一个spring-boot项目">(1)新建一个spring boot项目</h2>
<p><a href="https://blog.csdn.net/qq_27525611/article/details/103241368">可以看这里</a></p>
<h2 id="2entity">(2)Entity</h2>
<p>新建User类作为实体类:</p>
<pre><code class="language-java">package com.test;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>这里其实使用的是(1)中的代码,里面有详细的解释.</p>
<h2 id="3repository">(3)Repository</h2>
<p>新建UserRepository去实现增删查改:</p>
<pre><code class="language-java">package com.test;

import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@Repository
public interface UserRepository extends CrudRepository&lt;User,Integer&gt;
{
    @Query(value = &quot;select * from user where name = ?1&quot;,nativeQuery = true)
    public List&lt;User&gt; findByName(String name);

    @Modifying
    @Query(value = &quot;delete from user where name = ?1&quot;,nativeQuery = true)
    public int deleteByName(String name);
}
</code></pre>
<p>由于CrudRepository中已经包含了&quot;增&quot;与&quot;改&quot;,所以按需要实现自己的&quot;查&quot;与&quot;删&quot;即可.<br>
CrudRepository的api很简单,<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html">官方文档在这里.</a></p>
<ul>
<li>&quot;增&quot;使用save即可,参数为实体类</li>
<li>&quot;删&quot;使用deleteById,通过主键删除,若不想通过主键删除可以自己编写sql,像上面一样</li>
<li>&quot;查&quot;使用findAll或findById,自定义查找的话需要自己编写sql.</li>
<li>&quot;改&quot;也可使用save,注意需要设置主键.</li>
</ul>
<p>@Query用于设置sql,nativeQuery表示使用原生sql.</p>
<h2 id="4service">(4)Service</h2>
<p>新建一个MainService.java</p>
<pre><code class="language-java">package com.test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.util.List;

@Transactional
@Service
public class MainService {
    @Autowired
    private UserRepository userRepository;

    public Iterable&lt;User&gt; getAllUsers()
    {
        return userRepository.findAll();
    }

    public List&lt;User&gt; findByName(String name)
    {
        return userRepository.findByName(name);
    }

    public boolean add(String name)
    {
        User user = new User();
        user.setName(name);
        userRepository.save(user);
		return true;
    }

    public boolean modify(Integer id,String name)
    {
        User user = new User();
        user.setName(name);
        user.setId(id);
        userRepository.save(user);
        return true;
    }

    public boolean deleteByName(String name)
    {
        return userRepository.deleteByName(name) != 0;
    }
}
</code></pre>
<ul>
<li>getAllUsers()返回所有行,Iterable&lt;E&gt;类型</li>
<li>findByName()根据name返回所有name相同的行.</li>
<li>add直接使用了save,由于save返回的是实体类,原本的代码是这样写的:</li>
</ul>
<pre><code class="language-java">return userRepository.save(user) != null;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191126232352501.jpg" alt="在这里插入图片描述" loading="lazy"><br>
但是文档说了不会为null,所以只能强制返回true了.</p>
<ul>
<li>modify使用了id与name作为参数,新建一个user,将其作为setter的参数,然后交给save.</li>
<li>deleteByName使用了自定义的删除函数,返回的是int,在UserRepository中这个int代表sql影响的行数,删除成功则行数不为0,删除失败,或者没有这行数据则行数为0.因此将返回值与0进行比较.</li>
</ul>
<h2 id="5controller">(5)Controller</h2>
<pre><code class="language-java">package com.test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
@RequestMapping(path = &quot;/demo&quot;)
public class MainController {
    @Autowired
    private MainService mainService;

    @GetMapping(path = &quot;/getAll&quot;)
    public @ResponseBody Iterable&lt;User&gt; getAllUsers()
    {
        return mainService.getAllUsers();
    }

    @PostMapping(path = &quot;/get&quot;)
    public @ResponseBody List&lt;User&gt; findByName(String name)
    {
        return mainService.findByName(name);
    }

    @PostMapping(path = &quot;/add&quot;)
    public @ResponseBody boolean add(@RequestParam String name)
    {
        return mainService.add(name);
    }

    @PostMapping(path = &quot;/modify&quot;)
    public @ResponseBody boolean modify(@RequestParam Integer id,@RequestParam String name)
    {
        return mainService.modify(id,name);
    }

    @PostMapping(path = &quot;/delete&quot;)
    public @ResponseBody boolean deleteByName(@RequestParam String name)
    {
        return mainService.deleteByName(name);
    }
}
</code></pre>
<p>Controller主要就是几个注解,除了getAllUsers使用Get外,其他的都是用Post.另外就是路径设置,直接在path中设置即可.<br>
后端的话到这里就基本完成了,剩下的打包部署操作就.....</p>
<h1 id="4前端">4.前端</h1>
<p>什么新建工程之类的就不说了.<br>
直接上MainActivity:</p>
<pre><code class="language-java">package com.example.myapplication;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Looper;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import com.alibaba.fastjson.JSONArray;
import com.example.myapplication.model.dao.*;
import com.example.myapplication.model.entity.*;

import java.io.IOException;
import java.util.List;

import okhttp3.FormBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;


public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button register = findViewById(R.id.register);
        register.setOnClickListener(
                v -&gt;
                {
                    new Thread(()-&gt; {
                        OkHttpClient okHttpClient = new OkHttpClient();
                        String name = ((EditText) findViewById(R.id.name)).getText().toString();
                        FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
                        Request request = new Request.Builder()
                                .url(Constant.ADD)
                                .post(formBody)
                                .build();
                        try (Response response = okHttpClient.newCall(request).execute()) {
                            Looper.prepare();
                            if (Boolean.parseBoolean(response.body().string()))
                            {
                                Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show();
                            }
                            else
                            {
                                Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show();
                            }
                            Looper.loop();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }).start();
                }
        );
        Button login = findViewById(R.id.login);
        login.setOnClickListener(
                v -&gt;
                {
                    new Thread(()-&gt; {
                        OkHttpClient okHttpClient = new OkHttpClient();
                        String name = ((EditText) findViewById(R.id.name)).getText().toString();
                        FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
                        Request request = new Request.Builder()
                                .url(Constant.GET)
                                .post(formBody)
                                .build();
                        try (Response response = okHttpClient.newCall(request).execute()) {
                            List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class);
                            Looper.prepare();
                            if(users.size() == 0)
                            {
                                Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show();
                            }
                            else
                            {
                                Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show();
                            }
                            Looper.loop();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }).start();
                }
        );

        Button delete = findViewById(R.id.delete);
        delete.setOnClickListener(
                v -&gt;
                {
                    new Thread(()-&gt; {
                        OkHttpClient okHttpClient = new OkHttpClient();
                        String name = ((EditText) findViewById(R.id.name)).getText().toString();
                        FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
                        Request request = new Request.Builder()
                                .url(Constant.DELETE)
                                .post(formBody)
                                .build();
                        try (Response response = okHttpClient.newCall(request).execute()) {
                            Looper.prepare();
                            if (Boolean.parseBoolean(response.body().string()))
                            {
                                Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show();
                            }
                            else
                            {
                                Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show();
                            }
                            Looper.loop();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }).start();
                }
        );

        Button modify = findViewById(R.id.modify);
        modify.setOnClickListener(
                v -&gt;
                {
                    new Thread(()-&gt; {
                        OkHttpClient okHttpClient = new OkHttpClient();
                        String name = ((EditText) findViewById(R.id.name)).getText().toString();
                        String id = ((EditText)findViewById(R.id.id)).getText().toString();
                        FormBody formBody = new FormBody.Builder()
                                .add(&quot;name&quot;, name)
                                .add(&quot;id&quot;,id)
                                .build();
                        Request request = new Request.Builder()
                                .url(Constant.MODIFY)
                                .post(formBody)
                                .build();
                        try (Response response = okHttpClient.newCall(request).execute()) {
                            Looper.prepare();
                            if (Boolean.parseBoolean(response.body().string()))
                            {
                                Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show();
                            }
                            else
                            {
                                Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show();
                            }
                            Looper.loop();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }).start();
                }
        );
    }
}
</code></pre>
<h2 id="1增">(1)增</h2>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient();
String name = ((EditText) findViewById(R.id.name)).getText().toString();
FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
Request request = new Request.Builder()
        .url(Constant.ADD)
        .post(formBody)
        .build();
try (Response response = okHttpClient.newCall(request).execute()) {
    Looper.prepare();
    if (Boolean.parseBoolean(response.body().string()))
    {
        Toast.makeText(this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show();
    }
    else
    {
        Toast.makeText(this, &quot;注册失败&quot;, Toast.LENGTH_SHORT).show();
    }
    Looper.loop();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>使用okhttp,通过FormBody设置参数,然后创建Request通过OkHttpClient发送.<br>
由于后端&quot;增&quot;的方法返回的是一个true,因此这里将response.body().string()转换成boolean判断是否操作成功.<br>
稍微提一下,</p>
<pre><code class="language-java">Looper.prepare();
Looper.loop();
</code></pre>
<p>这两行可以在非UI线程中使用Toast.</p>
<h2 id="2删">(2)删</h2>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient();
String name = ((EditText) findViewById(R.id.name)).getText().toString();
FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
Request request = new Request.Builder()
        .url(Constant.DELETE)
        .post(formBody)
        .build();
try (Response response = okHttpClient.newCall(request).execute()) {
    Looper.prepare();
    if (Boolean.parseBoolean(response.body().string()))
    {
        Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show();
    }
    else
    {
        Toast.makeText(this, &quot;删除失败&quot;, Toast.LENGTH_SHORT).show();
    }
    Looper.loop();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>删这部分也是差不多的,就是改一下url,然后....然后没有了....<s>好像很简单的样子?</s></p>
<h2 id="3查">(3)查</h2>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient();
String name = ((EditText) findViewById(R.id.name)).getText().toString();
FormBody formBody = new FormBody.Builder().add(&quot;name&quot;, name).build();
Request request = new Request.Builder()
        .url(Constant.GET)
        .post(formBody)
        .build();
try (Response response = okHttpClient.newCall(request).execute()) {
    List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class);
    Looper.prepare();
    if(users.size() == 0)
    {
        Toast.makeText(this,&quot;登录失败&quot;,Toast.LENGTH_SHORT).show();
    }
    else
    {
        Toast.makeText(this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show();
    }
    Looper.loop();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>查这里注意一下后端返回的是List,这里借助阿里的fastjson转换成List.</p>
<pre><code class="language-java">List&lt;User&gt; users = JSONArray.parseArray(response.body().string(),User.class);
</code></pre>
<p>然后判断有没有的话就判断长度是否为0即可.</p>
<h2 id="4改">(4)改</h2>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient();
String name = ((EditText) findViewById(R.id.name)).getText().toString();
String id = ((EditText)findViewById(R.id.id)).getText().toString();
FormBody formBody = new FormBody.Builder()
        .add(&quot;name&quot;, name)
        .add(&quot;id&quot;,id)
        .build();
Request request = new Request.Builder()
        .url(Constant.MODIFY)
        .post(formBody)
        .build();
try (Response response = okHttpClient.newCall(request).execute()) {
    Looper.prepare();
    if (Boolean.parseBoolean(response.body().string()))
    {
        Toast.makeText(this, &quot;修改成功&quot;, Toast.LENGTH_SHORT).show();
    }
    else
    {
        Toast.makeText(this, &quot;修改失败&quot;, Toast.LENGTH_SHORT).show();
    }
    Looper.loop();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>改的话只需一个额外的ID参数,在FormBody中add一个即可,不难.</p>
<h2 id="5界面">(5)界面</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/delete&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginStart=&quot;280dp&quot;
        android:layout_marginTop=&quot;404dp&quot;
        android:text=&quot;删除&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/register&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginStart=&quot;32dp&quot;
        android:layout_marginTop=&quot;293dp&quot;
        android:text=&quot;注册&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/modify&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginStart=&quot;32dp&quot;
        android:layout_marginTop=&quot;404dp&quot;
        android:text=&quot;修改&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

    &lt;EditText
        android:id=&quot;@+id/name&quot;
        android:layout_width=&quot;336dp&quot;
        android:layout_height=&quot;50dp&quot;
        android:layout_marginStart=&quot;32dp&quot;
        android:layout_marginTop=&quot;192dp&quot;
        android:layout_marginEnd=&quot;43dp&quot;
        android:ems=&quot;10&quot;
        android:hint=&quot;请输入姓名&quot;
        android:inputType=&quot;textPersonName&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;0.0&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

    &lt;EditText
        android:id=&quot;@+id/id&quot;
        android:layout_width=&quot;336dp&quot;
        android:layout_height=&quot;50dp&quot;
        android:layout_marginStart=&quot;32dp&quot;
        android:layout_marginTop=&quot;112dp&quot;
        android:layout_marginEnd=&quot;43dp&quot;
        android:ems=&quot;10&quot;
        android:hint=&quot;请输入id&quot;
        android:inputType=&quot;textPersonName&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;0.0&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

    &lt;Button
        android:id=&quot;@+id/login&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;293dp&quot;
        android:layout_marginEnd=&quot;43dp&quot;
        android:text=&quot;登录&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>界面不详细说了,不难.</p>
<h2 id="6依赖与其他">(6)依赖与其他</h2>
<p><img src="https://img-blog.csdnimg.cn/20191127015216289.png" alt="在这里插入图片描述" loading="lazy"><br>
注意一下依赖,还有设置java8.</p>
<h2 id="7网络权限">(7)网络权限</h2>
<p>这个作者之前的文章有说.<br>
<a href="https://blog.csdn.net/qq_27525611/article/details/102493643">请看这里.</a></p>
<h1 id="5测试">5.测试</h1>
<p>这是&quot;原本的&quot;数据库.<br>
<s>没办法为了测试.</s><br>
<img src="https://img-blog.csdnimg.cn/20191127015752855.png" alt="在这里插入图片描述" loading="lazy"><br>
注册一个.<br>
<img src="https://img-blog.csdnimg.cn/20191127015830255.png" alt="在这里插入图片描述" loading="lazy"><br>
看看数据库:<br>
<img src="https://img-blog.csdnimg.cn/20191127015937365.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img-blog.csdnimg.cn/20191127015903596.png" alt="在这里插入图片描述" loading="lazy"><br>
试试登录一个不存在的.<br>
<img src="https://img-blog.csdnimg.cn/20191127020030459.png" alt="在这里插入图片描述" loading="lazy"><br>
修改:<br>
<img src="https://img-blog.csdnimg.cn/20191127020118499.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191127020149349.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191127020214410.png" alt="在这里插入图片描述" loading="lazy"><br>
最后是删除:<br>
<img src="https://img-blog.csdnimg.cn/20191127020251561.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191127020319777.png" alt="在这里插入图片描述" loading="lazy"><br>
删除一个不存在的会删除失败.<br>
<img src="https://img-blog.csdnimg.cn/20191127020354806.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6源码">6.源码</h1>
<ul>
<li><a href="https://github.com/2293736867/spring-boot-Android-Mysql">github</a></li>
<li><a href="https://gitee.com/imykr/spring-boot-Android-Mysql">码云</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring boot+Mysql+Spring data JPA一个Web的Demo]]></title>
        <id>https://2293736867.github.io/post/spring-bootmysqlspring-data-jpa-yi-ge-web-de-demo/</id>
        <link href="https://2293736867.github.io/post/spring-bootmysqlspring-data-jpa-yi-ge-web-de-demo/">
        </link>
        <updated>2020-06-02T19:32:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E6%A6%82%E8%BF%B0">1.概述</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8Bspring-demo">2.创建初始spring demo</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90">3.配置数据源</a>
<ul>
<li><a href="#1%E5%BB%BA%E5%BA%93">(1)建库</a></li>
<li><a href="#2%E5%BB%BA%E7%94%A8%E6%88%B7">(2)建用户</a></li>
<li><a href="#3%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83">(3)用户授权</a></li>
<li><a href="#4%E9%85%8D%E7%BD%AEapplicationproperties">(4)配置application.properties</a>
<ul>
<li><a href="#anone">a.none</a></li>
<li><a href="#bupdate">b.update</a></li>
<li><a href="#ccreate">c.create</a></li>
<li><a href="#dcreate-drop">d.create-drop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB">4.创建实体类</a></li>
<li><a href="#5%E5%88%9B%E5%BB%BArepository">5.创建Repository</a></li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%99%A8">6.创建控制器</a></li>
<li><a href="#7ide%E4%B8%8A%E6%B5%8B%E8%AF%95">7.IDE上测试</a></li>
<li><a href="#8%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83">8.打包发布</a></li>
<li><a href="#9%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">9.完整代码</a></li>
</ul>
</p>
<h1 id="1概述">1.概述</h1>
<p>因为要用spring boot,最近刚刚学习.这是一个web项目的配合mysq+Hibernate+tomcat的简单示例demo,很容易在此基础上扩展成自己的项目.</p>
<h1 id="2创建初始spring-demo">2.创建初始spring demo</h1>
<p>作者用的IDE是IDEA,新建一个工程,选择Spring Initalizer.<br>
<img src="https://img-blog.csdnimg.cn/2019112523242899.jpg" alt="在这里插入图片描述" loading="lazy"><br>
下一步的话由于作者需要部署到服务器上面,选择了war.不需要的话可以选择jar.<br>
<img src="https://img-blog.csdnimg.cn/20191125232753957.jpg" alt="在这里插入图片描述" loading="lazy"><br>
选择spring web+spring Data JPA+Mysql Driver.<br>
<img src="https://img-blog.csdnimg.cn/20191125233048539.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/201911252330373.jpg" alt="在这里插入图片描述" loading="lazy"></figure>
<p><img src="https://img-blog.csdnimg.cn/20191125233023480.jpg" alt="在这里插入图片描述" loading="lazy"><br>
然后完成即可,首次运行的话配置依赖需要一点时间,请耐心等待.</p>
<h1 id="3配置数据源">3.配置数据源</h1>
<p>配置数据源分为两部分,一部分是建表与建用户,另一部分是在application.properties中配置的.</p>
<h2 id="1建库">(1)建库</h2>
<pre><code class="language-sql">create database test;
</code></pre>
<p>注意这里不用创建表了,因为Hibernate从实体类自动创建一个同名的表.</p>
<h2 id="2建用户">(2)建用户</h2>
<pre><code class="language-sql">create user 'db'@'%' identified by 'xxxxx';
</code></pre>
<h2 id="3用户授权">(3)用户授权</h2>
<pre><code class="language-sql">grant all on test.* to 'db'@'%';
</code></pre>
<p>这里建议授权all,因为后面Hibernate会用到建表权限,不能仅仅授权增删查改.</p>
<h2 id="4配置applicationproperties">(4)配置application.properties</h2>
<p>配置四个属性:</p>
<pre><code class="language-java">spring.jpa.hibernate.ddl-auto=
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
</code></pre>
<p>第一个属性是可以取值</p>
<ul>
<li>none</li>
<li>update</li>
<li>create</li>
<li>create-drop</li>
</ul>
<h3 id="anone">a.none</h3>
<p>none是对mysql的默认值,不会改变数据库结构.</p>
<h3 id="bupdate">b.update</h3>
<p>Hibernate会根据给出的实体类去改变数据库.</p>
<h3 id="ccreate">c.create</h3>
<p>创建数据库但是不会在关闭的时候删除.</p>
<h3 id="dcreate-drop">d.create-drop</h3>
<p>创建数据库,当SessionFactory关闭时删除数据库.这个是对H2与其他嵌入式数据库的默认选项.</p>
<p>第一次运行时必须设置为update或create,因为还不知道确切的实体类,第一次运行后,可以设置为update或none.<br>
url的话对于mysql来说是</p>
<pre><code>jdbc:mysql://ip:3306/database
</code></pre>
<p>剩下的两个为用户名与密码.<br>
以下是作者的配置,供参考:<br>
<img src="https://img-blog.csdnimg.cn/20191125235544555.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4创建实体类">4.创建实体类</h1>
<p>这里创建一个简单的User实体类,需要用到javax中的Entity,Id,GeneratedValue与GenerationType注解.<br>
Entity用于标识实体类,Id用于标识主键,GeneratedValue与GenerationType用于配置主键.</p>
<pre><code class="language-java">package com.test;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    private String name;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>除了主键之外,可以加上自己想要的属性,还有setter与getter,Hibernate会自动将实体类制作成一个数据表.</p>
<h1 id="5创建repository">5.创建Repository</h1>
<p>创建仓库保存用户记录.需要继承CrudRepository&lt;T,ID&gt;,第一个类型为实体类,第二个类型为主键类型.</p>
<pre><code class="language-java">package com.test;

import org.springframework.data.repository.CrudRepository;

public interface UserRepository extends CrudRepository&lt;User,Integer&gt;
{
}
</code></pre>
<h1 id="6创建控制器">6.创建控制器</h1>
<p>控制器用于控制Http请求,在控制器中可以配置不同的路径实现不同的操作.</p>
<pre><code class="language-java">package com.test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(path = &quot;/demo&quot;)
public class MainController {
    @Autowired
    private UserRepository userRepository;
    
    @PostMapping(path = &quot;/add&quot;)
    public @ResponseBody String addNewUser(@RequestParam String name)
    {
        User user = new User();
        user.setName(name);
        userRepository.save(user);
        return &quot;Saved.&quot;;
    }
    
    @GetMapping(path = &quot;/all&quot;)
    public @ResponseBody Iterable&lt;User&gt; getAllUsers()
    {
        return userRepository.findAll();
    }
}
</code></pre>
<p>@RequestMapping中的值表示url以此值开头.<br>
@PostMapping是仅处理post请求的路径.<br>
@ResponseBody表示返回的类型.<br>
@RequestParam表示一个从get或post中获取的参数.<br>
getAllUsers()会返回一个json或者xml.</p>
<h1 id="7ide上测试">7.IDE上测试</h1>
<p>首先输入</p>
<pre><code class="language-java">localhost:8080/demo/all
</code></pre>
<p>由于作者先前已经有一行数据所以有显示.<br>
<img src="https://img-blog.csdnimg.cn/20191126001631148.png" alt="在这里插入图片描述" loading="lazy"><br>
否则的话应该显示为[]<br>
接下来可以添加数据:</p>
<pre><code class="language-bash">curl localhost:8080/demo/add -d name=123
</code></pre>
<p>回应:<br>
<img src="https://img-blog.csdnimg.cn/20191126001842383.png" alt="在这里插入图片描述" loading="lazy"><br>
接下来可以选择再次查看:<br>
<img src="https://img-blog.csdnimg.cn/20191126001922655.png" alt="在这里插入图片描述" loading="lazy"><br>
在看看数据库:<br>
<img src="https://img-blog.csdnimg.cn/20191126001956984.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="8打包发布">8.打包发布</h1>
<p>Build-&gt;Build Artifacts.<br>
<img src="https://img-blog.csdnimg.cn/20191126002525722.jpg" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191126002457453.jpg" alt="在这里插入图片描述" loading="lazy"><br>
Build即可.<br>
然后会在项目目录的target下有一个test-0.0.1-xxx的war文件,就是这个了.<br>
<img src="https://img-blog.csdnimg.cn/20191126002610710.png" alt="在这里插入图片描述" loading="lazy"><br>
改名字放到tomcat的webapps/下,比如作者改成了demo.war:<br>
<img src="https://img-blog.csdnimg.cn/20191126002746230.png" alt="在这里插入图片描述" loading="lazy"><br>
然后可以去访问了,注意路径,这里的路径是war的路径再加上@RequestMapping中的路径再加上 @PostMapping或 @GetMapping路径:<br>
<img src="https://img-blog.csdnimg.cn/20191126002912162.png" alt="在这里插入图片描述" loading="lazy"><br>
完成!</p>
<h1 id="9完整代码">9.完整代码</h1>
<ul>
<li><a href="https://github.com/2293736867/spring-boot-hibernate-tomcat-mysql">github</a></li>
<li><a href="https://gitee.com/imykr/spring-boot-hibernate-tomcat-mysql">码云</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDBC+C3P0+DBCP 基本使用]]></title>
        <id>https://2293736867.github.io/post/jdbcc3p0dbcp-ji-ben-shi-yong/</id>
        <link href="https://2293736867.github.io/post/jdbcc3p0dbcp-ji-ben-shi-yong/">
        </link>
        <updated>2020-06-02T19:31:30.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E6%A6%82%E8%BF%B0">1.概述</a></li>
<li><a href="#2mysql%E7%9A%84%E5%A4%84%E7%90%86">2.mysql的处理</a>
<ul>
<li><a href="#1%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7">(1)新建用户</a></li>
<li><a href="#2%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E8%A1%A8">(2)建立数据表</a></li>
<li><a href="#3%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90">(3)用户权限</a></li>
</ul>
</li>
<li><a href="#2jdbc">2.JDBC</a>
<ul>
<li><a href="#1jar%E5%8C%85">(1)jar包</a></li>
<li><a href="#2%E8%BF%9E%E6%8E%A5">(2)连接</a></li>
<li><a href="#3statement">(3)Statement</a></li>
<li><a href="#4preparedstatement">(4)PreparedStatement</a></li>
<li><a href="#5%E4%BA%8B%E5%8A%A1">(5)事务</a></li>
</ul>
</li>
<li><a href="#3c3p0">3.C3P0</a>
<ul>
<li><a href="#1jar%E5%8C%85-2">(1)jar包</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">(2)配置文件</a></li>
<li><a href="#3%E5%B7%A5%E5%85%B7%E7%B1%BB">(3)工具类</a></li>
</ul>
</li>
<li><a href="#4dbcp">4.DBCP</a>
<ul>
<li><a href="#1jar%E5%8C%85-3">(1)jar包</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-2">(2)配置文件</a></li>
<li><a href="#3%E5%B7%A5%E5%85%B7%E7%B1%BB-2">(3)工具类</a></li>
</ul>
</li>
<li><a href="#5%E6%BA%90%E7%A0%81">5.源码</a></li>
</ul>
</p>
<h1 id="1概述">1.概述</h1>
<p>这篇文章主要说了JDBC的基本使用,包括Statement,PreparedStatement,JDBC的连接,Mysql创建用户创建数据表,C3P0的连接与配置,DBCP的连接与配置.</p>
<h1 id="2mysql的处理">2.mysql的处理</h1>
<p>这里的JDBC使用Mysql作为DBMS,请先安装Mysql,未安装的<a href="https://www.mysql.com/">请点击这里下载</a>,<a href="https://www.cnblogs.com/xzlive/p/11023527.html">安装教程在这里</a>,作者使用的Mysql的8.0.17版本.</p>
<h2 id="1新建用户">(1)新建用户</h2>
<p>随便新建一个用户,比如这里作者新建的是aa,密码是aa123bb.</p>
<pre><code class="language-sql">create user 'aa'@'localhost' identified by 'aa123bb'
</code></pre>
<h2 id="2建立数据表">(2)建立数据表</h2>
<p>建立测试用的数据表与数据库.</p>
<pre><code class="language-sql">create database db;
use db;

create table db
(
    id int PRIMARY key,
    name char(20)
);
</code></pre>
<h2 id="3用户权限">(3)用户权限</h2>
<p>对刚才新建的用户授权:</p>
<pre><code class="language-sql">grant select,update,delete,insert on db.* to 'aa'@'localhost';
</code></pre>
<h1 id="2jdbc">2.JDBC</h1>
<h2 id="1jar包">(1)jar包</h2>
<p><a href="https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.17/mysql-connector-java-8.0.17.jar">8.0.17版本在这里</a></p>
<p><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">各个版本的在这里下载</a></p>
<h2 id="2连接">(2)连接</h2>
<p>首先注册驱动,驱动需要一个url,用户名和密码,用户名和密码是上一步创建好的,url包含ip地址,端口和数据库的名字.</p>
<pre><code class="language-java">private static final boolean mysqlVersionGreaterThen8 = true;
private static final String driver = &quot;com.mysql&quot; + (mysqlVersionGreaterThen8 ? &quot;.cj&quot; : &quot;&quot;) + &quot;.jdbc.Driver&quot;;
private static final String ip = &quot;127.0.0.1&quot;;
private static final String port = &quot;3306&quot;;
private static String databaseName = &quot;db&quot;;
private static String url;
private static String username = &quot;aa&quot;;
private static String password = &quot;k041400r&quot;;
private static Connection connection = null;

public static Connection getConnection() {
    try {
        url = &quot;jdbc:mysql://&quot; + ip + &quot;:&quot; + port + &quot;/&quot; + databaseName;
        Class.forName(driver);
        return connection = DriverManager.getConnection(url, username, password);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>这里要注意以下旧版本的mysql的驱动叫com.mysql.jdbc.Driver,新版本的叫com.mysql.cj.jdbc.Driver.还有就是url的格式:</p>
<pre><code class="language-java">jdbc:mysql://ip:port/database
</code></pre>
<h2 id="3statement">(3)Statement</h2>
<p>获取数据库连接后,使用createStatement方法创建Statement</p>
<ul>
<li>对于select,使用Statement的executeQuery(sql),返回ResultSet</li>
<li>对于update,delete,insert,使用Statement的executeUpdate(sql)</li>
</ul>
<p>其中sql是要执行的sql语句,一个String.</p>
<pre><code class="language-java">public void useStatement() {
    try {
        useStatementInsert();
        useStatementSelect();
        useStatementUpdate();
        useStatementSelect();
        useStatementDelete();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

public void useStatementInsert() throws SQLException {
    String sql = &quot;insert into db(id,name) values(1,'23')&quot;;
    Statement statement = connection.createStatement();
    statement.executeUpdate(sql);
}

public void useStatementDelete() throws SQLException {
    String sql = &quot;delete from db&quot;;
    Statement statement = connection.createStatement();
    statement.executeUpdate(sql);
}

public void useStatementSelect() throws SQLException {
    String sql = &quot;select * from db&quot;;
    Statement statement = connection.createStatement();
    ResultSet resultSet = statement.executeQuery(sql);
    ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
    int count = resultSetMetaData.getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i &lt;= count; ++i) {
            System.out.println(resultSet.getObject(i));
        }
    }
}

public void useStatementUpdate() throws SQLException {
    Statement statement = connection.createStatement();
    String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;;
    statement.executeUpdate(sql);
}
</code></pre>
<p>这里对ResultSet使用的getMetaData,可以获取结果集的各种类型信息,包括字段的类型,个数,等等.</p>
<h2 id="4preparedstatement">(4)PreparedStatement</h2>
<p>PreparedStatement与Statement使用基本一样.调用的时候先使用Connection的prepareStatement(sql)创建,然后</p>
<ul>
<li>对于select,使用executeQuery(),返回一个ResultSet</li>
<li>对于update,delete,insert使用executeUpdate().</li>
</ul>
<pre><code class="language-java">public void usePrepareStatement() {
    try {
        usePrepareStatementInsert();
        usePrepareStatementSelect();
        usePrepareStatementUpdate();
        usePrepareStatementSelect();
        usePrepareStatementDelete();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

public void usePrepareStatementInsert() throws SQLException {
    String sql = &quot;insert into db(id,name) values(1,'23')&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    preparedStatement.executeUpdate();
}

public void usePrepareStatementDelete() throws SQLException {
    String sql = &quot;delete from db&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    preparedStatement.executeUpdate();
}

public void usePrepareStatementSelect() throws SQLException {
    String sql = &quot;select * from db&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    ResultSet resultSet = preparedStatement.executeQuery();
    ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
    int count = resultSetMetaData.getColumnCount();
    while (resultSet.next()) {
        for (int i = 1; i &lt;= count; ++i)
            System.out.println(resultSet.getObject(i));
    }
}

public void usePrepareStatementUpdate() throws SQLException {
    String sql = &quot;update db set id = 3,name = '555' where id = 1&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    preparedStatement.executeUpdate();
}
</code></pre>
<h2 id="5事务">(5)事务</h2>
<p>Connection有一个setAutoCommit()方法,把它设置成false即可关闭自动提交,所有语句准备好后,一次性使用commit()提交即可.<br>
实现回滚可以配合SavePoint使用.</p>
<h1 id="3c3p0">3.C3P0</h1>
<h2 id="1jar包-2">(1)jar包</h2>
<p>两个:</p>
<ul>
<li>
<p><a href="https://repo1.maven.org/maven2/com/mchange/c3p0/0.9.5.4/c3p0-0.9.5.4.jar">c3p0</a></p>
</li>
<li>
<p><a href="https://repo1.maven.org/maven2/com/mchange/mchange-commons-java/0.2.19/mchange-commons-java-0.2.19.jar">mchange-commons</a></p>
</li>
</ul>
<h2 id="2配置文件">(2)配置文件</h2>
<p>src下创建一个叫c3p0.properties的文件:</p>
<pre><code class="language-cpp">c3p0.driverClass=com.mysql.cj.jdbc.Driver
c3p0.jdbcUrl=jdbc:mysql://127.0.0.1:3306/db
c3p0.user=aa
c3p0.password=aa123bb
</code></pre>
<p>这里按自己需要更改即可.</p>
<h2 id="3工具类">(3)工具类</h2>
<pre><code class="language-java">import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.sql.Connection;

public class DbUtil
{
    private static ComboPooledDataSource C3P0dataSource = new ComboPooledDataSource(&quot;c3p0.properties&quot;);
    public static void releaseConnection(Connection connection)
    {
        try
        {
            if(connection != null)
                connection.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public static Connection getC3P0Connection()
    {
        try
        {
            return C3P0dataSource.getConnection();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<h1 id="4dbcp">4.DBCP</h1>
<h2 id="1jar包-3">(1)jar包</h2>
<p>三个:</p>
<ul>
<li>
<p><a href="https://repo1.maven.org/maven2/org/apache/commons/commons-dbcp2/2.7.0/commons-dbcp2-2.7.0.jar">commons-dbcp</a></p>
</li>
<li>
<p><a href="https://repo1.maven.org/maven2/commons-logging/commons-logging/1.2/commons-logging-1.2.jar">commons-logging</a></p>
</li>
<li>
<p><a href="https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.7.0/commons-pool2-2.7.0.jar">commons-pool</a></p>
</li>
</ul>
<h2 id="2配置文件-2">(2)配置文件</h2>
<p>src下新建dbcp.properties:</p>
<pre><code class="language-cpp">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/db
username=aa
password=k041400r
initialSize=10
maxActive=50
maxIdle=15
minIdle=10
maxWait=60000
connectionProperties=useUnicode=true;characterEncoding=utf8
defaultAutoCommit=true
</code></pre>
<p>分别是驱动,url,用户名,密码,初始化连接数,最大连接数,最大空闲连接数,最小空闲连接数,最大等待实际,连接属性(这里设置了编码),自动提交.</p>
<h2 id="3工具类-2">(3)工具类</h2>
<pre><code class="language-java">import org.apache.commons.dbcp2.BasicDataSourceFactory;

import java.io.InputStream;
import java.sql.Connection;
import java.util.Properties;
import javax.sql.DataSource;

public class DbUtil {
    private static DataSource DBCPdataSource;
    static {
        try {
            InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);
            Properties properties = new Properties();
            properties.load(inputStream);
            DBCPdataSource = BasicDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Connection getDBCPConnection() {
        try {
            return DBCPdataSource.getConnection();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void releaseConnection(Connection connection) {
        try {
            if (connection != null)
                connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>首先加载属性文件,再使用Properties的load方法将其加载到一个Properties对象中,最后交给BasicDataSourceFactory处理.</p>
<h1 id="5源码">5.源码</h1>
<p>包含了jar包,配置文件,sql文件与测试代码.</p>
<ul>
<li><a href="https://github.com/2293736867/JDBC-C3P0-DBCP">github</a></li>
<li><a href="https://gitee.com/imykr/JDBC-C3P0-DBCP">码云</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从0开始自制计算器!]]></title>
        <id>https://2293736867.github.io/post/cong-0-kai-shi-zi-zhi-ji-suan-qi/</id>
        <link href="https://2293736867.github.io/post/cong-0-kai-shi-zi-zhi-ji-suan-qi/">
        </link>
        <updated>2020-06-02T19:31:07.000Z</updated>
        <content type="html"><![CDATA[<p>先看看效果吧:<br>
<img src="https://img-blog.csdnimg.cn/20191118032442550.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118032657882.gif" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118032707244.gif" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118032719443.gif" alt="在这里插入图片描述" loading="lazy"><br>
很炫酷吧?<br>
想不想要?<br>
<s>想要吧.</s><br>
<s>当然作者知道你们肯定想.</s><br>
<s>不然也不会点进来对不对.</s><br>
好.进入正题.<br>
<ul class="markdownIt-TOC">
<li><a href="#1%E6%A6%82%E8%BF%B0">1.概述</a></li>
<li><a href="#2%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B">2.新建工程</a></li>
<li><a href="#2%E7%95%8C%E9%9D%A2">2.界面</a>
<ul>
<li><a href="#1-%E6%8C%89%E9%94%AE">(1) 按键</a>
<ul>
<li><a href="#a%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAgrid-layout%E8%B0%83%E6%95%B4%E5%A5%BD%E5%A4%A7%E5%B0%8F">a.添加一个Grid Layout,调整好大小.</a></li>
<li><a href="#b%E6%8B%96%E5%85%A5push-button%E4%BD%9C%E4%B8%BA%E6%8C%89%E9%94%AEsizepolicy%E5%B1%9E%E6%80%A7%E9%82%A3%E9%87%8C%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%9E%E6%80%A7%E9%83%BD%E9%80%89%E6%8B%A9expanding">b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding.</a></li>
<li><a href="#c%E8%B0%83%E6%95%B4%E5%A5%BD%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AEstylesheet%E4%B8%8E%E5%AD%97%E4%BD%93">c.调整好颜色,设置styleSheet与字体</a></li>
<li><a href="#d%E5%A4%8D%E5%88%B6%E5%88%B6%E4%BD%9C%E5%A5%BD%E7%9A%84button%E5%B8%83%E5%A5%BD%E5%B1%80">d.复制制作好的button,布好局</a></li>
<li><a href="#e%E6%94%B9%E5%86%85%E5%AE%B9">e.改内容</a></li>
<li><a href="#f%E6%95%B4%E4%BD%93%E4%BF%AE%E6%94%B9%E5%A4%A7%E5%B0%8F%E5%90%8C%E6%97%B6%E5%8A%A0%E4%B8%8A%E9%97%B4%E9%9A%94">f.整体修改大小,同时加上间隔</a></li>
</ul>
</li>
<li><a href="#2-%E8%BE%93%E5%87%BA%E6%A1%86">(2) 输出框</a>
<ul>
<li><a href="#a%E6%B7%BB%E5%8A%A0qlineedit">a.添加QLineEdit</a></li>
<li><a href="#b%E8%B0%83%E6%95%B4%E5%A5%BD%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%E5%A5%BD%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2">b.调整好大小,设置好背景颜色</a></li>
<li><a href="#c%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%8F%AA%E8%AF%BB%E5%AF%B9%E9%BD%90">c.设置字体,只读,对齐</a></li>
</ul>
</li>
<li><a href="#3-%E6%A0%87%E9%A2%98%E6%A0%8F">(3) 标题栏</a>
<ul>
<li><a href="#a%E6%96%B0%E5%BB%BAhorizontal-layout">a.新建Horizontal Layout</a></li>
<li><a href="#b%E6%B7%BB%E5%8A%A0%E7%BB%86%E8%8A%82">b.添加细节</a></li>
</ul>
</li>
<li><a href="#4%E6%95%B4%E4%BD%93%E5%A4%84%E7%90%86">(4)整体处理</a>
<ul>
<li><a href="#a%E6%A0%87%E9%A2%98%E6%A0%8F">a.标题栏</a></li>
<li><a href="#b%E8%B0%83%E6%95%B4%E6%95%B4%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0%E9%80%8F%E6%98%8E%E5%BA%A6">b.调整整体大小,同时添加透明度</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86">3.事件处理</a>
<ul>
<li><a href="#1%E5%85%89%E6%A0%87%E4%BA%8B%E4%BB%B6">(1)光标事件</a>
<ul>
<li><a href="#a%E6%A0%87%E9%A2%98%E6%A0%8F-2">A.标题栏</a>
<ul>
<li><a href="#a%E6%8B%96%E5%8A%A8%E6%95%88%E6%9E%9C">a.拖动效果</a></li>
<li><a href="#b%E6%9C%80%E5%B0%8F%E5%8C%96%E4%B8%8E%E5%85%B3%E9%97%AD">b.最小化与关闭</a></li>
</ul>
</li>
<li><a href="#b%E6%8C%89%E9%94%AE">B.按键</a>
<ul>
<li><a href="#a%E7%A7%BB%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%87%BA%E4%BA%8B%E4%BB%B6">a.移入与移出事件</a></li>
<li><a href="#b%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6">b.单击事件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6">(2)键盘事件</a>
<ul>
<li><a href="#a%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1">A.添加阴影</a></li>
<li><a href="#b%E6%B7%BB%E5%8A%A0%E8%BE%93%E5%87%BA">B.添加输出</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4%E6%95%B4%E4%BD%93%E7%BB%86%E8%8A%82%E5%86%8D%E5%A4%84%E7%90%86">4.整体细节再处理</a>
<ul>
<li><a href="#1%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C">(1)淡入效果</a></li>
<li><a href="#2%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8">(2)设置固定尺寸</a></li>
<li><a href="#3%E6%B7%A1%E5%87%BA%E6%95%88%E6%9E%9C">(3)淡出效果</a></li>
</ul>
</li>
<li><a href="#5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%84%E7%90%86">5.表达式处理</a>
<ul>
<li><a href="#1%E5%88%A4%E6%96%AD">(1)判断</a>
<ul>
<li><a href="#a%E5%8E%BB%E9%99%A4%E6%89%80%E6%9C%89%E7%A9%BA%E6%A0%BC">a.去除所有空格</a></li>
<li><a href="#b%E5%88%86%E7%B1%BB%E5%88%A4%E6%96%AD">b.分类判断</a></li>
<li><a href="#c%E5%8A%A00">c.加0</a></li>
</ul>
</li>
<li><a href="#2%E8%AE%A1%E7%AE%97">(2)计算</a>
<ul>
<li><a href="#acalc%E8%BE%85%E5%8A%A9%E7%B1%BB">a.calc辅助类</a></li>
<li><a href="#b%E8%AE%A1%E7%AE%97%E9%83%A8%E5%88%86">b.计算部分</a></li>
<li><a href="#c%E6%B5%8B%E8%AF%95">c.测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6%E6%95%B4%E5%90%88">6.整合</a>
<ul>
<li><a href="#1%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">(1)设置界面的调用进程,并获取输出结果</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E5%9C%B0%E6%96%B9">(2)修改一些细节地方</a>
<ul>
<li><a href="#a%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E4%BF%AE%E6%94%B9%E4%BA%8B%E4%BB%B6">a.鼠标键盘修改事件</a></li>
<li><a href="#bexe%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F">b.exe中设置数字的格式</a></li>
<li><a href="#c%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA">c.设置错误提示</a></li>
<li><a href="#d%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E6%8A%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%95%B4%E5%90%88%E8%BF%87%E6%9D%A5">d.可以考虑把错误处理整合过来</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83">7.打包发布</a>
<ul>
<li><a href="#1-%E9%A6%96%E5%85%88%E5%8E%BB%E4%B8%8B%E8%BD%BDenigma-virtual-box">(1) 首先去下载Enigma Virtual Box</a></li>
<li><a href="#2-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">(2) 添加环境变量</a></li>
<li><a href="#3-%E6%89%93%E5%8C%85%E5%BA%93%E6%96%87%E4%BB%B6">(3) 打包库文件</a></li>
<li><a href="#4-%E7%94%9F%E6%88%90%E5%8D%95%E4%B8%AAexe">(4) 生成单个exe</a></li>
<li><a href="#5-%E6%B5%8B%E8%AF%95">(5) 测试</a></li>
</ul>
</li>
<li><a href="#8%E6%BA%90%E7%A0%81">8.源码</a></li>
<li><a href="#9%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">9.参考链接</a></li>
<li><a href="#10%E6%9C%80%E5%90%8E">10.最后</a></li>
</ul>
</p>
<h1 id="1概述">1.概述</h1>
<p>这个是仿照win10自带的计算器制作的简化版本.是用Qt做的,直接把整个表达式输入然后得出计算结果.<br>
主要分为三部分.界面部分,事件处理部分与表达式处理部分.</p>
<ul>
<li>界面部分就是看到的计算器,包括标题栏,中间的输出框,还有各个按键.</li>
<li>事件处理就是处理对应的鼠标与键盘事件.</li>
<li>表达式处理部分就是处理整个输入的字符串,返回计算的结果,当然这个还支持错误判断功能.</li>
</ul>
<h1 id="2新建工程">2.新建工程</h1>
<p>选择Widgets Application.<br>
<img src="https://img-blog.csdnimg.cn/20191114184528165.png" alt="在这里插入图片描述" loading="lazy"><br>
起名字.<br>
<img src="https://img-blog.csdnimg.cn/20191114184543747.png" alt="在这里插入图片描述" loading="lazy"><br>
一般只需MinGW.<br>
<img src="https://img-blog.csdnimg.cn/20191114184553837.png" alt="在这里插入图片描述" loading="lazy"><br>
这里默认即可,名字可以随便改<br>
<img src="https://img-blog.csdnimg.cn/20191114184604273.png" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191114184613382.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="2界面">2.界面</h1>
<h2 id="1-按键">(1) 按键</h2>
<p>按键的话,基本上按着改就可以了.改布局,改颜色,改字体,主要就是这三个.<br>
首先先打开.ui文件:<br>
<img src="https://img-blog.csdnimg.cn/20191114184829290.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="a添加一个grid-layout调整好大小">a.添加一个Grid Layout,调整好大小.</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191114184941135.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="b拖入push-button作为按键sizepolicy属性那里水平和垂直属性都选择expanding">b.拖入Push Button作为按键,sizePolicy属性那里水平和垂直属性都选择Expanding.</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191114185119705.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="c调整好颜色设置stylesheet与字体">c.调整好颜色,设置styleSheet与字体</h3>
<p><img src="https://img-blog.csdnimg.cn/20191114185401438.png" alt="在这里插入图片描述" loading="lazy"><br>
这里给出作者的参考style:</p>
<pre><code class="language-css">border:1px groove rgb(220,220,220);
background-color:rgb(243,243,243);
</code></pre>
<p>字体:<br>
<img src="https://img-blog.csdnimg.cn/20191114185700611.png" alt="在这里插入图片描述" loading="lazy"><br>
这里按个人喜好调整即可.</p>
<h3 id="d复制制作好的button布好局">d.复制制作好的button,布好局</h3>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191114185915745.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="e改内容">e.改内容</h3>
<p>这里不仅把里面的字符改变,还要把相应的对象名也改变.<br>
<img src="https://img-blog.csdnimg.cn/20191114190130655.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191115010216798.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>再细调每一个按键,包括大小,字体与颜色,使总体效果更好.<br>
<img src="https://img-blog.csdnimg.cn/20191114190336106.png" alt="在这里插入图片描述" loading="lazy"><br>
数字要注意有&quot;加粗&quot;效果,符号的话尽量&quot;精细&quot;一点.</p>
<h3 id="f整体修改大小同时加上间隔">f.整体修改大小,同时加上间隔</h3>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191114190539729.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>调整好间隔.注意细节.<br>
下面是win10自带的计算器:<br>
<img src="https://img-blog.csdnimg.cn/20191114190659754.png" alt="在这里插入图片描述" loading="lazy"><br>
看到间隔了没?<br>
作者要的就是这种效果.<br>
可以先运行看看.<br>
<img src="https://img-blog.csdnimg.cn/20191114190820357.png" alt="在这里插入图片描述" loading="lazy"><br>
两边的间隔的话一会配合widget的大小调整即可.</p>
<h2 id="2-输出框">(2) 输出框</h2>
<p>输出框很简单,就是一个QLineEdit.</p>
<h3 id="a添加qlineedit">a.添加QLineEdit</h3>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/201911141910456.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="b调整好大小设置好背景颜色">b.调整好大小,设置好背景颜色</h3>
<p><img src="https://img-blog.csdnimg.cn/20191114191322333.png" alt="在这里插入图片描述" loading="lazy"><br>
作者的qss:</p>
<pre><code class="language-css">border:0px groove rgb(243,243,243);
background-color:rgb(245,245,245);
</code></pre>
<h3 id="c设置字体只读对齐">c.设置字体,只读,对齐</h3>
<p><img src="https://img-blog.csdnimg.cn/20191114191740173.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191114191747885.png" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191114191756851.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="3-标题栏">(3) 标题栏</h2>
<p>标题栏其实也很简单,一个QBoxLayout</p>
<h3 id="a新建horizontal-layout">a.新建Horizontal Layout</h3>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191114191911850.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="b添加细节">b.添加细节</h3>
<p><img src="https://img-blog.csdnimg.cn/20191114192046829.png" alt="在这里插入图片描述" loading="lazy"><br>
QLabel输入标题,两个QPushButton表示最小化与关闭,同时加入两个Spacer,让标题与左边空出一些距离.<br>
其实就是模仿win10的标题栏的效果<br>
<img src="https://img-blog.csdnimg.cn/20191114192221689.png" alt="在这里插入图片描述" loading="lazy"><br>
这里就不做最大化了.因为涉及到按钮的重新排布问题,这个可以自己选择实现.</p>
<h2 id="4整体处理">(4)整体处理</h2>
<h3 id="a标题栏">a.标题栏</h3>
<p>把上一步做的标题栏移到合适的位置,同时删除自带的QMenuBar,QToolBar,QStatusBar.<br>
<img src="https://img-blog.csdnimg.cn/20191114192719390.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="b调整整体大小同时添加透明度">b.调整整体大小,同时添加透明度</h3>
<p><img src="https://img-blog.csdnimg.cn/20191114193321429.png" alt="在这里插入图片描述" loading="lazy"><br>
调整好后大概就那样,透明度这里选择了0.9.</p>
<p><s>真是完美啊!</s></p>
<h1 id="3事件处理">3.事件处理</h1>
<h2 id="1光标事件">(1)光标事件</h2>
<h3 id="a标题栏-2">A.标题栏</h3>
<h4 id="a拖动效果">a.拖动效果</h4>
<p>首先把本来那个标题栏去掉.<br>
<img src="https://img-blog.csdnimg.cn/20191114193829338.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">setWindowFlags(windowFlags() | Qt::FramelessWindowHint);
</code></pre>
<p>再在protected中加入鼠标监听函数:<br>
<img src="https://img-blog.csdnimg.cn/20191114193953328.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">void mousePressEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
</code></pre>
<p>私有成员中加入两个QPoint.分别表示当前窗口坐标与光标的坐标.<br>
<img src="https://img-blog.csdnimg.cn/20191114194113842.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">QPoint mousePoint;
QPoint windowPoint;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191114194209704.png" alt="在这里插入图片描述" loading="lazy"><br>
第一个函数是鼠标按下时触发的,根据event-&gt;button()判断是否是左键,是的话获取mouse坐标,在设置window坐标.<br>
当触发第二个函数时,即先判断是否按住左键不放,使用MainWindow的move方法移动窗口.<br>
event-&gt;globalPos()获取坐标后减去原来光标的坐标得到window坐标的变化量,再用原坐标加上这个变化量.</p>
<pre><code class="language-cpp">void MainWindow::mousePressEvent(QMouseEvent *event)
{
    if(event-&gt;button() == Qt::LeftButton)
    {
        mousePoint = event-&gt;globalPos();
        windowPoint = frameGeometry().topLeft();
    }
}

void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    if(event-&gt;buttons() &amp; Qt::LeftButton)
    {
        move(windowPoint + event-&gt;globalPos() - mousePoint);
    }
}
</code></pre>
<h4 id="b最小化与关闭">b.最小化与关闭</h4>
<p>这里以最小化为例,关闭也一样的,改一下函数调用即可.<br>
在最小化按钮中右键选择Go to slot:<br>
<img src="https://img-blog.csdnimg.cn/20191114200607500.png" alt="在这里插入图片描述" loading="lazy"><br>
选择clicked()<br>
<img src="https://img-blog.csdnimg.cn/20191114200634521.png" alt="在这里插入图片描述" loading="lazy"><br>
添加一个最小化函数:<br>
<img src="https://img-blog.csdnimg.cn/20191114200703913.png" alt="在这里插入图片描述" loading="lazy"><br>
下面是关闭的函数:<br>
<img src="https://img-blog.csdnimg.cn/20191114200736537.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="b按键">B.按键</h3>
<p>按键的鼠标事件包括两个:</p>
<ul>
<li>光标移入与移出事件,为按键添加阴影,加深颜色等</li>
<li>单击事件,在输出框中增减对应的字符</li>
</ul>
<h4 id="a移入与移出事件">a.移入与移出事件</h4>
<p>这里的实现方式是通过事件过滤器实现的.增加一个eventFilter()函数<br>
<img src="https://img-blog.csdnimg.cn/20191114194911539.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp"> bool eventFilter(QObject *,QEvent *);
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191114195011401.png" alt="在这里插入图片描述" loading="lazy"><br>
首先通过event-&gt;type()判断事件类型,如果是光标悬停,再判断对应的各个对象增加阴影效果.<br>
addNumButtonEffet():</p>
<pre><code class="language-cpp">void MainWindow::addNumButtonEffect(QPushButton *button,QGraphicsDropShadowEffect *shadow)
{
    shadow-&gt;setEnabled(true);
    button-&gt;setStyleSheet(
        &quot;border:1px groove rgb(220,220,220);&quot;
        &quot;background-color:rgb(193,193,193);&quot;
    );
}
</code></pre>
<p>这里QGraphicsDropShadowEffect *shadow事先初始化好了.<br>
<img src="https://img-blog.csdnimg.cn/20191114195401340.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191114195412448.png" alt="在这里插入图片描述" loading="lazy"><br>
然后在添加事件过滤器:<br>
<img src="https://img-blog.csdnimg.cn/20191114195502933.png" alt="在这里插入图片描述" loading="lazy"><br>
这里可以对比一下有没有阴影的效果:</p>
<p>没有阴影:<br>
<img src="https://img-blog.csdnimg.cn/20191114195858141.gif" alt="在这里插入图片描述" loading="lazy"><br>
加上阴影:<br>
<img src="https://img-blog.csdnimg.cn/20191114200031844.gif" alt="在这里插入图片描述" loading="lazy"><br>
呃....这里可能是截图工具的问题,看不来多大的效果,但是直接在机器上看是有比较大的区别的,建议还是加上阴影.</p>
<h4 id="b单击事件">b.单击事件</h4>
<p>单击事件就是单击了某个按键然后用户可以在输出框中看到对应的反应.</p>
<p>依次选择按键,右键Go to slot:<br>
<img src="https://img-blog.csdnimg.cn/20191114200951455.png" alt="在这里插入图片描述" loading="lazy"><br>
选择clicked()<br>
<img src="https://img-blog.csdnimg.cn/20191114201020242.png" alt="在这里插入图片描述" loading="lazy"><br>
然后添加处理函数,作者这里自己实现了一个添加文本与清除焦点的函数,添加文本就是对应按键被光标单击后添加到输出框,至于为什么要清除焦点....<br>
因为...<br>
因为空格.<br>
<s>因为作者的&quot;良好&quot;习惯,习惯在运算符前后加上空格</s><br>
单击后会把焦点保留在这个按钮上,键盘上敲空格默认会帮你&quot;按一次&quot;这个按钮,因此如果不清除焦点的话,在光标单击了某个按钮,比如7,按空格就会在输出框上输出7,光标单击了8后,按空格就会在输出框上输出8.<br>
<img src="https://img-blog.csdnimg.cn/20191114201052143.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191114201546519.png" alt="在这里插入图片描述" loading="lazy"><br>
这里添加文本时还要注意默认的起提示作用的0.</p>
<pre><code class="language-cpp">void MainWindow::appendText(const QString &amp;s)
{
    if(ui-&gt;box-&gt;text() == &quot;0&quot;)
        ui-&gt;box-&gt;setText(s);
    else
        ui-&gt;box-&gt;setText(ui-&gt;box-&gt;text()+s);
}

void MainWindow::appendTextAndClearFocus(QPushButton *button, const QString &amp;s)
{
    appendText(s);
    button-&gt;clearFocus();
}
</code></pre>
<h2 id="2键盘事件">(2)键盘事件</h2>
<p>键盘事件就是主要处理各个按键按下时的阴影与输出框添加输出.<br>
键盘事件通过以下两个函数处理:<br>
<img src="https://img-blog.csdnimg.cn/2019111500342187.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">void keyPressEvent(QKeyEvent *);
void keyReleaseEvent(QKeyEvent *);
</code></pre>
<p>第一个是按键按下时触发的,第二个是松开按键触发的.</p>
<h3 id="a添加阴影">A.添加阴影</h3>
<p>在按键按下时添加上阴影与颜色加深效果.<br>
<img src="https://img-blog.csdnimg.cn/20191115003541292.png" alt="在这里插入图片描述" loading="lazy"><br>
通过event-&gt;key()依次判断各个键.<br>
<a href="https://blog.csdn.net/judgejames/article/details/93191524">键位可以看这里</a></p>
<p>然后添加在keyRealeseEvent()中把对应的阴影去掉:</p>
<pre><code class="language-cpp">void MainWindow::keyReleaseEvent(QKeyEvent *event)
{
    switch (event-&gt;key())
    {
        case Qt::Key_0:
        case Qt::Key_1:
        case Qt::Key_2:
        case Qt::Key_3:
        case Qt::Key_4:
        case Qt::Key_5:
        case Qt::Key_6:
        case Qt::Key_7:
        case Qt::Key_8:
        case Qt::Key_9:
        case Qt::Key_Plus:
        case Qt::Key_Minus:
        case Qt::Key_Asterisk:
        case Qt::Key_Slash:
        case Qt::Key_AsciiCircum:
        case Qt::Key_Percent:
        case Qt::Key_ParenLeft:
        case Qt::Key_ParenRight:
        case Qt::Key_BraceLeft:
        case Qt::Key_BraceRight:
        case Qt::Key_BracketLeft:
        case Qt::Key_BracketRight:
        case Qt::Key_Backspace:
        case Qt::Key_Space:
        case Qt::Key_Period:
        case Qt::Key_Escape:
        case Qt::Key_Equal:
        case Qt::Key_Return:
            removeNumButtonEffect(ui-&gt;num0,num0_shadow);
            removeNumButtonEffect(ui-&gt;num1,num1_shadow);
            removeNumButtonEffect(ui-&gt;num2,num2_shadow);
            removeNumButtonEffect(ui-&gt;num3,num3_shadow);
            removeNumButtonEffect(ui-&gt;num4,num4_shadow);
            removeNumButtonEffect(ui-&gt;num5,num5_shadow);
            removeNumButtonEffect(ui-&gt;num6,num6_shadow);
            removeNumButtonEffect(ui-&gt;num7,num7_shadow);
            removeNumButtonEffect(ui-&gt;num8,num8_shadow);
            removeNumButtonEffect(ui-&gt;num9,num9_shadow);
            removeSignButtonEffect(ui-&gt;plus,plus_shadow);
            removeSignButtonEffect(ui-&gt;minus,minus_shadow);
            removeSignButtonEffect(ui-&gt;mutiply,mutiply_shadow);
            removeSignButtonEffect(ui-&gt;divide,divide_shadow);
            removeSignButtonEffect(ui-&gt;pow,pow_shadow);
            removeSignButtonEffect(ui-&gt;percent,percent_shadow);
            removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow);
            removeSignButtonEffect(ui-&gt;parentheses,parentheses_shadow);
            removeSignButtonEffect(ui-&gt;brace,brace_shadow);
            removeSignButtonEffect(ui-&gt;brace,brace_shadow);
            removeSignButtonEffect(ui-&gt;bracket,bracket_shadow);
            removeSignButtonEffect(ui-&gt;bracket,bracket_shadow);
            removeSignButtonEffect(ui-&gt;backspace,backspace_shadow);
            removeSignButtonEffect(ui-&gt;blank,space_shadow);
            removeSignButtonEffect(ui-&gt;dot,dot_shadow);
            removeSignButtonEffect(ui-&gt;C,c_shadow);
            removeSignButtonEffect(ui-&gt;equal,equal_shadow);
            break;
    }
}
</code></pre>
<p>这里之所以没有一个个按键去判断是因为有可能同时多个按键按下,然后同时松开后发现某个按键还存在阴影,因此统一当其中一个按键释放时去除所有按键的阴影.</p>
<h3 id="b添加输出">B.添加输出</h3>
<p>在输出框中添加输出,调用一个函数即可:<br>
<img src="https://img-blog.csdnimg.cn/20191115003820819.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4整体细节再处理">4.整体细节再处理</h1>
<h2 id="1淡入效果">(1)淡入效果</h2>
<p>看看效果:<br>
<img src="https://img-blog.csdnimg.cn/2019111501343198.gif" alt="在这里插入图片描述" loading="lazy"><br>
这里实际使用了Qt的动画,针对透明度改变的动画.</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2019111501315492.png" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-cpp">void MainWindow::fadeIn(void)
{
    QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;);
    changeOpacity-&gt;setStartValue(0);
    changeOpacity-&gt;setEndValue(0.91);
    changeOpacity-&gt;setDuration(2500);
    changeOpacity-&gt;start();
}
</code></pre>
<p>第一行表示改变的是透明度,第二三行设置起始值与结束值,接下来设置动画时间(单位ms),然后开始动画.</p>
<h2 id="2设置固定尺寸">(2)设置固定尺寸</h2>
<p>这里可以不设置最大尺寸,但一定要设置最小尺寸.<br>
<img src="https://img-blog.csdnimg.cn/20191115004857972.png" alt="在这里插入图片描述" loading="lazy"><br>
设置这个实际上禁止了拖拽去改变大小.</p>
<h2 id="3淡出效果">(3)淡出效果</h2>
<p>淡出效果与淡入效果类似.<br>
不同的时需要添加计时处理,不能直接在exit(0)前调用fadeOut()函数,因为动画会在另一个线程启动,所以需要在主线程休眠指定秒数,等待淡出效果完成后,主线程再调用exit(0);<br>
<img src="https://img-blog.csdnimg.cn/20191115021629109.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">void MainWindow::fadeOut(void)
{
    QPropertyAnimation * changeOpacity = new QPropertyAnimation(this,&quot;windowOpacity&quot;);
    changeOpacity-&gt;setStartValue(0.9);
    changeOpacity-&gt;setEndValue(0);
    changeOpacity-&gt;setDuration(2500);
    changeOpacity-&gt;start();

    QTime start = QTime::currentTime().addMSecs(2500);
    while(QTime::currentTime() &lt; start)
        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
}
</code></pre>
<p>其中addMSecs()表示要延迟的秒数,while循环体中表示处理本线程的事件,其中100表示处理事件最多100ms就返回本语句.<br>
<img src="https://img-blog.csdnimg.cn/2019111502171357.png" alt="在这里插入图片描述" loading="lazy"><br>
这里就不放淡出效果的图片了.</p>
<h1 id="5表达式处理">5.表达式处理</h1>
<p>由于这是整个字符串作为表达式进行输入,需要先进行判断再计算.所以分为判断与计算两部分.<br>
这里使用了一个新开的控制台工程,后面会把这个整合起来.</p>
<h2 id="1判断">(1)判断</h2>
<p>使用了一个check类判断,由于只有10个数字按键,加减乘除,小数点,求余,求次幂,大中小括号,空格,所以可以分成这几类进行判断.</p>
<h3 id="a去除所有空格">a.去除所有空格</h3>
<pre><code class="language-cpp">void removeAllBlank(void)
{
	size_t i = 0;
	while((i = s.find(' ',i)) != string::npos)
		s.erase(i,1);
}
</code></pre>
<p>首先把所有空格去除,避免之后的判断.</p>
<h3 id="b分类判断">b.分类判断</h3>
<p>把表达式中的所有字符分成5类:</p>
<ul>
<li>数字</li>
<li>小数点</li>
<li>运算符号 + - * / ^ %</li>
<li>左括号类  ( [ {</li>
<li>右括号类  ) ] }</li>
</ul>
<p>然后就是针对每个类型判断它的下一个字符是否是允许的类型,不是的话返回false.<br>
比如碰上了一个 ( 或 [ 或 {<br>
则它的下一个不能是运算符号或者小数点,当然允许-与+,因为有<br>
(-7) (+234)<br>
这种情况.<br>
然后把这个符号保存下来判断后面是否是对应的右括号.</p>
<pre><code class="language-cpp">if(isLeftBrace(i))
{
    if(isSignOrDot(i+1))
    {
        if(s[i+1] != '-' &amp;&amp; s[i+1] != '+')
            return false;
    }
    braces.push(s[i]);
}
</code></pre>
<p>整个判断函数如下:</p>
<pre><code class="language-cpp">bool valid(void)
{
    if(isSignOrDot(0) || isRightBrace(0))
        return false;
    len = s.size();
    stack&lt;char&gt; braces;
    for(size_t i=0;i&lt;len;++i)
    {
        if(isLeftBrace(i))
        {
            if(isSignOrDot(i+1))
            {
                if(s[i+1] != '-' &amp;&amp; s[i+1] != '+')
                    return false;
            }
            if(isRightBrace(i+1))
                return false;
            braces.push(s[i]);
        }
        else if(isRightBrace(i))
        {
            if(isDot(i+1) || isDigit(i+1) || isLeftBrace(i+1))
                return false;
            if(isRightBrace(i+1))
            {
                stack&lt;char&gt; braces_copy(braces);
                if(braces_copy.empty())
                    return false;
                braces_copy.pop();
                if(braces_copy.empty())
                    return false;
            }
            if(braces.empty())
                return false;
            char brace = braces.top();
            if((brace == '(' &amp;&amp; s[i] != ')') || (brace == '[' &amp;&amp; s[i] != ']') || (brace == '{' &amp;&amp; s[i] != '}'))
                return false;
            braces.pop();
        }
        else if(isSign(i))
        {
            if(isSign(i+1) || isDot(i+1) || isRightBrace(i+1))
                return false;
        }
        else if(isDot(i))
        {
            if(isSignOrDot(i+1) || isBrace(i+1))
                return false;
        }
        else if(isDigit(i))
        {
            if(isRightBrace(i+1))
            {
                if(braces.empty())
                    return false;
                char brace = braces.top();
                if((brace == '(' &amp;&amp; s[i+1] != ')') || (brace == '[' &amp;&amp; s[i+1] != ']') || (brace == '{' &amp;&amp; s[i+1] != '}'))
                    return false;
            }
        }
    }
    return braces.empty();
}
</code></pre>
<p>特别要注意下的就是碰到右括号的情况,除了要判断是否是单独存在的右括号,还有判断是否与前一个左括号匹配.</p>
<h3 id="c加0">c.加0</h3>
<p>这是针对单目运算符-的情况,比如(-7),然后把它转化为(0-7):</p>
<pre><code class="language-cpp">string getResult(void)
{
    size_t len = s.size();
    for(size_t i = 0;i&lt;len;++i)
    {
        if(s[i] == '(' &amp;&amp; (s[i+1] == '-' || s[i+1] == '+'))
            s.insert(i+1,&quot;0&quot;);
    }
    return s;
}
</code></pre>
<p>在左小括号后判断是否是-或+,是的话对应位置插入0.</p>
<h2 id="2计算">(2)计算</h2>
<h3 id="acalc辅助类">a.calc辅助类</h3>
<p>calc辅助类中使用了两个栈,运算符栈与操作数栈.</p>
<pre><code class="language-cpp">private:
    stack&lt;char&gt; operators;
    stack&lt;double&gt; operands;
</code></pre>
<p>其中有两个重要的方法:</p>
<pre><code class="language-cpp">bool canCalculate(char sign);
void calculate(void);
</code></pre>
<p>第一个方法将下一个准备进入的符号作为参数,判断是否可以计算操作数栈的前两个数,如果可以的话,使用第二个函数进行计算.<br>
calculate()会将出栈两个操作数与一个运算符,得出结果后在将其压回操作数栈.</p>
<pre><code class="language-cpp">void calculate(void)
{
    double post = popAndGetNum();
    char sign = popAndGetSign();
    double pre = popAndGetNum();
    double result = 0.0;
    switch (sign)
    {
        case '+':
            result = pre+post;
        break;
        case '-':
            result = pre-post;
        break;
        case '*':
            result = pre*post;
        break;
        case '/':
            if(fabs(post) &lt; 1e-6)
            {
                cout&lt;&lt;&quot;Error.Divisor is 0.&quot;;
                exit(EXIT_FAILURE);
            }
            else
                result = pre / post;
        break;
        case '^':
            result = pow(pre,post);
        break;
        case '%':
            result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post);
        break;
    }
    push(result);
}

bool canCalculate(char sign)
{
    if(sign == '(' || sign == '[' || sign == '{' || operators.empty())
        return false;
    char t = getSign();
    if(t == '^')
        return true;
    switch (t)
    {
        case '+':
        case '-':
            return sign == '+' || sign == '-';
        case '*':
        case '/':
        case '%':
            return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%';
    }
    return false;
}
</code></pre>
<p>下面是calc类:</p>
<pre><code class="language-cpp">class calc
{
private:
    stack&lt;char&gt; operators;
    stack&lt;double&gt; operands;

    char getSign(void)
    {
        return operators.top();
    }

    double getNum(void)
    {
        return operands.top();
    }

    void popSign(void)
    {
        operators.pop();
    }

    void popNum(void)
    {
        operands.pop();
    }

    double popAndGetNum(void)
    {
        double num = getNum();
        popNum();
        return num;
    }

    char popAndGetSign(void)
    {
        char sign = getSign();
        popSign();
        return sign;
    }
public:
    void push(double num)
    {
        operands.push(num);
    }

    void push(char sign)
    {
        operators.push(sign);
    }

    char get(void)
    {
        return getSign();
    }

    void pop(void)
    {
        popSign();
    }

    double result(void)
    {
        return getNum();
    }

    void calculate(void)
    {
        double post = popAndGetNum();
        char sign = popAndGetSign();
        double pre = popAndGetNum();
        double result = 0.0;
        switch (sign)
        {
            case '+':
                result = pre+post;
            break;
            case '-':
                result = pre-post;
            break;
            case '*':
                result = pre*post;
            break;
            case '/':
                if(fabs(post) &lt; 1e-6)
                {
                    cout&lt;&lt;&quot;Error.Divisor is 0.&quot;;
                    exit(EXIT_FAILURE);
                }
                else
                    result = pre / post;
            break;
            case '^':
                result = pow(pre,post);
            break;
            case '%':
                result = static_cast&lt;int&gt;(pre) % static_cast&lt;int&gt;(post);
            break;
        }
        push(result);
    }

    bool canCalculate(char sign)
    {
        if(sign == '(' || sign == '[' || sign == '{' || operators.empty())
            return false;
        char t = getSign();
        if(t == '^')
            return true;
        switch (t)
        {
            case '+':
            case '-':
                return sign == '+' || sign == '-';
            case '*':
            case '/':
            case '%':
                return sign == '+' || sign == '-' || sign == '*' || sign == '/' || sign == '%';
        }
        return false;
    }

    bool empty(void)
    {
        return operators.empty();
    }
};
</code></pre>
<p>private封装了一些简单的对两个栈进行操作的工具方法,公有的pop()与get()是对运算符栈进行的操作.因为外部不需要对操作数栈进行操作,由calculate()进行操作,公有的push重载了,可以push到操作数栈或运算符栈.</p>
<h3 id="b计算部分">b.计算部分</h3>
<p>计算部分在这里直接放在了main中:</p>
<pre><code class="language-cpp">int main(void)
{
    check chk;
    while(!chk.inputAndCheck())
        cout&lt;&lt;&quot;Error!Please input again.\n&quot;;
    string s = chk.getResult();
    size_t len = s.size();
    calc c;
    for(size_t i=0;i&lt;len;++i)
    {
        if(isdigit(s[i]))
        {
            double num;
            size_t i1 = i+1;
            while(i1 &lt; len &amp;&amp; (isdigit(s[i1]) || s[i1] == '.'))
                ++i1;
            istringstream input(s.substr(i,i1));
            input&gt;&gt;num;
            i = i1-1;
            c.push(num);
        }
        else if(s[i] == '}' || s[i] == ']' || s[i] == ')')
        {
            char sign;
            char start = (s[i] == '}' ? '{' : ( s[i] == ']' ? '[' : '('));
            while((sign = c.get()) != start)
                c.calculate();
            c.pop();
        }
        else                          //s[i]  is  [ ( {  + - * / ^ %
        {
            while(c.canCalculate(s[i]))
                c.calculate();
            c.push(s[i]);
        }
    }
    while(!c.empty())
        c.calculate();
    cout&lt;&lt;&quot;result is &quot;&lt;&lt;c.result()&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>对表达式的每个字符逐个处理,若是数字,提取出来并压栈.<br>
若是右括号类,不断从运算符栈中提取直到把这段括号内的表达式计算完成.<br>
否则若是左括号或者是运算符,当可以计算的时候一直计算,提取两个操作数运算并压栈,再把新的运算符压栈.<br>
最后使用result()获取结果.</p>
<h3 id="c测试">c.测试</h3>
<p>这里就显示几个很长的例子算了 <s>当然作者测试了很多的例子</s><br>
<img src="https://img-blog.csdnimg.cn/2019111700135896.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191117001405412.png" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20191117001411641.jpg" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code>6.6/{2.3+34.3*2.22-5%2+22%4*[2+3.4/5-(4.3+3.2*33.3)]+34.3} + 7.8*{2.4-6/6+0-0*[23.4-3.4/6+4*(2.2+3)]}+0 - 0 + 0.0 
= 10.8569

3.4 - (+3.34) + 34.3 * (-2) / 3.34 + {[(-3.4)^2/3.4+3.4/3]-3.32+[3*(-3)]}
= -28.2656

9^5-34.4^2.3+5%6-34+66%78-78%4 + (-3)*3.4 / {3*(-7)+[3*(-8)+3*(3.4+4.34)/9.3-3.2 + 0.0 - 0]+0.0 - 0}+3.4^4/6.888 
= 55683.2
</code></pre>
<p><s>不信的话可以手工计算一下.</s></p>
<h1 id="6整合">6.整合</h1>
<p>这部分把界面部分与表达式处理部分整合起来.</p>
<h2 id="1设置界面的调用进程并获取输出结果">(1)设置界面的调用进程,并获取输出结果</h2>
<p>计算表达式的程序叫MyCalc.exe,注意把它放在对应的工程文件夹下面,然后使用QProcess调用.<br>
<img src="https://img-blog.csdnimg.cn/2019111714570688.png" alt="在这里插入图片描述" loading="lazy"><br>
使用execute执行,表达式先去除所有的空格,然后作为命令行参数传递给计算程序,然后计算程序把计算结果写入到result.txt文件,Qt读取这个文件,如果读到#表示表达式输入错误,否则,则是正确的计算结果.<br>
对于结果因为在计算程序中设置了fixed格式,因此对于<br>
1+2<br>
也会返回<br>
3.000000<br>
这步把多余的0去掉,还要注意小数点的情况.</p>
<h2 id="2修改一些细节地方">(2)修改一些细节地方</h2>
<h3 id="a鼠标键盘修改事件">a.鼠标键盘修改事件</h3>
<p><img src="https://img-blog.csdnimg.cn/2019111715004056.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191117150044654.png" alt="在这里插入图片描述" loading="lazy"><br>
修改setText的内容,把结果传递过去.</p>
<h3 id="bexe中设置数字的格式">b.exe中设置数字的格式</h3>
<p><img src="https://img-blog.csdnimg.cn/20191117150121849.png" alt="在这里插入图片描述" loading="lazy"><br>
设置fixed格式,否则的话显示的是科学计数法,对小数位数有要求的话可以设置setprecision.</p>
<h3 id="c设置错误提示">c.设置错误提示</h3>
<p>这里出现错误时,输出&quot;#&quot;,然后主程序读取到就会提示&quot;表达式错误,请重新输入.&quot;<br>
<img src="https://img-blog.csdnimg.cn/20191117210854293.jpg" alt="在这里插入图片描述" loading="lazy"><br>
还有除数为0的错误提示,这个要注意一下:<br>
<img src="https://img-blog.csdnimg.cn/20191118042016590.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118032146199.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="d可以考虑把错误处理整合过来">d.可以考虑把错误处理整合过来</h3>
<p>比如输入了一个点,不能继续输入点,输入了一个乘号或者除号不能再继续输入另一个符号:<br>
<img src="https://img-blog.csdnimg.cn/20191118032347914.gif" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7打包发布">7.打包发布</h1>
<h2 id="1-首先去下载enigma-virtual-box">(1) 首先去下载Enigma Virtual Box</h2>
<h2 id="2-添加环境变量">(2) 添加环境变量</h2>
<p><img src="https://img-blog.csdnimg.cn/20191118011154757.jpg" alt="在这里插入图片描述" loading="lazy"><br>
把Qt文件夹下的如图所示的bin添加到Path环境变量,</p>
<h2 id="3-打包库文件">(3) 打包库文件</h2>
<p>使用windeployqt打包,首先把程序调成release模式,运行一次,生成release的exe,然后把exe复制到一个单独的文件夹,再用命令行进入到这个文件夹,运行</p>
<pre><code class="language-bash">windelpoyqt xxx.exe
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191118011710387.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118011715831.png" alt="在这里插入图片描述" loading="lazy"><br>
这个命令把需要的dll复制到当前所在文件夹.</p>
<h2 id="4-生成单个exe">(4) 生成单个exe</h2>
<p>打开Enigma Virtual Box,选择<br>
<img src="https://img-blog.csdnimg.cn/20191118011822588.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191118012046134.png" alt="在这里插入图片描述" loading="lazy"><br>
第一个选择release的exe,第二个选择打包之后的文件夹,然后选择添加文件,选择递归添加,添加上一步生成的所有文件(夹).<br>
<img src="https://img-blog.csdnimg.cn/20191118011914560.png" alt="在这里插入图片描述" loading="lazy"><br>
这里选择压缩文件.<br>
然后选择压缩等待完成即可.</p>
<h2 id="5-测试">(5) 测试</h2>
<p>点击运行.<br>
<img src="https://img-blog.csdnimg.cn/20191118012144251.png" alt="在这里插入图片描述" loading="lazy"><br>
大功告成!!</p>
<h1 id="8源码">8.源码</h1>
<ul>
<li>
<p>1.<a href="https://github.com/2293736867/Calculator">github(里面包含完整可执行的单个exe)</a><br>
注:由于使用了lfs上传大文件,所以clone的时候请使用</p>
<pre><code class="language-bash">git lfs clone
</code></pre>
</li>
<li>
<p>2.<a href="https://gitee.com/imykr/Calculator">码云</a></p>
</li>
</ul>
<h1 id="9参考链接">9.参考链接</h1>
<p>1.<a href="https://blog.csdn.net/zzwdkxx/article/details/84972067">Qt淡入</a><br>
2.<a href="https://blog.csdn.net/judgejames/article/details/93191524">Qt按键</a><br>
3.<a href="https://blog.csdn.net/qq21497936/article/details/79223848">Qt标题栏</a><br>
4.<a href="https://blog.csdn.net/rl529014/article/details/53446455">事件过滤器</a><br>
5.<a href="https://blog.csdn.net/chinley/article/details/95404282">Qt鼠标事件</a><br>
6.<a href="https://blog.csdn.net/qq_40194498/article/details/80063960">Qt延时处理</a><br>
7.<a href="https://blog.csdn.net/sagghab/article/details/82223343">Qt文件读写</a><br>
8.<a href="https://blog.csdn.net/u014453443/article/details/85837138">Qt打包成单文件</a></p>
<h1 id="10最后">10.最后</h1>
<p>这个简单的计算器有很大的改进空间,比如可以添加各种&quot;数&quot;:<br>
正弦函数,余弦函数,正切函数,反正弦函数,指数函数,对数函数,高阶导数,抽象函数,复合函数.<s>心里没数</s><br>
等等.另外还可以改进矩形的按钮,可以改成圆角矩形或者椭圆形.<br>
另外,对于阴影的处理可以添加淡入淡出效果.<br>
最后就是磨砂.因为win10的是有磨砂效果的,这个作者还不会....<br>
最后再上几个图,看看效果(由于动图大小的限制只是简单的表达式...):<br>
<img src="https://img-blog.csdnimg.cn/20191118014534597.gif" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/2019111801454998.gif" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20191118014556403.gif" alt="在这里插入图片描述" loading="lazy"></figure>
<p><img src="https://img-blog.csdnimg.cn/20191118014605752.gif" alt="在这里插入图片描述" loading="lazy"><br>
希望你们也有一个属于自己的计算器!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java多种文件复制方式以及效率比较]]></title>
        <id>https://2293736867.github.io/post/java-duo-chong-wen-jian-fu-zhi-fang-shi-yi-ji-xiao-lu-bi-jiao/</id>
        <link href="https://2293736867.github.io/post/java-duo-chong-wen-jian-fu-zhi-fang-shi-yi-ji-xiao-lu-bi-jiao/">
        </link>
        <updated>2020-06-02T19:30:44.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E8%83%8C%E6%99%AF">1.背景</a></li>
<li><a href="#2%E6%A6%82%E8%BF%B0">2.概述</a></li>
<li><a href="#3jar%E5%8C%85">3.jar包</a></li>
<li><a href="#4%E9%81%8D%E5%8E%86">4.遍历</a>
<ul>
<li><a href="#1listfiles">(1)listFiles()</a></li>
<li><a href="#2list">(2)list()</a></li>
<li><a href="#3orgcodehausplexusutilfileutilsgetfiles">(3)org.codehaus.plexus.util.FileUtils.getFiles</a></li>
<li><a href="#4commonsio%E5%B7%A5%E5%85%B7%E5%8C%85">(4)Commons.io工具包</a></li>
<li><a href="#5nio-walkfiletree">(5)NIO--walkFileTree</a></li>
</ul>
</li>
<li><a href="#5%E5%A4%8D%E5%88%B6">5.复制</a>
<ul>
<li><a href="#1fileinputstreamfileoutputstream">(1)FileInputStream+FileOutputStream</a>
<ul>
<li><a href="#aread">A.read()</a></li>
<li><a href="#breadb">B.read(b)</a></li>
<li><a href="#creadbofflen">C.read(b,off,len)</a></li>
</ul>
</li>
<li><a href="#2bufferedinputstreambufferedoutputstream">(2)BufferedInputStream+BufferedOutputStream</a>
<ul>
<li><a href="#areadb">A.read(b)</a></li>
<li><a href="#breadbofflen">B.read(b,off,len)</a></li>
<li><a href="#creadallbytes">C.readAllBytes()</a></li>
</ul>
</li>
<li><a href="#3filereaderfilewriter">(3)FileReader+FileWriter</a></li>
<li><a href="#4bufferedreaderbufferedwriter">(4)BufferedReader+BufferedWriter</a></li>
<li><a href="#5nio-filechannel">(5)NIO--FileChannel</a></li>
<li><a href="#6nio-filechannelbytebuffer">(6)NIO--FileChannel+ByteBuffer</a></li>
<li><a href="#7fileutilscopyfile">(7)FileUtils.copyFile()</a></li>
<li><a href="#8filescopy">(8)Files.copy()</a></li>
</ul>
</li>
<li><a href="#6%E5%85%B6%E4%BB%96">6.其他</a>
<ul>
<li><a href="#1swing%E5%B8%83%E5%B1%80">(1)swing布局</a>
<ul>
<li><a href="#a%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80">A.网格布局</a></li>
<li><a href="#b%E5%B1%85%E4%B8%AD">B.居中</a></li>
<li><a href="#c%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4">C.组件的添加与删除</a></li>
</ul>
</li>
<li><a href="#2%E8%BF%9B%E5%BA%A6%E6%9D%A1">(2)进度条</a></li>
</ul>
</li>
<li><a href="#7%E6%B5%8B%E8%AF%95">7.测试</a>
<ul>
<li><a href="#11g%E6%96%87%E4%BB%B6">(1)1G文件</a></li>
<li><a href="#210g%E6%96%87%E4%BB%B6">(2)10G文件</a></li>
<li><a href="#31g%E7%9B%AE%E5%BD%95">(3)1G目录</a></li>
<li><a href="#410g%E7%9B%AE%E5%BD%95">(4)10G目录</a></li>
</ul>
</li>
<li><a href="#8%E6%BA%90%E7%A0%81">8.源码</a></li>
</ul>
</p>
<h1 id="1背景">1.背景</h1>
<p>java复制文件的方式其实有很多种,可以分为</p>
<ul>
<li>传统的字节流读写复制FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStream</li>
<li>传统的字符流读写复制FileReader,FileWriter,BufferWriter,BufferedWriter,BufferedReader</li>
<li>NIO系列的FileChannel</li>
<li>FileChannel+缓冲</li>
<li>java.nio.Files.copy()</li>
<li>第三方包中的FileUtils.copy方法,比如org.apache.commons.io.FileUtils,org.codehaus.plexus.util.FileUtils等等.</li>
</ul>
<p>所以呢,看看各种方法效率怎么样,主要衡量的标准就是时间,另外的一些标准包括大文件的复制时的内存溢出等问题.</p>
<h1 id="2概述">2.概述</h1>
<p>由于很多时候复制文件都包括了文件夹下的所有子目录及文件的复制,所以作者采用的遍历+复制方法去复制文件.就是把整个复制过程分为先遍历,遍历的过程中遇到文件夹就创建,遇到文件就调用不同的复制方法.<br>
遍历的5种方法:</p>
<ul>
<li>(1)File.listFiles()</li>
<li>(2)File.list()</li>
<li>(3)org.codehaus.plexus.util.FileUtils.getFiles()</li>
<li>(4)org.apache.commons.io.FileUtils.listFiles()</li>
<li>(5)java nio中的java.nio.file.Files.walkFileTree</li>
</ul>
<p>复制的8种方法:</p>
<ul>
<li>(1)FileInputStream+FileOutputStream</li>
<li>(2)BufferedInputStream+BufferedOutputStream</li>
<li>(3)FileReader+FileWriter</li>
<li>(4)BufferedReader+BufferedWriter</li>
<li>(5)FileChannel</li>
<li>(6)FileChannel+buffer</li>
<li>(7)org.apache.commons.io.FileUtils.copyFile()</li>
<li>(8)java.nio.file.Files.copy()</li>
</ul>
<p>另外作者不太想看控制台.....所以配合了一点swing使用.</p>
<h1 id="3jar包">3.jar包</h1>
<p>1.<a href="https://repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar">org.apache.commons</a><br>
2.<a href="https://repo1.maven.org/maven2/org/codehaus/plexus/plexus-utils/3.3.0/plexus-utils-3.3.0.jar">org.codehaus.plexus</a></p>
<h1 id="4遍历">4.遍历</h1>
<h2 id="1listfiles">(1)listFiles()</h2>
<pre><code class="language-java"> private static void traverseByListFiles(File srcFile,File desFile) throws IOException
{
	if(srcFile.isDirectory())
	{
		File[] files = srcFile.listFiles();
		assert files != null;
		for(File file : files)
		{
			File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
			if(file.isDirectory())
			{
				if(desFileOrDir.exists())
					desFileOrDir.delete();
				desFileOrDir.mkdirs();
			}
			traverseByListFiles(file, desFileOrDir);
		}
	}
	else 
	{
		copyFile(srcFile, desFile);
	}
}
</code></pre>
<p>通过srcFile的listFiles()获取所有的子文件与子文件夹,然后判断是否是目录<br>
如果是目录,首先判断有没有这个文件(有时候本来是文件夹但是却存在同名的文件,就先删除),再创建文件夹,然后递归执行函数.<br>
如果不是目录,直接把两个File作为参数进行文件复制,里面用什么方法后面会设置.</p>
<h2 id="2list">(2)list()</h2>
<pre><code class="language-java">private static void traverseByList(File srcFile,File desFile) throws IOException
{
	if (srcFile.isDirectory())
	{
		String[] files = srcFile.list();
		assert files != null;
		for (String file : files)
		{
			File subSrcFile = new File(srcFile, file);
			File subDesFile = new File(desFile, file);
			if (subSrcFile.isDirectory())
			{
				if (subDesFile.exists())
					subDesFile.delete();
				subDesFile.mkdirs();
			}
			traverseByList(subSrcFile, subDesFile);
		}
	}
	else
	{
		copyFile(srcFile, desFile);
	}
}
</code></pre>
<p>list与第一种listFiles()类似,不过是String[],也是先判断目录,创建目录,不是目录直接复制</p>
<h2 id="3orgcodehausplexusutilfileutilsgetfiles">(3)org.codehaus.plexus.util.FileUtils.getFiles</h2>
<pre><code class="language-java">private static void traverseByGetFiles(File srcFile, File desFile) throws IOException
{
	if (srcFile.isDirectory())
	{
		java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null);
		for (File file : fileList)
		{
			File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
			if(file.isDirectory())
			{
				if(desFileOrDir.exists())
					desFileOrDir.delete();
				desFileOrDir.mkdirs();
			}
			traverseByListFiles(file, desFileOrDir);
		}
	}
	else
	{
		copyFile(srcFile, desFile);
	}
}
</code></pre>
<p>这是用了别人的工具类进行遍历.</p>
<pre><code class="language-java">org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null);
</code></pre>
<p>返回的结果的java.util.List</p>
<h2 id="4commonsio工具包">(4)Commons.io工具包</h2>
<pre><code class="language-java">private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException
{
	if (srcFile.isDirectory())
	{
		Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false);
		for (File file : files)
		{
			File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
			if(file.isDirectory())
			{
				if(desFileOrDir.exists())
					desFileOrDir.delete();
				desFileOrDir.mkdirs();
			}
			traverseByCommonsIO(file, desFileOrDir);
        }
	}
	else 
	{
		copyFile(srcFile, desFile);
	}
}
</code></pre>
<p>使用org.apache.commons.io.FileUtils的listFiles方法，参数为要遍历的目录，一个null和一个false，第二个参数表示过滤器，表示过滤出特定后缀名的文件，类型为String [],第三个布尔参数表示是否递归访问子目录.</p>
<h2 id="5nio-walkfiletree">(5)NIO--walkFileTree</h2>
<p>利用FileVisitor这个接口.实际中常用SimpleFileVisitor.</p>
<pre><code class="language-java">private static void traverseByNIO2(File srcFile) throws IOException
{
	java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() {
		@Override
		public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException 
		{
			File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length()));
            new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs();
            copyFile(path.toFile(), d);
            return FileVisitResult.CONTINUE;
        }
    });
}
</code></pre>
<p>FileVisitor接口定义了四个方法，分别为：</p>
<pre><code class="language-java">public interface FileVisitor&lt;T&gt;
{
	FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs)
	{
		//访问dir前的操作，dir类型一般为java.nio.Path
	}
	
	FileVisitResult postVisitDirectory(T dir,BasicFileAttributes attrs)
	{
		//访问dir后的操作
	}
	
	FileVisitResult visitFile(T file,BasicFileAttributes attrs)
	{
		//访问file时的操作
	}
	
	FileVisitResult visitFileFailed(T file,BasicFileAttributes attrs)
	{
		//访问file失败时的操作
	}
}
</code></pre>
<p>在上面的例子中只是实现了visitFile，因为只是复制操作，首先判断是否是源目录的路径，不是的话创建文件夹再复制文件.<br>
这里说一下返回值FileVisitResult.FileVisitResult是一个枚举类型，根据返回值判断是否继续遍历.<br>
FileVisitResult可取值:</p>
<ul>
<li>CONTINUE:继续</li>
<li>TERMINNATE:结束</li>
<li>SKIP_SIBLINGS:继续，跳过同一目录的节点</li>
<li>SKIP_SUBTREE:继续，跳过子目录，但会访问子文件</li>
</ul>
<h1 id="5复制">5.复制</h1>
<h2 id="1fileinputstreamfileoutputstream">(1)FileInputStream+FileOutputStream</h2>
<p>首先是经典的字节流FileInputStream+FileOutputStream,这个比较简单,使用FileInputStream读取后使用FileOutputStream写入,不过效率嘛.....一般般.</p>
<pre><code class="language-java">private static void copyByFileStream(File srcFile,File desFile) throws IOException
{
	FileInputStream inputStream = new FileInputStream(srcFile);
	FileOutputStream outputStream = new FileOutputStream(desFile);
	byte [] b = new byte[1024];
	while(inputStream.read(b) != -1)
	{
		outputStream.write(b);
		addCopySize();
	}
	inputStream.close();
	outputStream.close();
}
</code></pre>
<p>这里说一下三个read方法的区别,FileInputStream有三个read方法:</p>
<pre><code class="language-java">input.read();
input.read(b);
input.read(b,off,len);
</code></pre>
<h3 id="aread">A.read()</h3>
<p>逐个字节进行读取,返回int,写入时直接使用write(n);</p>
<pre><code class="language-java">int n = input.read();
output.write(n);
</code></pre>
<p>这个可以说是三个read中最慢的....作者试了一个2G左右的文件,用了大概10分钟才复制160M......</p>
<h3 id="breadb">B.read(b)</h3>
<p>参数是一个byte [],将字节缓冲到其中,返回数组的字节个数,这个比read()快很多.</p>
<pre><code class="language-java">byte [] b = new byte[1024];
while(input.read(b) != -1)
	output.write(b);
</code></pre>
<h3 id="creadbofflen">C.read(b,off,len)</h3>
<p>这个方法其实和read(b)差不多,read(b)相当于省略了参数的read(b,off,len).</p>
<pre><code class="language-java">byte [] b = new byte[1024];
int n;
while((n = input.read(b,0,1024))!=-1)
	output.write(b,0,n);
</code></pre>
<pre><code class="language-java">public int read(byte b[], int off, int len) throws IOException 
{
	return readBytes(b, off, len);
}

public int read(byte b[]) throws IOException 
{
	return readBytes(b, 0, b.length);
}
</code></pre>
<p>这两个都是调用一样的readBytes():</p>
<pre><code class="language-java">private native int readBytes(byte b[], int off, int len) throws IOException;
</code></pre>
<p>至于效率...可以看看结果(作者用的是10G内的小文件):<br>
<img src="https://img-blog.csdnimg.cn/2019110618161675.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106181622795.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106181628553.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106181635467.png" alt="在这里插入图片描述" loading="lazy"><br>
可以看到,没有哪个一定比另外一个更快(不过最后一个误差有点太大了?7G不够的文件.).<br>
采用哪一个建议自己去测试,毕竟这存在很多误差,比如文件,java版本,机器本身等等,仅供参考.</p>
<h2 id="2bufferedinputstreambufferedoutputstream">(2)BufferedInputStream+BufferedOutputStream</h2>
<p>缓冲字节流BufferedInputStream+BufferedOutputStream,相比起FileInputStream,BufferedInputStream读取时会先从缓冲区读取数据,缓冲区无可读数据再从文件读取,所以会比FileInputStream快.</p>
<pre><code class="language-java">private static void copyByBufferStream(File srcFile,File desFile) throws IOException
{
	BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile));
	BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile));
	byte [] b = new byte[1024];
	while(inputStream.read(b) != -1)
	{
		addCopySize();
		outputStream.write(b);
	}
	inputStream.close();
	outputStream.close();
}
</code></pre>
<p>这里也说一下BufferedInputStream的三个read(实际上还有,还有readN,与read(),read()肯定最慢,readN作者很少用,所以就没列出来了)</p>
<pre><code class="language-java">read(b);
read(b,off,len);
readAllBytes();
</code></pre>
<h3 id="areadb">A.read(b)</h3>
<p>这个其实和FileInputStream的那个没啥区别,把一个字节数组仍进去就好了.</p>
<h3 id="breadbofflen">B.read(b,off,len)</h3>
<p>这个....也和FileInputStream那个没啥区别,不说了</p>
<h3 id="creadallbytes">C.readAllBytes()</h3>
<p>这个一次可以读取所有的字节.不过用这个虽然省事,可以直接</p>
<pre><code class="language-java">output.write(input.readAllBytes());
</code></pre>
<p>但是呢,有代价的:<br>
<img src="https://img-blog.csdnimg.cn/20191106181439394.png" alt="在这里插入图片描述" loading="lazy"><br>
会出现OutOfMemory错误,就是对于大文件还是老老实实分开吧,不要&quot;一口搞定&quot;,&quot;多吃几口&quot;.</p>
<p>看看效率:<br>
<img src="https://img-blog.csdnimg.cn/20191106181730636.png" alt="在这里插入图片描述" loading="lazy"><br>
readAllBytes对于大文件(作者这个是5G内的文件)直接爆内存....<br>
<img src="https://img-blog.csdnimg.cn/20191106181901643.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106182220116.png" alt="在这里插入图片描述" loading="lazy"><br>
readAllBytes()又爆了.....这个才2G不到的文件...readAllBytes()看来不是很给力啊....不过对于小文件效率还可以接受.</p>
<h2 id="3filereaderfilewriter">(3)FileReader+FileWriter</h2>
<p>字符流读写FileReader+FileWriter,相比起字节流的read,基本上把byte[]换成char[]即可,因为是逐个字符读取,而字节流是逐个字节读取因此采用byte[].<br>
注意这个不能用来读取图片,音乐等文件,不然复制出来的文件打不开.</p>
<pre><code class="language-java">private static void copyByFileReader(File srcFile,File desFile) throws IOException
{
	FileReader reader = new FileReader(srcFile);
	FileWriter writer = new FileWriter(desFile);

	char [] c = new char[1024];
	while(reader.read(c) != -1)
	{
		addCopySize();
		writer.write(c);
	}
	reader.close();
	writer.close();
}
</code></pre>
<h2 id="4bufferedreaderbufferedwriter">(4)BufferedReader+BufferedWriter</h2>
<p>缓冲字符流读写BufferedReader+BufferedWriter,BufferedReader相比起FileReader有一个readLine()方法,可以每行读入,会比FileReader快.对应的BufferedWriter提供了write(String)方法,当然也有write(String s,int off,int len).同样这个不能用来读取图片等.</p>
<pre><code class="language-java">private static void copyByBufferReader(File srcFile,File desFile) throws IOException
{
	BufferedReader reader = new BufferedReader(new FileReader(srcFile));
	BufferedWriter writer = new BufferedWriter(new FileWriter(desFile));

	char [] c = new char[1024];
	while(reader.read(c) != -1)
	{
		addCopySize();
		writer.write(c);
	}
	reader.close();
	writer.close();
}
</code></pre>
<h2 id="5nio-filechannel">(5)NIO--FileChannel</h2>
<p>通过FileChannel复制,首先通过FileInputStream与FileOutputStream打开流,再用getChannel()方法.最后使用transferTo()或transferFrom()进行复制,一条语句即可,十分方便,而且效率很高.</p>
<pre><code class="language-java">private static void copyByFileChannel(File srcFile,File desFile) throws IOException
{
	FileChannel srcChannel = new FileInputStream(srcFile).getChannel();
	FileChannel desChannel = new FileOutputStream(desFile).getChannel();
	srcChannel.transferTo(0,srcChannel.size(),desChannel);
	srcChannel.close();
	desChannel.close();
}
</code></pre>
<h2 id="6nio-filechannelbytebuffer">(6)NIO--FileChannel+ByteBuffer</h2>
<p>在利用了FileInputStream与FileOutputStream打开了FileChannel的基础上,配合ByteBuffer使用.</p>
<pre><code class="language-java">private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException
{
	FileChannel srcChannel = new FileInputStream(srcFile).getChannel();
	FileChannel desChannel = new FileOutputStream(desFile).getChannel();
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
	while(srcChannel.read(buffer) != -1)
	{
		buffer.flip();
		desChannel.write(buffer);
		buffer.clear();
		addCopySize();
	}
	srcChannel.close();
	desChannel.close();
}
</code></pre>
<p>flip的意思是&quot;翻转&quot;,</p>
<pre><code class="language-java">buffer.flip();
</code></pre>
<p>把Buffer从写模式变为读模式,接着write(buffer),再把buffer清空.<br>
看看这两种方法效率:<br>
<img src="https://img-blog.csdnimg.cn/20191106190454690.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106190911444.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191106192021387.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>另外作者发现transferTo的&quot;上限&quot;为2G,就是对于大于2G的单个文件最多最能复制2个G.<br>
所以...对于大文件没有可比性了.</p>
<h2 id="7fileutilscopyfile">(7)FileUtils.copyFile()</h2>
<p>这是工具类,没啥好说的,参数是两个File,分别表示源与目标.</p>
<pre><code class="language-java">private static void copyByCommonsIO(File srcFile,File desFile) throws IOException
{
	FileUtils.copyFile(srcFile, desFile);
}
</code></pre>
<h2 id="8filescopy">(8)Files.copy()</h2>
<p>这是官方提供的Files工具类,前两个参数为Path,分别表示源与目标,可以设置第三个参数(或者省略),表示选项.例如可以设置</p>
<pre><code class="language-java">StandardCopyOption.REPLACE_EXISTING
</code></pre>
<pre><code class="language-java">private static void copyByFiles(File srcFile,File desFile) throws IOException
{
	Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
}
</code></pre>
<p>注意Files.copy会保持文件的隐藏属性,原来是隐藏的文件复制后也是隐藏的.以上7种则不会.</p>
<h1 id="6其他">6.其他</h1>
<h2 id="1swing布局">(1)swing布局</h2>
<h3 id="a网格布局">A.网格布局</h3>
<p>主JFrame采用了网格布局</p>
<pre><code class="language-java">setLayout(new GridLayout(3,1,5,3));
</code></pre>
<p>三行一列，因为只要三个按钮，选择源文件(夹),选择目标文件夹,选择遍历方式.<br>
选择遍历方式/复制方式的JFrame同样适用了网格布局:</p>
<pre><code class="language-java">showTraverseMethod.setLayout(new GridLayout(5,1,3,3));
showCopyMethod.setLayout(new GridLayout(4,2,5,5));
</code></pre>
<h3 id="b居中">B.居中</h3>
<pre><code class="language-java">setBounds(
(int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200,
(int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 
400, 400);
</code></pre>
<p>高400,宽400,利用ToolKit.getDefaultToolKit().getScreenSize()获取屏幕的高度和宽度实现居中.</p>
<h3 id="c组件的添加与删除">C.组件的添加与删除</h3>
<p>由于在主JFrame中只有三个按钮,选择完遍历方式后需要更新这个组件,作者的做法是先删除这个组件在添加组件:</p>
<pre><code class="language-java">traverseMethodButton.setVisible(false);
remove(traverseMethodButton);
add(copyMethodButton);
copyMethodButton.setVisible(true);
</code></pre>
<p>设置它不可见再删除,再添加另一组件,再设置可见.</p>
<h2 id="2进度条">(2)进度条</h2>
<p>进度条这个东西把作者搞得很惨啊......其实就是新建一个线程就可以了.<br>
核心代码为:</p>
<pre><code class="language-java">new Thread(
	() -&gt;
	{
		int percent;
		while ((percent = getCopyPercent()) &lt; 100)
		{
			try
			{
				Thread.sleep(100);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			copyProgressBar.setValue(percent);
		}
	}
).start();
</code></pre>
<p>作者的JProgressBar是直接添加在一个JFrame中的,不用什么太复杂的布局.<br>
获取百分比后调用setValue(),一定要新建一个线程操作,不然不能正常显示进度条.<br>
另外复制的操作建议使用SwingWorker.</p>
<pre><code class="language-java">SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;()
{
	@Override
	protected String doInBackground()
	{
		try
		{
			if (traverseMethod[0])
				traverseByListFiles(src, des);
			else if (traverseMethod[1])
				traverseByList(src, des);
			else if (traverseMethod[2])
				traverseByGetFiles(src, des);
			else if (traverseMethod[3])
				traverseByCommonsIO(src, des);
			else if (traverseMethod[4])
				traverseByNIO2(src);
			else
			{
				showProgressBar.dispose();
				showMessage(&quot;遍历失败,找不到遍历方法&quot;);
			}
		}
		catch (IOException e)
		{
			e.printStackTrace();
			showProgressBar.dispose();
			showMessage(&quot;未知错误复制失败&quot;);
		}
		finish(start);
		return null;
	}
};
copyTask.execute();
</code></pre>
<h1 id="7测试">7.测试</h1>
<p>说了那么多来点实际的.<br>
(以下所有的测试都是删除复制的文件后再进行新一次的复制.)</p>
<h2 id="11g文件">(1)1G文件</h2>
<table>
<thead>
<tr>
<th>1G file</th>
<th>File.listFiles()</th>
<th>File.list()</th>
<th>plexus.util.FileUtils.getFiles()</th>
<th>commons.io.FileUtils.listFiles</th>
<th>Files.walkFileTree</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileIntput/OutputStream</td>
<td>20.189s</td>
<td>21.152s</td>
<td>18.249s</td>
<td>20.131s</td>
<td>21.782s</td>
</tr>
<tr>
<td>BufferedInput/OuputStream</td>
<td>17.761s</td>
<td>23.786s</td>
<td>22.118s</td>
<td>19.646s</td>
<td>16.806s</td>
</tr>
<tr>
<td>FileReader/Writer</td>
<td>61.334s</td>
<td>58.3s</td>
<td>58.904s</td>
<td>58.679s</td>
<td>55.762s</td>
</tr>
<tr>
<td>BufferedReader/Writer</td>
<td>63.287s</td>
<td>59.546s</td>
<td>56.664s</td>
<td>58.212s</td>
<td>59.884s</td>
</tr>
<tr>
<td>FileChannel</td>
<td>20.097s</td>
<td>22.272s</td>
<td>22.751s</td>
<td>22.765s</td>
<td>20.291s</td>
</tr>
<tr>
<td>FileChannel+ByteBuffer</td>
<td>18.857s</td>
<td>22.489s</td>
<td>23.148s</td>
<td>22.337s</td>
<td>17.213s</td>
</tr>
<tr>
<td>FileUtils.copyFile</td>
<td>25.398s</td>
<td>21.95s</td>
<td>22.808s</td>
<td>25.325s</td>
<td>22.483s</td>
</tr>
<tr>
<td>Files.copy</td>
<td>16.272s</td>
<td>14.166s</td>
<td>17.057s</td>
<td>14.987s</td>
<td>10.653s</td>
</tr>
</tbody>
</table>
<p>文件的话其实纵向比较即可,因为基本不用怎么遍历,横向比较可以勉强看作求平均值.<br>
对于非文本文件,FileReader/Writer和BufferedReader/Writer没有太大的参考意义,比如复制视频文件是打不开的,而且复制出来的文件会变大.对于单文件Files.copy的性能非常好,java的nio果然厉害.</p>
<h2 id="210g文件">(2)10G文件</h2>
<table>
<thead>
<tr>
<th>10G file</th>
<th>File.listFiles()</th>
<th>File.list()</th>
<th>plexus.util.FileUtils.getFiles()</th>
<th>commons.io.FileUtils.listFiles</th>
<th>Files.walkFileTree</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileIntput/OutputStream</td>
<td>171.427s</td>
<td>173.146s</td>
<td>172.611s</td>
<td>184.182s</td>
<td>250.251s</td>
</tr>
<tr>
<td>BufferedInput/OuputStream</td>
<td>203.509s</td>
<td>174.792s</td>
<td>167.727s</td>
<td>177.451s</td>
<td>217.53s</td>
</tr>
<tr>
<td>FileReader/Writer</td>
<td>187.55s</td>
<td>169.306s</td>
<td>226.571s</td>
<td>168.982s</td>
<td>218.303s</td>
</tr>
<tr>
<td>BufferedReader/Writer</td>
<td>155.134s</td>
<td>165.883s</td>
<td>166.192s</td>
<td>176.488s</td>
<td>206.306s</td>
</tr>
<tr>
<td>FileChannel</td>
<td>34.48s</td>
<td>35.445s</td>
<td>43.896s</td>
<td>41.827s</td>
<td>41.755s</td>
</tr>
<tr>
<td>FileChannel+ByteBuffer</td>
<td>175.632s</td>
<td>167.091s</td>
<td>178.455s</td>
<td>182.977s</td>
<td>183.763s</td>
</tr>
<tr>
<td>FileUtils.copyFile</td>
<td>203.997s</td>
<td>206.623s</td>
<td>201.01s</td>
<td>213.949s</td>
<td>208.739s</td>
</tr>
<tr>
<td>Files.copy</td>
<td>209.898s</td>
<td>186.889s</td>
<td>244.355s</td>
<td>222.336s</td>
<td>244.68s</td>
</tr>
</tbody>
</table>
<p>这个10G的文件是文本文件.<br>
现在可以看看FileChannel的这一行,明显所花的时间要比其他要少,为什么呢?<br>
因为文件大于2G.FileChannel的trasferTo方法只能写入最多2G的文件,所以对于大于2G的文件复制出来只有2G,因此FileChannel的这一行没有太大可比性.对于文本文件,BufferedReader/Writer的复制速度是最快的了,其次是FileInput/OutputStream.对于单个大文件,apache的FileUtils与NIO的Files.copy的速度比FileInputStream慢啊...</p>
<h2 id="31g目录">(3)1G目录</h2>
<table>
<thead>
<tr>
<th>1G dir</th>
<th>File.listFiles()</th>
<th>File.list()</th>
<th>plexus.util.FileUtils.getFiles()</th>
<th>commons.io.FileUtils.listFiles</th>
<th>Files.walkFileTree</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileIntput/OutputStream</td>
<td>23.549s</td>
<td>99.386s</td>
<td>143.388s</td>
<td>13.451s</td>
<td>10.773s</td>
</tr>
<tr>
<td>BufferedInput/OuputStream</td>
<td>6.306s</td>
<td>59.458s</td>
<td>20.704s</td>
<td>6.668s</td>
<td>6.616s</td>
</tr>
<tr>
<td>FileReader/Writer</td>
<td>49.059s</td>
<td>103.257s</td>
<td>51.995s</td>
<td>49.729s</td>
<td>51.509s</td>
</tr>
<tr>
<td>BufferedReader/Writer</td>
<td>59.932s</td>
<td>127.359s</td>
<td>51.731s</td>
<td>51.418s</td>
<td>50.317s</td>
</tr>
<tr>
<td>FileChannel</td>
<td>40.082s</td>
<td>71.713s</td>
<td>17.617s</td>
<td>15.782s</td>
<td>19.777s</td>
</tr>
<tr>
<td>FileChannel+ByteBuffer</td>
<td>33.355s</td>
<td>83.845s</td>
<td>19.68s</td>
<td>10.288s</td>
<td>17.152s</td>
</tr>
<tr>
<td>FileUtils.copyFile</td>
<td>24.163s</td>
<td>63.979s</td>
<td>8.277s</td>
<td>6.115s</td>
<td>19.513s</td>
</tr>
<tr>
<td>Files.copy</td>
<td>14.528s</td>
<td>28.215s</td>
<td>6.578s</td>
<td>5.883s</td>
<td>7.502s</td>
</tr>
</tbody>
</table>
<p>对于目录的话可以考虑放弃BufferedReader与FileReader了,除非全部是文本文件,否则推荐使用BufferedInput/OutputStream与Files.copy()进行复制,工具类FileUtils的复制方法表现还是不错的,但相比起java标准的Files.copy效率都差了.<br>
对于FileChannel与配合缓冲使用的FileChannel,1G的话好像不相上下.<br>
遍历方式的话...可以看到plexus的遍历方法表现差距很大,而apache的listFiles或者java nio的walkFileTree比较稳定且速度还可以,推荐使用这两种方式遍历目录.</p>
<h2 id="410g目录">(4)10G目录</h2>
<table>
<thead>
<tr>
<th>10G dir</th>
<th>File.listFiles()</th>
<th>File.list()</th>
<th>plexus.util.FileUtils.getFiles()</th>
<th>commons.io.FileUtils.listFiles</th>
<th>Files.walkFileTree</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileIntput/OutputStream</td>
<td>216.822s</td>
<td>228.792s</td>
<td>227.908s</td>
<td>240.042s</td>
<td>191.863s</td>
</tr>
<tr>
<td>BufferedInput/OuputStream</td>
<td>218.599s</td>
<td>210.941s</td>
<td>207.375s</td>
<td>213.991s</td>
<td>167.614s</td>
</tr>
<tr>
<td>FileReader/Writer</td>
<td>536.747s</td>
<td>550.755s</td>
<td>550.415s</td>
<td>548.881s</td>
<td>516.684s</td>
</tr>
<tr>
<td>BufferedReader/Writer</td>
<td>587.612s</td>
<td>552.55s</td>
<td>549.716s</td>
<td>553.484s</td>
<td>498.18s</td>
</tr>
<tr>
<td>FileChannel</td>
<td>115.126s</td>
<td>117.538s</td>
<td>117.456s</td>
<td>118.207s</td>
<td>97.626s</td>
</tr>
<tr>
<td>FileChannel+ByteBuffer</td>
<td>225.887s</td>
<td>224.932s</td>
<td>222.077s</td>
<td>223.812s</td>
<td>180.177s</td>
</tr>
<tr>
<td>FileUtils.copyFile</td>
<td>233.724s</td>
<td>230.199s</td>
<td>232.133s</td>
<td>223.286s</td>
<td>189.737s</td>
</tr>
<tr>
<td>Files.copy</td>
<td>229.819s</td>
<td>227.562s</td>
<td>226.793s</td>
<td>226.78s</td>
<td>181.071s</td>
</tr>
</tbody>
</table>
<p>FileReader与BufferedReader这两行可以忽略了.对于小文件用FileChannel的话还是不错的,对于大文件一定要用FileChannel的话可以配合ByteBuffer使用,不过从数据上看效果比BufferedInput/OutputStream要低.<br>
再看看org.apache.commons.io.FileUtils与java.nio.file.Files的copy,差别不太,效果接近,但在1G的时候差距有点大.<br>
遍历方式的话,java nio的walkFileTrees最快.</p>
<p>当然这些测试仅供参考,具体使用哪一个要看看具体环境,另外这种方式把遍历与复制分开,apache的FileUtils有方法可以直接复制目录的,因此,使用哪个更合适还需要个人具体测试.</p>
<h1 id="8源码">8.源码</h1>
<p>作者比较偷懒全部仍在一个文件了.七百行.</p>
<pre><code class="language-java">import java.awt.*;
import javax.swing.*;
import java.nio.*;
import java.nio.channels.*;
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.util.*;
import org.apache.commons.io.*;

public class Test extends JFrame
{
    public static final long serialVersionUID = 12398129389122L;

    private JFrame showTraverseMethod = new JFrame(&quot;遍历方式&quot;);
    private JFrame showCopyMethod = new JFrame(&quot;复制方式&quot;);

    private JButton traverseMethodButton = new JButton(&quot;请选择遍历方式&quot;);
    private JButton copyMethodButton = new JButton(&quot;请选择复制方式&quot;);
    private JButton copyButton = new JButton(&quot;开始复制&quot;);

    private JButton traverseByListFiles = new JButton(&quot;File.listFiles()&quot;);
    private JButton traverseByList = new JButton(&quot;File.list()&quot;);
    private JButton traverseByGetFiles = new JButton(&quot;(plexus)getFiles()&quot;);
    private JButton traverseByCommonsIO = new JButton(&quot;Commons IO&quot;);
    private JButton traverseByNIO2 = new JButton(&quot;NIO2&quot;);

    private JButton copyByFileStream = new JButton(&quot;File stream&quot;);
    private JButton copyByBufferStream = new JButton(&quot;Buffer stream&quot;);
    private JButton copyByFileReader = new JButton(&quot;File reader&quot;);
    private JButton copyByBufferReader = new JButton(&quot;Buffer reader&quot;);
    private JButton copyByFileChannel = new JButton(&quot;File channel&quot;);
    private JButton copyByFileChannelWithBuffer = new JButton(&quot;File channel with buffer&quot;);
    private JButton copyByCommonsIO = new JButton(&quot;Commons IO&quot;);
    private JButton copyByFiles = new JButton(&quot;Files.copy&quot;);

    public Test()
    {
        JButton src = new JButton(&quot;选择源文件(夹)&quot;);
        src.addActionListener(
            event -&gt;
            {
                JFileChooser fileChooser = new JFileChooser();
                fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                fileChooser.showDialog(new Label(), &quot;选择文件(夹)&quot;);
                FilesCopy.setSrc(fileChooser.getSelectedFile());
            }
        );
        JButton des = new JButton(&quot;选择目标文件夹&quot;);
        des.addActionListener(
            event -&gt;
            {
                JFileChooser fileChooser = new JFileChooser();
                fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                fileChooser.showDialog(new JLabel(),&quot;选择文件夹&quot;);
                FilesCopy.setDes(fileChooser.getSelectedFile());
            }
        );

        traverseMethodButton.addActionListener(
            event -&gt;
            {
                traverseByListFiles.addActionListener(
                    e-&gt;
                    {
                        FilesCopy.setTraverseByListFiles();
                        showTraverseMethod.dispose();
                    }
                );

                traverseByList.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setTraverseByList();
                        showTraverseMethod.dispose();
                    }
                );

                traverseByGetFiles.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setTraverseByGetfiles();
                        showTraverseMethod.dispose();
                    }
                );

                traverseByCommonsIO.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setTraverseByCommonsIO();
                        showTraverseMethod.dispose();
                    }
                );

                traverseByNIO2.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setTraverseByNIO2();
                        showTraverseMethod.dispose();
                    }
                );


                showTraverseMethod.setLayout(new GridLayout(5,1,3,3));
                showTraverseMethod.setTitle(&quot;遍历方式&quot;);
                showTraverseMethod.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200,
                        (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400);
                showTraverseMethod.setVisible(true);
                showTraverseMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                showTraverseMethod.add(traverseByListFiles);
                showTraverseMethod.add(traverseByList);
                showTraverseMethod.add(traverseByGetFiles);
                showTraverseMethod.add(traverseByCommonsIO);
                showTraverseMethod.add(traverseByNIO2);

                traverseMethodButton.setVisible(false);
                remove(traverseMethodButton);
                add(copyMethodButton);
                copyMethodButton.setVisible(true);
            }
        );

        copyMethodButton.addActionListener(
            event -&gt;
            {
                copyByFileStream.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByFileStream();
                        showCopyMethod.dispose();
                    }
                );

                copyByBufferStream.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByBufferStream();
                        showCopyMethod.dispose();
                    }
                );

                copyByFileReader.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByFileReader();
                        showCopyMethod.dispose();
                    }
                );

                copyByBufferReader.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByBufferReader();
                        showCopyMethod.dispose();
                    }
                );

                copyByFileChannel.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByFileChannel();
                        showCopyMethod.dispose();
                    }
                );

                copyByFileChannelWithBuffer.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByFileChannelWithBuffer();
                        showCopyMethod.dispose();
                    }
                );

                copyByCommonsIO.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByCommonsIO();
                        showCopyMethod.dispose();
                    }
                );

                copyByFiles.addActionListener(
                    e -&gt;
                    {
                        FilesCopy.setCopyByFiles();
                        showCopyMethod.dispose();
                    }
                );

                showCopyMethod.setLayout(new GridLayout(4,2,5,5));
                showCopyMethod.setTitle(&quot;复制方式&quot;);
                showCopyMethod.setBounds(
                        (int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200,
                        (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400);
                showCopyMethod.setVisible(true);
                showCopyMethod.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                showCopyMethod.add(copyByFileStream);
                showCopyMethod.add(copyByBufferStream);
                showCopyMethod.add(copyByFileReader);
                showCopyMethod.add(copyByBufferReader);
                showCopyMethod.add(copyByFileChannel);
                showCopyMethod.add(copyByFileChannelWithBuffer);
                showCopyMethod.add(copyByCommonsIO);
                showCopyMethod.add(copyByFiles);

                copyMethodButton.setVisible(false);
                remove(copyMethodButton);
                add(copyButton);
                copyButton.setVisible(true);
            }
        );

        copyButton.addActionListener(
            event -&gt;
            {
                if(FilesCopy.haveSelectedSrcAndDes())
                {
                    FilesCopy.copy();
                    copyButton.setVisible(false);
                    remove(copyButton);
                    add(traverseMethodButton);
                    traverseMethodButton.setVisible(true);
                }
                else
                    JOptionPane.showMessageDialog(null,&quot;请先选择源文件(夹)与目标文件夹!&quot;);
            }
        );

        setLayout(new GridLayout(3,1,5,3));
        setTitle(&quot;复制文件&quot;);
        setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 200,
                (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 200, 400, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        add(src);
        add(des);
        add(traverseMethodButton);
    }

    public static void main(String[] args) {
        new Test();
    }
}

class FilesCopy
{
    private static File src = null;
    private static File des = null;
    private static long desSize = 0;
    private static long srcSize = 0;
    private static boolean [] traverseMethod = {false,false,false,false,false,false};
    private static boolean[] copyMethod = { false, false, false, false, false, false ,false,false};
    private static JFrame showProgressBar = new JFrame();
    private static JProgressBar copyProgressBar = new JProgressBar();
    private static JTextField textField = new JTextField();
    private static int index = 0;

    private static int getCopyPercent()
    {
        return (int)(desSize * 100.0 / srcSize);
    }

    private static void addCopySize() {
        desSize += 1024L;
    }

    public static void setTraverseByListFiles()
    {
        traverseMethod[0] = true;
    }

    private static void traverseByListFiles(File srcFile,File desFile) throws IOException
    {
        if(srcFile.isDirectory())
        {
            File[] files = srcFile.listFiles();
            assert files != null;
            for(File file : files)
            {
                File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
                if(file.isDirectory())
                {
                    if(desFileOrDir.exists())
                        desFileOrDir.delete();
                    desFileOrDir.mkdirs();
                }
                traverseByListFiles(file, desFileOrDir);
            }
        }
        else {
            copyFile(srcFile, desFile);
        }
    }

    public static void setTraverseByList()
    {
        traverseMethod[1] = true;
    }

    private static void traverseByList(File srcFile,File desFile) throws IOException
    {
        if (srcFile.isDirectory())
        {
            String[] files = srcFile.list();
            assert files != null;
            for (String file : files)
            {
                File subSrcFile = new File(srcFile, file);
                File subDesFile = new File(desFile, file);
                if (subSrcFile.isDirectory())
                {
                    if (subDesFile.exists())
                        subDesFile.delete();
                    subDesFile.mkdirs();
                }
                traverseByList(subSrcFile, subDesFile);
            }
        }
        else
        {
            copyFile(srcFile, desFile);
        }

    }

    public static void setTraverseByGetfiles()
    {
        traverseMethod[2] = true;
    }

    private static void traverseByGetFiles(File srcFile, File desFile) throws IOException
    {
        if (srcFile.isDirectory())
        {
            java.util.List&lt;File&gt; fileList = org.codehaus.plexus.util.FileUtils.getFiles(srcFile,null,null);
            for (File file : fileList)
            {
                File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
                if(file.isDirectory())
                {
                    if(desFileOrDir.exists())
                        desFileOrDir.delete();
                    desFileOrDir.mkdirs();
                }
                traverseByListFiles(file, desFileOrDir);
            }
        }
        else
        {
            copyFile(srcFile, desFile);
        }
    }

    public static void setTraverseByCommonsIO()
    {
        traverseMethod[3] = true;
    }

    private static void traverseByCommonsIO(File srcFile, File desFile) throws IOException
    {
        if (srcFile.isDirectory())
        {
            Collection&lt;File&gt; files = org.apache.commons.io.FileUtils.listFiles(srcFile,null,false);
            for (File file : files)
            {
                File desFileOrDir = new File(desFile.getAbsolutePath() + File.separator + file.getName());
                if(file.isDirectory())
                {
                    if(desFileOrDir.exists())
                        desFileOrDir.delete();
                    desFileOrDir.mkdirs();
                }
                traverseByCommonsIO(file, desFileOrDir);
            }
        }
        else {
            copyFile(srcFile, desFile);
        }
    }

    public static void setTraverseByNIO2()
    {
        traverseMethod[4] = true;
    }

    private static void traverseByNIO2(File srcFile) throws IOException
    {
        java.nio.file.Files.walkFileTree(srcFile.toPath(), new SimpleFileVisitor&lt;&gt;() {
            @Override
            public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
                File d = new File(des.toString() + path.toAbsolutePath().toString().substring(src.toString().length()));
                new File(d.toString().substring(0, d.toString().lastIndexOf(File.separator))).mkdirs();
                copyFile(path.toFile(), d);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    public static void setCopyByFileStream()
    {
        copyMethod[0] = true;
    }

    private static void copyByFileStream(File srcFile,File desFile) throws IOException
    {
        FileInputStream inputStream = new FileInputStream(srcFile);
        FileOutputStream outputStream = new FileOutputStream(desFile);
        byte [] b = new byte[1024];
        while(inputStream.read(b) != -1)
        {
            outputStream.write(b);
            addCopySize();
        }
        inputStream.close();
        outputStream.close();
    }

    public static void setCopyByBufferStream()
    {
        copyMethod[1] = true;
    }

    private static void copyByBufferStream(File srcFile,File desFile) throws IOException
    {
        BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(srcFile));
        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(desFile));
        byte [] b = new byte[1024];
        while(inputStream.read(b) != -1)
        {
            addCopySize();
            outputStream.write(b);
        }
        inputStream.close();
        outputStream.close();
    }

    public static void setCopyByFileReader()
    {
        copyMethod[2] = true;
    }

    private static void copyByFileReader(File srcFile,File desFile) throws IOException
    {
        FileReader reader = new FileReader(srcFile);
        FileWriter writer = new FileWriter(desFile);

        char [] c = new char[1024];
        while(reader.read(c) != -1)
        {
            addCopySize();
            writer.write(c);
        }
        reader.close();
        writer.close();
    }

    public static void setCopyByBufferReader()
    {
        copyMethod[3] = true;
    }

    private static void copyByBufferReader(File srcFile,File desFile) throws IOException
    {
        BufferedReader reader = new BufferedReader(new FileReader(srcFile));
        BufferedWriter writer = new BufferedWriter(new FileWriter(desFile));

        char [] c = new char[1024];
        while(reader.read(c) != -1)
        {
            addCopySize();
            writer.write(c);
        }
        reader.close();
        writer.close();
    }

    public static void setCopyByFileChannel()
    {
        copyMethod[4] = true;
    }

    private static void copyByFileChannel(File srcFile,File desFile) throws IOException
    {
        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();
        FileChannel desChannel = new FileOutputStream(desFile).getChannel();
        srcChannel.transferTo(0,srcChannel.size(),desChannel);
        srcChannel.close();
        desChannel.close();
    }

    public static void setCopyByFileChannelWithBuffer()
    {
        copyMethod[5] = true;
    }

    private static void copyByFileChannelWithBuffer(File srcFile,File desFile) throws IOException
    {
        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();
        FileChannel desChannel = new FileOutputStream(desFile).getChannel();
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
        while(srcChannel.read(buffer) != -1)
        {
            buffer.flip();
            desChannel.write(buffer);
            buffer.clear();
            addCopySize();
        }
        srcChannel.close();
        desChannel.close();
    }

    public static void setCopyByCommonsIO()
    {
        copyMethod[6] = true;
    }

    private static void copyByCommonsIO(File srcFile,File desFile) throws IOException
    {
        FileUtils.copyFile(srcFile, desFile);
    }

    public static void setCopyByFiles()
    {
        copyMethod[7] = true;
    }

    private static void copyByFiles(File srcFile,File desFile) throws IOException
    {
        Files.copy(srcFile.toPath(), desFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
    }

    public static void setSrc(File srcFile) {
		src = srcFile;
		if(srcFile.isDirectory())
		    srcSize = org.apache.commons.io.FileUtils.sizeOfDirectory(srcFile);
		else
            srcSize = src.length();
	}

    public static void setDes(File desFile) {
        des = desFile;
        desSize = 0;
    }

    public static void setSrc(Path srcPath)
    {
        setSrc(srcPath.toFile());
    }

    public static void setDes(Path desPath)
    {
        setDes(desPath.toFile());
    }

    private static void copyFile(File srcFile,File desFile) throws IOException
    {
        if (copyMethod[0])
            copyByFileStream(srcFile,desFile);
        else if (copyMethod[1])
            copyByBufferStream(srcFile, desFile);
        else if (copyMethod[2])
            copyByFileReader(srcFile, desFile);
        else if (copyMethod[3])
            copyByBufferReader(srcFile, desFile);
        else if (copyMethod[4])
            copyByFileChannel(srcFile, desFile);
        else if (copyMethod[5])
            copyByFileChannelWithBuffer(srcFile, desFile);
        else if (copyMethod[6])
            copyByCommonsIO(srcFile, desFile);
        else if (copyMethod[7])
            copyByFiles(srcFile, desFile);
        else
            showMessage(&quot;复制失败,找不到复制方法.&quot;);
    }

    private static void showMessage(String message)
    {
        JOptionPane.showMessageDialog(null, message);
    }

    public static boolean haveSelectedSrcAndDes()
    {
        return src != null &amp;&amp; des != null;
    }

    public static void copy()
    {
        long start = System.currentTimeMillis();
        if(haveSelectedSrcAndDes())
        {
            if(src.isFile())
            {
                des = new File(des.getAbsolutePath()+File.separator+src.getName());
            }
            SwingWorker&lt;String,Object&gt; copyTask = new SwingWorker&lt;&gt;()
            {
                @Override
                protected String doInBackground()
                {
                    try
                    {
                        if (traverseMethod[0])
                            traverseByListFiles(src, des);
                        else if (traverseMethod[1])
                            traverseByList(src, des);
                        else if (traverseMethod[2])
                            traverseByGetFiles(src, des);
                        else if (traverseMethod[3])
                            traverseByCommonsIO(src, des);
                        else if (traverseMethod[4])
                            traverseByNIO2(src);
                        else
                        {
                            showProgressBar.dispose();
                            showMessage(&quot;遍历失败,找不到遍历方法&quot;);
                        }
                    }
                    catch (IOException e)
                    {
                        e.printStackTrace();
                        showProgressBar.dispose();
                        showMessage(&quot;未知错误复制失败&quot;);
                    }
                    finish(start);
                    return null;
                }
            };
            copyTask.execute();
            if (!copyMethod[4] &amp;&amp; !copyMethod[6] &amp;&amp; !copyMethod[7])
            {
                copyProgressBar.setMinimum(0);
                copyProgressBar.setMaximum(100);
                copyProgressBar.setValue(0);
                copyProgressBar.setVisible(true);
                copyProgressBar.setStringPainted(true);

                showProgressBar.add(copyProgressBar);
                showProgressBar.setTitle(&quot;复制进度&quot;);
                showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 150,
                        (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 50, 300, 100);
                showProgressBar.setVisible(true);
                new Thread(
                        () -&gt;
                        {
                            int percent;
                            while ((percent = getCopyPercent()) &lt; 100)
                            {
                                try
                                {
                                    Thread.sleep(100);
                                }
                                catch(InterruptedException e)
                                {
                                    e.printStackTrace();
                                }
                                copyProgressBar.setValue(percent);
                            }
                        }
                ).start();
            }
            else
            {

                final String [] text = {&quot;.&quot;,&quot;..&quot;,&quot;...&quot;,&quot;....&quot;,&quot;.....&quot;,&quot;.......&quot;,&quot;......&quot;,&quot;.....&quot;,&quot;....&quot;,&quot;...&quot;,&quot;..&quot;,&quot;.&quot;};
                textField.setVisible(true);
                textField.setHorizontalAlignment(JTextField.CENTER);
                textField.setEditable(false);
                showProgressBar.add(textField);
                showProgressBar.setTitle(&quot;复制中&quot;);
                showProgressBar.setBounds((int) (Toolkit.getDefaultToolkit().getScreenSize().getWidth() / 2) - 120,
                        (int) (Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2) - 40, 240, 80);
                showProgressBar.setVisible(true);

                new Thread(
                        () -&gt;
                        {
                            while (getCopyPercent() &lt; 100)
                            {
                                try
                                {
                                    Thread.sleep(400);
                                }
                                catch(InterruptedException e)
                                {
                                    e.printStackTrace();
                                }
                                if(index &lt; text.length)
                                    textField.setText(&quot;复制中&quot;+text[index++]);
                                else
                                    index = 0;
                            }
                        }
                ).start();
            }
        }
    }

    private static void finish(long start)
    {
        long end = System.currentTimeMillis();
        showProgressBar.dispose();
        showMessage(&quot;复制成功,用时:&quot; + (end - start) / 1000.0 + &quot;s&quot;);

        copyProgressBar.setVisible(false);
        showProgressBar.remove(copyProgressBar);
        textField.setVisible(false);
        showProgressBar.remove(textField);

        Arrays.fill(traverseMethod, false);
        Arrays.fill(copyMethod, false);
        des = src = null;
        desSize = srcSize;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊聊java中final那点事]]></title>
        <id>https://2293736867.github.io/post/liao-liao-java-zhong-final-na-dian-shi/</id>
        <link href="https://2293736867.github.io/post/liao-liao-java-zhong-final-na-dian-shi/">
        </link>
        <updated>2020-06-02T19:30:02.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1final%E6%98%AF%E4%BB%80%E4%B9%88">1.final是什么</a></li>
<li><a href="#2final%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">2.final有什么用</a></li>
<li><a href="#3final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.final修饰成员变量</a>
<ul>
<li><a href="#1%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">(1)修饰静态变量</a></li>
<li><a href="#2%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">(2)修饰普通成员变量</a></li>
</ul>
</li>
<li><a href="#4final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">4.final修饰局部变量</a>
<ul>
<li><a href="#1%E4%BF%AE%E9%A5%B0%E5%BD%A2%E5%8F%82">(1)修饰形参</a></li>
<li><a href="#2%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">(2)修饰局部变量</a></li>
<li><a href="#3final%E4%BF%AE%E9%A5%B0%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F">(3)final修饰引用变量</a></li>
</ul>
</li>
<li><a href="#5final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95">5.final修饰方法</a></li>
<li><a href="#6final%E4%BF%AE%E9%A5%B0%E7%B1%BB">6.final修饰类</a></li>
</ul>
</p>
<h1 id="1final是什么">1.final是什么</h1>
<p>final是一个java关键字,一个修饰符,可用于修饰变量,方法,修饰类.</p>
<h1 id="2final有什么用">2.final有什么用</h1>
<ul>
<li>final可以修饰变量时,可以使其值不能改变</li>
<li>final修饰方法时使其不能被重写</li>
<li>final修饰类时,使其不能被继承.</li>
</ul>
<h1 id="3final修饰成员变量">3.final修饰成员变量</h1>
<p>fianl最常见的用法时用来修饰成员变量,成员变量分为静态变量与普通变量.<br>
对于final修饰的变量,不是不能被赋值,是其值不能被改变,可以理解成只能赋一次值.可以在定义时赋值,也可以在定义后在另外赋值,但无论何种方式只能被赋值一次.</p>
<h2 id="1修饰静态变量">(1)修饰静态变量</h2>
<p>修饰静态变量时,可以选择以下两种方式赋值:</p>
<ul>
<li>在定义时赋值</li>
<li>静态初始化块内赋值</li>
</ul>
<pre><code class="language-java">final static int a = 6;
final static int b;
static 
{
	b = 6;
}
</code></pre>
<h2 id="2修饰普通成员变量">(2)修饰普通成员变量</h2>
<p>修饰普通成员变量时,可以选择以下三种方式赋值:</p>
<ul>
<li>定义时赋值</li>
<li>初始化块内赋值</li>
<li>构造方法赋值</li>
</ul>
<pre><code class="language-java">public class test
{
	int c = 1;
	int d;
	int e;
	{
		d = 2;
	}
	public test()
	{
		e = 3;
	}
}
</code></pre>
<p>根据&quot;静态&quot;不能访问&quot;非静态&quot;规则,就是说静态的方法不能访问非静态成员,static初始化块不能初始化非静态成员,普通初始化块也不能初始化静态变量.<br>
但是,有一个&quot;bug&quot;就是java允许通过方法访问final成员,因此...有趣的事情发生了.</p>
<pre><code class="language-java">public class test
{
    final int a;
    {
        System.out.println(a);//这里会报错
        printA();
        a = 3;
        printA();
    }
    void printA()
    {
        System.out.println(a);
    }
    public static void main(String[] args) {
        new test();
    }
}
</code></pre>
<p>以上这段代码会报错,因为java不允许final成员未初始化前访问.</p>
<p><img src="https://img-blog.csdnimg.cn/20191025210132589.jpg" alt="在这里插入图片描述" loading="lazy"><br>
把上面那一行出错的代码注释后...居然通过了编译?!</p>
<pre><code class="language-java">public class test
{
    final int a;
    {
        //System.out.println(a);//这里会报错
        printA();
        a = 3;
        printA();
    }
    void printA()
    {
        System.out.println(a);
    }
    public static void main(String[] args) {
        new test();
    }
}
</code></pre>
<p>printA()中只是用方法包装了一下输出函数,居然就通过了编译...有没有兴趣看一下结果?</p>
<p><img src="https://img-blog.csdnimg.cn/20191025210403178.jpg" alt="在这里插入图片描述" loading="lazy"><br>
emmmmmm....final&quot;默认值&quot;为0.....总之<s>就不要想这些歪门邪道去在final初始化之前访问final变量了</s> ,在使用final变量前初始化,初始化,初始化,重要的事情说三遍.</p>
<h1 id="4final修饰局部变量">4.final修饰局部变量</h1>
<p>final修饰局部变量其实也分两种,一种是修饰形参,一种是修饰方法内部的局部变量</p>
<h2 id="1修饰形参">(1)修饰形参</h2>
<p>没什么好说的...就是形参的值不能改变.</p>
<pre><code class="language-java">public void f(final int a)
{
	a = 3;//报错.
}
</code></pre>
<h2 id="2修饰局部变量">(2)修饰局部变量</h2>
<p>修饰局部变量时可以定义时赋值,也可以在定义后在赋值(仅一次).</p>
<pre><code class="language-java">public void f()
{
	final int  a = 3;
	final int b;
	b = 2;
}
</code></pre>
<h2 id="3final修饰引用变量">(3)final修饰引用变量</h2>
<p>嗯.....这个是一个特别一点的例子,Talk is cheap.上代码.</p>
<pre><code class="language-java">import java.util.Arrays;

public class test
{
    public static void main(String[] args) {
        final int[] arr = {1,2,3};
        arr[1] = 5;
        Arrays.stream(arr).forEach(System.out::print);
        System.out.println();
        final A a = new A();
        a.setA(9);
        System.out.println(a.getA());
    }
}

class A
{
    private int a = 3;
    public void setA(int a)
    {
        this.a = a;
    }
    public int getA()
    {
        return a;
    }
}
</code></pre>
<p>为什么final数组可以赋值???fianl对象的值被改变了???看看结果:<br>
<img src="https://img-blog.csdnimg.cn/20191025213120723.jpg" alt="在这里插入图片描述" loading="lazy"><br>
final数组居然被改变了??final对象的值也被改变了??<br>
其实呢,因为数组是引用类型,final修饰引用类型时,只能保证这个变量永远&quot;指向&quot;那一段内存空间,保存的仅仅是一个引用,但是那段内存空间的值是可以改变的.修饰对象时也是一样的道理.</p>
<h1 id="5final修饰方法">5.final修饰方法</h1>
<p>final修饰的方法不能被重写,当然,不能&quot;配合&quot;private&quot;使用&quot;,因为private把方法变成了私有,相当于对子类不可见,子类都不知道父类&quot;还有这玩意&quot;,就可以进行所谓的&quot;重写&quot;了.</p>
<pre><code class="language-java">class A
{
	private final void f(){}
}
class B extends A
{
	public final void f(){}//没毛病
}
</code></pre>
<p>因为B类的f()是属于B类的,不是从A类继承过来的.</p>
<h1 id="6final修饰类">6.final修饰类</h1>
<p>final修饰类时表示该类不能被继承.</p>
<pre><code class="language-java">final class A{}
class B extends A{}//出错
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java自定义的getInstance()返回泛型]]></title>
        <id>https://2293736867.github.io/post/java-zi-ding-yi-de-getinstancefan-hui-fan-xing/</id>
        <link href="https://2293736867.github.io/post/java-zi-ding-yi-de-getinstancefan-hui-fan-xing/">
        </link>
        <updated>2020-06-02T19:28:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1背景">1.背景</h1>
<p>实际中经常使用getInstance()方法返回一个对象,对于工厂模式,传入对应的参数返回与之相对应的对象.但是,问题来了,返回的对象需要被强制转换,很麻烦.</p>
<pre><code class="language-java">import java.lang.reflect.*;

public class test
{
    public static void main(String[] args) {
        test1 t1 = factory.getInstance(&quot;test1&quot;);
        test2 t2 = factory.getInstance(&quot;test2&quot;);
    }
}

class factory
{
    public static Object getInstance(String className)
    {
        try
        {
            return Class.forName(className).getConstructor().newInstance();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }
}

class test1
{
    public test1()
    {
    }
}

class test2
{
    public test2()
    {
    }
}
</code></pre>
<p>编译不通过,说类型不兼容.<br>
<img src="https://img-blog.csdnimg.cn/20191025171011736.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<p>因此加上强制类型转换,编译通过了.</p>
<pre><code class="language-java">test1 t1 = (test1)factory.getInstance(&quot;test1&quot;);
test2 t2 = (test2)factory.getInstance(&quot;test2&quot;);
</code></pre>
<h1 id="2如何处理">2.如何处理</h1>
<p>例子只有两个类,手动强制转换还可以,但如果多个类咋办啊?而且作者是那种非常懒的人,也不想手动去转换,因此,用大招-----泛型!</p>
<h1 id="3使用泛型">3.使用泛型</h1>
<p>使用Class&lt;T&gt; 泛型可以避免强制转换<s>从而更有效地偷懒</s> ,需要把返回类型改成&lt;T&gt; T,同时由于使用了T,必须修改传进来的参数.</p>
<pre><code class="language-java">public static &lt;T&gt; T getInstance(Class&lt;T&gt; t)
</code></pre>
<h1 id="4完整代码">4.完整代码</h1>
<pre><code class="language-java">import java.lang.reflect.*;

public class test
{
    public static void main(String[] args) {
        test1 t1 = factory.getInstance(test1.class);
        test2 t2 = factory.getInstance(test2.class);
    }
}

class factory
{
    public static &lt;T&gt; T getInstance(Class&lt;T&gt; t)
    {
        try
        {
            return t.getConstructor().newInstance();
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }
}

class test1
{
    public test1()
    {

    }
}

class test2
{
    public test2()
    {

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java反射Array的使用]]></title>
        <id>https://2293736867.github.io/post/java-fan-she-array-de-shi-yong/</id>
        <link href="https://2293736867.github.io/post/java-fan-she-array-de-shi-yong/">
        </link>
        <updated>2020-06-02T19:28:33.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AFarray">1.什么是Array</a></li>
<li><a href="#2array%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">2.Array有什么用</a></li>
<li><a href="#3array%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">3.Array使用示例</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA">(1)创建</a></li>
<li><a href="#2%E8%B5%8B%E5%80%BC">(2)赋值</a></li>
<li><a href="#3%E8%8E%B7%E5%8F%96%E5%80%BC">(3)获取值</a></li>
<li><a href="#4%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">(4)强制类型转换</a></li>
</ul>
</li>
<li><a href="#4%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">4.完整代码</a></li>
<li><a href="#5%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">5.运行结果</a></li>
</ul>
</p>
<h1 id="1什么是array">1.什么是Array</h1>
<p>Array是一个类的简写,全限定类名是java.lang.reflect.Array.</p>
<h1 id="2array有什么用">2.Array有什么用</h1>
<p>Array可以代表所有的数组,可以通过Array动态创建与修改里面的元素.</p>
<h1 id="3array使用示例">3.Array使用示例</h1>
<h2 id="1创建">(1)创建</h2>
<p>使用静态方法newInstance()构造Object对象.方法如下:</p>
<pre><code class="language-java">public static Object newInstance(Class&lt;?&gt; element, int ... length);
</code></pre>
<p>第一个参数是代表元素的类,剩下的参数表示维数,一个参数表示一维数组,两个参数表示二维数组(数组的数组),参数的值代表维数的长度.</p>
<pre><code class="language-java">Object intArray = Array.newInstance(int.class,3);              //int [3]
Object stringArray = Array.newInstance(String.class,2,3);      //String [2][3]
</code></pre>
<h2 id="2赋值">(2)赋值</h2>
<p>赋值使用静态方法set即可,参数为Array返回的Object对象,下标与对应的值.</p>
<pre><code class="language-java">public static void set(Object array,int index,Object value);
public static void setBoolean(Object array,int index,boolean b);
public static void setXxxx(Object array,int index,xxx);
</code></pre>
<p>其中最后一个表示对应的基本类型,第二个为boolean类型的示例.</p>
<pre><code class="language-java">Array.set(intArray,2,3);
Array.set(stringArray,1,new String[]{&quot;123&quot;,&quot;456&quot;});
</code></pre>
<h2 id="3获取值">(3)获取值</h2>
<p>使用静态方法get,参数为Array返回的Object对象与下标.</p>
<pre><code class="language-java">public static Object get(Object array,int index);
public static boolean getBoolean(Object array,int index);
public static xxx getXxx(Object array,int index);
</code></pre>
<p>最后一个表示对应的基本类型,第二个为boolean类型的示例</p>
<pre><code class="language-java">System.out.println(Array.get(intArray,2));
System.out.println(Array.get(Array.get(stringArray,1),1));
</code></pre>
<h2 id="4强制类型转换">(4)强制类型转换</h2>
<p>可以通过强制类型转换使Array返回的Object对象转换为对应的数组.</p>
<pre><code class="language-java">var castIntArray = (int [])intArray;
var castStringArray = (String [][])stringArray;
</code></pre>
<p>这样可以当作一个普通数组使用.</p>
<h1 id="4完整代码">4.完整代码</h1>
<pre><code class="language-java">import java.lang.reflect.*;

public class test
{
    public static void main(String[] args) {
        var intArray = Array.newInstance(int.class, 3);
        var stringArray = Array.newInstance(String.class, 2,3);
        Array.set(intArray, 2, 3);
        Array.set(stringArray, 1, new String[] { &quot;123&quot;, &quot;456&quot; });

        System.out.println(Array.get(intArray, 2));
        System.out.println(Array.get(Array.get(stringArray,1),1));

        System.out.println(&quot;-------cast-------&quot;);
        System.out.println(((int[]) intArray)[2]);
        System.out.println(((String [][])stringArray)[1][1]);
    }
}
</code></pre>
<h1 id="5运行结果">5.运行结果</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191025164406672.jpg" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[log4j2入门hello world]]></title>
        <id>https://2293736867.github.io/post/log4j2-ru-men-hello-world/</id>
        <link href="https://2293736867.github.io/post/log4j2-ru-men-hello-world/">
        </link>
        <updated>2020-06-02T19:27:55.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AFlog4j2">1.什么是log4j2</a>
<ul>
<li><a href="#1log4j">(1)log4j</a></li>
<li><a href="#2log4j2">(2)log4j2</a></li>
</ul>
</li>
<li><a href="#3vscode%E4%B8%8B%E4%BD%BF%E7%94%A8log4j2%E4%B8%8D%E7%94%A8maven">3.VScode下使用log4j2(不用Maven)</a>
<ul>
<li><a href="#1%E5%87%86%E5%A4%87jar%E5%8C%85">(1)准备jar包</a></li>
<li><a href="#2%E5%87%86%E5%A4%87%E6%8F%92%E4%BB%B6">(2)准备插件</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">(3)创建项目</a></li>
<li><a href="#4%E8%AE%BE%E7%BD%AEjar%E5%8C%85%E8%B7%AF%E5%BE%84">(4)设置jar包路径</a></li>
<li><a href="#5%E6%96%B0%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6">(5)新建测试文件</a></li>
<li><a href="#6%E8%BF%90%E8%A1%8C">(6)运行</a></li>
<li><a href="#7%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E5%85%B6%E8%BE%93%E5%87%BA%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">(7)创建配置文件使其输出更多信息</a></li>
<li><a href="#8%E5%86%8D%E6%AC%A1%E8%BF%90%E8%A1%8C">(8)再次运行</a></li>
</ul>
</li>
<li><a href="#4vscode%E4%B8%8B%E4%BD%BF%E7%94%A8log4j2%E5%B8%A6maven">4.VScode下使用log4j2(带Maven)</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE">(1)创建maven项目</a></li>
<li><a href="#2%E5%9C%A8pomxml%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96">(2)在pom.xml配置依赖</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BAlog4j2xml">(3)创建log4j2.xml</a></li>
<li><a href="#4%E4%BF%AE%E6%94%B9%E6%B5%8B%E8%AF%95%E7%B1%BB">(4)修改测试类</a></li>
<li><a href="#5%E6%B5%8B%E8%AF%95">(5)测试</a></li>
</ul>
</li>
<li><a href="#5idea%E4%B8%8B%E4%BD%BF%E7%94%A8log4j2%E4%B8%8D%E7%94%A8maven">5.IDEA下使用log4j2(不用Maven)</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">(1)创建项目</a></li>
<li><a href="#2%E6%B7%BB%E5%8A%A0jar%E5%8C%85">(2)添加jar包</a></li>
<li><a href="#3%E6%96%B0%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB">(3)新建测试类</a></li>
<li><a href="#4%E6%96%B0%E5%BB%BAlog4j2xml">(4)新建log4j2.xml</a></li>
<li><a href="#5%E6%B5%8B%E8%AF%95-2">(5)测试</a></li>
</ul>
</li>
<li><a href="#6idea%E4%B8%8B%E4%BD%BF%E7%94%A8log4j2%E5%B8%A6maven">6.IDEA下使用log4j2(带Maven)</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E5%9D%97">(1)创建maven<s>项目</s> 模块</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96">(2)配置依赖</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BAlog4j2xml-2">(3)创建log4j2.xml</a></li>
<li><a href="#4%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB">(4)创建测试类</a></li>
<li><a href="#5%E6%B5%8B%E8%AF%95-3">(5)测试</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1什么是log4j2">1.什么是log4j2</h1>
<h2 id="1log4j">(1)log4j</h2>
<p>log4j是apache的一个开源项目,表示log for java.是一个日志工具,可以将日志信息输出到文件,控制台等其他地方 ,还可以定义日志的输出格式,另外还有日志级别的区分,可通过配置文件去配置输出格式,输出目的地等信息.</p>
<h2 id="2log4j2">(2)log4j2</h2>
<p>log4j2从名字就知道了,是log4j的升级版本,性能有了很大提升,增加了很多新特性(如自定义级别,lambda表达式)与新的API,直接与tomcat等服务器集成.</p>
<h1 id="3vscode下使用log4j2不用maven">3.VScode下使用log4j2(不用Maven)</h1>
<h2 id="1准备jar包">(1)准备jar包</h2>
<p><a href="https://logging.apache.org/log4j/2.x/download.html">点击这里下载</a><br>
<img src="https://img-blog.csdnimg.cn/20191020200608156.png" alt="在这里插入图片描述" loading="lazy"><br>
作者用的是win10,下载zip.</p>
<h2 id="2准备插件">(2)准备插件</h2>
<p>搜索安装:Eclipse New Java Project<br>
<img src="https://img-blog.csdnimg.cn/20191020200424893.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="3创建项目">(3)创建项目</h2>
<p>ctrl+shift+p调出命令面板,输入new java project<br>
<img src="https://img-blog.csdnimg.cn/20191020201508261.png" alt="在这里插入图片描述" loading="lazy"><br>
项目名<br>
<img src="https://img-blog.csdnimg.cn/20191020201518977.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>JavaSE版本<br>
<img src="https://img-blog.csdnimg.cn/20191020201534737.png" alt="在这里插入图片描述" loading="lazy"><br>
创建完毕.<br>
<img src="https://img-blog.csdnimg.cn/201910202015435.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="4设置jar包路径">(4)设置jar包路径</h2>
<p>在项目根路径下新建lib文件夹,把下载的<br>
<img src="https://img-blog.csdnimg.cn/20191020201650516.png" alt="在这里插入图片描述" loading="lazy"><br>
这两个jar包放进去.<br>
下一步设置.classpath.<br>
添加</p>
<pre><code class="language-xml">&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-api-2.12.1.jar&quot; /&gt;
&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/log4j-core-2.12.1.jar&quot; /&gt;
</code></pre>
<h2 id="5新建测试文件">(5)新建测试文件</h2>
<p>src下直接建立test.java</p>
<p>test.java:</p>
<pre><code class="language-java">import org.apache.logging.log4j.*;

public class test
{
    private final static Logger logger = LogManager.getLogger(test.class.getName());
    public static void main(String[] args) {
        logger.info(&quot;info&quot;);
        logger.error(&quot;error&quot;);
        logger.debug(&quot;debug&quot;);
        logger.trace(&quot;trace&quot;);
        logger.fatal(&quot;fatel&quot;);
    }
}
</code></pre>
<h2 id="6运行">(6)运行</h2>
<p>点击main上的Run<br>
<img src="https://img-blog.csdnimg.cn/20191020202234941.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>结果:<br>
<img src="https://img-blog.csdnimg.cn/20191020202300581.png" alt="在这里插入图片描述" loading="lazy"><br>
输出了fatel与error信息.<br>
另外还提示了没有找到log4j2配置文件,使用默认的配置文件,默认输出到控制台.</p>
<h2 id="7创建配置文件使其输出更多信息">(7)创建配置文件使其输出更多信息</h2>
<p>src下创建log4j2.xml配置文件.<br>
<img src="https://img-blog.csdnimg.cn/20191020202514614.png" alt="在这里插入图片描述" loading="lazy"><br>
log4j2的配置文件只能是.xml或.json或.jsn文件,默认会在classpath下寻找(在这里classpath相当于图中的src).<br>
默认情况下系统选择配置文件的优先级如下:</p>
<ul>
<li>1.classpath下名为 log4j-test.json 或者log4j-test.jsn文件</li>
<li>2.classpath下名为 log4j2-test.xml</li>
<li>3.classpath下名为 log4j.json 或者log4j.jsn文件</li>
<li>4.classpath下名为 log4j2.xml</li>
</ul>
<p>这里使用log4j2.<br>
xml.log4j2.xml如下:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    
&lt;configuration status=&quot;OFF&quot;&gt;    
  &lt;appenders&gt;    
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;    
      &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;    
    &lt;/Console&gt;    
  &lt;/appenders&gt;    
  &lt;loggers&gt;    
    &lt;logger name=&quot;test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;    
      &lt;appender-ref ref=&quot;Console&quot;/&gt;    
    &lt;/logger&gt;    
    &lt;root level=&quot;info&quot;&gt;    
      &lt;appender-ref ref=&quot;Console&quot;/&gt;    
    &lt;/root&gt;    
  &lt;/loggers&gt;    
&lt;/configuration&gt;  
</code></pre>
<p>Logger三个主要的组件为</p>
<ul>
<li>logger(记录器)</li>
<li>appender(输出目的地)</li>
<li>layout(布局,定义日志的格式)</li>
</ul>
<p>&lt;appenders&gt;了输出目的地,&lt;Console&gt;表示控制台,&lt;PatternLayout&gt;定义了布局,里面的布局表示时间格式(%d,HH:mm:ss.SSS),接着是日志线程名(%t),%-5表示最小长度为5左对齐,level表示输出日志级别.<br>
%logger表示输出logger名称.<br>
%m是%msg与%message的缩写,表示输出应用提供的与记录事件有关的信息.<br>
%n表示换行.</p>
<p>&lt;loggers&gt;定义的logger与logger使用的appender.root为log默认的输出形式,如果一个类的没有明确loggers中的输出格式就会采用root的格式.</p>
<h2 id="8再次运行">(8)再次运行</h2>
<p>没有之前的&quot;没有配置文件&quot;的提示了.<br>
<img src="https://img-blog.csdnimg.cn/20191020205433738.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4vscode下使用log4j2带maven">4.VScode下使用log4j2(带Maven)</h1>
<h2 id="1创建maven项目">(1)创建maven项目</h2>
<p>使用插件maven for java创建,命令面板(ctrl+shift+p)输入.<br>
<img src="https://img-blog.csdnimg.cn/20191020205627669.png" alt="在这里插入图片描述" loading="lazy"><br>
选择quickstart.<br>
<img src="https://img-blog.csdnimg.cn/20191020205733268.png" alt="在这里插入图片描述" loading="lazy"><br>
选择版本.<br>
<img src="https://img-blog.csdnimg.cn/2019102020581850.png" alt="在这里插入图片描述" loading="lazy"><br>
最后选择项目路径即可.<br>
在控制台中vscode会下载相关文件,然后会提示以交互模式创建:<br>
<img src="https://img-blog.csdnimg.cn/20191020213533538.png" alt="在这里插入图片描述" loading="lazy"><br>
这里等一会就好了.<br>
然后会提示输入一些值.<br>
<img src="https://img-blog.csdnimg.cn/20191021074532605.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191021074613153.png" alt="在这里插入图片描述" loading="lazy"><br>
ok.</p>
<h2 id="2在pomxml配置依赖">(2)在pom.xml配置依赖</h2>
<p>在&lt;dependencies&gt;中添加如下代码:</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>以下是完整的pom.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;test&lt;/name&gt;
    &lt;!-- FIXME change it to the project's website --&gt;
    &lt;url&gt;http://www.example.com&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.11&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
            &lt;version&gt;2.12.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.12.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
            &lt;plugins&gt;
                &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.1.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.8.0&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.22.1&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.5.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.8.2&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.7.1&lt;/version&gt;
                &lt;/plugin&gt;
                &lt;plugin&gt;
                    &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt;
                    &lt;version&gt;3.0.0&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;

</code></pre>
<p>右键选择Update project configuration.<br>
<img src="https://img-blog.csdnimg.cn/20191021074957718.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="3创建log4j2xml">(3)创建log4j2.xml</h2>
<p>在java目录下新建log4j2.xml.<br>
<img src="https://img-blog.csdnimg.cn/20191021075807542.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration status=&quot;OFF&quot;&gt;
    &lt;appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt;
        &lt;/Console&gt;
    &lt;/appenders&gt;
    &lt;loggers&gt;
        &lt;logger name=&quot;com.example.App&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/logger&gt;
        &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="4修改测试类">(4)修改测试类</h2>
<p>修改默认的App.java.</p>
<pre><code class="language-java">package com.example;
import org.apache.logging.log4j.*;
public class App
{
    private static final Logger logger = LogManager.getLogger(App.class.getName());
    public static void main( String[] args )
    {
        logger.info(&quot;info&quot;);
        logger.error(&quot;error&quot;);
        logger.debug(&quot;debug&quot;);
        logger.trace(&quot;trace&quot;);
        logger.fatal(&quot;fatel&quot;);
    }
}
</code></pre>
<h2 id="5测试">(5)测试</h2>
<p>run即可.<br>
<img src="https://img-blog.csdnimg.cn/20191021080047982.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191021080054841.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5idea下使用log4j2不用maven">5.IDEA下使用log4j2(不用Maven)</h1>
<h2 id="1创建项目">(1)创建项目</h2>
<p>什么也不用选,直接next.<br>
<img src="https://img-blog.csdnimg.cn/20191020210516150.png" alt="在这里插入图片描述" loading="lazy"><br>
勾选从模板创建项目.<br>
<img src="https://img-blog.csdnimg.cn/2019102021064196.png" alt="在这里插入图片描述" loading="lazy"><br>
选好路径与填好项目名即可.</p>
<h2 id="2添加jar包">(2)添加jar包</h2>
<p><img src="https://img-blog.csdnimg.cn/20191020210903580.png" alt="在这里插入图片描述" loading="lazy"><br>
选择刚才的lib目录,或者自己手动改成两个jar包(log4j-api-版本.jar,log4j-core-版本.jar).<br>
<img src="https://img-blog.csdnimg.cn/20191020210913784.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="3新建测试类">(3)新建测试类</h2>
<p>项目结构如下:<br>
<img src="https://img-blog.csdnimg.cn/20191020211309252.png" alt="在这里插入图片描述" loading="lazy"><br>
Main.java</p>
<pre><code class="language-java">package com.test;
import org.apache.logging.log4j.*;

public class Main {

    private static final Logger logger = LogManager.getLogger(Main.class.getName());
    public static void main(String[] args) {
        logger.info(&quot;info&quot;);
        logger.error(&quot;error&quot;);
        logger.debug(&quot;debug&quot;);
        logger.trace(&quot;trace&quot;);
        logger.fatal(&quot;fatel&quot;);
    }
}

</code></pre>
<h2 id="4新建log4j2xml">(4)新建log4j2.xml</h2>
<p>在src下新建log4j2.xml.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration status=&quot;OFF&quot;&gt;
    &lt;appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt;
        &lt;/Console&gt;
    &lt;/appenders&gt;
    &lt;loggers&gt;
        &lt;logger name=&quot;com.test.Main&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/logger&gt;
        &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="5测试-2">(5)测试</h2>
<p>直接点击run按钮.<br>
<img src="https://img-blog.csdnimg.cn/20191020211513646.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6idea下使用log4j2带maven">6.IDEA下使用log4j2(带Maven)</h1>
<h2 id="1创建maven项目-模块">(1)创建maven<s>项目</s> 模块</h2>
<p>这里作者偷懒就直接在上面项目的基础上新建模块不新建项目了.<br>
<img src="https://img-blog.csdnimg.cn/20191020211928566.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>都不用选直接next.<br>
<img src="https://img-blog.csdnimg.cn/20191020211952402.png" alt="在这里插入图片描述" loading="lazy"><br>
填好GroupId与ArtifactId之后next.<br>
<img src="https://img-blog.csdnimg.cn/20191020212033878.png" alt="在这里插入图片描述" loading="lazy"><br>
最后选好位置.</p>
<h2 id="2配置依赖">(2)配置依赖</h2>
<p>pom.xml中加入:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.12.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.12.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>以下是完整的pom.xml文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
            &lt;version&gt;2.12.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.12.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>右键选择同步pom.xml.<br>
<img src="https://img-blog.csdnimg.cn/20191021074734906.png" alt="在这里插入图片描述" loading="lazy"><br>
选择右下角弹出的提示中的Import Changes.<br>
<img src="https://img-blog.csdnimg.cn/20191021075520677.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="3创建log4j2xml-2">(3)创建log4j2.xml</h2>
<p>在target下的classes下创建log4j2.xml.<br>
<img src="https://img-blog.csdnimg.cn/20191021120152165.png" alt="在这里插入图片描述" loading="lazy"><br>
log4j2.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration status=&quot;OFF&quot;&gt;
    &lt;appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt;
        &lt;/Console&gt;
    &lt;/appenders&gt;
    &lt;loggers&gt;
        &lt;logger name=&quot;com.example.test&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/logger&gt;
        &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="4创建测试类">(4)创建测试类</h2>
<p>创建包与test.java.</p>
<p>test.java</p>
<pre><code class="language-java">package com.example;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
public class test {
    private static final Logger logger = LogManager.getLogger(test.class.getName());
    public static void main(String[] args) {
        logger.info(&quot;info&quot;);
        logger.error(&quot;error&quot;);
        logger.debug(&quot;debug&quot;);
        logger.trace(&quot;trace&quot;);
        logger.fatal(&quot;fatel&quot;);
    }
}

</code></pre>
<h2 id="5测试-3">(5)测试</h2>
<p>新建配置Application.<br>
<img src="https://img-blog.csdnimg.cn/20191021115456431.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>输入Main class与名字.<br>
<img src="https://img-blog.csdnimg.cn/20191021115507597.png" alt="在这里插入图片描述" loading="lazy"><br>
run.<br>
<img src="https://img-blog.csdnimg.cn/20191021120310528.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>参考:<br>
1.<a href="https://blog.csdn.net/moonpure/article/details/83415432">log4j2(1)</a><br>
2.<a href="https://www.iteye.com/blog/bijian10J13-2307334">log4j2(2)</a><br>
3.<a href="https://www.cnblogs.com/littleatp/p/9260784.html">log4j2(3)</a><br>
4.<a href="https://www.cnblogs.com/sa-dan/p/6837225.html">log4j2(4)</a><br>
5.<a href="http://logging.apache.org/log4j/2.x/manual/layouts.html">log4j2(5)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java通过ServerSocket与Socket实现通信]]></title>
        <id>https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/</id>
        <link href="https://2293736867.github.io/post/java-tong-guo-serversocket-yu-socket-shi-xian-tong-xin/">
        </link>
        <updated>2020-06-02T19:24:13.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1serversocket">1.ServerSocket</a>
<ul>
<li><a href="#1">(1)</a></li>
<li><a href="#2">(2)</a></li>
<li><a href="#3">(3)</a></li>
</ul>
</li>
<li><a href="#2socket">2.Socket</a>
<ul>
<li><a href="#1-2">(1)</a></li>
<li><a href="#2-2">(2)</a></li>
<li><a href="#3-2">(3)</a></li>
<li><a href="#4">(4)</a></li>
</ul>
</li>
<li><a href="#3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">3.服务器端</a></li>
<li><a href="#4%E5%AE%A2%E6%88%B7%E7%AB%AF">4.客户端</a></li>
<li><a href="#5%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">5.运行结果</a></li>
<li><a href="#6socket%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6">6.Socket设置超时</a></li>
</ul>
<br>
首先说一下ServerSocket与Socket.</p>
<h1 id="1serversocket">1.ServerSocket</h1>
<p>ServerSocket是用来监听客户端Socket连接的类,如果没有连接会一直处于等待状态.<br>
ServetSocket有三个构造方法:</p>
<h2 id="1">(1)</h2>
<pre><code class="language-java">ServerSocket(int port);
</code></pre>
<p>这个使用指定的端口去创建ServerSocket,IP地址使用默认的本地IP地址.</p>
<h2 id="2">(2)</h2>
<pre><code class="language-java">ServetSocket(int port,int backlog);
</code></pre>
<p>除了端口外,还有一个用来改变队列长度参数的backlog,指定当服务器繁忙时,可以与之保持连接请求的客户端数量,默认为50.</p>
<h2 id="3">(3)</h2>
<pre><code class="language-java">ServetSocket(int port,int backlog,InetAddress ip);
</code></pre>
<p>这个使用指定的端口,backlog,ip地址去创建ServerSocket.</p>
<p>(这里简单提一下InetAddress,InetAddress没有构造方法,只有两个静态方法获取InetAddress对象,分别是</p>
<pre><code class="language-java">getByName(String hostName);
getByAddress(byte[] address);
</code></pre>
<p>)</p>
<h1 id="2socket">2.Socket</h1>
<p>Socket一般用来连接到服务器,程序通过Socket发出网络请求或应答网络请求.<br>
Socket有三个构造方法:</p>
<h2 id="1-2">(1)</h2>
<pre><code class="language-java">Socket(InetAddress address,int port);
</code></pre>
<p>使用指定IP与指定端口构造Socket,对于本地地址,默认使用本地ip,对于本地端口则动态分配.</p>
<h2 id="2-2">(2)</h2>
<pre><code class="language-java">Socket(String address,int port);
</code></pre>
<p>与(1)一样,使用String表示远程ip.</p>
<h2 id="3-2">(3)</h2>
<pre><code class="language-java">Socket(InetAddress address,int port,InetAddress localAddr,int localPort);
</code></pre>
<p>创建指定了远程ip,远程端口,本地ip,本地端口的Socket.</p>
<h2 id="4">(4)</h2>
<pre><code class="language-java">Socket(String address,int port,InetAddress localAddr,int localPort)
</code></pre>
<p>与(2)类似,使用String表示远程ip,用InetAddress表示本地ip.</p>
<p>了解了ServerSocket与Socket后可以编写实现简单的通信了.</p>
<h1 id="3服务器端">3.服务器端</h1>
<pre><code class="language-java">import java.io.IOException;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Server
{
    public static void main(String[] args) throws IOException
    {
        ServerSocket serverSocket = new ServerSocket(12345);//这个端口自己随意,建议1024以上未使用的端口.
        while(true)
        {
            Socket socket = serverSocket.accept();//一直等待来自客户端的请求.
            PrintStream printStream = new PrintStream(socket.getOutputStream());//创建输出流
            printStream.println(&quot;Server message.&quot;);
            printStream.close();
            socket.close();
        }
    }
}
</code></pre>
<p>说一下ServetSocket的accept()方法:</p>
<pre><code class="language-java">Socket accept();
</code></pre>
<p>没有参数,返回一个Socket,如果接收到客户端的一个Socket,则返回,否则一直处于等待状态,线程也被阻塞.</p>
<h1 id="4客户端">4.客户端</h1>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.Socket;

public class Client
{
    public static void main(String[] args) throws IOException
    {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345);
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        System.out.println(&quot;This message comes from server:&quot;+bufferedReader.readLine());
        bufferedReader.close();
        socket.close();
    }
}
</code></pre>
<pre><code class="language-java">Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345);
</code></pre>
<p>表示创建一个本地地址,端口为12345的Socket,创建好了后服务器的.accept()方法就会接收到这个Socket,并创建输出流输出相应信息,然后客户端从Socket获取输入流进行读取,读取到了来自服务器的信息.</p>
<h1 id="5运行结果">5.运行结果</h1>
<p>(由于作者的漂亮终端不知道什么原因坏了....只能让用VScode的默认终端了....)<br>
先运行服务器端的代码:<br>
<img src="https://img-blog.csdnimg.cn/20191018234828415.png" alt="在这里插入图片描述" loading="lazy"><br>
服务器端这边因为accept()方法会一直阻塞直到客户端发送请求.<br>
<img src="https://img-blog.csdnimg.cn/20191018234834135.png" alt="在这里插入图片描述" loading="lazy"><br>
客户端这边一运行就收到了来自服务器端的信息.</p>
<h1 id="6socket设置超时">6.Socket设置超时</h1>
<p>可以为Socket设置超时设置,当Socket超过这个时间没有连接上时系统会认为连接失败.</p>
<pre><code class="language-java">Socket socket = new Socket(&quot;127.0.0.1&quot;,12345);
socket.setToTimeout(10000);//单位:ms,在这里是10s
</code></pre>
<p>但是未连接上之前无法创建Socket对象,并且Socket没有提供指定超时的构造方法,因此常见的做法是先创建一个无连接的Socket,再调用connect()方法连接.</p>
<pre><code class="language-java">Socket socket = new Socket();
socket.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,12345),12345);
</code></pre>
<p>connect()方法其实有两个重载方法,分别是</p>
<pre><code class="language-java">void connect(SocketAddress endpoint);
void connect(SocketAddress endpoint,int timeout);
</code></pre>
<p>对于第一个connect()官方文档没有提及超时之类的,就是直接连接.<br>
对于第二个connect,timeout指定的超时时间,单位为ms,设置为0则为无限期等待.</p>
<p>参考链接<br>
1.<a href="https://blog.csdn.net/hutaoxiaodai/article/details/48030145">socket</a></p>
]]></content>
    </entry>
</feed>