<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2020-06-02T20:52:48.513Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>我配不上你，
纵然很努力。</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每天AC系列(九):合并K个排序链表]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-jiu-he-bing-k-ge-pai-xu-lian-biao/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-jiu-he-bing-k-ge-pai-xu-lian-biao/">
        </link>
        <updated>2020-06-02T20:52:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode第23题</a>,合并k个有序的链表.<br>
<img src="https://img-blog.csdnimg.cn/20200130181741680.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-暴力法">2 暴力法</h1>
<p>直接遍历所有链表,取出所有节点的值,用数组存储,非降序排序,然后创建一个新链表用头插法依次插入节点.</p>
<pre><code class="language-java">List&lt;Integer&gt; s = new ArrayList&lt;&gt;();
for(ListNode x:lists)
{
    while(x != null)
    {
        s.add(x.val);
        x = x.next;
    }
}
s.sort((a,b) -&gt; {return a.compareTo(b);});
ListNode result = new ListNode(0);
ListNode t = result;
for(Integer x:s)
{
    t.next = new ListNode(x);
    t = t.next;
}
return result.next;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200130205630834.png" alt="在这里插入图片描述" loading="lazy"><br>
这里要注意一下,sort那里不能写成:</p>
<pre><code class="language-java">s.sort((a,b)-&gt;{return a&gt;b ? 1 : -1;});
</code></pre>
<p>没有考虑到等于的情况,所以用compareTo代替:</p>
<pre><code class="language-java">s.sort((a,b)-&gt;{return a.compareTo(b);});
</code></pre>
<h1 id="3-直接合并法">3 直接合并法</h1>
<p>每次遍历所有链表,取出首节点的值,各个比较然后得出最小值,将最小值插入新链表,然后移动最小值所在的链表的指针,直到所有链表为空.</p>
<pre><code class="language-java">ListNode result = new ListNode(0);
ListNode t = result;
int len = lists.length;
int nullNodeNums = 0;
for(boolean [] b = new boolean[len];nullNodeNums&lt;len;)
{
    int min = Integer.MAX_VALUE;
    int minIndex = -1;
    for(int index = 0;index&lt;len;++index)
    {
        ListNode x = lists[index];
        if(x == null)
        {
            if(!b[index])
            {
                b[index] = true;
                ++nullNodeNums;
            }
        }
        else if(x.val &lt; min)
        {
            min = x.val;
            minIndex = index;
        }
    }
    if(minIndex != -1)
    {
        t.next = new ListNode(min);
        t = t.next;
        lists[minIndex] = lists[minIndex].next;
    }
}
return result.next;
</code></pre>
<p>这里使用了一个布尔数组判断是否某个节点已经移动到尾部,即表示是否为空,为空的话跳过这个节点,不为空的话取其值,计算是否为最小值.得到最小值后,添加到结果节点中,并移动最小值所在链表的指针.<br>
<img src="https://img-blog.csdnimg.cn/20200131022403181.png" alt="在这里插入图片描述" loading="lazy"><br>
这个方法看起来慢得很啊.</p>
<h1 id="4-优先队列">4 优先队列</h1>
<p>优先队列是上两个方法的结合,遍历所有节点,取值并根据其值确定优先级添加到优先队列中,然后依次出队,将出队的值直接插入到新链表中.</p>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();
for(ListNode x:lists)
{
    while(x != null)
    {
        queue.add(x.val);
        x = x.next;
    }
}
ListNode s = new ListNode(0);
ListNode t = s;
while(!queue.isEmpty())
{
    t.next = new ListNode(queue.poll());
    t = t.next;
}
return s.next;
</code></pre>
<p>java的优先队列可以直接add即可,按照默认出队序列(对于整数是小的先出)使用尾插法插入到新链表中.<br>
<img src="https://img-blog.csdnimg.cn/20200131023647945.png" alt="在这里插入图片描述" loading="lazy"><br>
嗯,好像还可以的样子,但是还是不够快.</p>
<h1 id="5-两两合并法">5 两两合并法</h1>
<p>合并k个链表,相当于合并2个链表k-1次,利用递归的思想,每次合并两个链表,将合并后的链表后返回作为下一个要合并的链表继续合并.</p>
<pre><code class="language-java">public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0)
        return null;
    ListNode t = lists[0];
    for(int i=1;i&lt;lists.length;++i)
        t = merge(t, lists[i]);
    return t;
}
//public ListNode merge(ListNode a,ListNode b)
</code></pre>
<p>merge为直接合并两个链表的操作,不难,就不贴代码了,首先赋值t为第一个链表,然后依次合并t与剩下的n-1个链表.<br>
<img src="https://img-blog.csdnimg.cn/20200131025014753.png" alt="在这里插入图片描述" loading="lazy"><br>
好慢啊.</p>
<h1 id="6-分治法">6 分治法</h1>
<p>分治法是两两合并法的改进,两两合并每次合并两个链表,分治法每次合并一半数量的链表,总体思想是这样的:想要得到最终有序的链表,若左半部分的链表与右半部分的链表都有序,则相当于合并两个有序链表,为了得到左半部分的有序链表,需要继续对左半部分进行一半的分割,再次分成左半部分与右半部分,然后再分,直到某部分只有一个链表,然后返回,以合并两个普通有序链表的方式合并两个返回的链表.</p>
<pre><code class="language-java">public ListNode f(int start,int end)
{
    int len = end - start;
    if(len &lt;= 1)
        return lists[start];
    ListNode l = f(start,start+len/2);
    ListNode r = f(start+len/2,end);
    return merge(l, r);
}
</code></pre>
<p>代码非常简洁,一开始为判断递归的条件,区间长度小于等于1直接返回[start]的节点,然后递归合并左半部分与右半部分的节点.<br>
<img src="https://img-blog.csdnimg.cn/20200131031405559.png" alt="在这里插入图片描述" loading="lazy"><br>
一个字,舒服.<br>
真快.</p>
<h1 id="7-源码">7 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day9">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day9">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(八):括号生成]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-ba-gua-hao-sheng-cheng/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-ba-gua-hao-sheng-cheng/">
        </link>
        <updated>2020-06-02T20:52:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">LeetCode第22题</a>,根据一个整数生成所有的有效的括号组合,这个整数表示括号的对数.<br>
<img src="https://img-blog.csdnimg.cn/20200129171333358.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-暴力法">2 暴力法</h1>
<p>对于n对括号,总共2n个字符,每个字符可以为左括号或右括号,所以总共2^(2n)中组合,暴力法就是枚举各个组合,然后判断它们是否为有效的组合:</p>
<pre><code class="language-java">public void f(char c[],int pos,List&lt;String&gt; result)
{
    if(pos == c.length)
    {
        if(valid(c))
            result.add(Arrays.toString(c).replaceAll(&quot;(\\[)|(\\])| |,&quot;,&quot;&quot;));
    }
    else
    {
        c[pos] = '(';
        f(c,pos+1,result);
        c[pos] = ')';
        f(c,pos+1,result);
    }
}

public boolean valid(char [] f)
{
    int len = 0;
    for(char c:f)
    {
        if(c == '(' )
        {
            if(++len &gt; f.length/2)
                return false;
        }
        else if(len-- &lt;=0)
            return false;
    }
    return len == 0;
}
</code></pre>
<p>首先加上左括号,进入下一轮递归,同时把加括号的位置加1,然后到达2n长度后,判断是否有效,有效的话加入结果数组,然后回到上一层的递归,把当前位置的括号换成右括号,接着再次进入下一轮递归,一样直到2n长度,继续判断是否有效,这样不断递归就会枚举了所有的组合.<br>
<img src="https://img-blog.csdnimg.cn/2020013013414089.png" alt="在这里插入图片描述" loading="lazy"><br>
看来不太理想啊.</p>
<h1 id="3-深搜">3 深搜</h1>
<p>深搜的话是暴力的改进,暴力的话不管序列是什么状态都直接添加括号,而深搜的话,当序列有效时才添加括号.<br>
<strong>添加左括号的条件:当前的左括号数量小于n.</strong><br>
<strong>添加右括号的条件:当前左括号的数量小于右括号的数量.</strong></p>
<pre><code class="language-java">public void f(String c,int n,int l,int r,List&lt;String&gt; result)
{
    if(l == n &amp;&amp; r == n)
        result.add(c);
    else
    {
        if(l &lt; r)
            return ;
        if(l &lt; n)
            f(c+&quot;(&quot;,n,l+1,r,result);
        if(r &lt; n)
            f(c+&quot;)&quot;,n,l,r+1,result);
    }
}
</code></pre>
<p>c为上一次递归的结果,l,r分别表示左括号与右括号的数量,递归的结束条件是左右括号的数量均为n,继续递归的条件是左右括号的数量小于n.<br>
<img src="https://img-blog.csdnimg.cn/20200130143438111.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-动态规划">4 动态规划</h1>
<p>设f(n)表示n对括号的所有有效序列,则有<br>
<img src="https://img-blog.csdnimg.cn/20200130161054631.png" alt="在这里插入图片描述" loading="lazy"><br>
具体来说:</p>
<pre><code>f(3) = ( + f(0) + ) + f(2)
f(3) = ( + f(1) + ) + f(1)
f(3) = ( + f(2) + ) + f(0)
</code></pre>
<p>这三个都是三对括号的有效序列,因此f(3)最后的结果是这三个有效序列组成的数组.<br>
因为f(n)不一定为一个有效序列,因此返回值为一个数组,剩下的只需要遍历这个数组,把它们添加到最终结果数组中去:</p>
<pre><code class="language-java">public List&lt;String&gt; f(int n)
{
    List&lt;String&gt; s = new ArrayList&lt;&gt;();
    if(n == 0)
        s.add(&quot;&quot;);
    for(int i=0;i&lt;n;++i)
    {
        List&lt;String&gt; l = f(i);
        List&lt;String&gt; r = f(n-i-1);
        for(String ll:l)
        {
            for(String rr:r)
            {
                s.add(&quot;(&quot;+ll+&quot;)&quot;+rr);
            }
        }
    }
    return s;
}
</code></pre>
<p>若n为0,添加一个空序列然后返回,若n不为0,l表示i对括号的所有有效序列,r表示n-i-1对括号的所有有效序列,然后只需要遍历这两个序列,在两边加上左括号与右括号即可.<br>
<img src="https://img-blog.csdnimg.cn/20200130160421541.png" alt="在这里插入图片描述" loading="lazy"><br>
这个...好像没有深搜快.</p>
<h1 id="5-动规优化">5 动规优化</h1>
<p>上面的递归的动规没有保存之前计算过的结果,比如计算n=3的时候,</p>
<pre><code>f(3) = ( + f(0) + ) + f(2)
f(3) = ( + f(1) + ) + f(1)
f(3) = ( + f(2) + ) + f(0)
</code></pre>
<p>f(2):</p>
<pre><code>f(2) = ( + f(1) + ) + f(0)
f(2) = ( + f(0) + ) + f(1)
</code></pre>
<p>f(1)</p>
<pre><code>f(1) = ( + f(0) + ) + f(0)
</code></pre>
<p>只是计算f(3),计算了</p>
<pre><code>f(2):2次
f(1):2+2*2=6次
f(0):2+2*2+6*2=18次
</code></pre>
<p>当n增大时,计算的重复度会变得更大,因此可以考虑用一个数组存储之前计算的结果,需要时直接取出来即可.</p>
<pre><code class="language-java">public List&lt;String&gt; generateParenthesis(int n) 
{
    List&lt;List&lt;String&gt;&gt; s = new ArrayList&lt;&gt;();
    s.add(Arrays.asList(&quot;&quot;));
    s.add(Arrays.asList(&quot;()&quot;));
    for(int n1 = 2;n1&lt;=n;++n1)
    {
        List&lt;String&gt; t = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;n1;++i)
        {
            List&lt;String&gt; l = s.get(i);
            List&lt;String&gt; r = s.get(n1-i-1);
            for(String ll:l)
            {
                for(String rr:r)
                {
                    t.add(&quot;(&quot;+ll+&quot;)&quot;+rr);
                }
            }
        }
        s.add(t);
    }
    return s.get(n);
}
</code></pre>
<p>可以先看最后的return,因为s保存了0到n的所有结果,所以,直接get即可.<br>
然后设置一个临时的n1,表示当前要计算的n1对括号的序列,当n1增加时,表示已经完成了计算n1对括号的序列,t为结果,添加到s中去.直到n1与n相等,计算完最后一个n1后,直接返回s的最后一个序列.<br>
<img src="https://img-blog.csdnimg.cn/2020013016333722.png" alt="在这里插入图片描述" loading="lazy"><br>
嗯,快了1ms,看来优化还是有效果的.</p>
<h1 id="6-源码">6 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day8">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day8">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式匹配方括号]]></title>
        <id>https://2293736867.github.io/post/zheng-ze-biao-da-shi-pi-pei-fang-gua-hao/</id>
        <link href="https://2293736867.github.io/post/zheng-ze-biao-da-shi-pi-pei-fang-gua-hao/">
        </link>
        <updated>2020-06-02T20:51:13.000Z</updated>
        <content type="html"><![CDATA[<p>Java代码:</p>
<pre><code class="language-java">String s = &quot;[1,2,3]+[4,5,6]&quot;;
System.out.println(s.replaceAll(&quot;(\\[)&quot;,&quot;&quot;));         //匹配左方括号
System.out.println(s.replaceAll(&quot;(\\])&quot;,&quot;&quot;));         //匹配右方括号
System.out.println(s.replaceAll(&quot;(\\[)|(\\])&quot;,&quot;&quot;));   //匹配左右方括号
</code></pre>
<p>结果:<br>
<img src="https://img-blog.csdnimg.cn/20200130134515159.png" alt="在这里插入图片描述" loading="lazy"><br>
需要使用replaceAll而不是replace.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(七):合并两个有序链表]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-qi-he-bing-liang-ge-you-xu-lian-biao/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-qi-he-bing-liang-ge-you-xu-lian-biao/">
        </link>
        <updated>2020-06-02T20:50:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode第21题</a>,合并两个有序链表.<br>
<img src="https://img-blog.csdnimg.cn/20200129164140734.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-直接合并">2 直接合并</h1>
<p>因为已经有序了,类似归并排序中的合并一样,操作不难,直接上代码了.</p>
<pre><code class="language-java">ListNode t = new ListNode(0);
ListNode head = t;
while(l1 != null &amp;&amp; l2 != null)    
{
    if(l1.val &lt; l2.val)
    {
        t.next = l1;
        l1 = l1.next;
    }
    else
    {
        t.next = l2;
        l2 = l2.next;
    }
    t = t.next;
}
while(l1 != null)
{
    t.next = l1;
    l1 = l1.next;
    t = t.next;
}
while(l2 != null)
{
    t.next = l2;
    l2 = l2.next;
    t = t.next;
}
return head.next;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200129164254378.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-递归合并">3 递归合并</h1>
<p>这个可以采用递归优化,而且不用额外设置一个移动的临时结点t.首先对两个指针进行判空操作,其中一个为空的话返回另一个,然后进行递归合并,首先创建一个head结点,进行赋值后递归合并next结点,将返回值赋给head.next,最后返回head.</p>
<pre><code class="language-java">if(l1 == null) return l2;
if(l2 == null) return l1;

ListNode head = null;
if(l1.val &lt; l2.val)
{
    head = l1;
    head.next = mergeTwoLists(l1.next, l2);
}
else
{
    head = l2;
    head.next = mergeTwoLists(l1, l2.next);
}
return head;
</code></pre>
<h1 id="4-源码">4 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day7">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day7">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(六):有效的括号]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-liu-you-xiao-de-gua-hao/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-liu-you-xiao-de-gua-hao/">
        </link>
        <updated>2020-06-02T20:49:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode第20题</a>,这题比较简单,匹配括号.<br>
<img src="https://img-blog.csdnimg.cn/20200128181932985.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-栈">2 栈</h1>
<p>这是栈的典型应用,括号匹配,当然不需要直接使用栈,使用一个StringBuilder即可:</p>
<pre><code class="language-java">if(s.isEmpty())
   return true;
char a = s.charAt(0);
if (a != '(' &amp;&amp; a != '[' &amp;&amp; a != '{')
    return false;
StringBuilder t = new StringBuilder();
int len = -1;
for(char c:s.toCharArray())
{
    if(c == '(' || c == '[' || c == '{')
    {
        t.append(c);
        ++len;
    }
    else
    {
        if(len == -1)
            return false;
        char cc = t.charAt(len);
        if(
            (c == ')' &amp;&amp; cc != '(')
            ||
            (c == ']' &amp;&amp; cc != '[')
            ||
            (c == '}' &amp;&amp; cc != '{')
        )
            return false;
        t.deleteCharAt(len--);
    }
}
return len == -1;
</code></pre>
<p>首先判断是否为空,再判断第一个字符,然后进入逐个循环判断,若表示左边的括号则append,若表示右边的括号首先判断len,然后取出len处字符进行判断是否匹配,不匹配直接返回false,匹配的话则删除这个字符.最后根据len是否为-1返回最终结果.<br>
<img src="https://img-blog.csdnimg.cn/20200129005758741.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="3-优化">3 优化</h1>
<p>其实就是简化一下代码,直接开辟一个大的空间,不需要进行append与delete,只需移动栈顶指针.栈顶指针从1开始,若从0开始的话对于&quot;]&quot;这种情况会报下标越界错误,压栈就是++p,压入字符,出栈直接- - p,然后判断是否匹配即可.</p>
<pre><code class="language-java">char[] t = new char[s.length() + 1];
int p = 1;
for (char c : s.toCharArray()) 
{
    if (c == '(' || c == '[' || c == '{')
        t[p++] = c;
    else 
    {
        --p;
        if ((c == ')' &amp;&amp; t[p] != '(') || (c == ']' &amp;&amp; t[p] != '[') || (c == '}' &amp;&amp; t[p] != '{'))
            return false;
    }
}
return p == 1;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200129010905339.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-源码">4 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day6">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day6">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(五):删除链表的倒数第N个节点]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-wu-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-wu-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/">
        </link>
        <updated>2020-06-02T20:49:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode第19题</a>,删除链表倒数的第n个结点.<br>
<img src="https://img-blog.csdnimg.cn/20200128030219150.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-两趟扫描">2 两趟扫描</h1>
<p>两趟扫描的思想很简单,第一趟扫描确定长度,第二趟扫描定位到目标结点并进行删除操作.</p>
<pre><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) 
{
	if(head == null || head.next == null)
	    return null;
	ListNode head_copy = head;
	int length = 0;
	while(head != null)
	{
	    head = head.next;
	    ++length;
	}
	head = head_copy;
	ListNode before = head;
	int i = 0;
	for(;i&lt;length-n;++i)
	{
	    before = head;
	    head = head.next;
	}
	if(i == 0)
	    return head.next;
	else
	    before.next = before.next.next;
	return head_copy;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200128030433545.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-一趟扫描">3 一趟扫描</h1>
<p>当然,来刷题的话不能就这样就算了,肯定得把它弄成一趟扫描,对吧?<br>
两趟扫描的目的是获取长度再进行定位,因此,为了能一次定位,可以使用两个头指针,对于给定的n,先让第一个头指针访问n次,第二个头指针不动,当第一个头指针访问n次后,第一个头指针继续访问直到最后一个,第二个头指针与第一个头指针并行访问,这样,当第一个头指针访问到最后一个时,第二个头指针就指向倒数第N个节点.</p>
<pre><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode a = head;
    ListNode b = head;
    ListNode t = head;
    for(int i=0;i&lt;n;++i)
        a = a.next;
    if(a == null)
        return head.next;
    while(a != null)
    {
        t = b;
        a = a.next;
        b = b.next;
    }
    t.next = t.next.next;
    return head;
}
</code></pre>
<p>总的来说这个只需要一趟扫描即可,针对只有两个结点或者一个结点的要判断一下.<br>
<img src="https://img-blog.csdnimg.cn/20200129003032302.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-源码">4 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day5">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day5">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[android+spring boot 选择,上传,下载文件]]></title>
        <id>https://2293736867.github.io/post/androidspring-boot-xuan-ze-shang-chuan-xia-zai-wen-jian/</id>
        <link href="https://2293736867.github.io/post/androidspring-boot-xuan-ze-shang-chuan-xia-zai-wen-jian/">
        </link>
        <updated>2020-06-02T20:48:29.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-android">3 android</a>
<ul>
<li><a href="#31-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">3.1 准备工作</a>
<ul>
<li><a href="#311-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B">3.1.1 新建工程</a></li>
<li><a href="#312-androidmanifestxml">3.1.2 AndroidManifest.xml</a></li>
<li><a href="#313-buildgradle">3.1.3 build.gradle</a></li>
<li><a href="#314-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">3.1.4 上传文件</a></li>
<li><a href="#315-%E5%B8%83%E5%B1%80">3.1.5 布局</a></li>
</ul>
</li>
<li><a href="#32-%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6">3.2 选择文件</a>
<ul>
<li><a href="#321-%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90">3.2.1 申请权限</a></li>
<li><a href="#322-intent%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6">3.2.2 Intent选择文件</a></li>
</ul>
</li>
<li><a href="#33-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">3.3 上传文件</a></li>
<li><a href="#34-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">3.4 下载文件</a></li>
</ul>
</li>
<li><a href="#4-spring-boot">4 Spring Boot</a>
<ul>
<li><a href="#41-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">4.1 准备工作</a>
<ul>
<li><a href="#411-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B">4.1.1 新建工程</a></li>
<li><a href="#412-applicationproperties">4.1.2 application.properties</a></li>
<li><a href="#413-pomxml">4.1.3 pom.xml</a></li>
</ul>
</li>
<li><a href="#42-%E5%A4%84%E7%90%86%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">4.2 处理上传文件</a></li>
<li><a href="#43-%E5%A4%84%E7%90%86%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">4.3 处理下载文件</a></li>
</ul>
</li>
<li><a href="#5-%E6%B5%8B%E8%AF%95">5 测试</a>
<ul>
<li><a href="#51-postman%E6%B5%8B%E8%AF%95">5.1 postman测试</a>
<ul>
<li><a href="#511-%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95">5.1.1 上传测试</a></li>
<li><a href="#512-%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95">5.1.2 下载测试</a></li>
</ul>
</li>
<li><a href="#52-android%E7%AB%AF%E6%B5%8B%E8%AF%95">5.2 android端测试</a>
<ul>
<li><a href="#521-%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95">5.2.1 上传测试</a></li>
<li><a href="#522-%E4%B8%8B%E8%BD%BD%E6%B5%8B%E8%AF%95">5.2.2 下载测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">6 部署到服务器</a>
<ul>
<li><a href="#61-%E9%83%A8%E7%BD%B2">6.1 部署</a>
<ul>
<li><a href="#611-%E6%94%B9%E5%8F%98%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F">6.1.1 改变打包方式</a></li>
<li><a href="#612-%E5%8E%BB%E9%99%A4tomcat%E4%BE%9D%E8%B5%96">6.1.2 去除tomcat依赖</a></li>
<li><a href="#613-%E4%BF%AE%E6%94%B9main">6.1.3 修改Main</a></li>
<li><a href="#614-%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84">6.1.4 修改路径</a></li>
<li><a href="#615-%E8%AE%BE%E7%BD%AE%E6%89%93%E5%8C%85%E5%90%8D%E5%AD%97">6.1.5 设置打包名字</a></li>
<li><a href="#616-%E6%89%93%E5%8C%85">6.1.6 打包</a></li>
<li><a href="#617-%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">6.1.7 上传到服务器</a></li>
<li><a href="#618-%E8%BF%90%E8%A1%8C">6.1.8 运行</a></li>
</ul>
</li>
<li><a href="#62-%E6%B5%8B%E8%AF%95">6.2 测试</a>
<ul>
<li><a href="#621-postman%E6%B5%8B%E8%AF%95">6.2.1 postman测试</a></li>
<li><a href="#622-android%E7%AB%AF%E6%B5%8B%E8%AF%95">6.2.2 android端测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-%E6%9C%80%E6%9C%80%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84-%E5%9D%91">7 <s>最最最喜欢的</s> 坑</a>
<ul>
<li><a href="#71-%E6%9D%83%E9%99%90">7.1 权限</a></li>
<li><a href="#72-%E8%B7%AF%E5%BE%84">7.2 路径</a></li>
<li><a href="#73-%E6%9C%89%E5%85%B3http%E7%9A%84%E9%97%AE%E9%A2%98">7.3 有关http的问题</a>
<ul>
<li><a href="#731-okhttp%E7%9A%84stream%E5%85%B3%E9%97%AD">7.3.1 okhttp的stream关闭</a></li>
<li><a href="#732-http">7.3.2 http</a></li>
<li><a href="#733-%E7%BA%BF%E7%A8%8B">7.3.3 线程</a></li>
<li><a href="#734-avd">7.3.4 AVD</a></li>
</ul>
</li>
<li><a href="#74-ip">7.4 ip</a></li>
<li><a href="#75-%E5%88%A4%E7%A9%BA%E5%A4%84%E7%90%86">7.5 判空处理</a></li>
</ul>
</li>
<li><a href="#8-%E6%BA%90%E7%A0%81">8 源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>前端android,上传与下载文件,使用OkHttp处理请求,后端使用spring boot+MVC,处理android发送来的上传与下载请求.这个其实不难,就是特别多奇奇怪怪的坑,因此,希望看到的,不要像笔者这样踩的那么痛苦了...</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li>win10</li>
<li>Spring Boot 2.2.2 RELEASE</li>
<li>IDEA 2019.3.1</li>
<li>Android Studio 3.6RC1</li>
<li>Tomcat 9.0.30</li>
</ul>
<h1 id="3-android">3 android</h1>
<h2 id="31-准备工作">3.1 准备工作</h2>
<h3 id="311-新建工程">3.1.1 新建工程</h3>
<p>这次用一个全新的例子写博客,因此从新建工程开始:<br>
<img src="https://img-blog.csdnimg.cn/20200127143649841.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200127143753821.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="312-androidmanifestxml">3.1.2 AndroidManifest.xml</h3>
<p>加入</p>
<pre><code class="language-xml">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;application android:usesCleartextTraffic=&quot;true&quot;&gt;
</code></pre>
<p>网络权限,读写SD卡权限,当然还有允许http请求的权限.</p>
<h3 id="313-buildgradle">3.1.3 build.gradle</h3>
<p>加入</p>
<pre><code class="language-css">compileOptions {
	sourceCompatibility = 1.8
    targetCompatibility = 1.8
}
</code></pre>
<p>这个是支持JDK8的.<br>
还有这两个okhttp与conscrypt,<a href="https://github.com/square/okhttp">最新版本okhttp可以在这里查看</a>,<a href="https://github.com/google/conscrypt">最新版本conscrypt在这里</a>:</p>
<pre><code class="language-java">implementation 'com.squareup.okhttp3:okhttp:4.3.1'
implementation 'org.conscrypt:conscrypt-android:2.2.1'
</code></pre>
<h3 id="314-上传文件">3.1.4 上传文件</h3>
<p>手动上传一些文件到AVD设备,为下一步选择与上传文件做准备,先把这个窗口工具栏打开:<br>
<img src="https://img-blog.csdnimg.cn/20200127144628683.png" alt="在这里插入图片描述" loading="lazy"><br>
打开后,打开在右侧栏中的Device File Explorer:<br>
<img src="https://img-blog.csdnimg.cn/20200127144718597.png" alt="在这里插入图片描述" loading="lazy"><br>
然后选择sdcard文件夹上传文件即可,其他文件夹一般没有权限.<br>
<img src="https://img-blog.csdnimg.cn/2020012714483682.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="315-布局">3.1.5 布局</h3>
<p>添加三个button(上传/下载/选择文件),一个EditText(上传文件名与下载文件名),一个ImageView(显示下载的图片).<br>
<img src="https://img-blog.csdnimg.cn/20200127153503538.png" alt="在这里插入图片描述" loading="lazy"><br>
直接拖放改一下id.</p>
<h2 id="32-选择文件">3.2 选择文件</h2>
<h3 id="321-申请权限">3.2.1 申请权限</h3>
<p>首先申请动态读写文件权限(其实选择文件只需要读权限,因为后面的下载需要写权限所以这里就一起申请了):<br>
<img src="https://img-blog.csdnimg.cn/20200127153643669.png" alt="在这里插入图片描述" loading="lazy"><br>
使用checkSelfPermission检查权限,参数为一个Context与String,String表示相应的权限,如果有了这个权限就会返回</p>
<pre><code class="language-js">PackageManager.PERMISSION_GRANTED
</code></pre>
<p>没有就会返回</p>
<pre><code class="language-js">PackageManager.PERMISSION_DENIED
</code></pre>
<p>没有就利用requestPermissions()申请,参数为Content,String[],int,String[]表示要申请的所有权限,int是一个requestCode.</p>
<h3 id="322-intent选择文件">3.2.2 Intent选择文件</h3>
<p><img src="https://img-blog.csdnimg.cn/20200127150444157.png" alt="在这里插入图片描述" loading="lazy"><br>
新建一个Intent后,设置选择类型,然后就重写onActivityResult:<br>
<img src="https://img-blog.csdnimg.cn/20200127165315522.png" alt="在这里插入图片描述" loading="lazy"><br>
这是简化了的处理,因为选择的是图片,选择其他文件的话可以参照<a href="https://blog.csdn.net/yingtian648/article/details/79066800">这里</a>.<br>
其中path是选择的文件的路径,可能你会问:</p>
<pre><code class="language-java">String path = dir.toString().substring(0,dir.toString().indexOf(&quot;0&quot;)+2) +
	DocumentsContract.getDocumentId(uri).split(&quot;:&quot;)[1];
</code></pre>
<p>这个是怎么来的,其实是拼凑过来的,因为这是图片,是这个的简化版:<br>
<img src="https://img-blog.csdnimg.cn/20200127164352187.png" alt="在这里插入图片描述" loading="lazy"><br>
(<a href="https://blog.csdn.net/yingtian648/article/details/79066800">博客在这里</a>)</p>
<h2 id="33-上传文件">3.3 上传文件</h2>
<p><img src="https://img-blog.csdnimg.cn/20200128161254596.png" alt="在这里插入图片描述" loading="lazy"><br>
参数为文件路径与文件名,然后使用OkHttpClient,因为是文件,用的body是MultipartBody,增加一个叫file的FormDataPart与一个叫filename的FormDataPart.然后使用execute()发送请求,body()获取响应内容,这里假设了后端响应一个布尔,表示上传成功或失败,url的话使用了本地的路径,注意不能是localhost,使用内网ip,然后还要与后端对应.</p>
<h2 id="34-下载文件">3.4 下载文件</h2>
<p><img src="https://img-blog.csdnimg.cn/20200128161427455.png" alt="在这里插入图片描述" loading="lazy"><br>
参数为一个文件名,根据这个文件名返回对应的文件,返回一个File,这里请求体可以选择FormBody或MultipartBody,因为这是一个文件名参数,这里笔者为了统一就选择了MultipartBody,使用FormBody的话,只需要将RequestBody的那一行改为:</p>
<pre><code class="language-java">RequestBody body = new FormBody.Builder().add(&quot;filename&quot;,filename).build();
</code></pre>
<p>有了请求体后发送请求获取响应体,进而获取输入流,然后首先需要判断是否为空,但不能直接这样判断:</p>
<pre><code class="language-java">inputStream == null
</code></pre>
<p>因为后端是这样的:<br>
<img src="https://img-blog.csdnimg.cn/20200128161951334.png" alt="在这里插入图片描述" loading="lazy"><br>
从响应体获取的inputStream肯定不为null,需要先进行一次读取(也就是判断里面的文件是否为null),若为null的话删除这个文件,不为null的话继续读取并写入文件.</p>
<h1 id="4-spring-boot">4 Spring Boot</h1>
<h2 id="41-准备工作">4.1 准备工作</h2>
<p>用的是IDEA,其他IDE请自行搜索如何新建一个SpringBoot工程.</p>
<h3 id="411-新建工程">4.1.1 新建工程</h3>
<p><img src="https://img-blog.csdnimg.cn/20200127172340171.png" alt="在这里插入图片描述" loading="lazy"><br>
打包的话可以jar或war,不用部署的话jar即可,要部署的话后期也可以改成war.<br>
<img src="https://img-blog.csdnimg.cn/20200127172434434.png" alt="在这里插入图片描述" loading="lazy"><br>
两个,一个Spring Web,用于MVC等,一个模板引擎,用于显示视图,如果不需要显示可以不选.<br>
<img src="https://img-blog.csdnimg.cn/20200127172855499.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="412-applicationproperties">4.1.2 application.properties</h3>
<p>作为一个示例demo,属性就直接在application.properties中配置了,实际情况请在相应的配置文件中配置相应属性.<br>
<img src="https://img-blog.csdnimg.cn/20200128032048667.png" alt="在这里插入图片描述" loading="lazy"><br>
需要配置上传文件的大小限制与上传文件夹的路径.</p>
<h3 id="413-pomxml">4.1.3 pom.xml</h3>
<p>这里其实不需要干什么,只是如果下载依赖慢的话,可以这样设置settings.xml文件,在&lt;mirrors&gt;中加上:</p>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;alimaven&lt;/id&gt;
    &lt;name&gt;aliyun maven&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;

&lt;mirror&gt;
    &lt;id&gt;uk&lt;/id&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;
    &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt;
&lt;/mirror&gt;

&lt;mirror&gt;
    &lt;id&gt;CN&lt;/id&gt;
    &lt;name&gt;OSChina Central&lt;/name&gt;
    &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;

&lt;mirror&gt;
    &lt;id&gt;nexus&lt;/id&gt;
    &lt;name&gt;internal nexus repository&lt;/name&gt;
    &lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;
    &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;

</code></pre>
<p>windows用户的话这个文件在</p>
<pre><code class="language-bash">C:\Users\{username}\.m2\settings.xml
</code></pre>
<p>linux的话在</p>
<pre><code class="language-bash">~/.m2/settings.xml
</code></pre>
<h2 id="42-处理上传文件">4.2 处理上传文件</h2>
<p><img src="https://img-blog.csdnimg.cn/20200128162502371.png" alt="在这里插入图片描述" loading="lazy"><br>
首先对应的post映射路径为/upload,与android端的路径对应,然后需要一个表示文件的MultipartFile与一个表示文件名的String,判断这两个是否为空后,如果上传的文件夹不存在则先创建,存在的话直接进行复制,然后根据复制成功或失败返回布尔值.复制使用了Files.copy(),第一个InputStream为上传文件的输入流,第二个Path为存储文件的路径,resolve(filename)相当于在上传目录下的filename文件.输出的话建议使用日志代替.</p>
<h2 id="43-处理下载文件">4.3 处理下载文件</h2>
<p>下载的话可以选择使用get或post请求,这里选择了post请求,因为android端是post请求,需要对应.get请求的话可以从浏览器发起.<br>
<img src="https://img-blog.csdnimg.cn/2020012803350758.png" alt="在这里插入图片描述" loading="lazy"><br>
首先根据文件名获取对应文件,判断文件是否存在后返回一个ResponseEntity,需要设定content-type与body,content-type根据需要设置即可,这里是图片,默认.jpg或.png,body的话使用FileSystemResource,直接new一个放进body即可.<br>
如果不存在相应的文件则返回null,这里需要注意一下前端的判断,不能直接判断ResponseBody是否为null.</p>
<h1 id="5-测试">5 测试</h1>
<h2 id="51-postman测试">5.1 postman测试</h2>
<p>postman只能测试与后端的连接,上传等是否有问题,可以用来定位后端的问题.</p>
<h3 id="511-上传测试">5.1.1 上传测试</h3>
<p>再Headers中设置了Content-Type为multipart/form-data后:<br>
<img src="https://img-blog.csdnimg.cn/20200128041048644.png" alt="在这里插入图片描述" loading="lazy"><br>
在body添加一个叫file的文件与一个叫filename的字符串表示文件名:<br>
<img src="https://img-blog.csdnimg.cn/20200128041026926.png" alt="在这里插入图片描述" loading="lazy"><br>
发送,返回true.<br>
<img src="https://img-blog.csdnimg.cn/2020012804134376.png" alt="在这里插入图片描述" loading="lazy"><br>
服务器端有输出提示:<br>
<img src="https://img-blog.csdnimg.cn/20200128041409533.png" alt="在这里插入图片描述" loading="lazy"><br>
查看文件夹:<br>
<img src="https://img-blog.csdnimg.cn/20200128041427428.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="512-下载测试">5.1.2 下载测试</h3>
<p>把file参数关掉,保留filename,修改路径.<br>
<img src="https://img-blog.csdnimg.cn/20200128041539668.png" alt="在这里插入图片描述" loading="lazy"><br>
然后发送,postman可以直接显示图片:<br>
<img src="https://img-blog.csdnimg.cn/20200128041741395.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="52-android端测试">5.2 android端测试</h2>
<h3 id="521-上传测试">5.2.1 上传测试</h3>
<p><img src="https://img-blog.csdnimg.cn/20200128155806544.gif" alt="在这里插入图片描述" loading="lazy"><br>
后端提示:<br>
<img src="https://img-blog.csdnimg.cn/20200128155753985.png" alt="在这里插入图片描述" loading="lazy"><br>
查看文件夹:<br>
<img src="https://img-blog.csdnimg.cn/20200128155829103.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="522-下载测试">5.2.2 下载测试</h3>
<p>输入文件名后直接下载:<br>
<img src="https://img-blog.csdnimg.cn/20200128155933425.gif" alt="在这里插入图片描述" loading="lazy"><br>
默认的话是放在这里,按需要更改位置即可,注意加上写权限:<br>
<img src="https://img-blog.csdnimg.cn/20200128161027921.png" alt="在这里插入图片描述" loading="lazy"><br>
若看不到文件选择synchronize即可.<br>
<img src="https://img-blog.csdnimg.cn/20200128153926242.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="6-部署到服务器">6 部署到服务器</h1>
<p>服务器用的是tomcat,需要修改一些Spring Boot的部分.</p>
<h2 id="61-部署">6.1 部署</h2>
<h3 id="611-改变打包方式">6.1.1 改变打包方式</h3>
<p>pom.xml中jar改成war.<br>
<img src="https://img-blog.csdnimg.cn/20200128164613506.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="612-去除tomcat依赖">6.1.2 去除tomcat依赖</h3>
<p>pom.xml加入:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="613-修改main">6.1.3 修改Main</h3>
<p>修改Main类,让其继承SpringBootServletInitializer,重载configure(),同时main()保持不变.<br>
修改前:<br>
<img src="https://img-blog.csdnimg.cn/20200128165014319.png" alt="在这里插入图片描述" loading="lazy"><br>
修改后:<br>
<img src="https://img-blog.csdnimg.cn/20200128164908318.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="614-修改路径">6.1.4 修改路径</h3>
<p>这个按需要修改即可,在这里不需要,注意就是@PostMapping,@GetMapping等都是相对于</p>
<pre><code class="language-bash">tomcat/webapps/项目/
</code></pre>
<p>目录下的.</p>
<h3 id="615-设置打包名字">6.1.5 设置打包名字</h3>
<p>build加上&lt;finalName&gt;.<br>
<img src="https://img-blog.csdnimg.cn/20200128165243261.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="616-打包">6.1.6 打包</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2020012816533874.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="617-上传到服务器">6.1.7 上传到服务器</h3>
<p>打包后的文件放在target下,使用scp上传即可,这里是本地的tomcat,就这接移动war了.</p>
<h3 id="618-运行">6.1.8 运行</h3>
<p>开启tomcat,双击startup.bat即可.<br>
<img src="https://img-blog.csdnimg.cn/20200128165527920.png" alt="在这里插入图片描述" loading="lazy"><br>
linux的话:</p>
<pre><code class="language-bash">cd xxxx/tomcat/bin
./startup.sh
</code></pre>
<h2 id="62-测试">6.2 测试</h2>
<p>在测试前需要确保没有占用相应端口,默认8080,也就是说,如果不改端口的话,需要关闭IDEA运行中的SpringBoot应用.</p>
<h3 id="621-postman测试">6.2.1 postman测试</h3>
<p>上传测试,注意需要改路径,加上打包项目名,ip的话可以使用localhost或者内网ip.<br>
<img src="https://img-blog.csdnimg.cn/20200128170329136.gif" alt="在这里插入图片描述" loading="lazy"><br>
服务器这边收到了,因为上传路径只是直接写名字,因此会与startup.bat同一路径.<br>
<img src="https://img-blog.csdnimg.cn/20200128170016425.png" alt="在这里插入图片描述" loading="lazy"><br>
下载测试:<br>
<img src="https://img-blog.csdnimg.cn/202001281706212.gif" alt="在这里插入图片描述" loading="lazy"><br>
服务器的输出:<br>
<img src="https://img-blog.csdnimg.cn/2020012817092774.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="622-android端测试">6.2.2 android端测试</h3>
<p>android端需要修改路径即可,加上war打包的名字.<br>
<img src="https://img-blog.csdnimg.cn/2020012817072767.png" alt="在这里插入图片描述" loading="lazy"><br>
这里打包的名字是kr,直接加上即可.<br>
<img src="https://img-blog.csdnimg.cn/20200128170759231.png" alt="在这里插入图片描述" loading="lazy"><br>
上传那里也是要加上,然后:<br>
<img src="https://img-blog.csdnimg.cn/20200128172216981.gif" alt="在这里插入图片描述" loading="lazy"><br>
服务器的输出:<br>
<img src="https://img-blog.csdnimg.cn/20200128172200484.png" alt="在这里插入图片描述" loading="lazy"><br>
查看文件:<br>
<img src="https://img-blog.csdnimg.cn/20200128172253701.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="7-最最最喜欢的-坑">7 <s>最最最喜欢的</s> 坑</h1>
<h2 id="71-权限">7.1 权限</h2>
<p>android需要读权限才能读取文件并上传,需要写权限才能保存从服务器返回的文件,在AndroidManifest.xml中加入:</p>
<pre><code class="language-xml">&lt;manifest&gt;...
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;application&gt;...&lt;/application&gt;
</code></pre>
<p>这是外部设备的读写权限.当然,加入这个还不能访问,因为,android6.0以后还需要动态申请权限,所以:</p>
<pre><code class="language-java">String [] permission = new String[]{
	&quot;android.permission.READ_EXTERNAL_STORAGE&quot;,
	&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;
};
if(
	ActivityCompat.checkSelfPermission(this,permission[0]) != PackageManager.PERMISSION_GRANTED
	||
	ActivityCompat.checkSelfPermission(this,permission[1]) != PackageManager.PERMISSION_DENIED
)
{
    ActivityCompat.requestPermissions(this,permission,1);
}
</code></pre>
<h2 id="72-路径">7.2 路径</h2>
<p>需要保证下面几个路径正确,还有可读,可写等:</p>
<ul>
<li>url路径不能错.</li>
<li>前端上传文件的路径.</li>
<li>后端接收前端上传文件的路径.</li>
<li>后端发送前端需要下载的文件的路径.</li>
<li>前端接收下载文件的路径.</li>
</ul>
<h2 id="73-有关http的问题">7.3 有关http的问题</h2>
<h3 id="731-okhttp的stream关闭">7.3.1 okhttp的stream关闭</h3>
<p><img src="https://img-blog.csdnimg.cn/20200128163649815.png" alt="在这里插入图片描述" loading="lazy"><br>
若前端是这样写的,在工具类中返回了之后Response已经关闭,因此需要读取输入流之类的需要先读取再返回,而不是返回一个ResponseBody或InputStream进行读取,否则会提示&quot;closed&quot;.</p>
<h3 id="732-http">7.3.2 http</h3>
<p>Android P开始默认禁用http,因此可以使用https或者在AndroidManifest.xml中允许http连接:</p>
<pre><code class="language-xml">&lt;application android:usesCleartextTraffic=&quot;true&quot;&gt;
</code></pre>
<h3 id="733-线程">7.3.3 线程</h3>
<p>网络请求不能在主线程中,新开一个线程即可.</p>
<h3 id="734-avd">7.3.4 AVD</h3>
<p>若检查过了服务器与android端没问题,那么有可能是AVD的问题,解决方法很简单,卸载,重启AVD,注意一定要卸载再重启.</p>
<h2 id="74-ip">7.4 ip</h2>
<p>在本地测试的话后端可以直接localhost,在android端不能直接localhost,可以使用ipconfig或ifconfig查看内网ip,输入内网ip即可.<br>
<img src="https://img-blog.csdnimg.cn/20200128150557717.png" alt="在这里插入图片描述" loading="lazy"><br>
若在服务器上测试直接使用服务器ip.</p>
<h2 id="75-判空处理">7.5 判空处理</h2>
<p>对于前端,应该判断存储路径是否为空,是否为null等,再传给后端,对于后端,要判断文件是否存在等,不存在就返回null,这时又需要前端进行判断返回的null,在下载文件时,虽然对不存在的文件后端返回null,但是,前端收到的是一个InputStream,不能直接判断是否为null,需要先读取一次,再进行剩下的读取:<br>
<img src="https://img-blog.csdnimg.cn/20200128155640346.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="8-源码">8 源码</h1>
<p><a href="https://github.com/2293736867/Android-SpringBoot-Upload-Download-file">github</a></p>
<p><a href="https://gitee.com/imykr/Android-SpringBoot-Upload-Download-file">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(四):四数之和]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-si-si-shu-zhi-he/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-si-si-shu-zhi-he/">
        </link>
        <updated>2020-06-02T20:47:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/4sum/">Leetcode第18题</a>,给定一个数组与一个target,找出数组中的四个数之和为target的不重复的所有四个数.<br>
<img src="https://img-blog.csdnimg.cn/20200126100609278.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-暴力">2 暴力</h1>
<pre><code class="language-java">List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
if (nums.length == 4 &amp;&amp; nums[0] + nums[1] + nums[2] + nums[3] == target)
    result.add(Arrays.asList(nums[0], nums[1], nums[2],nums[3]));
else if (nums.length &gt; 4) 
{
    Arrays.sort(nums);
    Set&lt;List&lt;Integer&gt;&gt; resultSet = new HashSet&lt;&gt;();
    for(int i=0;i&lt;nums.length-3;++i)
    {
        for(int j=i+1;j&lt;nums.length-2;++j)
        {
            for(int k=j+1;k&lt;nums.length-1;++k)
            {
                for(int m=k+1;m&lt;nums.length;++m)
                {
                    if(nums[i]+nums[j]+nums[k]+nums[m] == target)
                        resultSet.add(Arrays.asList(nums[i],nums[j],nums[k],nums[m]));
                }
            }
        }
    }
    result.addAll(resultSet);
    Collections.sort(result,(t1,t2)-&gt;
    {
        if(t1.get(0) &gt; t2.get(0))
            return 1;
        if (t1.get(0) &lt; t2.get(0))
            return -1;
        if (t1.get(1) &gt; t2.get(1))
            return 1;
        if (t1.get(1) &lt; t2.get(1))
            return -1;
        if (t1.get(2) &gt; t2.get(2))
            return 1;
        if (t1.get(2) &lt; t2.get(2))
            return -1;
        if (t1.get(3) &gt; t2.get(3))
            return 1;
        if (t1.get(3) &lt; t2.get(3))
            return -1;
        return 0;
    });
}
return result;
</code></pre>
<p>判断长度,然后排序,直接上四个for,然后...<br>
<img src="https://img-blog.csdnimg.cn/20200126100444693.png" alt="在这里插入图片描述" loading="lazy"><br>
好! 惨败.</p>
<h1 id="3-优化">3 优化</h1>
<h2 id="31-去掉结果排序">3.1 去掉结果排序</h2>
<p>首先最后的排序是不必要的,也就是后面的</p>
<pre><code class="language-java">Collections.sort(result,(t1,t2)-&gt;
{
    if(t1.get(0) &gt; t2.get(0))
        return 1;
    if (t1.get(0) &lt; t2.get(0))
        return -1;
    if (t1.get(1) &gt; t2.get(1))
        return 1;
    if (t1.get(1) &lt; t2.get(1))
        return -1;
    if (t1.get(2) &gt; t2.get(2))
        return 1;
    if (t1.get(2) &lt; t2.get(2))
        return -1;
    if (t1.get(3) &gt; t2.get(3))
        return 1;
    if (t1.get(3) &lt; t2.get(3))
        return -1;
    return 0;
});
</code></pre>
<p>对结果进行排序不必要,虽然会在测试时与答案有差别,但是提交的话不需要排序.</p>
<h2 id="32-stream去重">3.2 stream去重</h2>
<p>之前的操作用的是HashSet进行去重,有一个符合的四元组就直接添加进集合中,现在采用了stream+distinct去重:</p>
<pre><code class="language-java">return result.stream().distinct().collect(Collectors.toList());
</code></pre>
<h2 id="33-双指针最大最小剪枝">3.3 双指针+最大最小剪枝</h2>
<p>可以利用类似三数之和的思想,固定一个数,双指针分别指向两端的两个数,这里的话,四个数,选择固定两个数,计算它们的和并把它们看作一个数,即可利用双指针.</p>
<pre><code class="language-java">for(int i=0;i&lt;nums.length-3;++i)
{
     for(int j=i+1;j&lt;nums.length-2;++j)
     {
         int m = nums[i] + nums[j];
         int left = j+1;
         int right = nums.length-1;
         while(left &lt; right)
         {
             int temp = m + nums[left] + nums[right];
             if(temp == target)
             {
                 result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                 --right;
                 ++left;
             }
             else if(temp &gt; target)
                 --right;
             else
                 ++left;
         }
     }
 }
</code></pre>
<p>m为固定的数,left与right就是双指针,根据&quot;三数&quot;之和判断与目标值的大小移动双指针.<br>
最小剪枝就是首先计算&quot;三数&quot;的最小值,若大于目标值就可以跳过,最大剪枝就是计算&quot;三数&quot;的最大值,若小于目标值则跳过,进入下一个循环:</p>
<pre><code class="language-java">int m = nums[i] + nums[j];
int left = j+1;
int right = nums.length-1;
if(m + nums[left] + nums[left+1] &gt; target)
    continue;
if (m + nums[right-1] + nums[right] &lt; target)
    continue;
</code></pre>
<h2 id="34-提交">3.4 提交</h2>
<p><img src="https://img-blog.csdnimg.cn/20200126104700810.png" alt="在这里插入图片描述" loading="lazy"><br>
呃...好了那么一点点吧.</p>
<h1 id="4-来来来再快一点">4 来来来再快一点</h1>
<h2 id="41-初始判断">4.1 初始判断</h2>
<p>首先,初始的判断可以再简单一点,如果数组为空或长度小于4,直接返回.</p>
<pre><code class="language-java">List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
if (nums == null &amp;&amp; nums.length &lt; 4)
	return result;
</code></pre>
<h2 id="42-一次不够就再剪几次">4.2 一次不够,就再剪几次</h2>
<p>上面的算法中,只是在两层for里面进行了一次最大最小剪枝,可以在没进入for之前剪一次:</p>
<pre><code class="language-java">Arrays.sort(nums);
int len = nums.length;
if(
	nums[0] + nums[1] + nums[2] + nums[3] &gt;  target 
	|| 
	nums[len-4] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target
)
    return result;
for(int i=0;i&lt;len-3;++i)   
</code></pre>
<p>注意要先排序,然后直接判断整个数组的最大最小值并与target判断.<br>
然后在进入第一层for之后再剪一次:</p>
<pre><code class="language-java">for(int i=0;i&lt;len-3;++i)
{
	if(nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target)
		break;
    if(nums[i] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target)
		continue;
    for(int j=i+1;j&lt;len-2;++j)
}
</code></pre>
<p>因为数组是升序排序的,因此,&quot;最左边&quot;四个数肯定是最小值,若这个最小值大于target,可以直接break了,但是,最右边三个数与nums[i]相加不一定为最大值,因此判断之后若小于target只能continue.</p>
<h2 id="43-去重">4.3 去重</h2>
<h3 id="431-双指针去重">4.3.1 双指针去重</h3>
<p>首先,在双指针的循环中,若发现了有四个数符合条件,可以尝试多次移动指针:</p>
<pre><code class="language-java">result.add(Arrays.asList(nums[i], nums[j], nums[left++], nums[right--]));
while(left &lt; right &amp;&amp; nums[left] == nums[left-1])
    ++left;
while(left &lt; right &amp;&amp; nums[right] == nums[right+1]) 
    --right;
</code></pre>
<p>因为值一样的可以一次性移动指针,不需要再次进行和的判断.<br>
呃,可以尝试提交了.<br>
<img src="https://img-blog.csdnimg.cn/20200126112957623.png" alt="在这里插入图片描述" loading="lazy"><br>
咦,不对啊,做了这么多,没快多少啊...<br>
为啥呢...<br>
...</p>
<h3 id="432-外循环去重">4.3.2 外循环去重</h3>
<p>找了很久,发现是这里的原因:</p>
<pre><code class="language-java">return result.stream().distinct().collect(Collectors.toList());
</code></pre>
<p>这里去重的话,用是用的很舒服,一个stream(),一个distinct()就好了,问题是...还是很慢啊!!!<br>
所以呢,需要手动去重,出现重复的原因就是数组中有重复的数,比如:</p>
<pre><code class="language-java">[1,1,1,1,2,2,2,2],target=6
</code></pre>
<p>顺序判断时,会好几个</p>
<pre><code class="language-java">[1,1,2,2]
</code></pre>
<p>因此,对于重复的数,进行跳过处理,在第一层for中,对重复过的进行跳过:</p>
<pre><code class="language-java">for(int i=0;i&lt;len-2;++i)
	if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue;
</code></pre>
<p>其次,在第二层for中,也对重复过的进行跳过:</p>
<pre><code class="language-java">for(int j=i+1;j&lt;len-2;++j)
	if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) continue;
</code></pre>
<p>这样的话,例如对于上面的(不同的1用字母区分)</p>
<pre><code class="language-java">[1(a),1(b),1(c),1(d),2,2,2,2]
</code></pre>
<p>一开始是a处的1与b处的1,然后到了第二层循环,因为此时j=i+1,指向b处的1,因此不会跳过1,会进入双指针循环,第二次j指向c处的1,出现重复,j不断跳过直到j指向2.然后2结束后,到了i这层循环,因为1出现过,i不断跳过直到i指向2.</p>
<p>没错,说了这么多,去重不需要什么HashSet,不需要什么stream,只需两行:</p>
<pre><code class="language-java">if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue;
if(j&gt;i + 1 &amp;&amp; nums[j] == nums[j-1]) continue;
</code></pre>
<h2 id="44-提交">4.4 提交</h2>
<p><img src="https://img-blog.csdnimg.cn/20200126125547527.png" alt="在这里插入图片描述" loading="lazy"><br>
尽力了.</p>
<h1 id="5-源码">5 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day4">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day4">码云</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[@Scheduled注解]]></title>
        <id>https://2293736867.github.io/post/scheduled-zhu-jie/</id>
        <link href="https://2293736867.github.io/post/scheduled-zhu-jie/">
        </link>
        <updated>2020-06-02T20:47:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-cron">2 cron</a>
<ul>
<li><a href="#21-cron%E9%80%9A%E9%85%8D%E7%AC%A6">2.1 cron通配符</a></li>
<li><a href="#22-cron%E7%A4%BA%E4%BE%8B">2.2 cron示例</a></li>
</ul>
</li>
<li><a href="#3-fixedrate">3 fixedRate</a>
<ul>
<li><a href="#31-fixedrate">3.1 fixedRate</a></li>
<li><a href="#32-fixedratestring">3.2 fixedRateString</a></li>
</ul>
</li>
<li><a href="#4-fixeddelay">4 fixedDelay</a>
<ul>
<li><a href="#41-fixeddelay">4.1 fixedDelay</a></li>
<li><a href="#42-fixeddelaystring">4.2 fixedDelayString</a></li>
</ul>
</li>
<li><a href="#5-initialdelay">5 initialDelay</a>
<ul>
<li><a href="#51-initialdelay">5.1 initialDelay</a></li>
<li><a href="#52-initialdelaystring">5.2 initialDelayString</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>@Scheduled注解是spring boot提供的用于定时任务控制的注解,主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意需要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay.</p>
<h1 id="2-cron">2 cron</h1>
<p>cron是@Scheduled的一个参数,是一个字符串,以5个空格隔开,只允许6个域(注意不是7个,7个直接会报错),分别表示秒,分,时,日,月,周.</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>允许值</th>
<th>允许通配符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒</td>
<td>0-59</td>
<td>, - * /</td>
</tr>
<tr>
<td>分</td>
<td>0-59</td>
<td>, - * /</td>
</tr>
<tr>
<td>时</td>
<td>0-23</td>
<td>, - * /</td>
</tr>
<tr>
<td>日</td>
<td>1-31</td>
<td>, - * / ? L W</td>
</tr>
<tr>
<td>月</td>
<td>1-12 或 JAN-DEC(大小写均可)</td>
<td>, - * / ?</td>
</tr>
<tr>
<td>周</td>
<td>1-7 或 SUN-SAT(大小写均可)</td>
<td>, - * / ? L #</td>
</tr>
</tbody>
</table>
<h2 id="21-cron通配符">2.1 cron通配符</h2>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>所有值.在秒字段上表示每秒执行,在月字段上表示每月执行</td>
</tr>
<tr>
<td>?</td>
<td>不指定值,不需要关系当前指定的字段的值,比如每天都执行但不需要关心周几,就可以把周的字段设为?</td>
</tr>
<tr>
<td>-</td>
<td>区间,如秒的0-2,表示0秒,1秒,2秒都会触发</td>
</tr>
<tr>
<td>,</td>
<td>多个值,比如在0秒,20秒,25秒触发,可以把秒的字段设为0,20,25</td>
</tr>
<tr>
<td>/</td>
<td>递增触发,比如秒的字段上设0/3,从第0秒开始,每隔3秒触发</td>
</tr>
<tr>
<td>L</td>
<td>最后,只允许在日字段或周字段上,在日字段上使用L表示当月最后一天,在周字段上使用3L表示该月最后一个周四</td>
</tr>
<tr>
<td>W</td>
<td>只允许用在日字段上,表示距离最近的该日的工作日.工作日指的是周一至周五</td>
</tr>
<tr>
<td>#</td>
<td>只允许在周字段上,表示每月的第几个周几,如2#3,每月的第3个周二</td>
</tr>
</tbody>
</table>
<h2 id="22-cron示例">2.2 cron示例</h2>
<pre><code class="language-java">@Scheduled(cron = &quot;0 * * * 1 SAT&quot;) //每年的1月的所有周六的所有0秒时间执行
</code></pre>
<pre><code class="language-java">@Scheduled(cron = &quot;0 0 0 1 Jan ?&quot;) //每年的1月的1日的0时0分0秒执行
</code></pre>
<p>cron支持占位符,若在配置文件中有</p>
<pre><code class="language-java">cron = 2 2 2 2 2 ?
</code></pre>
<p>则</p>
<pre><code class="language-java">@Scheduled(cron = &quot;${cron}&quot;)
</code></pre>
<p>表示每年的二月二号的两时两分两秒执行.</p>
<h1 id="3-fixedrate">3 fixedRate</h1>
<h2 id="31-fixedrate">3.1 fixedRate</h2>
<p>fixedRate表示自上一次执行时间之后多长时间执行,以ms为单位.<br>
如</p>
<pre><code class="language-java">@Scheduled(fixedRate = 1000 * 5)
</code></pre>
<p>自上次执行之后5秒再执行.</p>
<h2 id="32-fixedratestring">3.2 fixedRateString</h2>
<p>有一个类似的参数叫fixedRateString,是字符串的形式,支持占位符.<br>
如</p>
<pre><code class="language-java">@Scheduled(fixedRateString = &quot;1000&quot;)
</code></pre>
<p>自上次执行1秒再执行.<br>
若在配置文件中有相应的属性,可以用占位符获取属性,如在application.properties中有</p>
<pre><code class="language-xml">interval=2000
</code></pre>
<p>可以使用</p>
<pre><code class="language-java">@Scheduled(fixedRateStirng=&quot;${interval}&quot;)
</code></pre>
<p>表示2秒间隔.</p>
<h1 id="4-fixeddelay">4 fixedDelay</h1>
<h2 id="41-fixeddelay">4.1 fixedDelay</h2>
<p>fixedDelay与fixedRate有点类似,不过fixedRate是上一次开始之后计时,fixedDelay是上一次结束之后计时,也就是说,fixedDelay表示上一次执行完毕之后多长时间执行,单位也是ms.</p>
<pre><code class="language-java">@Scheduled(fixedDelay = 1000 * 3600 * 12) //上一次执行完毕后半天后再次执行
</code></pre>
<h2 id="42-fixeddelaystring">4.2 fixedDelayString</h2>
<p>与fixedRateString类似,也是支持占位符</p>
<pre><code class="language-java">@Scheduled(fixedDelayString = &quot;${fixedDelay}&quot;)
</code></pre>
<h1 id="5-initialdelay">5 initialDelay</h1>
<h2 id="51-initialdelay">5.1 initialDelay</h2>
<p>initialDelay表示首次延迟多长时间后执行,单位ms,之后按照cron/fixedRate/fixedRateString/fixedDelay/fixedDelayString指定的规则执行,需要指定其中一个规则.</p>
<pre><code class="language-java">@Scheduled(initialDelay=1000,fixedRate=1000) //首次运行延迟1s
</code></pre>
<h2 id="52-initialdelaystring">5.2 initialDelayString</h2>
<p>与initialDelay类似,不过是字符串,支持占位符.</p>
<pre><code class="language-java">@Scheduled(initialDelayString = &quot;${initialDelay}&quot;,cron = &quot;0 0 0 14 4 ?&quot;) 
//按照配置文件initialDelay指定的时间首次延迟,并于每年4月14日0时0分0秒执行
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每天AC系列(三):电话号码的字母组合]]></title>
        <id>https://2293736867.github.io/post/mei-tian-ac-xi-lie-san-dian-hua-hao-ma-de-zi-mu-zu-he/</id>
        <link href="https://2293736867.github.io/post/mei-tian-ac-xi-lie-san-dian-hua-hao-ma-de-zi-mu-zu-he/">
        </link>
        <updated>2020-06-02T20:46:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-题目">1 题目</h1>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">Leetcode第17题。</a><br>
数字2-9映射字母，给出一个包含字符串的数字，列出字母的所有组合。<br>
<img src="https://img-blog.csdnimg.cn/20200125132943630.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-递归">2 递归</h1>
<p>拿到这样的题目想到了递归实现，创建一个Map映射对应的字母，然后把它传给递归函数，同时创建一个临时变量temp，保存每一次添加字母的结果，递归的结束条件是数字串的长度为0.</p>
<pre><code class="language-java">public void one(String digits,List&lt;String&gt; result,HashMap&lt;Integer,String&gt; ss,String temp)
{
    if(digits.length() &gt; 0)
    {
        String s = ss.get((int)(digits.charAt(0))-48);
        for(int i=0;i&lt;s.length();++i)
            one(digits.substring(1),result,ss,temp+s.charAt(i));
    }
    else
        result.add(temp);
}
</code></pre>
<h1 id="3-提交">3 提交</h1>
<p>直接一次AC.</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200125133042554.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="4-优化">4 优化</h1>
<p>其实可以不需要Map的，可以直接使用一个字符串数组，因为是数字到字符串的映射，对于数字可以用下标代替。其次，为了更快的速度可以使用StringBuilder代替String.</p>
<p>还有就是用下标代替了截断digits，对于digits其实没必要使用截断，只需要一个下标表示范围即可，对于StringBuilder，因为没有像String这样的+，因此需要在使用append后对其进行删除处理。</p>
<pre><code class="language-java">public void one(String digits,int index,StringBuilder temp)
{
    if(index &lt; digits.length())
    {
        String d = s[digits.charAt(index)-'0'];
        for(int i=0;i&lt;d.length();++i)
        {
            one(digits,index+1,temp.append(d.charAt(i)));
            temp.deleteCharAt(index);
        }
    }
    else
        result.add(temp.toString());
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200125140355421.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="5-源码">5 源码</h1>
<p><a href="https://github.com/2293736867/ACEveryDay/tree/master/Day3">github</a></p>
<p><a href="https://gitee.com/imykr/ACEveryDay/tree/master/Day3">码云</a></p>
]]></content>
    </entry>
</feed>