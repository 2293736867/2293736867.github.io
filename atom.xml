<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2293736867.github.io</id>
    <title>氷泠&apos;s blog</title>
    <updated>2021-07-08T04:58:15.788Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2293736867.github.io"/>
    <link rel="self" href="https://2293736867.github.io/atom.xml"/>
    <subtitle>几百遍，重复了几百遍
重复的情绪重复的熬过想你的夜</subtitle>
    <logo>https://2293736867.github.io/images/avatar.png</logo>
    <icon>https://2293736867.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 氷泠&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[每日分享 第388期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-388-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-388-qi/">
        </link>
        <updated>2021-07-08T04:45:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>这年头有些人靠脸吃饭，而有些人，靠不要脸吃饭。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>坐睡觉来无一事，满窗晴日看蚕生。<br>
——范成大《春日田园杂兴》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>别的禅，我都不修。独你是我的禅，秀色可餐。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625719676250.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>用哈希表存储前缀和为<code>sum</code>的个数，如果当前的前缀和大于目标，直接加上<code>前缀和-目标</code>对应的哈希表的个数：</p>
<pre><code class="language-java">public class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int [] pre = new int[nums.length+1];
        pre[0] = 1;
        int sum = 0;
        int res = 0;
        for (int num:nums){
            sum += num;
            if(sum &gt;= goal){
                res += pre[sum-goal];
            }
            ++pre[sum];
        }
        return res;
    }
}
</code></pre>
<p>官方题解还有个滑动窗口解法：</p>
<pre><code class="language-java">class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int left1 = 0, left2 = 0, right = 0;
        int sum1 = 0, sum2 = 0;
        int ret = 0;
        while (right &lt; n) {
            sum1 += nums[right];
            while (left1 &lt;= right &amp;&amp; sum1 &gt; goal) {
                sum1 -= nums[left1];
                left1++;
            }
            sum2 += nums[right];
            while (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) {
                sum2 -= nums[left2];
                left2++;
            }
            ret += left2 - left1;
            right++;
        }
        return ret;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot demo系列（十四）：ShardingSphere + MyBatisPlus 分库分表 + 读写分离]]></title>
        <id>https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-si-shardingsphere-mybatisplus-fen-ku-fen-biao-du-xie-fen-chi/</id>
        <link href="https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-si-shardingsphere-mybatisplus-fen-ku-fen-biao-du-xie-fen-chi/">
        </link>
        <updated>2021-07-07T07:15:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83">2 环境</a></li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">3 数据库环境准备</a></li>
<li><a href="#4-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">4 新建项目</a></li>
<li><a href="#5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5 配置文件</a></li>
<li><a href="#6-%E5%87%86%E5%A4%87%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">6 准备测试代码</a></li>
<li><a href="#7-%E6%B5%8B%E8%AF%95">7 测试</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81">8 参考代码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>之前笔者写过两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_27525611/article/details/118218614?spm=1001.2014.3001.5501">ShardingSphere 读写分离</a></li>
<li><a href="https://blog.csdn.net/qq_27525611/article/details/118521446">ShardingSphere 分库分表</a></li>
</ul>
<p>这里将两者结合起来，实现读写分离+分库分表的功能。关于环境的配置本文将进行简化叙述，详细可以参考前两篇文章。</p>
<h1 id="2-环境">2 环境</h1>
<ul>
<li><code>MySQL 8.0.25</code>（<code>Docker</code>）</li>
<li><code>MyBatis Plus 3.4.3.1</code></li>
<li><code>MyBatis Plus Generator 3.5.0</code></li>
<li><code>Druid 1.2.6</code></li>
<li><code>ShardingSphere 4.1.1</code></li>
<li><code>Yitter 1.0.6</code>（一个雪花<code>id</code>生成器）</li>
</ul>
<h1 id="3-数据库环境准备">3 数据库环境准备</h1>
<p>由于环境准备不是本文的重点，一主一从的主从复制环境可以参考<a href="https://blog.csdn.net/qq_27525611/article/details/118218614">此处</a>搭建。</p>
<p>准备好环境，本地启动两个<code>MySQL</code>，主节点环境：</p>
<ul>
<li>名字：<code>master</code></li>
<li>端口：<code>3306</code></li>
<li>数据库：两个库（<code>test0</code>、<code>test1</code>）</li>
<li>数据表：六个表，每个库三个（<code>test0.user0</code>、<code>test0.user1</code>、<code>test0.user2</code>、<code>test1.user0</code>、<code>test1.user1</code>、<code>test1.user2</code>）</li>
</ul>
<p>从节点环境：</p>
<ul>
<li>名字：<code>slave</code></li>
<li>端口：<code>3307</code></li>
<li>数据库：两个库（<code>test0</code>、<code>test1</code>）</li>
<li>数据表：六个表，每个库三个（<code>test0.user0</code>、<code>test0.user1</code>、<code>test0.user2</code>、<code>test1.user0</code>、<code>test1.user1</code>、<code>test1.user2</code>）</li>
</ul>
<p>主库配置文件：</p>
<pre><code class="language-bash">[mysqld]
server-id=1
binlog-do-db=test0
binlog-do-db=test1
</code></pre>
<p>从库配置文件：</p>
<pre><code class="language-bash">[mysqld]
server-id=2
replicate-do-db=test0
replicate-do-db=test1
</code></pre>
<p>完整的数据库脚本和<code>MySQL</code>配置文件放在文末的源码链接中。</p>
<h1 id="4-新建项目">4 新建项目</h1>
<p>新建项目并引入如下依赖：</p>
<ul>
<li><code>Druid</code></li>
<li><code>MyBatis Plus starter</code></li>
<li><code>MyBaits Plus Generator</code></li>
<li><code>Velocity core</code></li>
<li><code>ShardingSphere</code></li>
<li><code>Yitter</code></li>
</ul>
<p><code>Maven</code>如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.5.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.realityforge.org.jetbrains.annotations&lt;/groupId&gt;
    &lt;artifactId&gt;org.jetbrains.annotations&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.yitter&lt;/groupId&gt;
    &lt;artifactId&gt;yitter-idgenerator&lt;/artifactId&gt;
    &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>如下：</p>
<pre><code class="language-bash">implementation 'com.baomidou:mybatis-plus-boot-starter:3.4.3.1'
implementation 'org.apache.velocity:velocity-engine-core:2.3'
implementation 'org.realityforge.org.jetbrains.annotations:org.jetbrains.annotations:1.7.0'
implementation 'com.alibaba:druid:1.2.6'
implementation 'org.apache.shardingsphere:sharding-jdbc-spring-boot-starter:4.1.1'
implementation 'com.github.yitter:yitter-idgenerator:1.0.6'
</code></pre>
<h1 id="5-配置文件">5 配置文件</h1>
<pre><code class="language-yml">spring:
  shardingsphere:
    datasource:
      names: master-test0,master-test1,slave-test0,slave-test1                 # 数据源节点名字
                                                                               # master-test0表示主节点的test0库，master-test1表示主节点的test1库
                                                                               # slave-test0表示从节点的test0库，slave-test1表示从节点的test1库
      master-test0:
        type: com.alibaba.druid.pool.DruidDataSource                           # 连接池
        url: jdbc:mysql://127.0.0.1:3306/test0                                 # 主节点的test0库
        username: root
        password: 123456
      master-test1:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3306/test1                                 # 主节点的test1库
        username: root
        password: 123456
      slave-test0:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3307/test0                                 # 从节点的test0库，端口3307
        username: root
        password: 123456
      slave-test1:
        type: com.alibaba.druid.pool.DruidDataSource
        url: jdbc:mysql://127.0.0.1:3307/test1                                 # 从节点的test1库，端口3307
        username: root
        password: 123456
    sharding:
      default-database-strategy:
        inline:
          sharding-column: age                                                 # 按照哪一列分库
          algorithm-expression: master-test$-&gt;{age % 2}                        # 分库规则为对年龄取模
      tables:
        user:
          actual-data-nodes: master-test$-&gt;{0..1}.user$-&gt;{0..2}                # 分表的节点，格式为 [数据源.表名]
          table-strategy:
            inline:
              sharding-column: id                                              # 按照哪一列分表
              algorithm-expression: user$-&gt;{id%3}                              # 分表规则，对id取模

      master-slave-rules:                                                      # 读写分离的规则
        master-test0:                                                          # 哪一个主节点
          master-datasource-name: master-test0                                 # 指定主节点名字
          slave-data-source-names: slave-test0                                 # 指定从节点名字
        master-test1:
          master-datasource-name: master-test1
          slave-data-source-names: slave-test1
    props:
      sql:
        show:
          true                                                                 # 打印SQL
</code></pre>
<h1 id="6-准备测试代码">6 准备测试代码</h1>
<p>使用<code>MyBatis Plus Generator</code>生成器类生成代码：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;

public class MyBatisPlusGenerator {
    public static void main(String[] args) {
        DataSourceConfig dataSourceConfig = new DataSourceConfig.Builder(&quot;jdbc:mysql://localhost:3306/test0&quot;, &quot;root&quot;, &quot;123456&quot;).build();
        String projectPath = System.getProperty(&quot;user.dir&quot;);
        StrategyConfig strategyConfig = new StrategyConfig.Builder().addInclude(&quot;user&quot;).build();
        GlobalConfig globalConfig = new GlobalConfig.Builder().outputDir(projectPath + &quot;/src/main/java&quot;).openDir(false).build();
        PackageConfig packageConfig = new PackageConfig.Builder().moduleName(&quot;user&quot;).parent(&quot;com.example.demo&quot;).serviceImpl(&quot;service&quot;).build();
        new AutoGenerator(dataSourceConfig).global(globalConfig).packageInfo(packageConfig).strategy(strategyConfig).execute();
    }
}
</code></pre>
<p>实体类加上<code>@Builder</code>，同时设置<code>id</code>类型为<code>IdType.ASSIGN_ID</code>：</p>
<pre><code class="language-java">@Builder
public class User implements Serializable {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    //...
}
</code></pre>
<p>修改<code>Controller</code>类：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class UserController {
    private final Random random = new Random();
    private final UserServiceImpl service;
    @GetMapping(&quot;/select&quot;)
    public List&lt;User&gt; select(){
        return service.list();
    }

    @GetMapping(&quot;/insert&quot;)
    public boolean insert(){
        return service.save(User.builder().age(random.nextInt(80)+20).name(&quot;test name&quot;).email(&quot;test@test.com&quot;).build());
    }
}
</code></pre>
<p>同时新增一个雪花<code>id</code>生成器类（具体配置方法可以参考<code>MyBatis Plus</code><a href="https://mybatis.plus/guide/id-generator.html">官方文档</a>）：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
import com.github.yitter.contract.IdGeneratorOptions;
import com.github.yitter.idgen.YitIdHelper;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class IdGenerator implements IdentifierGenerator {
    final IdGeneratorOptions options = new IdGeneratorOptions((short) 1);

    @PostConstruct
    public void init() {
        YitIdHelper.setIdGenerator(options);
    }

    @Override
    public Long nextId(Object entity) {
        return YitIdHelper.nextId();
    }
}
</code></pre>
<h1 id="7-测试">7 测试</h1>
<p>刷新几次插入页面：</p>
<pre><code class="language-bash">http://localhost:8080/user/insert
</code></pre>
<p>从输出可以看到插入都是在主节点中进行的：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210707004418800.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>而查询的时候：</p>
<pre><code class="language-bash">http://localhost:8080/user/select
</code></pre>
<p>输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210707004509588.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>是在从节点查询的。</p>
<h1 id="8-参考代码">8 参考代码</h1>
<p><code>Java</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoJava/-/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">CODE CHINA</a></li>
</ul>
<p><code>Kotlin</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoKotlin/-/tree/main/ShardingSphereMyBatisPlusDataShardingAndReadWriteSplitting">CODE CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第387期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-387-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-387-qi/">
        </link>
        <updated>2021-07-07T02:53:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>脱发怎么办？要健康饮食保持良好心态，这样就能接受这个事实了。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>黄沙百战穿金甲，不破楼兰终不还。<br>
——王昌龄《从军行七首·其四》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>如果有一个喜欢你的人出现，一定不要凶她哦！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625626553273.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>使用哈希表存储个数，键就是美味程度，值就是该美味程度出现的个数，重复出现的时候直接从哈希表里面<code>get</code>：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int countPairs(int[] deliciousness) {
        int n = deliciousness.length;
        int ans = 0;
        final int MOD = 1_0000_0000_0 + 7;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(n);
        for (int i = 0; i &lt; n; i++) {
            int val = deliciousness[i];
            for (int sum = 1; sum &gt; 0; sum &lt;&lt;= 1) {
                int count = map.getOrDefault(sum - val, 0);
                if (count != 0) {
                    ans = (ans + count) % MOD;
                }
            }
            map.put(val, map.getOrDefault(val,0) + 1);
        }
        return ans;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625626628192.png" alt="" loading="lazy"></figure>
<p>中规中矩的时间。</p>
<p>参考第一名优化了一下：</p>
<ul>
<li>使用数组代替<code>HashMap</code></li>
<li>利用最大值与最小值减小<code>map</code>数组需要开辟的空间（<code>int []map = new int [max - min + 1]</code>）</li>
<li>使用<code>long</code>代替<code>int</code>存储结果，减小求模的次数</li>
</ul>
<pre><code class="language-java">public class Solution {
    public int countPairs(int[] deliciousness) {
        long ans = 0;
        int max = deliciousness[0];
        int min = deliciousness[0];
        for (int v : deliciousness) {
            if (v &gt; max) {
                max = v;
            }
            if (v &lt; min) {
                min = v;
            }
        }
        int[] map = new int[max - min + 1];
        for (int v : deliciousness) {
            for (int s = 1; ; s &lt;&lt;= 1) {
                int x = s - v;
                if(x &lt; min){
                    continue;
                }
                if(x &gt; max){
                    break;
                }
                ans += map[x-min];
            }
            ++map[v-min];
        }
        return (int)(ans % 1_000_000_007L);
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625626543216.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot demo系列（十三）：ShardingSphere + MyBatisPlus 分库分表]]></title>
        <id>https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-san-shardingsphere-mybatisplus-fen-ku-fen-biao/</id>
        <link href="https://2293736867.github.io/post/spring-boot-demo-xi-lie-shi-san-shardingsphere-mybatisplus-fen-ku-fen-biao/">
        </link>
        <updated>2021-07-06T10:30:17.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a></li>
<li><a href="#2-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83">2 准备数据库环境</a>
<ul>
<li><a href="#21-%E4%B8%A4%E5%BA%93%E5%85%AD%E8%A1%A8">2.1 两库六表</a></li>
<li><a href="#22-%E5%8F%AF%E9%80%89mybatis-plus-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%A1%A8">2.2 （可选）<code>MyBatis Plus Generator</code>代码生成表</a></li>
</ul>
</li>
<li><a href="#3-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">3 新建项目</a></li>
<li><a href="#4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4 配置文件</a></li>
<li><a href="#5-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">5 测试代码生成</a></li>
<li><a href="#6-%E5%A2%9E%E5%8A%A0%E9%9B%AA%E8%8A%B1id%E7%94%9F%E6%88%90%E5%99%A8">6 增加雪花<code>id</code>生成器</a></li>
<li><a href="#7-%E6%B5%8B%E8%AF%95">7 测试</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E6%BA%90%E7%A0%81">8 参考源码</a></li>
</ul>
</p>
<h1 id="1-概述">1 概述</h1>
<p>本文主要讲述了如何使用<code>ShardingSphere</code>（其中的<code>Sharding-JDBC</code>）和<code>MyBatisPlus</code>进行分库分表，具体步骤包括：</p>
<ul>
<li>准备数据库环境</li>
<li>准备依赖</li>
<li>编写配置文件</li>
<li>测试</li>
</ul>
<h1 id="2-准备数据库环境">2 准备数据库环境</h1>
<h2 id="21-两库六表">2.1 两库六表</h2>
<p>准备好两个库：</p>
<ul>
<li><code>test0</code></li>
<li><code>test1</code></li>
</ul>
<p>在两个库中分别建立三个字段一样的表：</p>
<ul>
<li><code>user0</code></li>
<li><code>user1</code></li>
<li><code>user2</code></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210706152233931.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>字段如下：</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20210706152320541.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这样就准备了两个库以及其中的六个表了。</p>
<h2 id="22-可选mybatis-plus-generator代码生成表">2.2 （可选）<code>MyBatis Plus Generator</code>代码生成表</h2>
<p>因为<code>MyBatis Plus Generator</code>生成的<code>Controller</code>等代码默认是按照表名命名的，这样就会生成类似<code>User0</code>、<code>User0Controller</code>这样的命名，因此这里创建一个叫<code>user</code>的表，仅仅用于代码的生成，里面不会存放任何的数据：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20210706153020483.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="3-新建项目">3 新建项目</h1>
<p>新建<code>Spring Boot</code>项目并引入如下依赖：</p>
<ul>
<li><code>Druid</code></li>
<li><code>MyBatis Plus starter</code></li>
<li><code>MyBaits Plus Generator</code></li>
<li><code>Velocity core</code></li>
<li><code>ShardingSphere</code></li>
<li><code>Yitter</code>（一个雪花<code>id</code>生成器）</li>
</ul>
<p><code>Maven</code>如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.5.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.realityforge.org.jetbrains.annotations&lt;/groupId&gt;
    &lt;artifactId&gt;org.jetbrains.annotations&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;4.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.yitter&lt;/groupId&gt;
    &lt;artifactId&gt;yitter-idgenerator&lt;/artifactId&gt;
    &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>Gradle</code>如下：</p>
<pre><code class="language-bash">implementation 'com.baomidou:mybatis-plus-boot-starter:3.4.3.1'
implementation 'org.apache.velocity:velocity-engine-core:2.3'
implementation 'org.realityforge.org.jetbrains.annotations:org.jetbrains.annotations:1.7.0'
implementation 'com.alibaba:druid:1.2.6'
implementation 'org.apache.shardingsphere:sharding-jdbc-spring-boot-starter:4.1.1'
implementation 'com.github.yitter:yitter-idgenerator:1.0.6'
</code></pre>
<h1 id="4-配置文件">4 配置文件</h1>
<p>配置文件可以参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/yaml/sharding/">ShardingSphere文档</a>，这里给出一个示例配置：</p>
<pre><code class="language-yml">spring:
  shardingsphere:
    datasource:
      names: test0,test1                                        # 数据源，这里为了方便直接使用库名的名称
      test0:                                                   
        type: com.alibaba.druid.pool.DruidDataSource            # Druid连接池
        url: jdbc:mysql://127.0.0.1:3306/test0                  # 连接test0的url
        username: root
        password: 123456
      test1:
        type: com.alibaba.druid.pool.DruidDataSource            # Druid连接池
        url: jdbc:mysql://127.0.0.1:3306/test1                  # 连接test1的url
        username: root
        password: 123456
    sharding:
      default-database-strategy:                                # 默认分库策略
        inline:  
          sharding-column: age                                  # 表示根据age列进行分库
          algorithm-expression: test$-&gt;{age % 2}                # 根据age对2的模进行分库，模为0表示test0库，模为1表示test1库
      tables:
        user:
          actual-data-nodes: test$-&gt;{0..1}.user$-&gt;{0..2}        # 表的名字，test$-&gt;{0..1}可以表示test0、test1两个库
                                                                # user$-&gt;{0..2}表示user0、user1、user2三个库
          table-strategy:                                       # 分表策略
            inline:
              sharding-column: id                               # 根据哪一列进行分表，id表示根据列名为&quot;id&quot;的列分表
              algorithm-expression: user$-&gt;{id%3}               # 分表规则为id对3取模，id%3为0表示分到user0表
                                                                # id%3为1表示分到user1表，id%3为2表示分到user2表
    props:
      sql:
        show:
          true                                                  # 打印sql
</code></pre>
<p>这里使用自动取模分片策略，<code>ShardingShphere</code>内置了如下分片算法：</p>
<ul>
<li>自动分片算法：取模分片、哈希取模分片、基于分片容量的范围分片、基于分片边界的范围分片、自动时间段分片</li>
<li>标准分片算法：行表达式分片、时间范围分片</li>
<li>复合行表达式分片</li>
<li><code>Hint</code>行表达式分片</li>
</ul>
<p>如果不能满足需要还可以自定义分片算法，具体请看<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding/">官方文档</a>。</p>
<h1 id="5-测试代码生成">5 测试代码生成</h1>
<p>使用<code>MyBaits Plus Generator</code>生成相应代码，具体使用可以参考笔者之前的文章，这里直接放上生成类的代码：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;

public class MyBatisPlusGenerator {
    public static void main(String[] args) {
        DataSourceConfig dataSourceConfig = new DataSourceConfig.Builder(&quot;jdbc:mysql://localhost:3306/test0&quot;, &quot;root&quot;, &quot;123456&quot;).build();
        String projectPath = System.getProperty(&quot;user.dir&quot;);
        StrategyConfig strategyConfig = new StrategyConfig.Builder().addInclude(&quot;user&quot;).build();
        GlobalConfig globalConfig = new GlobalConfig.Builder().outputDir(projectPath + &quot;/src/main/java&quot;).openDir(false).build();
        PackageConfig packageConfig = new PackageConfig.Builder().moduleName(&quot;user&quot;).parent(&quot;com.example.demo&quot;).serviceImpl(&quot;service&quot;).build();
        new AutoGenerator(dataSourceConfig).global(globalConfig).packageInfo(packageConfig).strategy(strategyConfig).execute();
    }
}
</code></pre>
<p>把<code>UserController</code>类修改如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class UserController {
    private final Random random = new Random();
    private final UserServiceImpl service;
    @GetMapping(&quot;/select&quot;)
    public List&lt;User&gt; select(){
        return service.list();
    }

    @GetMapping(&quot;/insert&quot;)
    public boolean insert(){
        return service.save(User.builder().age(random.nextInt(80)+20).name(&quot;test name&quot;).email(&quot;test@test.com&quot;).build());
    }
}
</code></pre>
<h1 id="6-增加雪花id生成器">6 增加雪花<code>id</code>生成器</h1>
<p>首先修改<code>User</code>类，增加一个<code>@Builder</code>注解，同时修改<code>id</code>的生成策略，使用<code>IdType.ASSIGN_ID</code>：</p>
<pre><code class="language-java">@Builder
public class User implements Serializable {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    //...
}
</code></pre>
<p>新建<code>id</code>生成器类：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
import com.github.yitter.contract.IdGeneratorOptions;
import com.github.yitter.idgen.YitIdHelper;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class IdGenerator implements IdentifierGenerator {
    final IdGeneratorOptions options = new IdGeneratorOptions((short) 1);

    @PostConstruct
    public void init() {
        YitIdHelper.setIdGenerator(options);
    }

    @Override
    public Long nextId(Object entity) {
        return YitIdHelper.nextId();
    }
}
</code></pre>
<p>这样生成<code>id</code>的时候，就会自动调用<code>nextId()</code>方法，其中的<code>id</code>生成器可以根据需要进行替换，换成其他雪花<code>id</code>生成器或分布式<code>id</code>生成器。</p>
<p>配置的时候可以参考<a href="https://mybatis.plus/guide/id-generator.html">MyBaits Plus 自定义ID生成器文档</a>。</p>
<h1 id="7-测试">7 测试</h1>
<p>先随机插入三条数据，刷新三次如下页面：</p>
<pre><code class="language-bash">localhost:8080/test/user/insert
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20210706155553392.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>可以看到执行了三次插入操作，插入的三个表分别是：</p>
<ul>
<li><code>test0.user2</code></li>
<li><code>test0.user0</code></li>
<li><code>test0.user2</code></li>
</ul>
<p>因为这里测试的时候年龄都恰好是偶数，都插入到了<code>test0</code>表。</p>
<p>查看数据：</p>
<pre><code class="language-bash">http://localhost:8080/user/select
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20210706160020660.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>日志输出如下：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/2021070616012131.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>表示这是对六个表查询的结果，并将最后的结果进行聚合返回。</p>
<h1 id="8-参考源码">8 参考源码</h1>
<p><code>Java</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataSharding">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoJava/tree/main/ShardingSphereMyBatisPlusDataSharding">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoJava/-/tree/main/ShardingSphereMyBatisPlusDataSharding">CODE.CHINA</a></li>
</ul>
<p><code>Kotlin</code>版：</p>
<ul>
<li><a href="https://github.com/2293736867/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataSharding">Github</a></li>
<li><a href="https://gitee.com/u6b7b5fc3/SpringBootDemoKotlin/tree/main/ShardingSphereMyBatisPlusDataSharding">码云</a></li>
<li><a href="https://codechina.csdn.net/qq_27525611/SpringBootDemoKotlin/-/tree/main/ShardingSphereMyBatisPlusDataSharding">CODE.CHINA</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第386期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-386-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-386-qi/">
        </link>
        <updated>2021-07-06T02:54:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>唯一比孤独更可怕的，是被人知道你孤独。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>酒困路长惟欲睡，日高人渴漫思茶。<br>
——苏轼《浣溪沙·蔌蔌衣巾落枣花》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>回避现实的人，未来将更不理想。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625540146259.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接上两个<code>TreeMap</code>：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) {
        Map&lt;Integer, Map&lt;String, Integer&gt;&gt; map = new TreeMap&lt;&gt;();
        Set&lt;String&gt; foods = new TreeSet&lt;&gt;();
        int n = orders.size();
        for (int i = 0; i &lt; n; i++) {
            Integer table = Integer.parseInt(orders.get(i).get(1));
            String food = orders.get(i).get(2);
            foods.add(food);
            if (map.containsKey(table)) {
                map.get(table).put(food, map.get(table).getOrDefault(food, 0) + 1);
            }else{
                Map&lt;String,Integer&gt; temp = new TreeMap&lt;&gt;();
                temp.put(food,1);
                map.put(table,temp);
            }
        }
//        System.out.println(map);
//        System.out.println(foods);
        int foodsSize = foods.size();
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(map.size()+1);
        List&lt;String&gt; temp = new ArrayList&lt;&gt;(foodsSize+1);
        temp.add(&quot;Table&quot;);
        temp.addAll(foods);
        list.add(temp);
        for (Map.Entry&lt;Integer,Map&lt;String,Integer&gt;&gt; entry:map.entrySet()){
            temp = new ArrayList&lt;&gt;(foodsSize+1);
            temp.add(String.valueOf(entry.getKey()));
            Map&lt;String,Integer&gt; foodsMap = entry.getValue();
            for (String s:foods){
                temp.add(String.valueOf(foodsMap.getOrDefault(s,0)));
            }
            list.add(temp);
        }
        return list;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625540154308.png" alt="" loading="lazy"></figure>
<p><s>好像有点慢。</s></p>
<p>优化一点点：</p>
<ul>
<li>采用<code>HashMap</code>和<code>HashSet</code>，添加完毕再排序</li>
<li>指定初始化<code>HashMap</code>的大小，降低动态扩容的开销</li>
<li>缓存<code>table</code>的数字转字符串后的字符串</li>
</ul>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public List&lt;List&lt;String&gt;&gt; displayTable(List&lt;List&lt;String&gt;&gt; orders) {
        Map&lt;Integer, Map&lt;String, Integer&gt;&gt; map = new HashMap&lt;&gt;(512);
        Set&lt;String&gt; foods = new HashSet&lt;&gt;();
        String[] numberToString = new String[512];
        int n = orders.size();
        for (int i = 0; i &lt; n; i++) {
            String tableStr = orders.get(i).get(1);
            Integer table = Integer.parseInt(tableStr);
            numberToString[table] = tableStr;
            String food = orders.get(i).get(2);
            foods.add(food);
            if (map.containsKey(table)) {
                map.get(table).put(food, map.get(table).getOrDefault(food, 0) + 1);
            }else{
                Map&lt;String,Integer&gt; temp = new HashMap&lt;&gt;();
                temp.put(food,1);
                map.put(table,temp);
            }
        }
        int foodsSize = foods.size();
        foods = new TreeSet&lt;&gt;(foods);
        map = new TreeMap&lt;&gt;(map);
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(map.size()+1);
        List&lt;String&gt; temp = new ArrayList&lt;&gt;(foodsSize+1);
        temp.add(&quot;Table&quot;);
        temp.addAll(foods);
        list.add(temp);
        for (Map.Entry&lt;Integer,Map&lt;String,Integer&gt;&gt; entry:map.entrySet()){
            temp = new ArrayList&lt;&gt;(foodsSize+1);
            temp.add(numberToString[entry.getKey()]);
            Map&lt;String,Integer&gt; foodsMap = entry.getValue();
            for (String s:foods){
                temp.add(String.valueOf(foodsMap.getOrDefault(s,0)));
            }
            list.add(temp);
        }
        return list;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625543943000.png" alt="" loading="lazy"></figure>
<p>好像有那么一点效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第385期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-385-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-385-qi/">
        </link>
        <updated>2021-07-05T06:34:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>你努力找他说话的样子，像极了商场里的导购。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>日啖荔枝三百颗，不辞长作岭南人。<br>
——苏轼《食荔枝》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>卑屈游戏谁是先该离场的呢？</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625466878403.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>好家伙，真真正正的困难题，需要用到哈希表、栈以及字符串处理的一些方法。</p>
<p>一开始朴素的想法是，将其分块处理，比如：</p>
<pre><code class="language-bash">Mg(OH)2
</code></pre>
<p>可以分成三块：</p>
<ul>
<li><code>Mg</code></li>
<li><code>OH</code></li>
<li><code>2</code></li>
</ul>
<p>于是就写出了下面的代码：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class Solution {
    private char[] formula;
    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String,Integer&gt; map = new TreeMap&lt;&gt;(countFormula(0,formula.length()-1));
        StringBuilder builder = new StringBuilder();
        for(Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
            builder.append(entry.getKey());
            int value = entry.getValue();
            if(value != 1){
                builder.append(value);
            }
        }
        return builder.toString();
    }

    private Map&lt;String,Integer&gt; countFormula(int begin,int end){
        char [] formula = this.formula;
        int beginBracket = begin;
        while(beginBracket &lt;= end &amp;&amp; formula[beginBracket] != '('){
            ++beginBracket;
        }
        if(beginBracket &gt; end){
            return countAtom(begin,end);
        }
        int endBracket = end;
        while(endBracket &gt;= begin &amp;&amp; formula[endBracket] != ')'){
            --endBracket;
        }
        int num = Integer.parseInt(new String(formula,endBracket+1,end - endBracket));
        Map&lt;String,Integer&gt; map = countFormula(beginBracket+1,endBracket-1);
        for (Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
            entry.setValue(entry.getValue() * num);
        }
        Map&lt;String,Integer&gt; prefix = countAtom(begin,beginBracket-1);
        for (Map.Entry&lt;String,Integer&gt; entry:prefix.entrySet()){
            map.put(entry.getKey(),map.getOrDefault(entry.getKey(),0)+entry.getValue());
        }
        return map;
    }

    private Map&lt;String,Integer&gt; countAtom(int begin,int end){
        char[] formula = this.formula;
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = begin; i &lt;= end; i++) {
            if(Character.isUpperCase(formula[i])){
                int j = i;
                ++i;
                while(i &lt;= end &amp;&amp; Character.isLowerCase(formula[i])){
                    ++i;
                }
                String str = new String(formula,j,i-j);
                StringBuilder num = new StringBuilder();
                while(i &lt;= end &amp;&amp; Character.isDigit(formula[i])){
                    num.append(formula[i]);
                    ++i;
                }
                map.put(str,map.getOrDefault(str,0)+
                    (num.length() == 0 ? 1 : Integer.parseInt(num.toString())
                ));
                --i;
            }
        }
        return map;
    }
}
</code></pre>
<p>但是过不了下面的样例：</p>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625467206949.png" alt="" loading="lazy"></figure>
<p>于是又改了一下：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

public class Solution {
    private char[] formula;

    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(count(this.formula));
        StringBuilder builder = new StringBuilder();
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            builder.append(entry.getKey());
            int value = entry.getValue();
            if (value != 1) {
                builder.append(value);
            }
        }
        return builder.toString();
    }

    private Map&lt;String,Integer&gt; count(char[] formula) {
        int n = formula.length;
        Stack&lt;Map&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            int j = i;
            while (i &lt; n &amp;&amp; Character.isDigit(formula[i])){
                ++i;
            }
            if(j != i){
                int num = Integer.parseInt(new String(formula,j,i-j));
                Map&lt;String, Integer&gt; top = stack.pop();
                for (Map.Entry&lt;String, Integer&gt; entry : top.entrySet()) {
                    entry.setValue(entry.getValue() * num);
                }
                if(!stack.isEmpty()) {
                    Map&lt;String, Integer&gt; prefix = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : prefix.entrySet()) {
                        top.put(entry.getKey(), top.getOrDefault(entry.getKey(), 0) + entry.getValue());
                    }
                }
                stack.push(top);
            }
            j = i;
            while (i &lt; n &amp;&amp; formula[i] != '(' &amp;&amp; formula[i] != ')') {
                ++i;
            }
            Map&lt;String, Integer&gt; map = countAtom(j, i - 1);
//            System.out.println(&quot;map is &quot; + map);
            if(map.size() &gt; 0) {
                stack.push(map);
                if (i &lt; n &amp;&amp; formula[i] == ')') {
                    StringBuilder number = new StringBuilder();
                    ++i;
                    while (i &lt; n &amp;&amp; Character.isDigit(formula[i])) {
                        number.append(formula[i]);
                        ++i;
                    }
                    int num = (number.length() == 0 ? 1 : Integer.parseInt(number.toString()));
//                    System.out.println(&quot;num is &quot; + num);
                    Map&lt;String, Integer&gt; top = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : top.entrySet()) {
                        entry.setValue(entry.getValue() * num);
                    }
                    if(!stack.isEmpty()) {
                        Map&lt;String, Integer&gt; prefix = stack.pop();
                        for (Map.Entry&lt;String, Integer&gt; entry : prefix.entrySet()) {
                            map.put(entry.getKey(), map.getOrDefault(entry.getKey(), 0) + entry.getValue());
                        }
                    }
                    stack.push(top);
//                    System.out.println(&quot;[i] is &quot; + formula[i]);
                }
            }
        }
//        System.out.println(stack);
        return stack.pop();
    }

    private Map&lt;String, Integer&gt; countAtom(int begin, int end) {
        char[] formula = this.formula;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = begin; i &lt;= end; i++) {
            if (Character.isUpperCase(formula[i])) {
                int j = i;
                ++i;
                while (i &lt;= end &amp;&amp; Character.isLowerCase(formula[i])) {
                    ++i;
                }
                String str = new String(formula, j, i - j);
                StringBuilder num = new StringBuilder();
                while (i &lt;= end &amp;&amp; Character.isDigit(formula[i])) {
                    num.append(formula[i]);
                    ++i;
                }
                map.put(str, map.getOrDefault(str, 0) +
                        (num.length() == 0 ? 1 : Integer.parseInt(num.toString())
                        ));
                --i;
            }
        }
        return map;
    }
}
</code></pre>
<p>但是：</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625467234437.png" alt="" loading="lazy"></figure>
<p>后面重新换了一个思路，对单个原子进行处理，比如<code>Mg(OH)2</code>中的<code>OH</code>，不能直接看作一个<code>OH</code>，而是一个栈，从栈顶到栈底分别为：</p>
<ul>
<li><code>1</code></li>
<li><code>H</code></li>
<li><code>1</code></li>
<li><code>O</code></li>
</ul>
<p>这样每次遇到数字的时候就进行合并，遇到左括号直接压栈，遇到右括号就进行弹栈操作：</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

public class Solution {
    private char[] formula;
    private static final String TYPE = &quot;type&quot;;
    private static final Integer ATOM = 0;
    private static final Integer BRACKET = 1;

    public String countOfAtoms(String formula) {
        this.formula = formula.toCharArray();
        TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(count(this.formula));
        StringBuilder builder = new StringBuilder();
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
            if(!entry.getKey().equals(TYPE)) {
                builder.append(entry.getKey());
                int value = entry.getValue();
                if (value != 1) {
                    builder.append(value);
                }
            }
        }
        return builder.toString();
    }

    private Map&lt;String, Integer&gt; count(char[] formula) {
        int n = formula.length;
        Stack&lt;Map&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n; ) {
            if (Character.isUpperCase(formula[i])) {
                StringBuilder atom = new StringBuilder();
                atom.append(formula[i++]);
                while (i &lt; n &amp;&amp; Character.isLowerCase(formula[i])) {
                    atom.append(formula[i++]);
                }
                Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
                map.put(atom.toString(), 1);
                map.put(TYPE, ATOM);
                stack.push(map);
            } else if (Character.isDigit(formula[i])) {
                StringBuilder number = new StringBuilder();
                number.append(formula[i++]);
                while (i &lt; n &amp;&amp; Character.isDigit(formula[i])) {
                    number.append(formula[i++]);
                }
                int num = Integer.parseInt(number.toString());
                Map&lt;String, Integer&gt; map = stack.pop();
                for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                    if (!entry.getKey().equals(TYPE)) {
                        entry.setValue(entry.getValue() * num);
                    }
                }
                stack.push(map);
            } else if (formula[i] == '(') {
                Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
                map.put(TYPE, BRACKET);
                stack.push(map);
                ++i;
            } else {
                Map&lt;String, Integer&gt; map = stack.peek();
                Map&lt;String, Integer&gt; base = stack.pop();
                while (!map.get(TYPE).equals(BRACKET)) {
                    map = stack.pop();
                    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                        if (!entry.getKey().equals(TYPE)) {
                            base.put(entry.getKey(), base.getOrDefault(entry.getKey(), 0) + entry.getValue());
                        }
                    }
                }
                stack.push(base);
                ++i;
            }
        }
        Map&lt;String,Integer&gt; base = stack.pop();
        while(!stack.isEmpty()){
            Map&lt;String,Integer&gt; map = stack.pop();
            for (Map.Entry&lt;String,Integer&gt; entry:map.entrySet()){
                if (!entry.getKey().equals(TYPE)) {
                    base.put(entry.getKey(), base.getOrDefault(entry.getKey(), 0) + entry.getValue());
                }
            }
        }
        return base;
    }
}
</code></pre>
<p>最后经过两个小时的修改和煎熬终于<code>AC</code>了：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625467441798.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625467445201.png" alt="" loading="lazy"></figure>
<p>最后优化了几ms：</p>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1625467745085.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第384期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-384-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-384-qi/">
        </link>
        <updated>2021-07-04T01:33:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>人生最大的耻辱是什么，考试作弊了还不及格。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>纸屏石枕竹方床，手倦抛书午梦长。<br>
——蔡确《夏日登车盖亭》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>悲痛藏于心，欢喜言于表，说的不就是我们吗！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625362601439.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>直接哈希表：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        boolean[] hash = new boolean[1_0000 + 1];
        int repeated = 0;
        for (int num : nums) {
            if (hash[num]) {
                repeated = num;
            }
            hash[num] = true;
        }
        for (int i = 1; i &lt;= n; ++i) {
            if (!hash[i]) {
                return new int[]{repeated, i};
            }
        }
        return new int[]{};
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625362622318.png" alt="" loading="lazy"></figure>
<p>当然最朴素的想法就是直接计数：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int[] count = new int[n + 1];
        int[] res = new int[2];
        for (int num : nums) {
            ++count[num];
        }
        for (int i = 1; i &lt;= n; ++i) {
            if(count[i] == 2){
                res[0] = i;
            }
            if(count[i] == 0){
                res[1] = i;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625362781875.png" alt="" loading="lazy"></figure>
<p>好家伙这速度可以啊。</p>
<p>还有一种做法是使用<code>O(1)</code>空间的位运算：</p>
<pre><code class="language-java">public class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int x = 0;
        int y = 0;
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        for (int i = 1; i &lt;= n; i++) {
            xor ^= i;
        }
        xor &amp;= (-xor);
        for (int num : nums) {
            if ((num &amp; xor) == 0) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        for (int i = 1; i &lt;= n; i++) {
            if((i &amp; xor) == 0) {
                x ^= i;
            }else{
                y ^= i;
            }
        }
        for (int num:nums){
            if(num == x){
                return new int[]{x,y};
            }
        }
        return new int[]{y, x};
    }
}
</code></pre>
<p>思想就是：</p>
<ul>
<li>利用<code>xor</code>与原数组中每个数相异或</li>
<li>再利用<code>xor</code>与<code>1..n</code>相异或</li>
<li>这样<code>xor</code>就是三个重复的数与一个缺失的数字异或的结果</li>
<li>计算<code>lowbit</code>，<code>lowbit = xor ^ (-xor)</code>，使用<code>lowbit</code>得到最低位1表示的结果</li>
<li>再遍历原数组以及<code>1..n</code>组成的数组，将其中每个数与<code>lowbit</code>相与，如果为<code>0</code>，使用一个临时变量<code>x</code>与其相异或，否则使用临时变量<code>y</code>与其相异或</li>
<li>得到的<code>x</code>、<code>y</code>分别是重复的数字和丢失的数字，但具体哪个是哪个还不能确定</li>
<li>最后再次遍历原数组，如果<code>x</code>或<code>y</code>在原数组中出现过，那么它就是重复的数字，另一个就是丢失的数字</li>
<li>否则它是丢失的数字，另一个是重复的数字</li>
</ul>
<p>说了这么多，但是时间还是不怎么样，虽然空间做到了<code>O(1)</code>，但是扫太多遍了：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625363920298.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第383期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-383-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-383-qi/">
        </link>
        <updated>2021-07-03T02:41:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>遇到困难的三个步骤，面对它，处理它，放弃它。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>东边日出西边雨，道是无晴却有晴。<br>
——刘禹锡《竹枝词二首·其一》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>I'm nothing without you.</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625280248893.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>虽然写着是中等题，但是感觉是简单题，统计计数后排序然后将结果添加到结果中即可，注意包含大小写字母和数字（题目又没写。。。）：</p>
<pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public String frequencySort(String s) {
        if (s == null || s.isBlank()) {
            return s;
        }
        int n = s.length();
        char[] res = new char[n];
        Node[] nodes = new Node[62];
        for (int i = 0; i &lt; 26; i++) {
            nodes[i] = new Node((char) ('a' + i));
        }
        for (int i = 26; i &lt; 52; i++) {
            nodes[i] = new Node((char) ('A' + (i - 26)));
        }
        for (int i = 52; i &lt; 62; i++) {
            nodes[i] = new Node((char) ('0' + (i - 52)));
        }
        for (char c : s.toCharArray()) {
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
                ++nodes[c - 'a'].count;
            } else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
                ++nodes[c - 'A' + 26].count;
            } else {
                ++nodes[c - '0' + 52].count;
            }
        }

        Arrays.sort(nodes);
        int index = 0;
        for (Node node:nodes){
            int count = node.count;
            char c = node.c;
            for (int i = 0; i &lt; count; i++) {
                res[index++] = c; 
            }
        }
        return new String(res);
    }

    private static class Node implements Comparable&lt;Node&gt; {
        char c;
        int count = 0;

        public Node(char c) {
            this.c = c;
        }

        @Override
        public int compareTo(Node node) {
            return Integer.compare(node.count, count);
        }

        @Override
        public String toString() {
            return &quot;[c=&quot; + c + &quot;,count=&quot; + count + &quot;]&quot;;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625280239823.png" alt="" loading="lazy"></figure>
<p>寻思着好像没有什么优化方法，昨天的计排好像也用不上，看了题解用的居然是桶排，好家伙。</p>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625280765329.png" alt="" loading="lazy"></figure>
<p>但是最快的第一名还是用的快排：</p>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625281014724.png" alt="" loading="lazy"></figure>
<p>最后还是参考题解，配合栈用上了计排：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public String frequencySort(String s) {
        int n = s.length();
        char[] res = new char[n];
        int[] count = new int[62];
        for (char c : s.toCharArray()) {
            ++count[charToIndex(c)];
        }
        int max = 0;
        for (int c : count) {
            if (c &gt; max) {
                max = c;
            }
        }
        Stack[] stacks = new Stack[max + 1];
        for (int i = 0; i &lt; 62; ++i) {
            if (count[i] != 0) {
                int ct = count[i];
                if (stacks[ct] == null) {
                    stacks[ct] = new Stack&lt;&gt;();
                    stacks[ct].push(indexToChar(i));
                } else {
                    stacks[ct].push(indexToChar(i));
                }
            }
        }

        int index = 0;
        for (int i = max; i &gt;= 1; --i) {
            Stack stack = stacks[i];
            if (stack != null) {
                while (!stack.isEmpty()) {
                    char c = (Character) stack.pop();
                    for (int j = 0; j &lt; i; j++) {
                        res[index++] = c;
                    }
                }
            }
        }
        return new String(res);
    }

    private int charToIndex(char c) {
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
            return c - 'a';
        }
        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
            return c - 'A' + 26;
        }
        return c - '0' + 52;
    }

    private char indexToChar(int index) {
        if (index &gt;= 0 &amp;&amp; index &lt;= 25) {
            return (char) ('a' + index);
        }
        if (index &gt;= 26 &amp;&amp; index &lt;= 51) {
            return (char) ('A' + (index - 26));
        }
        return (char) ('0' + (index - 52));
    }

}
</code></pre>
<p>（<s>为什么<code>Java</code>不支持泛型数组</s>）</p>
<p>但还是一样的时间：</p>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625285002545.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第382期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-382-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-382-qi/">
        </link>
        <updated>2021-07-02T04:10:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>好好过日子吧，每天都会有新打击。</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>接天莲叶无穷碧，映日荷花别样红。<br>
——杨万里《晓出净慈寺送林子方》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>没有一个世界会比活在这个世界痛苦。</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625199129271.jpg" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<p>一开始直接上贪心：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625199695745.png" alt="" loading="lazy"></figure>
<p>中规中矩的水平吧，上<code>Github</code>拿个快排优化一下：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        quicksort(costs, 0, costs.length - 1);
        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }

    private static void quicksort(int[] ar, int lo, int hi) {
        if (lo &lt; hi) {
            int splitPoint = partition(ar, lo, hi);
            quicksort(ar, lo, splitPoint);
            quicksort(ar, splitPoint + 1, hi);
        }
    }

    private static int partition(int[] ar, int lo, int hi) {
        int pivot = ar[lo];
        int i = lo - 1, j = hi + 1;
        while (true) {
            do {
                i++;
            } while (ar[i] &lt; pivot);
            do {
                j--;
            } while (ar[j] &gt; pivot);
            if (i &lt; j) swap(ar, i, j);
            else return j;
        }
    }

    private static void swap(int[] ar, int i, int j) {
        int tmp = ar[i];
        ar[i] = ar[j];
        ar[j] = tmp;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625199743893.png" alt="" loading="lazy"></figure>
<p><s>???</s></p>
<p><s>离谱</s></p>
<p><s>这优化</s></p>
<p>然后想了一下怎么把时间优化到<code>O(n)</code>，看了一下题解居然是用计数排序（<s>怎么就没想到，裂开</s>）。</p>
<p>然后肯定就是手写一个简陋的计数排序：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] ct = new int[10_0000+1];
        for (int c:costs){
            ++ct[c];
        }
        int index = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if(ct[i] != 0) {
                for (int j = 0; j &lt; ct[i]; j++) {
                    costs[index++] = i;
                }
            }
        }
        //System.out.println(Arrays.toString(costs));

        int res = 0;
        for (int i = 0; i &lt; costs.length &amp;&amp; coins &gt;= costs[i]; ++i, ++res) {
            coins -= costs[i];
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625200111336.png" alt="" loading="lazy"></figure>
<p>u1s1还真有点效果。</p>
<p>但是还是不够快，想了一下因为是求最后的数量，计数后不需要把数放回原来的数组，直接从<code>coins</code>里面减就行了，如果变成负数了直接返回：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int index = 0;
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            for (int j = 0; j &lt; ct[i]; j++) {
                costs[index++] = i;
                if (coins &gt;= i) {
                    coins -= i;
                    ++res;
                } else {
                    return res;
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625200311409.png" alt="" loading="lazy"></figure>
<p>u1s1这才叫优化。</p>
<p>再优化一下下，如果是所有同样定价的雪糕可以同时买下，直接用倍数去乘，而不是循环去减：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int index = 0;
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if (ct[i] != 0) {
                if (coins &gt;= ct[i] * i) {
                    coins -= ct[i] * i;
                    res += ct[i];
                } else {
                    for (int j = 0; j &lt; ct[i]; j++) {
                        costs[index++] = i;
                        if (coins &gt;= i) {
                            coins -= i;
                            ++res;
                        } else {
                            return res;
                        }
                    }
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2293736867.github.io/post-images/1625200504043.png" alt="" loading="lazy"></figure>
<p>但是好像没什么效果。</p>
<p>不行，坚定信念要优化的笔者，决定再优化一下下，把循环去掉，用倍数加去代替逐个雪糕相减：</p>
<pre><code class="language-java">public class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int[] ct = new int[10_0000 + 1];
        for (int c : costs) {
            ++ct[c];
        }
        int res = 0;
        for (int i = 1; i &lt;= 10_0000; i++) {
            if (ct[i] != 0) {
                if (coins &gt;= ct[i] * i) {
                    coins -= ct[i] * i;
                    res += ct[i];
                } else {
                    res += (coins / i);
                    return res;
                }
            }
        }

        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://2293736867.github.io/post-images/1625200817021.png" alt="" loading="lazy"></figure>
<p>尽梨了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日分享 第381期]]></title>
        <id>https://2293736867.github.io/post/mei-ri-fen-xiang-di-381-qi/</id>
        <link href="https://2293736867.github.io/post/mei-ri-fen-xiang-di-381-qi/">
        </link>
        <updated>2021-06-30T16:33:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="每日鸡汤">每日鸡汤</h1>
<blockquote>
<p>对于穷人，生活不累的话，那就不叫生活！</p>
</blockquote>
<h1 id="每日诗词">每日诗词</h1>
<blockquote>
<p>烛摧花，鹤惊露，忽三更。<br>
——朱敦儒《水调歌头》</p>
</blockquote>
<h1 id="每日一句">每日一句</h1>
<blockquote>
<p>我只是不想再失去他——哪怕是仅存在一瞬的幻影！</p>
</blockquote>
<h1 id="每日力扣">每日力扣</h1>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://2293736867.github.io/post-images/1625070969908.png" alt="" loading="lazy"></figure>
<h2 id="解答">解答</h2>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map.containsKey(fromPlayer)){
                map.get(fromPlayer).add(toPlayer);
            }else{
                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                list.add(toPlayer);
                map.put(fromPlayer,list);
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                List&lt;Integer&gt; list = map.get(current);
                if(list != null){
                    queue.addAll(list);
                }
            }
        }
        while(!queue.isEmpty()){
            if(queue.remove() == n-1){
                ++res;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://2293736867.github.io/post-images/1625071812210.png" alt="" loading="lazy"></figure>
<p>这效率。。。</p>
<p>稍微优化一下，使用数组代替<code>HashMap</code>，但是也没有提高多少效率：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int [][] map = new int[n][];
        int [] mapLen = new int[n];
        int [] mapIndex = new int[n];

        for (int i = 0; i &lt; relation.length; i++) {
            ++mapLen[relation[i][0]];
        }

        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map[fromPlayer] == null){
                map[fromPlayer] = new int[mapLen[fromPlayer]];
                map[fromPlayer][0] = toPlayer;
                mapIndex[fromPlayer] = 1;
            }else{
                map[fromPlayer][mapIndex[fromPlayer]++] = toPlayer;
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                int [] value = map[current];
                if(value != null){
                    for (int l = 0; l &lt; value.length; l++) {
                        queue.add(value[l]);
                    }
                }
            }
        }
        while(!queue.isEmpty()){
            if(queue.remove() == n-1){
                ++res;
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://2293736867.github.io/post-images/1625072240855.png" alt="" loading="lazy"></figure>
<p>再优化一下下：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int [][] map = new int[n][];
        int [] mapLen = new int[n];
        int [] mapIndex = new int[n];

        for (int i = 0; i &lt; relation.length; i++) {
            ++mapLen[relation[i][0]];
        }

        for (int i = 0; i &lt; relation.length; i++) {
            int fromPlayer = relation[i][0];
            int toPlayer = relation[i][1];
            if(map[fromPlayer] == null){
                map[fromPlayer] = new int[mapLen[fromPlayer]];
                map[fromPlayer][0] = toPlayer;
                mapIndex[fromPlayer] = 1;
            }else{
                map[fromPlayer][mapIndex[fromPlayer]++] = toPlayer;
            }
        }

        int res = 0;
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(0);
        for (int i = 0; i &lt; k; i++) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                int current = queue.remove();
                int [] value = map[current];
                if(value != null){
                    for (int l = 0; l &lt; value.length; l++) {
                        int v = value[l];
                        if(i == k-1 &amp;&amp; v == n-1){
                            ++res;
                        }
                        queue.add(v);
                    }
                }
            }
        }
        return res;
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://2293736867.github.io/post-images/1625072398603.png" alt="" loading="lazy"></figure>
<p>极限了极限了。。。（<s>太菜了太菜了</s>）</p>
<p>看了题解发现原来有三种方法：</p>
<ul>
<li>深搜</li>
<li>广搜</li>
<li>动归</li>
</ul>
<p>动归解法如下：</p>
<pre><code class="language-java">class Solution {
    public int numWays(int n, int[][] relation, int k) {
        int[][] dp = new int[k + 1][n];
        dp[0][0] = 1;
        for (int i = 0; i &lt; k; i++) {
            for (int[] edge : relation) {
                int src = edge[0], dst = edge[1];
                dp[i + 1][dst] += dp[i][src];
            }
        }
        return dp[k][n - 1];
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2293736867.github.io/post-images/1625072669552.png" alt="" loading="lazy"></figure>
<p><s>BFS优化个der</s></p>
<h1 id="100周年">100周年</h1>
<p>建党100周年！</p>
<p>刚过12点就朋友圈刷屏了。</p>
]]></content>
    </entry>
</feed>